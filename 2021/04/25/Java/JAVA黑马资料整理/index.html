<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java基础教程 | LXY's blog</title><meta name="keywords" content="Java"><meta name="author" content="LXY,aethon47@163.com"><meta name="copyright" content="LXY"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="JAVA基础知识JAVA语言平台 J2SE：(Java 2 Platform Standard Edition)标准版,为开发普通桌面和商务应用程序,可以完成一些桌面型应用程序的开发。 J2ME：(Java 2 Platform Micro Edition)小型版,为开发电子消费产品和嵌入式设备。 J2EE：(Java 2 Platform Enterprise Edition)企业版,为开发企业">
<meta property="og:type" content="article">
<meta property="og:title" content="Java基础教程">
<meta property="og:url" content="http://www.codingcode.cn/2021/04/25/Java/JAVA%E9%BB%91%E9%A9%AC%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/index.html">
<meta property="og:site_name" content="LXY&#39;s blog">
<meta property="og:description" content="JAVA基础知识JAVA语言平台 J2SE：(Java 2 Platform Standard Edition)标准版,为开发普通桌面和商务应用程序,可以完成一些桌面型应用程序的开发。 J2ME：(Java 2 Platform Micro Edition)小型版,为开发电子消费产品和嵌入式设备。 J2EE：(Java 2 Platform Enterprise Edition)企业版,为开发企业">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/11/26/FaCzDKS1dcpfihA.jpg">
<meta property="article:published_time" content="2021-04-25T06:24:00.000Z">
<meta property="article:modified_time" content="2021-11-25T09:03:55.791Z">
<meta property="article:author" content="LXY">
<meta property="article:tag" content="Java">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/11/26/FaCzDKS1dcpfihA.jpg"><link rel="shortcut icon" href="/img/liu_favicon32.ico"><link rel="canonical" href="http://www.codingcode.cn/2021/04/25/Java/JAVA%E9%BB%91%E9%A9%AC%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java基础教程',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-11-25 17:03:55'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://i.loli.net/2021/11/26/WgScJEVydhutA7C.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">147</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://i.loli.net/2021/11/26/FaCzDKS1dcpfihA.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">LXY's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java基础教程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="fa-fw post-meta-icon far fa-calendar-alt"></i><span class="post-meta-label">发表于</span><time datetime="2021-04-25T06:24:00.000Z" title="undefined 2021-04-25 14:24:00">2021-04-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">32k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>109分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Java基础教程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="JAVA基础知识"><a href="#JAVA基础知识" class="headerlink" title="JAVA基础知识"></a>JAVA基础知识</h1><h2 id="JAVA语言平台"><a href="#JAVA语言平台" class="headerlink" title="JAVA语言平台"></a>JAVA语言平台</h2><ul>
<li><strong>J2SE</strong>：(Java 2 Platform Standard Edition)标准版,为开发普通桌面和商务应用程序,可以完成一些桌面型应用程序的开发。</li>
<li><strong>J2ME</strong>：(Java 2 Platform Micro Edition)小型版,为开发电子消费产品和嵌入式设备。</li>
<li><strong>J2EE</strong>：(Java 2 Platform Enterprise Edition)企业版,为开发企业环境下的应用程序,该体系中包含的技术入Servlet、Jsp等,主要针对Web应用程序开发。</li>
<li>JavaEE和JavaSE的区别：<ul>
<li>JavaEE：Java Enterprise Edition，Java企业版，多用于企业级开发，包括web开发等等。企业版本帮助开发和部署可移植、健壮、可伸缩切安全的服务端Java应用。Java EE是在JavaSE的基础上构建的他提供Web 服务、组建模型、管理和通信API.可以用来实现企业级的面向服务体系结构(service-oriented architecture,SOA)和web2.0应用程序。</li>
<li>JavaSE：通常是指Java Standard Edition，Java标准版，就是一般Java程序的开发就可以(如桌面程序)，可以看作是JavaEE的子集。它允许开发和部署在桌面、服务器、嵌入式环境和实施环境中使用的Java应用程序。JavaSE 包括支持Java　Ｗeb服务开发的类，并为Java Platform,Enterprise Edition(Java EE)提供基础。<h2 id="JAVA属于跨平台语言"><a href="#JAVA属于跨平台语言" class="headerlink" title="JAVA属于跨平台语言"></a>JAVA属于跨平台语言</h2></li>
</ul>
</li>
<li>什么是跨平台？<ul>
<li>平台：指的是操作系统(Windows,Linux,Mac)。</li>
<li>跨平台：Java程序可以在任意操作系统上运行,一次编写到处运行。</li>
<li>原理：实现跨平台需要依赖Java的虚拟机JVM（Java Virtual Machine）<h2 id="JVM、JRE、JDK说明"><a href="#JVM、JRE、JDK说明" class="headerlink" title="JVM、JRE、JDK说明"></a>JVM、JRE、JDK说明</h2></li>
</ul>
</li>
<li>JVM：JVM是java虚拟机(Java Virtual Machine),java程序需要运行在虚拟机上,不同平台有自己的虚拟机,因此java语言可以跨平台。</li>
<li>JRE：包括Java虚拟机(Java Virtual Machine)和Java程序所需的核心类库等。如果想要运行一个开发好的Java程序,计算机中只需要安装JRE即可。<br>&emsp;&emsp;JRE=JVM+核心类库。 </li>
<li>JDK：JDK是提供给Java开发人员使用的,其中包含了java的开发工具,也包括了JRE。所以安装了JDK,就不用在单独安装JRE了。<br>&emsp;&emsp;其中的开发工具：编译工具(javac.exe)、打包工具(jar.exe)等。<br>&emsp;&emsp;JDK=JRE+JAVA的开发工具。<h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2></li>
<li>运行代码步骤：<ul>
<li>在命令行模式中，输入javac命令对源代码进行编译，生成字节码文件<br>  – javac 源文件名.java</li>
<li>编译完成后，如果没有报错信息，输入java命令对class字节码文件进行解释运行,执行时不需要添加.class扩展名<ul>
<li>java HelloWorld<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2></li>
</ul>
</li>
</ul>
</li>
<li>Java语言是强类型语言,对于每一种数据都定义了明确的具体数据类型,在内存中分配了不同大小的内存空间。</li>
<li>Java中数据类型的分类：<ul>
<li>基本数据类型(8种)：byte,short,int,long,float,double,char,boolean</li>
<li>引用数据类型(3种)：类(class),接口(interface),数组([])  </li>
</ul>
</li>
</ul>
<p><img src="https://i.loli.net/2021/04/25/wjusHikbGVna73q.jpg" alt="JAVA基本数据类型.jpg"><br><img src="https://i.loli.net/2021/04/25/hTZCVmQJezEvYrA.jpg" alt="JAVA数据类型.jpg"></p>
<h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul>
<li>作用：给包,类,方法,变量等起名字</li>
<li>组成规则:<ul>
<li>由字符,下划线_,美元符$组成(这里的字符采用的是unicode字符集,所以包括英文大小写字母,中文字符,数字字符等)</li>
</ul>
</li>
<li>注意事项:<ul>
<li>不能以数字开头</li>
<li>不能是Java中的关键字</li>
</ul>
</li>
<li>命名原则：见名知意<ul>
<li>包：<ul>
<li>其实就是文件夹,用于对类进行管理</li>
<li>最好是域名倒过来,要求所有的字母小写</li>
<li>多级包用’.’隔开</li>
</ul>
</li>
<li>类或者接口：<ul>
<li>如果是一个单词,首字母大写</li>
<li>如果是多个单词,每个单词首字母大写(驼峰标识) </li>
</ul>
</li>
<li>方法或者变量：<ul>
<li>如果是一个单词,全部小写</li>
<li>如果是多个单词,从第二个单词首字母大写 </li>
</ul>
</li>
<li>常量：<ul>
<li>如果是一个单词,所有字母大写</li>
<li>如果是多个单词,所有的单词大写,用下划线区分每个单词 <h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2></li>
</ul>
</li>
</ul>
</li>
<li>隐式数据类型转换：<ul>
<li>取值范围小的数据类型与取值范围大的数据类型进行运算,会先将小的数据类型提升为大的,再进行运算。</li>
</ul>
</li>
<li>强制类型数据转换<ul>
<li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标类型 变量名 = (目标类型) (被转换的数据);</span></span><br><span class="line">b = (<span class="keyword">byte</span>)(a);</span><br></pre></td></tr></table></figure></li>
<li>注意事项：如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同。</li>
</ul>
</li>
</ul>
<h2 id="集成开发环境-IDE"><a href="#集成开发环境-IDE" class="headerlink" title="集成开发环境(IDE)"></a>集成开发环境(IDE)</h2><ul>
<li>集成开发环境IDE(Integrated Development Environment)<h2 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h2></li>
<li>运算符：对常量和变量进行操作的符号。</li>
<li>表达式：用运算符把常量或者变量连接起来的符合Java语法的式子。<br>&emsp;&emsp;&emsp;&emsp;不同运算符连接的式子体现的是不同类型的表达式。</li>
<li>常用运算符<ul>
<li>算术运算符：+,-,*,/(取整),%(取余),++,–</li>
<li>赋值运算符：<ul>
<li>基本的赋值运算符：=</li>
<li>扩展的赋值运算符：+=,-=,*=,/=,%=</li>
</ul>
</li>
<li>关系运算符：<ul>
<li>==,!=,&gt;,&gt;=,&lt;,&lt;=</li>
<li>关系运算符的结果都是boolean型,也就是要么是true,要么是false。</li>
</ul>
</li>
<li>逻辑运算符：<ul>
<li>&amp;,|,^,!,&amp;&amp;,||</li>
<li>&amp;逻辑与:有false则false。</li>
<li>|逻辑或:有true则true。</li>
<li>^逻辑异或:相同为false,不同为true。</li>
<li>!逻辑非:非false则true,非true则false。</li>
<li>逻辑运算符&amp;&amp;与&amp;的区别?<ul>
<li>最终结果一样。</li>
<li>&amp;&amp;具有短路效果。左边是false,右边不执行。</li>
<li>&amp;是无论左边是false还是true,右边都会执行。</li>
</ul>
</li>
<li>逻辑运算符||与|的区别?<ul>
<li>最终结果一样</li>
<li>||具有短路效果。左边是true,右边不执行。</li>
<li>|是无论左边是false还是true,右边都会执行。</li>
</ul>
</li>
</ul>
</li>
<li>三元运算符：<ul>
<li>格式：<code>(关系表达式)?表达式1：表达式2</code></li>
<li>如果条件为true,运算后的结果是表达式1。</li>
<li>如果条件为false,运算后的结果是表达式2。<h2 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h2></li>
</ul>
</li>
</ul>
</li>
<li>概述：把数据改进为键盘录入,提高程序的灵活性。</li>
<li>步骤：<ul>
<li>导包：import java.util.Scanner;</li>
<li>创建对象：Scanner sc = new Scanner(System.in);</li>
<li>接收数据：int x = sc.nextInt();</li>
</ul>
</li>
</ul>
<h2 id="选择流程控制语句"><a href="#选择流程控制语句" class="headerlink" title="选择流程控制语句"></a>选择流程控制语句</h2><ul>
<li>顺序结构：按照代码的先后顺序,依次执行。</li>
<li>if语句：</li>
<li>switch语句：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">   	<span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">		语句体<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">		语句体<span class="number">2</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	...</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		语句体n+<span class="number">1</span>;</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="循环流程控制语句"><a href="#循环流程控制语句" class="headerlink" title="循环流程控制语句"></a>循环流程控制语句</h2></li>
<li>for循环：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句;判断条件语句;控制条件语句) &#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>while循环：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(判断条件语句) &#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>do…while循环:(while为true时继续执行)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(判断条件语句);</span><br></pre></td></tr></table></figure>
<h2 id="控制循环语句"><a href="#控制循环语句" class="headerlink" title="控制循环语句"></a>控制循环语句</h2></li>
<li>break：退出当前的循环。</li>
<li>continue：退出本次循环。</li>
</ul>
<h2 id="产生随机数-Random"><a href="#产生随机数-Random" class="headerlink" title="产生随机数(Random)"></a>产生随机数(Random)</h2><ul>
<li>使用步骤：<ul>
<li>导包：import java.util.Random;</li>
<li>创建对象：Random r = new Random();</li>
<li>接收数据：int number = r.nextInt(10);//随机数范围[0,10)<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></li>
</ul>
</li>
<li>数组是存储同一种数据类型多个元素的容器。</li>
<li>数组既可以存储基本数据类型,也可以存储引用数据类型。</li>
<li>定义格式：<ul>
<li>格式1：数据类型[] 数组名;</li>
<li>格式2：数据类型 数组名[];</li>
</ul>
</li>
<li>数组初始化：Java中的数组必须先初始化,然后才能使用。所谓初始化：就是为数组中的数组元素分配内存空间,并为每个数组元素赋值。<ul>
<li>初始化方式：<ul>
<li>动态初始化:初始化时只指定数组长度,由系统为数组分配初始值<ul>
<li>格式：<code>数据类型[] 数组名 = new 数据类型[数组长度];</code>(数组长度其实就是数组中元素的个数)</li>
</ul>
</li>
<li>静态初始化:初始化时指定每个数组元素的初始值,由系统决定数组长度<ul>
<li>初始化的格式：<code>数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,...&#125;;</code></li>
<li>简化格式：<code>数据类型[] 数组名 = &#123;元素1,元素2,...&#125;;</code><h2 id="数组内存划分"><a href="#数组内存划分" class="headerlink" title="数组内存划分"></a>数组内存划分</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>JVM内存划分<ul>
<li>栈(存储局部变量)</li>
<li>堆(存储new出来的东西)</li>
<li>方法区(面向对象进阶讲)</li>
<li>本地方法区(和系统相关)</li>
<li>寄存器(给CPU使用)<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2></li>
</ul>
</li>
<li>定义格式：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型[][] 数组名;</span><br><span class="line">数据类型 数组名[][]; 不推荐</span><br><span class="line">数据类型[] 数组名[]; 不推荐</span><br></pre></td></tr></table></figure></li>
<li>初始化方式:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据类型[][] 变量名 = new 数据类型[m][n];</span><br><span class="line">数据类型[][] 变量名 = new 数据类型[][]&#123;&#123;元素…&#125;,&#123;元素…&#125;,&#123;元素…&#125;&#125;;</span><br><span class="line">简化版格式：</span><br><span class="line">数据类型[][] 变量名 = &#123;&#123;元素…&#125;,&#123;元素…&#125;,&#123;元素…&#125;&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li>方法就是完成特定功能的代码块。</li>
<li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名<span class="number">1</span>,参数类型 参数名<span class="number">2</span>…) &#123;</span><br><span class="line">	函数体;</span><br><span class="line">	<span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="方法的重载及参数传递"><a href="#方法的重载及参数传递" class="headerlink" title="方法的重载及参数传递"></a>方法的重载及参数传递</h2></li>
<li>方法的重载：<ul>
<li>概述：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</li>
<li>特点：与返回值类型无关，只看方法名和参数列表。在调用时，虚拟机通过参数列表的不同来区分同名方法。</li>
</ul>
</li>
<li>参数传递：<ul>
<li>方法的形式参数为基本数据类型：<ul>
<li>形式参数的改变<strong>不影响</strong>实际参数。</li>
<li>形式参数：用于接收实际数据的变量</li>
<li>实际参数：实际参与运算的变量</li>
</ul>
</li>
<li>方法的形式参数为引用数据类型：<ul>
<li>形式参数的改变<strong>直接影响</strong>实际参数。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h2><ul>
<li>面向过程：<ul>
<li>概述：其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。</li>
<li>特点：强调的是过程，所有事情都需要自己完成。</li>
</ul>
</li>
<li>面向对象：<ul>
<li>概述：思想就是不断的创建对象，使用对象，指挥对象做事情。（如果有对象，直接用对象，对我们直接提供服务）</li>
<li>特点：<ul>
<li>是一种更符合我们思想习惯的思想(懒人思想，我把事情自己不做，交给别人去做)。</li>
<li>可以将复杂的事情简单化(对使用者来说简单了，对象里面还是很复杂的)。</li>
<li>将我们从执行者变成了指挥者角色发生了转换。<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2></li>
</ul>
</li>
</ul>
</li>
<li>概述：<ul>
<li>我们学习编程是为了什么?<ul>
<li>是为了把我们日常生活中实物用学习语言描述出来。</li>
</ul>
</li>
<li>我们如何描述现实世界事物?<ul>
<li>属性：就是该事物的描述信息(事物身上的名词)</li>
<li>行为：就是该事物能够做什么(事物身上的动词)</li>
</ul>
</li>
<li>Java中最基本的单位是类,Java中用class描述事物也是如此<ul>
<li>成员变量:就是事物的属性</li>
<li>成员方法:就是事物的行为</li>
</ul>
</li>
<li>定义类其实就是定义类的成员(成员变量和成员方法)<ul>
<li>成员变量:和以前定义变量是一样的，只不过位置发生了改变。在类中，方法外。</li>
<li>成员方法:和以前定义方法是一样的，只不过把static去掉，后面在详细讲解static的作用。</li>
</ul>
</li>
<li>类和对象的概念<ul>
<li>类：是一组相关的属性和行为的集合（我们班所有的同学都具备相同的属性和行为，比如：姓名，年龄，学习，这样就把所有的学生成为学生类）</li>
<li>对象：是该类事物的具体体现（说某个同学时，他都具备自己特有的属性和行为）</li>
<li>举例：<ul>
<li>类:学生</li>
<li>对象:具体的某个学生就是一个对象</li>
<li>比如：车是一个类，具体的开的奔驰、宝马，就是对象<h2 id="成员变量和局部变量的区别："><a href="#成员变量和局部变量的区别：" class="headerlink" title="成员变量和局部变量的区别："></a>成员变量和局部变量的区别：</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>在类中的位置不同<ul>
<li>成员变量：类中，方法外。</li>
<li>局部变量：方法中或者方法声明上(形式参数)。</li>
</ul>
</li>
<li>在内存中的位置不同<ul>
<li>成员变量：堆内存。</li>
<li>局部变量：栈内存。</li>
</ul>
</li>
<li>生命周期不同<ul>
<li>成员变量：随着对象的创建而存在，随着对象的消失而消失。</li>
<li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失。</li>
</ul>
</li>
<li>初始化值的问题<ul>
<li>成员变量：有默认值。</li>
<li>局部变量：没有默认值。必须先定义，赋值，最后使用。<h2 id="封装-面向对象三大特性之一"><a href="#封装-面向对象三大特性之一" class="headerlink" title="封装(面向对象三大特性之一)"></a>封装(面向对象三大特性之一)</h2></li>
</ul>
</li>
<li>private关键字:<ul>
<li>是一个权限修饰符。</li>
<li>可以修饰成员(成员变量和成员方法)</li>
<li>被private修饰的成员只在本类中才能访问。</li>
</ul>
</li>
<li>封装的概述：<ul>
<li>是<a target="_blank" rel="noopener" href="https://www.cnblogs.com/fzz9/p/8973315.html">面向对象三大特征</a>之一(三大特征为：封装、继承、多态)。</li>
<li>是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。</li>
</ul>
</li>
<li>封装的原则：<ul>
<li>将不需要对外提供的内容都隐藏起来。</li>
<li>把属性隐藏，提供公共方法对其访问。</li>
<li>将成员变量设置为private，提供对应的getXxx()/setXxx()方法。</li>
</ul>
</li>
<li>封装的好处：<ul>
<li>通过方法来控制成员变量的操作，提高了代码的安全性。</li>
<li>把代码用方法进行封装，提高了代码的复用性。</li>
</ul>
</li>
<li>this关键字：<ul>
<li>this代表所在类的对象引用，方法被哪个对象调用，this就代表那个对象。</li>
<li>什么时候使用this呢：当局部变量和成员变量重名时。<h2 id="面向对象之构造方法"><a href="#面向对象之构造方法" class="headerlink" title="面向对象之构造方法"></a>面向对象之<strong>构造方法</strong></h2></li>
</ul>
</li>
<li>主要用来给对象的数据进行初始化。</li>
<li>构造方法格式：<ul>
<li>方法名与类名相同。</li>
<li>没有返回值类型，连void都没有。</li>
<li>没有具体的返回值。</li>
</ul>
</li>
<li>构造方法注意事项与重载<ul>
<li>如果我们没有给出构造方法，系统将会提供一个默认的无参构造方法供我们使用。</li>
<li>如果我们给出了构造方法，系统将不在提供默认的无参构造方法供我们使用。<br>这个时候，如果我们想使用无参构造方法，就必须自己提供。<br>推荐：自己给无参构造方法。</li>
<li>构造方法也是可以重载的,重载条件和普通方法相同。</li>
</ul>
</li>
</ul>
<h1 id="JAVA常用API"><a href="#JAVA常用API" class="headerlink" title="JAVA常用API"></a>JAVA常用API</h1><h2 id="API概述"><a href="#API概述" class="headerlink" title="API概述"></a>API概述</h2><ul>
<li>API(Application Programming Interface):应用程序编程接口。</li>
<li>String类：<ul>
<li>通过构造方法创建的字符串对象和直接赋值方式创建的字符串对象有什么区别呢?<ul>
<li>通过构造方法创建字符串对象是在堆内存。</li>
<li>直接赋值方式创建对象是在方法区的常量池。</li>
</ul>
</li>
</ul>
</li>
<li>“==”比较符：<ul>
<li>比较基本数据类型：比较的是基本数据类型的值是否相同。</li>
<li>比较引用数据类型：比较的是引用数据类型的地址值是否相同。</li>
</ul>
</li>
<li>StringBuilder类<ul>
<li>StringBuilder:是一个可变的字符串。字符串缓冲区类。  </li>
<li>String和StringBuilder的区别：<ul>
<li>String的内容是固定的，String拼接的时候<strong>会开辟</strong>一个新的内存空间。</li>
<li>StringBuilder的内容是可变的，拼接的时候<strong>不会开辟</strong>新的内存空间。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><ul>
<li>概述<ul>
<li>基本类型的数组:存储的元素为基本类型：<code>int[] arr=&#123;1,2,3,4&#125;</code></li>
<li>对象数组:存储的元素为引用类：<code>Student[] stus=new Student[3]</code><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2></li>
</ul>
</li>
<li>特点：长度可变。</li>
<li>ArrayList<E>集合:<ul>
<li>取长度：size();</li>
</ul>
</li>
</ul>
<h2 id="IO流及FileWriter类、FileReader类-基本流-使用"><a href="#IO流及FileWriter类、FileReader类-基本流-使用" class="headerlink" title="IO流及FileWriter类、FileReader类(基本流)使用"></a>IO流及FileWriter类、FileReader类(基本流)使用</h2><ul>
<li>IO概述及分类：<ul>
<li>IO流用来处理设备之间的数据传输。</li>
<li>Java对数据的操作是通过流的方式。</li>
<li>Java用于操作流的类都在IO包中。</li>
<li>流按流向分为两种：输入流、输出流。</li>
</ul>
</li>
<li>FileWriter类使用：<ul>
<li>FileWriter向文件中写数据<ul>
<li>步骤:<ul>
<li>使用FileWriter流关联文件</li>
<li>利用FileWriter的写方法写数据</li>
<li>利用FileWriter的刷新方法将数据从内存刷到硬盘上</li>
<li>利用FileWriter的关流方法将释放占用的系统底层资源</li>
</ul>
</li>
<li>FileWriter方法:<ul>
<li>构造方法<ul>
<li>FileWriter(String fileName)//传入一个文件的路径</li>
</ul>
</li>
<li>成员方法<ul>
<li>void write(String str)//向文件中写str</li>
<li>void flush()//将内存中的数据刷新到文件中(刷新缓冲区。流对象还可以继续使用)</li>
<li>void close()//关流释放系统底层资源(先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;e:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//FileWriter fw = new FileWriter(new File(&quot;e:\\a.txt&quot;), true); //设置成true就是追加</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 创建输出流对象做了哪些事情:</span></span><br><span class="line"><span class="comment">        * 		A:调用系统资源创建了一个文件</span></span><br><span class="line"><span class="comment">        * 		B:创建输出流对象</span></span><br><span class="line"><span class="comment">        * 		C:把输出流对象指向文件</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用输出流对象的写数据的方法</span></span><br><span class="line">        <span class="comment">//写一个字符串数据</span></span><br><span class="line">        fw.write(<span class="string">&quot;第一行&quot;</span>);</span><br><span class="line">        <span class="comment">/*如何实现数据的换行?</span></span><br><span class="line"><span class="comment">        &#x27;\n&#x27;可以实现换行，但是windows系统自带的记事本打开并没有换行，这是为什么呢?</span></span><br><span class="line"><span class="comment">        因为windows识别的换行不是\n，而是\r\n</span></span><br><span class="line"><span class="comment">            windows:\r\n</span></span><br><span class="line"><span class="comment">            linux:\n</span></span><br><span class="line"><span class="comment">            mac:\r</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;第二行&quot;</span>);</span><br><span class="line">        <span class="comment">//数据没有直接写到文件，其实是写到了内存缓冲区</span></span><br><span class="line">        fw.flush();<span class="comment">//刷新缓冲区。流对象还可以继续使用。</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="comment">//通知系统释放和该文件相关的资源</span></span><br><span class="line">        fw.close();<span class="comment">//先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>FileReader类使用：<ul>
<li>FileReader读数据一次读取一个字符<ul>
<li>输入流读文件的步骤：<ul>
<li>创建输入流对象。</li>
<li>调用输入流对象的读数据方法。</li>
<li>释放资源。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用输入流对象的读数据方法</span></span><br><span class="line">        <span class="comment">//int read():一次读取一个字符</span></span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span> ((ch = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>利用FileReader和FileWriter完成文件复制<ul>
<li>读一次写一次:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFileDemo</span> </span>&#123;<span class="comment">//a.txt-&gt;b.txt</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;f://b.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//读写数据</span></span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            fw.write(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>利用字符数组拷贝文件:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFileDemo2</span> </span>&#123;<span class="comment">//a.txt-&gt;b.txt</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;f://b.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//读写数据</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len=fr.read(chs))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            fw.write(chs, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="缓冲流介绍和使用"><a href="#缓冲流介绍和使用" class="headerlink" title="缓冲流介绍和使用"></a>缓冲流介绍和使用</h2></li>
</ul>
</li>
<li>BufferedWriter:将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输出缓冲流对象</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;f://a.txt&quot;</span>));</span><br><span class="line">        bw.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        bw.newLine();<span class="comment">//写入一个换行符，这个换行符由系统而定</span></span><br><span class="line">        <span class="comment">//bw.flush();</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>BufferedReader:从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入缓冲流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//一次读写一个字符数组</span></span><br><span class="line">        <span class="comment">/*char[] chs = new char[1024];</span></span><br><span class="line"><span class="comment">        int len;</span></span><br><span class="line"><span class="comment">        while((len=br.read(chs))!=-1) &#123;</span></span><br><span class="line"><span class="comment">            System.out.print(new String(chs,0,len));</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//一次读取一行，但不会读取换行符</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>缓冲流复制文本文件:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedCopyFileDemo</span> </span>&#123;<span class="comment">//a.txt-&gt;b.txt</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入缓冲流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//创建输出缓冲流对象</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;f://b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读写数据</span></span><br><span class="line">        <span class="comment">//一次读写一个字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = br.read(chs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bw.write(chs, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>缓冲流的特有方法使用:<ul>
<li>BufferedWriter:<ul>
<li>void newLine():写一个换行符，这个换行符由系统决定,不同的操作系统newLine()方法使用的换行符不同<br> windows:\r\n<br> linux:\n<br> mac:\r</li>
</ul>
</li>
<li>BufferedReader<ul>
<li>String readLine():一次读取一行数据，但是不读取换行符</li>
</ul>
</li>
</ul>
</li>
<li>缓冲流的特有方法复制文件:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedCopyFileDemo2</span> </span>&#123;<span class="comment">//a.txt-&gt;b.txt</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入缓冲流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//创建输出缓冲流对象</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;f://b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读写数据</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="static静态关键字"><a href="#static静态关键字" class="headerlink" title="static静态关键字"></a>static静态关键字</h2><ul>
<li>静态概述：<ul>
<li>当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？<br>答案是可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。</li>
</ul>
</li>
<li>静态的特点：<ul>
<li>被static修饰的成员变量属于类，不属于这个类的某个对象，被所有的对象所共享。<br>(也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量)</li>
<li>被static修饰的成员可以并且建议通过类名直接访问<br>  访问静态成员的格式:<ul>
<li>类名.静态成员变量名</li>
<li>类名.静态成员方法名(参数)</li>
</ul>
</li>
<li>静态的加载优先于对象。</li>
<li>随着类的加载而加载。</li>
</ul>
</li>
<li>静态的注意事项：<ul>
<li>静态成员只能直接访问静态成员。</li>
<li>非静态成员既可以访问非静态成员也可以访问静态成员。</li>
<li>即：<ul>
<li>静态方法：<pre><code>- 可以调用静态的成员变量
</code></pre>
<ul>
<li>可以调用静态的成员方法<ul>
<li>不可以调用非静态成员变量</li>
<li>不可以调用非静态成员方法</li>
<li>静态方法只能调用静态的成员</li>
</ul>
</li>
<li>非静态方法：<ul>
<li>可以调用静态的成员变量</li>
<li>可以调用静态的成员方法</li>
<li>可以调用非静态的成员变量</li>
<li>可以调用非静态的成员方法</li>
</ul>
</li>
</ul>
</li>
<li>静态的方法中没有this这个对象。</li>
</ul>
</li>
</ul>
</li>
<li>静态的优缺点：<ul>
<li>优点:<ul>
<li>对对象的共享数据提供单独空间的存储，节省空间，没有必要每一个对象都存储一份</li>
<li>可以直接被类名调用,不用在堆内存创建对象</li>
<li>静态成员可以通过类名直接访问,相对创建对象访问成员方便</li>
</ul>
</li>
<li>弊端:<ul>
<li>访问出现局限性。（静态虽好，但只能访问静态）<h2 id="静态的应用-Math类"><a href="#静态的应用-Math类" class="headerlink" title="静态的应用(Math类)"></a>静态的应用(Math类)</h2></li>
</ul>
</li>
</ul>
</li>
<li>Math.abs(double a)//返回绝对值</li>
<li>Math.ceil(double a)//天花板   向上取整</li>
<li>Math.floor(double a)//地板  向下取整</li>
<li>Math.round(double a)//四舍五入</li>
<li>Math.pow(double a, double b)//返回第一个参数的第二个参数次幂(a的b次方)</li>
<li>Math.random()//返回一个随机数，大于零且小于一<h2 id="类变量与实例变量辨析"><a href="#类变量与实例变量辨析" class="headerlink" title="类变量与实例变量辨析"></a>类变量与实例变量辨析</h2></li>
<li>类变量:其实就是静态变量<ul>
<li>定义位置:定义在类中方法外</li>
<li>所在内存区域:方法区</li>
<li>生命周期:随着类的加载而加载</li>
<li>特点:无论创建多少对象,类变量仅在方法区中,并且只有一份</li>
</ul>
</li>
<li>实例变量:其实就是非静态变量<ul>
<li>定义位置:定义在类中方法外</li>
<li>所在内存区域:堆</li>
<li>生命周期:随着对象的创建而加载</li>
<li>特点:每创建一个对象,堆中的对象中就有一份实例变量<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2></li>
</ul>
</li>
<li>局部代码块：定义在方法或语句中。<ul>
<li>以”{}”划定的代码区域，此时只需要关注作用域的不同即可</li>
<li>方法和类都是以代码块的方式划定边界的</li>
</ul>
</li>
<li>构造代码块：定义在类中成员位置的代码块。<ul>
<li>优先于构造方法执行，构造代码块用于执行所有对象均需要的初始化动作</li>
<li>每创建一个对象<strong>均会执行</strong>一次构造代码块。</li>
</ul>
</li>
<li>静态代码块：定义在成员位置，使用static修饰的代码块。<ul>
<li>随着类的加载而加载，只加载一次，加载类时需要做的一些初始化，比如加载驱动等。</li>
<li>它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行。</li>
<li>该类不管创建多少对象，静态代码块<strong>只执行一次</strong>。</li>
<li>可用于给静态变量赋值，用来给类进行初始化。</li>
</ul>
</li>
</ul>
<h2 id="继承-面向对象三大特性之一"><a href="#继承-面向对象三大特性之一" class="headerlink" title="继承(面向对象三大特性之一)"></a>继承(面向对象三大特性之一)</h2><h3 id="继承的概述："><a href="#继承的概述：" class="headerlink" title="继承的概述："></a>继承的概述：</h3><ul>
<li>在现实生活中，继承一般指的是子女继承父辈的财产。在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。</li>
<li>多个类有共同的成员变量和成员方法，抽取到另外一个类中（父类），在让多个类去继承这个父类，我们的多个类就可以获取到父类中的成员了。<h3 id="继承的格式及使用："><a href="#继承的格式及使用：" class="headerlink" title="继承的格式及使用："></a>继承的格式及使用：</h3></li>
<li>在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。</li>
<li>格式：<code>class 子类 extends 父类 &#123;&#125;</code>。<h3 id="继承的特点："><a href="#继承的特点：" class="headerlink" title="继承的特点："></a>继承的特点：</h3></li>
<li>在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类。</li>
<li>多个类可以继承一个父类。</li>
<li>在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类。</li>
<li>在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。<h3 id="继承中成员变量的特点："><a href="#继承中成员变量的特点：" class="headerlink" title="继承中成员变量的特点："></a>继承中成员变量的特点：</h3></li>
<li>子类只能获取父类<strong>非私有成员</strong><ul>
<li>子父类中成员变量的名字不一样直接获取父类的成员变量。</li>
<li>子父类中成员变量名字是一样的获取的是子类的成员变量。</li>
</ul>
</li>
<li>就近原则：谁离我近我就用谁<ul>
<li>如果有局部变量就使用局部变量。</li>
<li>如果没有局部变量，有子类的成员变量就使用子类的成员变量。</li>
<li>如果没有局部变量和子类的成员变量，有父类的成员变量就使用父类的成员变量。</li>
</ul>
</li>
<li>super:可以获取父类的成员变量和成员方法,用法和this是相似的。<h3 id="继承中成员方法的特点及方法重写"><a href="#继承中成员方法的特点及方法重写" class="headerlink" title="继承中成员方法的特点及方法重写"></a>继承中成员方法的特点及方法重写</h3></li>
<li>子类中没有这个方法,则调用父类的。</li>
<li>子类中重写了这个方法，则调用子类的。<ul>
<li><strong>方法的重写</strong>：在子父类当中，子类的方法和父类的完全一样，子类重写了父类的方法（覆盖），当子类重写了父类的方法之后，使用子类对象调用的就是子类的方法。</li>
<li><strong>方法的重载</strong>：在一个类中，有多个重名的方法，但是其参数不一样（参数的个数，参数的类型，参数的顺序），和返回值无关。<h3 id="方法重写的应用场景及注意事项"><a href="#方法重写的应用场景及注意事项" class="headerlink" title="方法重写的应用场景及注意事项"></a>方法重写的应用场景及注意事项</h3></li>
</ul>
</li>
<li>应用场景：当父类的方法不能完全满足子类使用的时候，既可以保留父类的功能（沿袭、传承），还可以有自己特有的功能</li>
<li>注意事项：<ul>
<li>不能重写父类私有的成员方法，压根就看不到父类的私有成员</li>
<li>权限必须大于等于父类方法的权限<ul>
<li>注解：@Override(方法重写，说明下面的方法是重写父类的方法)<h3 id="继承中构造方法的执行顺序"><a href="#继承中构造方法的执行顺序" class="headerlink" title="继承中构造方法的执行顺序"></a>继承中构造方法的执行顺序</h3></li>
</ul>
</li>
</ul>
</li>
<li><code>super(实参列表);</code>：在子类的构造方法中使用,用来调用父类中的构造方法(具体哪一个由传递的参数决定),并且只能在构造方法第一行使用</li>
<li><code>this(实参列表);</code>:在类的构造方法中使用,用来调用本类中的其它构造方法(具体哪一个由传递的参数决定),并且只能在构造方法的第一行使用</li>
<li>在子类的构造方法的第一行代码如果没有调用父类的构造或者没有调用子类的其他构造，则默认调用父类无参构造。</li>
<li>为什么要调用父类构造？<ul>
<li>因为需要给父类的成员变量初始化。</li>
</ul>
</li>
<li>肯定会先把父类的构造执行完毕，在去执行子类构造中的其他代码。<h3 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h3></li>
<li>this:当前对象的引用<ul>
<li>调用子类的成员变量。</li>
<li>调用子类的成员方法。</li>
<li>在子类的构造方法第一行调用子类其他构造方法。</li>
</ul>
</li>
<li>super:子类对象的父类引用<ul>
<li>调用父类的成员变量。</li>
<li>调用父类的成员方法。</li>
<li>在子类的构造方法第一行调用父类的构造方法。<h3 id="继承优缺点"><a href="#继承优缺点" class="headerlink" title="继承优缺点"></a>继承优缺点</h3></li>
</ul>
</li>
<li>优点<ul>
<li>提高了代码的复用性</li>
<li>提高了代码的可维护性</li>
</ul>
</li>
<li>缺点：<ul>
<li>类的耦合性增强了</li>
<li>开发的原则：高内聚低耦合<ul>
<li>内聚：就是自己完成某件事情的能力</li>
<li>耦合：类与类的关系<h2 id="匿名对象及final"><a href="#匿名对象及final" class="headerlink" title="匿名对象及final"></a>匿名对象及final</h2><h3 id="匿名对象定义及使用"><a href="#匿名对象定义及使用" class="headerlink" title="匿名对象定义及使用"></a>匿名对象定义及使用</h3></li>
</ul>
</li>
</ul>
</li>
<li>匿名对象即无名对象,直接使用new关键字来创建对象。</li>
<li>应用场景：<ul>
<li>当方法只调用一次的时候可以使用匿名对象。</li>
<li>可以当作参数进行传递，但是无法在传参之前做其他的事情。</li>
</ul>
</li>
<li>注意：匿名对象可以调用成员变量并赋值，但是赋值并没有意义。<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3></li>
<li><strong>final</strong>：修饰符，可以用于修饰类、成员方法和成员变量<ul>
<li>final所修饰的类：不能被继承，不能有子类</li>
<li>final所修饰的方法:不能被重写</li>
<li>final所修饰的变量：是不可以修改的，是常量<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2></li>
</ul>
</li>
<li>概述：<ul>
<li>当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的功能具体实现方式，那么这些方法都有具体的方法体。</li>
<li>但是有的时候，某个父类只是知道子类应该包含怎么样的方法，但是无法准确知道子类如何实现这些方法。比如一个图形类应该有一个求周长的方法，但是不同的图形求周长的算法不一样。那该怎么办呢？</li>
<li>分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是<strong>方法功能声明相同</strong>，但<strong>方法功能主体不同</strong>。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个<strong>抽象方法</strong>。</li>
</ul>
</li>
<li><strong>abstract</strong>:关键字，用于修饰方法和类<ul>
<li>抽象方法：不同类的方法是相似，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体。</li>
<li>抽象类：有抽象方法的类必须是抽象类</li>
</ul>
</li>
<li>抽象类的特点<ul>
<li>抽象方法<strong>只能</strong>在抽象类里面<ul>
<li>抽象类和抽象方法<strong>必须被abstract修饰</strong></li>
<li>抽象类不能创建对象（不能实例化）</li>
<li>抽象类中可以有非抽象的方法</li>
<li>抽象类和类的关系也是继承</li>
<li>一个类继承了抽象类要么<strong>重写所有</strong>的抽象方法，要么他自己是<strong>抽象类</strong></li>
</ul>
</li>
</ul>
</li>
<li>抽象类的成员的特点:<ul>
<li>成员变量<ul>
<li>可以有成员变量</li>
<li>可以有常量</li>
</ul>
</li>
<li>成员方法<ul>
<li>可以有抽象方法</li>
<li>可以有非抽象方法</li>
</ul>
</li>
<li>构造方法<ul>
<li>可以有构造方法的，需要对抽象类的成员变量进行初始化</li>
</ul>
</li>
</ul>
</li>
<li>抽象类的细节:<ul>
<li>抽象类关键字abstract<strong>不可以</strong>和哪些关键字共存?<ul>
<li>private：私有的方法子类是无法继承到的，也不存在覆盖，而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法，而private修饰子类根本无法得到父类这个方法。互相矛盾。</li>
<li>final: <ul>
<li>抽象类不能和final共存,因为抽象类自身无法创建对象,我们需要通过子类创建对象,一旦抽象类使用final关键字,那么抽象类就没有子类</li>
<li>抽象方法不能和final共存,因为抽象方法后期需要被子类重写,一旦加final无法重写   </li>
</ul>
</li>
<li>static：抽象方法不能和static关键字共存,因为一旦加static我们就可以通过类名直接访问抽象方法,由于抽象方法没有方法体,没有任何意义,也不允许这样做</li>
</ul>
</li>
<li>抽象类中是否可以不定义抽象方法?<ul>
<li>是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用</li>
</ul>
</li>
<li>抽象类是否有构造函数?<ul>
<li>有,抽象类的构造函数,是由子类的super语句来调用,用于给抽象类中的成员初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul>
<li>概述：<ul>
<li>接口是功能的集合，同样可看做是一种<strong>数据类型</strong>，是比抽象类更为抽象的”类”。</li>
<li>接口<strong>只描述</strong>所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。</li>
</ul>
</li>
<li>格式：<ul>
<li>与定义类的class不同，接口定义时需要使用<strong>interface</strong>关键字。</li>
<li>定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。这点可以让我们将接口看做是一种只包含了功能声明的特殊类。</li>
<li>定义格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;</span><br><span class="line">    抽象方法<span class="number">1</span>;</span><br><span class="line">    抽象方法<span class="number">2</span>;</span><br><span class="line">    抽象方法<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>接口的使用:<ul>
<li>接口中的方法全是<strong>抽象方法</strong>,直接new接口来调用方法没有意义,Java也不允许这样干</li>
<li>类与接口的关系为实现关系，即<strong>类实现接口</strong>。实现的动作类似继承，只是关键字不同，实现使用<strong>implements</strong></li>
<li>其他类(实现类)实现接口后，就相当于声明：”我应该具备这个接口中的功能”。实现类仍然必须要重写方法以实现具体的功能。</li>
<li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类 <span class="keyword">implements</span> 接口 </span>&#123;</span><br><span class="line">    重写接口中方法</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li>
<li>在类实现接口后，该类就会将接口中的抽象方法继承过来，此时该类必须重写该抽象方法，完成具体的逻辑。</li>
</ul>
</li>
<li>接口中成员的特点:<ul>
<li>接口中可以<strong>定义变量</strong>，但是变量必须有<strong>固定</strong>的修饰符修饰，<strong>public static final</strong> 所以接口中的变量也称之为<strong>常量</strong>，其值不能改变。</li>
<li>接口中可以定义方法，方法也有<strong>固定</strong>的修饰符，<strong>public abstract</strong></li>
<li>接口不可以创建对象。</li>
<li>子类<strong>必须覆盖</strong>掉接口中<strong>所有</strong>的抽象方法后，子类才可以实例化。<strong>否则</strong>子类是一个<strong>抽象类</strong>。</li>
</ul>
</li>
<li>接口和类的关系：<ul>
<li>类与类之间:<strong>继承</strong>关系,一个类<strong>只能直接继承一个</strong>父类,但是支持<strong>多层继承</strong></li>
<li>类与接口之间:只有<strong>实现</strong>关系,一个类可以<strong>实现多个接口</strong></li>
<li>接口与接口之间:只有<strong>继承</strong>关系,一个接口可以<strong>继承多个接口</strong></li>
</ul>
</li>
<li>接口的思想：<ul>
<li>举例：我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用。发现这个插口的出现让我们使用更多的设备。</li>
<li>接口的出现方便后期使用和维护，一方是在使用接口（如电脑），一方在实现接口（插在插口上的设备）。例如：笔记本使用这个规则（接口），电脑外围设备实现这个规则（接口）。</li>
<li>集合体系中大量使用接口<ul>
<li>Collection接口<ul>
<li>List接口<ul>
<li>ArrayList实现类</li>
<li>LinkedList实现类</li>
</ul>
</li>
<li>Set接口</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>接口优点：<ul>
<li><strong>类与接口</strong>的关系，<strong>实现</strong>关系，而且是<strong>多实现</strong>，一个类可以实现多个接口，<strong>类与类</strong>之间是<strong>继承</strong>关系，java中的继承是<strong>单一继承</strong>，一个类只能有一个父类，<strong>打破了继承的局限性</strong>。</li>
<li>对外提供规则（USB接口）</li>
<li>降低了程序的耦合性（可以实现模块化开发，定义好规则，每个人实现自己的模块，提高了开发的效率）</li>
</ul>
</li>
<li>接口和抽象类的区别：<ul>
<li>共性：不断的进行抽取，抽取出抽象的，没有具体实现的方法,都不能实例化（不能创建对象）</li>
<li>区别:    <ul>
<li>与类的关系：类与接口是实现关系，而且是多实现，一个类可以实现多个接口，类与抽象类是继承关系，Java中的继承是单一继承，多层继承，一个类只能继承一个父类，但是可以有爷爷类</li>
<li>成员上的区别：<ul>
<li>成员变量<ul>
<li><strong>抽象类</strong>可以有成员变量，也可以有常量</li>
<li><strong>接口</strong>只能有常量，默认修饰符public static final</li>
</ul>
</li>
<li>成员方法<ul>
<li><strong>抽象类</strong>可以有抽象方法，也可以有非抽象方法</li>
<li><strong>接口</strong>只能有抽象方法，默认修饰符 public abstract</li>
</ul>
</li>
<li>构造方法<ul>
<li><strong>抽象类</strong>有构造方法，为子类提供</li>
<li><strong>接口</strong>没有构造方法 <h2 id="多态-面向对象三大特性之一"><a href="#多态-面向对象三大特性之一" class="headerlink" title="多态(面向对象三大特性之一)"></a>多态(面向对象三大特性之一)</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>概述：<ul>
<li>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。    </li>
<li>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person</li>
</ul>
</li>
<li>多态的定义格式:<br>&emsp;&emsp;就是<strong>父类的引用变量指向子类对象</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure></li>
<li><strong>普通类多态</strong>定义的格式:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类 变量名 = <span class="keyword">new</span> 子类();</span><br></pre></td></tr></table></figure>
  如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//类的多态使用</span></span><br><span class="line">   Fu f = <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li>
<li><strong>抽象类多态</strong>定义的格式:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象类 变量名 = <span class="keyword">new</span> 抽象类子类();</span><br></pre></td></tr></table></figure>
  如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“重写父类抽象方法”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类的多态使用</span></span><br><span class="line">Fu fu= <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li>
<li><strong>接口多态</strong>定义的格式:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口 变量名 = <span class="keyword">new</span> 接口实现类();</span><br></pre></td></tr></table></figure>
  如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“重写接口抽象方法”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口的多态使用</span></span><br><span class="line">Fu fu = <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li>
<li>多态的前提：<ul>
<li>子父类的继承关系</li>
<li>方法的重写</li>
<li>父类引用指向子类对象</li>
</ul>
</li>
<li>动态绑定：运行期间调用的方法，是根据其具体的类型</li>
<li>多态成员的特点:<ul>
<li>多态<strong>成员变量</strong><ul>
<li>当子父类中出现同名的成员变量时，多态调用该变量时：<ul>
<li>编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。</li>
<li>运行时期：也是调用引用型变量所属的类中的成员变量。</li>
</ul>
</li>
<li>简单记：编译和运行都参考等号的左边。编译运行看左边。</li>
</ul>
</li>
<li>多态<strong>成员方法</strong><ul>
<li>当子父类中出现同名的成员方法时，多态调用该方法时：<ul>
<li>编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。</li>
<li>运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。</li>
</ul>
</li>
<li>简而言之：编译看左边，运行看右边</li>
</ul>
</li>
<li>多态<strong>静态方法</strong><ul>
<li>简而言之：编译时看的是左边，运行时看的也是左边</li>
</ul>
</li>
<li>总结：<strong>编译</strong>时看的都是<strong>左边</strong>，<strong>运行</strong>时<strong>成员方法</strong>看的是<strong>右边</strong>，其他（成员变量和静态的方法）看的都是左边</li>
</ul>
</li>
<li>多态中<strong>向上转型</strong>与<strong>向下转型</strong>：<ul>
<li>多态的转型分为向上转型与向下转型两种：</li>
<li><strong>向上转型</strong>(由小到大,子类型转换成父类型)：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。<br>使用格式：<br><code>父类类型  变量名 = new 子类类型();</code><br>如：<br><code>Person p = new Student();</code></li>
<li><strong>向下转型</strong>(由大到小)：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的。<br>使用格式：<br><code>子类类型 变量名 = (子类类型) 父类类型的变量;</code><br>如:<br><code>Student stu = (Student) p;  //变量p 实际上指向Student对象</code></li>
<li>引用类型之间的转换:<ul>
<li>向上转型:由小到大(子类型转换成父类型)</li>
<li>向下转型:由大到小</li>
</ul>
</li>
<li>基本数据类型的转换:<ul>
<li>自动类型转换:由小到大<br>byte short char —&gt; int —&gt; long —&gt; float —&gt; double</li>
<li>强制类型转换:由大到小</li>
</ul>
</li>
</ul>
</li>
<li>多态的优缺点：<ul>
<li>优点：可以提高可维护性（多态前提所保证的），提高代码的可扩展性。</li>
<li>缺点：无法直接访问子类特有的成员。</li>
</ul>
</li>
</ul>
<h2 id="包和权限修饰符"><a href="#包和权限修饰符" class="headerlink" title="包和权限修饰符"></a>包和权限修饰符</h2><ul>
<li><p>包的概述：</p>
<ul>
<li>java的包，其实就是我们电脑系统中的文件夹，包里存放的是类文件。</li>
<li>当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为<strong>分包管理</strong>。</li>
<li>在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是以包作为边界。</li>
</ul>
</li>
<li><p>包的声明格式：</p>
<ul>
<li>通常使用公司网址反写，<strong>可以有多层包</strong>，包名采用全部小写字母，多层包之间用”.”连接,不同包下的文件名可以重复。</li>
<li>类中包的声明格式：<code>package 包名.包名.包名…;</code></li>
<li>注意：声明包的语句，必须写在程序有效代码的第一行（注释不算)</li>
</ul>
</li>
<li><p>包之间互相访问：</p>
<ul>
<li>在访问类时，为了能够找到该类，必须使用含有包名的类全名（包名.类名）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">包名.包名….类名</span><br><span class="line">如：java.util.Scanner</span><br><span class="line">    java.util.Random</span><br><span class="line"> cn.lxy.Demo</span><br><span class="line">带有包的类，创建对象格式：</span><br><span class="line">包名.类名 变量名 = <span class="keyword">new</span>包名.类名();</span><br><span class="line">如：cn.lxy.Demo d = <span class="keyword">new</span> cn.lxy.Demo();</span><br></pre></td></tr></table></figure></li>
<li>前提：<strong>包的访问与访问权限密切相关</strong>，这里以一般情况来说，即类用public修饰的情况。</li>
<li>类的简化访问:<ul>
<li>当我们要使用一个类时，这个类与当前程序在同一个包中（即同一个文件夹中），或者这个类是java.lang包中的类时通常可以省略掉包名，直接使用该类。</li>
</ul>
</li>
<li>我们每次使用类时，都需要写很长的包名。很麻烦，我们可以通过import导包的方式来简化。<ul>
<li>可以通过导包的方式使用该类，可以避免使用全类名编写（即，包类.类名）。</li>
<li>导包的格式：<code>import 包名.类名;</code></li>
</ul>
</li>
<li>注意：’*’代表的是通配符，代表导入了这个包下所有的类，并没有导入子包下的类</li>
</ul>
</li>
<li><p>权限修饰符:<br>在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限，以下表来说明不同权限的访问能力：</p>
<table>
<thead>
<tr>
<th></th>
<th>public</th>
<th>protected</th>
<th>default</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一类中</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td>√</td>
</tr>
<tr>
<td>同一包中(子类与无关类)</td>
<td>√</td>
<td>√</td>
<td>√</td>
<td></td>
</tr>
<tr>
<td>不同包的子类</td>
<td>√</td>
<td>√</td>
<td></td>
<td></td>
</tr>
<tr>
<td>不同包中的无关类</td>
<td>√</td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&emsp;&emsp;A:要想仅能在本类中访问使用private修饰</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&emsp;&emsp;B:要想本包中的类都可以访问除了private修饰符,其它都可以</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&emsp;&emsp;C:要想本包中的类与其他包中的子类可以访问使用protected修饰</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>&emsp;&emsp;D:要想所有包中的所有类都可以访问使用public修饰。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>注意：如果类用public修饰，则类名必须与文件名相同。一个文件中<strong>只能有一个public修饰的类</strong>。</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
</li>
<li><p>权限修饰符：</p>
<ul>
<li>public:当前类，相同包下不同的类,不同包下的类</li>
<li>default:当前类，相同包下不同的类(当前包下使用)</li>
<li>private:当前类</li>
<li>protected:当前类，相同包下不同的类(让子类对象使用)</li>
</ul>
</li>
<li><p>修饰符总结:</p>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>类</th>
<th>成员变量</th>
<th>成员方法</th>
<th>构造方法</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>protected</td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>private</td>
<td></td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>abstract</td>
<td>Y</td>
<td></td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>static</td>
<td></td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
<tr>
<td>final</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td></td>
</tr>
</tbody></table>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2></li>
<li><p>概述：</p>
<ul>
<li>什么是内部类？<ul>
<li>将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。</li>
</ul>
</li>
<li>什么时候使用内部类？<ul>
<li>在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，这时发动机就可以使用内部类来描述。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 汽车 </span>&#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> 发动机 </span>&#123; <span class="comment">//内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p><strong>成员内部类</strong>:</p>
<ul>
<li>定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问</li>
<li>在类的成员位置，和成员变量以及成员方法所在的位置是一样的</li>
<li>在内部类当中，可以直接访问外部类的成员，包括私有成员</li>
<li>定义格式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123; </span><br><span class="line">    修饰符 <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">        <span class="comment">//其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>访问方式:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 变量名 = <span class="keyword">new</span> 外部类名().new 内部类名();</span><br></pre></td></tr></table></figure></li>
<li>成员内部类可以使用的修饰符:<strong>private,public,procted,final,static,abstract</strong></li>
</ul>
</li>
<li><p><strong>局部内部类</strong>:</p>
<ul>
<li>定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问.</li>
<li>在方法内，出了方法之后就无法使用</li>
<li>定义格式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123; </span><br><span class="line">    修饰符 返回值类型 方法名(参数) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">        <span class="comment">//其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>访问方式:在外部类方法中，创建内部类对象，进行访问</li>
</ul>
</li>
<li><p><strong>匿名内部类</strong>:</p>
<ul>
<li>作用：匿名内部类是<strong>创建某个类型子类对象</strong>的<strong>快捷方式</strong>。</li>
<li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类或接口()&#123;</span><br><span class="line"> <span class="comment">//如果是创建了继承这个类的子类对象，我们可以重写父类的方法</span></span><br><span class="line">    <span class="comment">//如果是创建了实现这个接口的子类对象，我们必须要实现该接口的所有方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li>可以把匿名内部类看成是一个没有名字的局部内部类</li>
<li>定义在方法当中</li>
<li>必须在定义匿名内部类的时候创建他的对象</li>
<li>原理：创建了<strong>继承</strong>这个<strong>类</strong>的子类对象或者是创建了<strong>实现</strong>这个<strong>接口</strong>的子类对象</li>
</ul>
</li>
</ul>
<h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><ul>
<li>概述：Object类是Java语言中的根类，即<strong>所有类的父类</strong>。它中描述的所有方法子类都可以使用。所有类在创建对象的时候，最终找的父类就是Object。</li>
<li>获取字节码对象的方式：<ul>
<li>通过Object类的getClass()方法获取。</li>
<li>通过类名调用属性class来获取。</li>
<li>通过Class类的静态方法forName()来获取。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException  </span>&#123;</span><br><span class="line">        <span class="comment">//方式1	通过Object类的getClass()方法获取</span></span><br><span class="line">        Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">        Class clazz = t.getClass();<span class="comment">//返回一个字节码对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式2	通过类名调用属性class来获取</span></span><br><span class="line">        Class clazz2 = Teacher.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式3	通过Class类的静态方法forName()来获取</span></span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">&quot;com.lxy.Teacher&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>toString()方法<ul>
<li>由于toString方法返回的结果是<strong>内存地址</strong>，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要<strong>重写</strong>它。</li>
</ul>
</li>
<li>equals()方法 <ul>
<li>用于比较两个对象是否相同，它其实就是使用两个对象的<strong>内存地址</strong>在<strong>比较</strong>。Object类中的equals方法内部使用的就是==比较运算符。</li>
<li>在开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较，也就是在开发经常需要子类重写equals方法根据对象的属性值进行比较。<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2>&emsp;&emsp;&emsp;System类包含一些有用的类字段和方法。它不能被实例化。</li>
</ul>
</li>
<li>成员方法<ul>
<li><code>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：从src源数组的srcPos索引开始,复制length个元素，从destPost位置开始将这些元素放至到dest数组中</li>
<li><code>static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间(1970-1-1 0:0:0至今过了多少毫秒)</li>
<li><code>static void exit(int status)</code>:终止当前正在运行的Java虚拟机<h2 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3></li>
</ul>
</li>
<li>Date:表示特定的瞬间，精确到毫秒，他可以通过方法来设定自己所表示的时间，可以表示任意的时间</li>
<li>Date类的构造方法<ul>
<li><code>Date()</code>：创建的是一个表示当前系统时间的Date对象</li>
<li><code>Date(long date)</code>：根据”指定时间”创建Date对象</li>
</ul>
</li>
<li>Date类<strong>常用方法</strong><ul>
<li><code>void setTime(long time)</code>:设置时间（毫秒）</li>
<li><code>long getTime()</code>：获取时间（毫秒）<h3 id="DateFormat类-amp-SimpleDateFormat类-日期-时间格式化类"><a href="#DateFormat类-amp-SimpleDateFormat类-日期-时间格式化类" class="headerlink" title="DateFormat类&amp;SimpleDateFormat类(日期/时间格式化类)"></a>DateFormat类&amp;SimpleDateFormat类(日期/时间格式化类)</h3></li>
</ul>
</li>
<li>DateFormat：是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat类）允许进行格式化（也就是日期-&gt;文本）、解析（文本-&gt;日期）和标准化。<ul>
<li>我们通过这个类可以帮我们完成日期和文本之间的转换。</li>
</ul>
</li>
<li>DateFormat&amp;SimpleDateFormat的常用方法<ul>
<li>要格式化一个当前语言环境下的日期也就是日期-&gt;文本），要通过下面的方法来完成。DateFormat是抽象类，我们需要使用其子类SimpleDateFormat来创建对象。</li>
<li>SimpleDateFormat构造方法：<ul>
<li><code>SimpleDateFormat()</code>:用默认的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li>
<li><code>SimpleDateFormat(String pattern)</code>:用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。<h3 id="Calendar类-日历类"><a href="#Calendar类-日历类" class="headerlink" title="Calendar类(日历类)"></a>Calendar类(日历类)</h3></li>
</ul>
</li>
</ul>
</li>
<li>概述：<ul>
<li>Calendar是<strong>日历类</strong>，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</li>
<li>Calendar为<strong>抽象类</strong>，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，将语言敏感内容处理好，再返回子类对象，如下：<ul>
<li>Calendar类静态方法:<ul>
<li><code>static Calendar getInstance()</code>:使用默认时区和语言环境获得一个日历</li>
<li><code>Calendar c = Calendar.getInstance()</code>:返回当前时间</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Calendar类常用方法:<ul>
<li><code>abstract void add(int field,int amount)</code>:根据日历规则，为给定的日历字段添加或减去制定的时间量。</li>
<li><code>int get(int field)</code>：返回给定日历字段的值。</li>
<li><code>Date getTime()</code>：返回一个表示此Calendar时间值(从历元至现在的毫秒偏移量)的Date对象。</li>
<li><code>void set(int field,int value)</code>：将给定的日历字段设置为给定值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//static Calendar getInstance()</span></span><br><span class="line">        Calendar c = Calendar.getInstance();<span class="comment">//返回当前时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//void set(int field, int value) ：把指定的字段修改成指定的值</span></span><br><span class="line">        c.set(Calendar.DAY_OF_MONTH, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void add(int field, int amount): 在指定的字段上加上指定的值</span></span><br><span class="line">        c.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> month = c.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="包装类-amp-正则表达式"><a href="#包装类-amp-正则表达式" class="headerlink" title="包装类&amp;正则表达式"></a>包装类&amp;正则表达式</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3></li>
</ul>
</li>
<li>在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等。那么，想<strong>实现字符串与基本数据之间转换</strong>怎么办呢？</li>
<li>Java中提供了相应的对象来解决该问题，基本数据类型对象包装类：java将基本数据类型值封装成了对象。封装成对象有什么好处？可以提供更多的操作基本数值的功能。</li>
<li>8种基本类型对应的包装类如下：<table>
<thead>
<tr>
<th>字节型</th>
<th>短整型</th>
<th>整型</th>
<th>长整型</th>
<th>字符型</th>
<th>布尔型</th>
<th>浮点型</th>
<th>浮点型</th>
</tr>
</thead>
<tbody><tr>
<td>byte</td>
<td>short</td>
<td>int</td>
<td>long</td>
<td>char</td>
<td>boolean</td>
<td>float</td>
<td>double</td>
</tr>
<tr>
<td>Byte</td>
<td>Short</td>
<td>Integer</td>
<td>Long</td>
<td>Character</td>
<td>Boolean</td>
<td>Float</td>
<td>Double</td>
</tr>
</tbody></table>
</li>
<li>包装类的常用方法<ul>
<li>构造方法:<ul>
<li><code>Integer(int value)</code>：构造一个新分配的Integer对象，它表示制定的int值。</li>
<li><code>Integer(String s)</code>：构造一个新分配的Integer对象，它表示String参数所指示的int值。</li>
</ul>
</li>
<li>成员方法:<ul>
<li><code>int intValue()</code>：以int类型返回该Integer的值。</li>
<li><code>static int parseInt(String s)</code>：将字符串参数作为有符号的十进制整数进行解析。</li>
<li><code>String toString()</code>：返回一个表示该Integer值的String对象。</li>
</ul>
</li>
</ul>
</li>
<li>包装类的<strong>自动装箱</strong>与<strong>自动拆箱</strong><ul>
<li>在需要的情况下，<strong>基本类型与包装类型</strong>可以<strong>通用</strong>。有些时候我们必须使用引用数据类型时，可以传入基本数据类型。</li>
<li>比如：基本类型可以使用运算符直接进行计算，但是引用类型不可以。而基本类型包装类作为引用类型的一种却可以计算，原因在于，Java’偷偷地’自动地<strong>进行了对象向基本数据类型的转换</strong>。</li>
<li>相对应的，引用数据类型变量的值必须是new出来的内存空间地址值，而我们可以将一个基本类型的值赋值给一个基本类型包装类的引用。原因同样在于Java又’偷偷地’自动地<strong>进行了基本数据类型向对象的转换</strong>。</li>
<li><strong>自动拆箱</strong>：对象转成基本数值</li>
<li><strong>自动装箱</strong>：基本数值转成对象<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3></li>
</ul>
</li>
<li><a href="./%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md">正则表达式</a></li>
</ul>
<h2 id="集合-amp-迭代器"><a href="#集合-amp-迭代器" class="headerlink" title="集合&amp;迭代器"></a>集合&amp;迭代器</h2><p>集合体系结构图:<br><img src="https://i.loli.net/2021/04/25/L8EQGW4rcveuTjz.png" alt="集合体系结构图.png"><br>在最顶层的父接口Collection中定义了所有子类集合的共同属性和方法,因此我们首先需要学习Collection中共性方法,然后再去针对每个子类集合学习它的特有方法。</p>
<ul>
<li>集合的体系结构：<ul>
<li>由于不同的数据结构（数据的组织，存储方式），所以Java为我们提供了不同的集合，但是不同的集合他们的功能都是相似，不断的向上提取，将共性抽取出来，这就是集合体系结构形成的原因。</li>
</ul>
</li>
<li>Collection中的常用功能：<ul>
<li><code>boolean add(Object e)</code>: 向集合中添加元素</li>
<li><code>void clear()</code>:清空集合中所有元素</li>
<li><code>boolean contains(Object o)</code>:判断集合中是否包含某个元素</li>
<li><code>boolean isEmpty()</code>:判断集合中的元素是否为空</li>
<li><code>boolean remove(Object o)</code>:根据元素的内容来删除某个元素</li>
<li><code>int size()</code>:获取集合的长度</li>
<li><code>Object[] toArray()</code>:能够将集合转换成数组并把集合中的元素存储到数组中</li>
</ul>
</li>
<li>迭代器:<ul>
<li>java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。我们要取出这些集合中的元素，可通过一种<strong>通用的获取方式</strong>来完成。</li>
<li>Collection集合元素的<strong>通用获取方式</strong>：<ul>
<li>在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为<strong>迭代</strong>。</li>
<li>集合中把这种取元素的方式描述在Iterator接口中。</li>
<li>Iterator接口的常用方法如下<ul>
<li><code>boolean hasNext()</code>方法：判断集合中是否有元素可以迭代 </li>
<li><code>E next()</code>方法：用来返回迭代的下一个元素，并把指针向后移动一位。</li>
</ul>
</li>
</ul>
</li>
<li>注意：在使用迭代器遍历集合时，不允许对元素进行增加或删除操作。<h2 id="增强for-amp-泛型"><a href="#增强for-amp-泛型" class="headerlink" title="增强for&amp;泛型"></a>增强for&amp;泛型</h2></li>
</ul>
</li>
<li>增强for：<ul>
<li>增强for循环是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。</li>
<li>它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</li>
<li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量 : Collection集合or数组)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意：它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</li>
</ul>
</li>
<li>泛型: <ul>
<li>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。<h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2></li>
</ul>
</li>
<li>数组：<ul>
<li>数组，采用该结构的集合，对元素的存取有如下的特点：<ul>
<li>数组的长度一旦定义则不可改变。</li>
<li>数组中的元素都有整数索引。</li>
<li>数组只能存储同一类型的元素。</li>
<li>数组既可以存储基本数据类型，也可以存储引用数据类型。</li>
<li>查找元素快：通过索引，可以快速访问指定位置的元素。</li>
<li>增删元素慢：每次添加元素需要移动大量元素或者创建新的数组。</li>
</ul>
</li>
</ul>
</li>
<li>链表：<ul>
<li>链表，采用该结构的集合，对元素的存取有如下的特点：<ul>
<li>多个节点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</li>
<li>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。</li>
<li>增删元素快。</li>
<li>增加元素：只需要修改连接下个元素的地址即可。</li>
<li>删除元素：只需要修改连接下个元素的地址即可。</li>
</ul>
</li>
</ul>
</li>
<li>栈：<ul>
<li>堆栈，采用该结构的集合，对元素的存取有如下的特点：<ul>
<li><strong>先进后出</strong>（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</li>
</ul>
</li>
</ul>
</li>
<li>队列：<ul>
<li>队列，采用该结构的集合，对元素的存取有如下的特点：<ul>
<li><strong>先进先出</strong>（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，安检。排成一列，每个人依次检查，只有前面的人全部检查完毕后，才能排到当前的人进行检查。<h2 id="List子体系"><a href="#List子体系" class="headerlink" title="List子体系"></a>List子体系</h2></li>
</ul>
</li>
</ul>
</li>
<li>List子体系特点<ul>
<li><strong>有序的</strong>（存储和读取的顺序是一致的） </li>
<li>有整数<strong>索引</strong></li>
<li><strong>允许重复</strong>的</li>
</ul>
</li>
<li>List的特有功能：<ul>
<li><code>void add(int index, E element)</code> :将元素添加到index索引位置上<ul>
<li><code>E get(int index)</code> :根据index索引获取元素</li>
<li><code>E remove(int index)</code> :根据index索引删除元素</li>
<li><code>E set(int index, E element)</code>:将index索引位置的的元素设置为element</li>
</ul>
</li>
</ul>
</li>
<li><strong>LinkedList</strong>特有功能:<ul>
<li>LinkedList底层使用的是<strong>链表</strong>结构,因此增删快,查询相对ArrayList较慢</li>
<li><code>void addFirst(E e)</code>:向链表的头部添加元素</li>
<li><code>void addLast(E e)</code>:向链表的尾部添加元素</li>
<li><code>E getFirst()</code>:获取链头的元素,不删除元素</li>
<li><code>E getLast()</code>:获取链尾的元素,不删除元素</li>
<li><code>E removeFirst()</code>:返回链头的元素并删除链头的元素</li>
<li><code>E removeLast()</code>:返回链尾的元素并删除链尾的元素</li>
</ul>
</li>
<li>如何选择使用不同的集合？<ul>
<li>如果查询多，增删少，则使用ArrayList</li>
<li>如果查询少，增删多，则使用LinkedList</li>
<li>如果你不知道使用什么，则使用ArrayList</li>
</ul>
</li>
</ul>
<h2 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h2><ul>
<li>Set接口的特点:<ul>
<li>存入集合的顺序和取出集合的<strong>顺序不一致</strong></li>
<li><strong>没有索引</strong></li>
<li><strong>不可重复</strong></li>
</ul>
</li>
<li>HashSet唯一性原理:<ul>
<li>规则:新添加到HashSet集合的元素都会与集合中已有的元素一一比较<ul>
<li>首先比较哈希值(每个元素都会调用hashCode()产生一个哈希值)</li>
<li>如果新添加的元素与集合中已有的元素的哈希值都不同,新添加的元素存入集合</li>
<li>如果新添加的元素与集合中已有的某个元素哈希值相同,此时还需要调用equals(Object obj)比较<ul>
<li>如果equals(Object obj)方法返回true,说明新添加的元素与集合中已有的某个元素的属性值相同,那么新添加的元素不存入集合。</li>
<li>如果equals(Object obj)方法返回false, 说明新添加的元素与集合中已有的元素的属性值都不同, 那么新添加的元素存入集合。</li>
</ul>
</li>
</ul>
</li>
<li>hashCode方法优化:<ul>
<li>如果让hashCode()方法返回一个固定值,那么每个新添加的元素都要调用equals(Object obj)方法比较,那么效率较低</li>
<li>只需要让不同属性的值的元素产生不同的哈希值,那么就可以不再调用equals方法比较提高效率<h2 id="Collections中的方法"><a href="#Collections中的方法" class="headerlink" title="Collections中的方法"></a>Collections中的方法</h2></li>
</ul>
</li>
</ul>
</li>
<li>面试题：Collection和Collections有什么区别？<ul>
<li>Collection是集合体系的最顶层，包含了集合体系的共性</li>
<li>Collections是一个工具类，方法都是用于操作Collection</li>
</ul>
</li>
<li><code>static void swap(List list, int i, int j);</code> :将指定列表中的两个索引进行位置互换</li>
<li><code>static void  sort(List&lt;T&gt; list);</code> :按照列表中元素的自然顺序进行排序</li>
<li><code>static void shuffle(List list);</code>:将元素的顺序随机置换</li>
<li><code>static void reverse(List list);</code>:将元素的顺序反转</li>
<li><code>static void fill(List list, Object obj);</code>:使用指定的对象填充指定列表的<strong>所有</strong>元素</li>
<li><code>static void copy(List dest, List src);</code>:是把源列表中的数据覆盖到目标列表(注意：目标列表的长度至少等于源列表的长度)</li>
<li><code>static int  binarySearch(List list, Object key);</code>:使用二分查找法查找指定元素在指定列表的索引位置<h2 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h2></li>
<li>Map接口概述:<ul>
<li>我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同:<ul>
<li>Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储</li>
<li>Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li>
<li>Collection中的集合称为单列集合，Map中的集合称为<strong>双列集合</strong>。</li>
<li>需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li>
</ul>
</li>
</ul>
</li>
<li>Map常用功能:<ul>
<li>映射功能：<ul>
<li><code>V put(K key, V value);</code> :以键=值的方式存入Map集合(如果key存在，则覆盖value，并将原来的value返回)</li>
</ul>
</li>
<li>获取功能：<ul>
<li><code>V get(Object key);</code>:根据键获取值</li>
<li><code>int size();</code>:返回Map中键值对的个数</li>
</ul>
</li>
<li>判断功能：<ul>
<li><code>boolean containsKey(Object key);</code>:判断Map集合中是否包含键为key的键值对</li>
<li><code>boolean containsValue(Object value);</code>:判断Map集合中是否包含值为value键值对</li>
<li><code>boolean isEmpty();</code>:判断Map集合中是否没有任何键值对 </li>
</ul>
</li>
<li>删除功能：<ul>
<li><code>void clear();</code>:清空Map集合中所有的键值对</li>
<li><code>V remove(Object key);</code>:根据键值删除Map中键值对,并返回key所对应的值，如果没有删除成功则返回null</li>
</ul>
</li>
<li>遍历功能：<ul>
<li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>:将每个键值对封装到一个个Entry对象中,再把所有Entry的对象封装到Set集合中返回</li>
<li><code>Set&lt;K&gt; keySet();</code> :将Map中所有的键装到Set集合中返回</li>
<li><code>Collection&lt;V&gt; values();</code>:返回集合中所有的value的值的集合</li>
</ul>
</li>
</ul>
</li>
<li>Map的两种遍历方式:<ul>
<li>利用keySet()方法遍历:<ul>
<li>首先召集所有的key</li>
<li>遍历所有的key</li>
<li>获取每一个key</li>
<li>让每一个key去找对应的value</li>
</ul>
</li>
<li>利用entrySet()方法遍历：<ul>
<li>通过Map.Entry对象来获取Key和Value<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key，V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() </span><br></pre></td></tr></table></figure>
<h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2></li>
</ul>
</li>
</ul>
</li>
<li>概述:<ul>
<li>当参数不确定的时候, 类型要明确</li>
<li>Java可以把多个参数直接帮我们转成数组</li>
</ul>
</li>
<li>理解: 可变参数本质就是一个长度可变的数组.</li>
<li>格式:<ul>
<li>实参: 一个参数一个参数的传递</li>
<li>形参: <code>类型...变量名</code>例如<code>String... strs</code>。</li>
</ul>
</li>
<li>注意：<ul>
<li>在可变参数之后不可以再追加参数</li>
<li>参数的数量定义, 可以给多个甚至也可以一个都不给</li>
</ul>
</li>
</ul>
<h2 id="异常产生-amp-异常处理"><a href="#异常产生-amp-异常处理" class="headerlink" title="异常产生&amp;异常处理"></a>异常产生&amp;异常处理</h2><ul>
<li>异常概述：<ul>
<li>什么是异常？Java代码在运行时期发生的问题就是异常。</li>
<li>在Java中，把异常信息封装成了一个类。当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）。</li>
<li>在Java中使用Exception类来描述异常。</li>
<li>API中Exception的描述：“Exception类及其子类是Throwable的一种形式，它用来表示java程序中可能会产生的异常，并要求对产生的异常进行合理的异常处理。”</li>
<li>Exception有继承关系，它的父类是Throwable。Throwable是Java语言中所有错误或异常的<strong>超类</strong>，即<strong>祖宗类</strong>。</li>
<li>另外，在异常Exception类中，有一个子类要特殊说明一下，RuntimeException子类，RuntimeException及其它的子类只能在Java程序运行过程中出现。</li>
<li>我们再来观察Throwable类，能够发现与异常Exception平级的有一个Error，它是Throwable的子类，它用来表示java程序中可能会产生的严重错误。解决办法只有一个，<strong>修改代码</strong>避免Error错误的产生。</li>
</ul>
</li>
<li>异常的体系结构：<ul>
<li>Throwable（最顶层）<ul>
<li>Error:出现的不能够处理的严重问题</li>
<li>Exception:可以处理的问题</li>
</ul>
</li>
</ul>
</li>
<li>异常处理：<ul>
<li>1.JVM默认处理方式：如果出现异常我们没有处理，jvm会帮我们进行处理，他会把异常的类型，原因还有位置显示在命令行并且还终止了程序，异常后面的代码将不再执行。</li>
<li>2.try…catch方式处理异常:<ul>
<li>捕获：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理捕获异常格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//需要被检测的语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类 变量) &#123; <span class="comment">//参数。</span></span><br><span class="line">    <span class="comment">//异常的处理语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//一定会被执行的语句。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>try：该代码块中编写可能产生异常的代码。</li>
<li>catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。</li>
<li>finally:无论try…catch语句如何执行，finally的代码一定会执行。</li>
</ul>
</li>
<li>3.throws方式处理异常<ul>
<li>throws使用:使用关键字throws在方法的声明出抛出异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表) <span class="keyword">throws</span> 异常类型<span class="number">1</span>,异常类型<span class="number">2.</span>..&#123;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>4.多异常处理<ul>
<li>对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//不用throws </span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//产生异常，直接捕获处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(XxxException e)&#123;</span><br><span class="line"><span class="comment">//处理方式	</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(YyyException e)&#123;</span><br><span class="line"><span class="comment">//处理方式	</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(ZzzException e)&#123;</span><br><span class="line"><span class="comment">//处理方式	</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。<h2 id="Throwable常用方法-amp-自定义异常"><a href="#Throwable常用方法-amp-自定义异常" class="headerlink" title="Throwable常用方法&amp;自定义异常"></a>Throwable常用方法&amp;自定义异常</h2></li>
</ul>
</li>
</ul>
</li>
<li>Throwable常用方法:<ul>
<li><code>String getMessage();</code>:返回此throwable的详细消息字符串</li>
<li><code>String toString();</code>:返回此throwable的简短描述</li>
<li><code>void printStackTrace();</code>:打印异常的堆栈的跟踪信息</li>
</ul>
</li>
<li>finally的概述和应用场景  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常变量)&#123;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//释放资源的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>无论try…catch语句如何执行，finally的代码一定会执行。</li>
</ul>
</li>
<li>编译时异常&amp;运行时异常<ul>
<li>编译时期异常:是Exception的子类，非RuntimeExcpetion的子类，在编译时期必须处理。</li>
<li>运行时期异常：RuntimeException和他的所有子类异常,都属于运行时期异常。<ul>
<li>NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常.</li>
<li>运行时期异常的特点:<ul>
<li>方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常</li>
<li>运行时期异常一旦发生,需要程序人员修改源代码。<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>递归，指在当前方法内调用自己的这种现象  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(“递归的演示”);</span><br><span class="line">    <span class="comment">//在当前方法内调用自己</span></span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>递归注意事项：<ul>
<li>递归一定要有出口，否则会内存溢出。</li>
<li>递归次数不宜过多，否则会内存溢出。</li>
</ul>
</li>
</ul>
<p>##File类</p>
<ul>
<li>File概述：<ul>
<li>File文件和目录路径名的抽象表示形式。即，Java中把<strong>文件</strong>或者目录（<strong>文件夹</strong>）都封装成File对象。也就是说如果我们要去操作硬盘上的文件，或者文件夹只要找到File这个类即可,那么我们就要研究研究File这个类中都有那些功能可以操作文件或者文件夹呢。</li>
</ul>
</li>
<li>File类的<strong>构造</strong>函数：<ul>
<li><code>File(String pathname);</code> :将一个字符串路径封装成File对象</li>
<li><code>File(String parent,String child);</code>:传入一个父级路径和子级路径</li>
<li><code>File(File parent,String child);</code>:传入一个File类型的父级路径和子级路径</li>
</ul>
</li>
<li>File类<strong>创建</strong>和<strong>删除</strong>功能：<ul>
<li><code>boolean createNewFile();</code>:指定路径不存在该文件时时创建文件,返回true,否则返回false</li>
<li><code>boolean mkdir();</code>:当指定的<strong>单级文件夹</strong>不存在时创建文件夹，并返回true，否则返回false  </li>
<li><code>boolean mkdirs();</code>:当指定的<strong>多级文件夹</strong>某一级文件夹**不存在时,创建多级文件夹，并返回true,否则返回false</li>
<li><code>boolean delete();</code>:删除文件或者删除单级文件夹(注意：删除一个文件夹，这个文件夹下面不能有其他的文件和文件夹)</li>
</ul>
</li>
<li>File类的<strong>判断</strong>功能：<ul>
<li><code>boolean exists();</code>:判断指定路径的文件或文件夹是否存在</li>
<li><code>boolean isAbsolute();</code>:判断当前路径是否是绝对路径</li>
<li><code>boolean isDirectory();</code>:判断当前的目录是否存在</li>
<li><code>boolean isFile();</code>:判断当前路径是否是一个文件</li>
<li><code>boolean isHidden();</code>:判断当前路径是否是隐藏文件</li>
</ul>
</li>
<li>File类的<strong>获取</strong>功能和<strong>修改名字</strong>功能<ul>
<li><code>File getAbsoluteFile();</code>:获取文件的绝对路径,返回File对象</li>
<li><code>String getAbsolutePath();</code>:获取文件的绝对路径,返回路径的字符串</li>
<li><code>String getParent();</code>:获取当前路径的父级路径,以字符串形式返回该父级路径</li>
<li><code>File getParentFile();</code>:获取当前路径的父级路径,以字File对象形式返回该父级路径</li>
<li><code>String getName();</code>:获取文件或文件夹的名称</li>
<li><code>String getPath();</code>:获取File对象中封装的路径</li>
<li><code>long lastModified();</code>:以毫秒值返回最后修改时间</li>
<li><code>long length();</code>:返回文件的字节数</li>
<li><code>boolean renameTo(File dest);</code>: 将当前File对象所指向的路径 修改为 指定File所指向的路径</li>
</ul>
</li>
<li>File类的<strong>其它获取</strong>功能<ul>
<li><code>String[] list();</code>:以字符串数组的形式返回当前路径下所有的文件和文件夹的名称(注意：只有指向文件夹的File对象才可以调用该方法)</li>
<li><code>File[] listFiles();</code>:以File对象的形式返回当前路径下所有的文件和文件夹的名称(注意：只有指向文件夹的File对象才可以调用该方法)</li>
<li><code>static File[] listRoots();</code>:获取计算机中所有的盘符</li>
</ul>
</li>
<li>File类的两个案例：<ul>
<li>一、列出当前路径下（包含子目录）的所有以’.java’结尾的文件名称<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">        listAllFileName(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 列出当前路径下（包含子目录）的所有以&#x27;.java&#x27;结尾的文件名称</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> file 文件夹</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAllFileName</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="comment">//判断是否是文件对象</span></span><br><span class="line">                <span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">                        System.out.println(f.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">//是一个目录对象</span></span><br><span class="line">                    listAllFileName(f);<span class="comment">//递归调用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>二、删除指定目录下所有文件和目录（包含子目录）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;e:\\threadFile&quot;</span>);</span><br><span class="line">        delAllFiles(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除指定目录下所有文件和目录（包含子目录）</span></span><br><span class="line"><span class="comment">    * 注意：如果要删除一个目录，则需要先删除这个目录下的所有子文件和子目录</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> file 文件夹</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delAllFiles</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">//干掉自己所有的子文件和子目录</span></span><br><span class="line">            <span class="comment">//获取所有的子文件和子目录</span></span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="keyword">if</span>(f.isFile()) &#123;</span><br><span class="line">                    <span class="comment">//直接干掉他</span></span><br><span class="line">                    System.out.println(f.getName());</span><br><span class="line">                    f.delete();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(f.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">//继续查看是否还有文件和子目录</span></span><br><span class="line">                    delAllFiles(f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干掉自己</span></span><br><span class="line">            System.out.println(file.getName());</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h2></li>
</ul>
</li>
<li>IO流分类：<ul>
<li>按<strong>流向</strong>分：<ul>
<li>输入流–读取数据–FileReader–Reader</li>
<li>输出流–写出数据–FileWriter–Writer</li>
</ul>
</li>
<li>按<strong>数据类型</strong>分：<ul>
<li>字节流    <ul>
<li>字节输入流–读取数据–InputStream</li>
<li>字节输出流–写出数据–OutputStream</li>
</ul>
</li>
<li>字符流<ul>
<li>字符输入流–读取数据–Reader</li>
<li>字符输出流–写出数据–Writer</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>字符流与字节流的区别：<ul>
<li><strong>字节流</strong>可以操作<strong>所有类型</strong>的文件,因为<strong>所有的文件</strong>在计算机中都是以<strong>字节</strong>形式存储。</li>
<li>而<strong>字符流</strong>只能用来操作<strong>纯文本类型</strong>的文件,不能操作字节类型的文件。</li>
</ul>
</li>
<li>二进制文件只能使用<strong>字节流</strong>进行复制（使用windows自带记事本打开读不懂的）</li>
<li>文本文件的复制即可使用字符流，也可以使用字节流</li>
</ul>
<h2 id="标准输入流-amp-转换流-amp-打印流"><a href="#标准输入流-amp-转换流-amp-打印流" class="headerlink" title="标准输入流 &amp; 转换流 &amp; 打印流"></a>标准输入流 &amp; 转换流 &amp; 打印流</h2><ul>
<li>标准输入输出流：<ul>
<li><code>public static final InputStream in;</code>:标准输入流–字节输入流,用来读取键盘录入的数据.</li>
<li><code>public static final PrintStream out;</code>:标准输出流–字节输出流,将数据输出到命令行.</li>
</ul>
</li>
<li>转换流<ul>
<li><code>OutputStreamWriter</code>:将字节输出流转换为字符输出流</li>
<li><code>InputStreamReader</code>:将字节输入流转换为字符输入流</li>
</ul>
</li>
<li>打印流<ul>
<li>打印流添加输出数据的功能，使它们能够方便地打印各种数据值表示形式.</li>
<li>字符打印流：PrintWriter<ul>
<li><code>void print(String str);</code>: 输出任意类型的数据，</li>
<li><code>void println(String str);</code>: 输出任意类型的数据，自动写入换行操作<h2 id="对象操作流"><a href="#对象操作流" class="headerlink" title="对象操作流"></a>对象操作流</h2></li>
</ul>
</li>
</ul>
</li>
<li>概述：<ul>
<li>用于从流中读取对象。</li>
<li><code>ObjectInputStream</code> 称为<strong>反序列化流</strong>,利用输入流从文件中读取对象。</li>
<li><code>ObjectOutputStream</code> 称为<strong>序列化流</strong>,利用输出流向文件中写入对象。</li>
<li>特点：<ul>
<li>用于操作对象。可以将对象写入到文件中，也可以从文件中读取对象。</li>
<li>可以用于读写任意类型的对象.</li>
<li>使用对象输出流写出对象，只能使用对象输入流来读取对象.</li>
<li>只能将支持 java.io.Serializable 接口的对象写入流中.</li>
</ul>
</li>
</ul>
</li>
<li>ObjectOutputStream<ul>
<li><code>writeObject</code></li>
<li><code>ObjectOutputStream(OutputStream out)</code></li>
</ul>
</li>
<li>ObjectInputStream<ul>
<li><code>readObject</code></li>
<li><code>ObjectInputStream(InputStream in)</code><h3 id="利用序列化流读写对象"><a href="#利用序列化流读写对象" class="headerlink" title="利用序列化流读写对象"></a>利用序列化流读写对象</h3></li>
</ul>
</li>
<li>Serializable:<ul>
<li><strong>序列号</strong>，是一个标识接口，只起标识作用，没有方法</li>
<li>当一个类的对象需要IO流进行读写的时候，这个类必须实现该接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//对象输出到文件</span></span><br><span class="line">        method();</span><br><span class="line">        <span class="comment">//读取对象文件</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象输出流的对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E://b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        <span class="comment">//写出学生对象</span></span><br><span class="line">        oos.writeObject(s);</span><br><span class="line">        oos.writeObject(s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象输入流的对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E://b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Object obj = ois.readObject();</span><br><span class="line">                System.out.println(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException e) &#123;<span class="comment">//读取到末尾会报异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读到了文件的末尾&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure>
<h3 id="解决对象输入流读取对象出现异常的问题"><a href="#解决对象输入流读取对象出现异常的问题" class="headerlink" title="解决对象输入流读取对象出现异常的问题"></a>解决对象输入流读取对象出现异常的问题</h3></li>
</ul>
</li>
<li>用集合解决<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStreamDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//对象输出到文件</span></span><br><span class="line">        method();</span><br><span class="line">        <span class="comment">//读取对象文件</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象输出流的对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E://b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加学生对象</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">30</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">28</span>));</span><br><span class="line">        <span class="comment">//写出集合对象</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象输入流的对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E://b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        List&lt;Student&gt; list = (List) obj;</span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解决读写对象版本不一致问题-解决对实现序列化接口出现的黄色警告问题"><a href="#解决读写对象版本不一致问题-解决对实现序列化接口出现的黄色警告问题" class="headerlink" title="解决读写对象版本不一致问题(解决对实现序列化接口出现的黄色警告问题)"></a>解决读写对象版本不一致问题(解决对实现序列化接口出现的黄色警告问题)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6361890890437825953L</span>;<span class="comment">//显式声明序列化ID</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h2></li>
<li>Properties介绍:<ul>
<li>Properties类表示了一个持久的属性集。</li>
<li>Properties可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</li>
<li>特点：<ul>
<li>Hashtable的子类，map集合中的方法都可以用。</li>
<li>该集合没有泛型。键值都是字符串。</li>
<li>它是一个可以持久化的属性集。键值可以存储到集合中，也可以存储到持久化的设备(硬盘、U盘、光盘)上。键值的来源也可以是持久化的设备。</li>
<li>有和流技术相结合的方法。<ul>
<li><code>void load(InputStream instream)</code>:从输入流中读取属性列表（键和元素对）</li>
<li><code>void load(Reader reader)</code>:按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）</li>
<li><code>void store(OutputStream outputStream,String comments)</code>:以适合使用load(InputStream)方法加载到Properties表中的格式，将此Properties表中的属性列表(键和元素对)写入输出流</li>
<li><code>void store(Writer writer,String comments)</code>:以适合使用load(Reader)方法的格式，将此Properties表中的属性列表(键和元素对)写入输出字符</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>利用Properties存储键值对<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建属性列表对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//添加映射关系</span></span><br><span class="line">        prop.put(<span class="string">&quot;CZBK001&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;CZBK002&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;CZBK003&quot;</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历属性列表</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : prop.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>Properties与流结合使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将属性列表写入文件</span></span><br><span class="line">        method();</span><br><span class="line">        <span class="comment">//将属性列表写入文件（并加入注释）</span></span><br><span class="line">        <span class="comment">//method3();</span></span><br><span class="line">        <span class="comment">//从文件读取写入列表</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建属性列表对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//添加映射关系</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK001&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK002&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK003&quot;</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建打印流对象</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;E://d.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//void list(PrintWriter out)</span></span><br><span class="line">        prop.list(out);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建属性列表对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//创建一个输入流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E://d.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//void load(Reader reader)</span></span><br><span class="line">        prop.load(fr);<span class="comment">//不会读取注释信息</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">        System.out.println(prop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建属性列表对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//添加映射关系</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK001&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK002&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK003&quot;</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E://d.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//void store(Writer writer, String comments)</span></span><br><span class="line">        prop.store(fw, <span class="string">&quot;hello world&quot;</span>);<span class="comment">//会加入注释和日期</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h2></li>
<li>概述:<ul>
<li>编码表：把计算机底层的二进制数据转换成我们能看到的字符<ul>
<li>ASCII</li>
<li>GB2312:GBK</li>
<li>Unicode:所有的字符都占2个字节</li>
<li>UTF-8    长度可变的码表</li>
<li>ANSI：本地编码表(gbk)</li>
</ul>
</li>
<li>Java中的字符串默认使用的ANSI（gbk）</li>
<li>乱码：编码保持前后一致即可解决</li>
</ul>
</li>
<li>Java中字符串的编码<ul>
<li>常用方法<ul>
<li>构造方法（字节数组转字符串）：<ul>
<li><code>String()</code>:初始化一个新创建的String对象，使其表示一个空字符序列。</li>
<li><code>String(byte[] bytes)</code>:使用平台的默认字符集解码指定的byte数组，构造一个新的String。</li>
<li><code>String(byte[] bytes, Charset charset)</code>:通过使用指定的charset解码指定的byte数组，构造一个新的String。</li>
</ul>
</li>
<li>成员方法（字符串转字节数组）<ul>
<li><code>getBytes()</code>:使用平台的默认字符集将此String编码为byte序列，并将结果存储到一个新的byte数组中。</li>
<li><code>getBytes(Charset charset)</code>:使用给定的charset将此String编码到byte序列，并将结果存储到新的byte数组。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>字符流中的编码<ul>
<li>常见对象<ul>
<li><code>InputStreamReader(InputStream in,CharsetDecoder dec)</code>:创建使用给定字符集解码器的InputStreamReader</li>
<li><code>OutputStreamWriter(OutputStream out,CharsetEncoder enc)</code>:创建使用给定字符集编码器的OutputStreamWriter</li>
</ul>
</li>
<li>字符流 = 字节流 + 编码</li>
</ul>
</li>
</ul>
<h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul>
<li>概述：<ul>
<li>学习多线程之前，我们先要了解几个关于多线程有关的概念。</li>
<li><strong>进程</strong>：指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</li>
<li><strong>线程</strong>：是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为<strong>多线程程序</strong>。</li>
<li>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。</li>
<li>什么是多线程呢？<ul>
<li>即一个程序中有多个线程在同时执行。</li>
</ul>
</li>
</ul>
</li>
<li>线程实现：                <ul>
<li>实现线程一:继承<strong>Thread类</strong>:<ul>
<li>Thread是程序中的执行线程。Java虚拟机允许应用程序并发地运行多个执行线程。</li>
<li>CPU执行程序的随机性。</li>
<li>创建线程的步骤：<ul>
<li>1.定义一个类继承Thread。</li>
<li>2.重写run方法。</li>
<li>3.创建子类对象，就是创建线程对象。</li>
<li>4.调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法</li>
</ul>
</li>
<li>Thread<ul>
<li><code>String getName()</code>:返回该线程的名称。 </li>
<li><code>void setName(String name)</code>:改变线程名称，使之与参数name相同。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程实例</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//修改线程名字</span></span><br><span class="line">        mt.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程实例</span></span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt2.setName(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        mt2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>实现线程二:实现<strong>Runnable接口</strong>:<ul>
<li>Runnable接口用来指定每个线程要执行的任务。包含了一个run的无参数抽象方法，需要由接口实现类重写该方法。</li>
<li>创建线程的步骤。<ul>
<li>1、定义类实现Runnable接口。</li>
<li>2、覆盖接口中的run方法。</li>
<li>3、创建Thread类的对象。</li>
<li>4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。</li>
<li>5、调用Thread类的start方法开启线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//链式编程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程实例</span></span><br><span class="line">        Thread mt = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2());</span><br><span class="line">        <span class="comment">//修改线程名字</span></span><br><span class="line">        mt.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程实例</span></span><br><span class="line">        Thread mt2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2());</span><br><span class="line">        mt2.setName(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        mt2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>多线程安全问题产生&amp;解决方案<ul>
<li>问题出现的原因：<ul>
<li>要有多个线程</li>
<li>要有被多个线程所共享的数据</li>
<li>多个线程并发的访问共享的数据</li>
</ul>
</li>
<li>使用<strong>同步代码块</strong>解决:<ul>
<li>synchronized:同步（锁），可以修饰代码块和方法，被修饰的代码块和方法一旦被某个线程访问，则直接锁住，其他的线程将无法访问</li>
<li>注意：锁对象需要被所有的线程所共享</li>
<li>同步：安全性高，效率低</li>
<li>非同步：效率高，但是安全性低<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式:</span></span><br><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="comment">//需要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>使用<strong>同步方法</strong>解决:<ul>
<li>同步方法:使用关键字synchronized修饰的方法，一旦被一个线程访问，则整个方法全部锁住，其他线程则无法访问</li>
<li>注意：<ul>
<li>非静态同步方法的锁对象是this</li>
<li>静态的同步方法的锁对象是当前类的字节码对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式:</span></span><br><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值 方法名()&#123;</span><br><span class="line">    <span class="comment">//需要同步的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="面向网络编程"><a href="#面向网络编程" class="headerlink" title="面向网络编程"></a>面向网络编程</h2><h3 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h3><ul>
<li>网络协议:<ul>
<li>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中,这些<strong>连接和通信的规则</strong>被称为<strong>网络通信协议</strong>，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li>
<li>网络通信协议有很多种，目前应用最广泛的是<strong>TCP/IP协议</strong>(Transmission Control Protocal/Internet Protoal传输控制协议/英特网互联协议)，它是一个包括TCP协议和IP协议，UDP（User Datagram Protocol）协议和其它一些协议的协议组，在学习具体协议之前首先了解一下TCP/IP协议组的层次结构。</li>
<li>在进行数据传输时，要求发送的数据与收到的数据完全一样，这时，就需要在原有的数据上添加很多信息，以保证数据在传输过程中数据格式完全一致。TCP/IP协议的层次结构比较简单，共分为四层，如图所示。<br><img src="https://i.loli.net/2021/04/25/NoIZBKWE1AYDcUj.png" alt="TCP-IP网络模型.png"></li>
<li>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。<ul>
<li><strong>链路层</strong>：用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li>
<li><strong>网络层</strong>：是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</li>
<li><strong>传输层</strong>：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。</li>
<li><strong>应用层</strong>：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li>
</ul>
</li>
</ul>
</li>
<li>IP地址和端口号:<ul>
<li>要想使网络中的计算机能够进行通信，必须为每台计算机指定一个<strong>标识号</strong>，通过这个标识号来指定接受数据的计算机或者发送数据的计算机。</li>
<li>在TCP/IP协议中，这个标识号就是<strong>IP地址</strong>，它可以唯一标识一台计算机，目前，IP地址广泛使用的版本是<strong>IPv4</strong>，它是由<strong>4个字节大小的二进制数</strong>来表示，如：00001010000000000000000000000001。由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”。</li>
<li>随着计算机网络规模的不断扩大，对IP地址的需求也越来越多，IPV4这种用4个字节表示的IP地址面临枯竭，因此<strong>IPv6</strong>便应运而生了，IPv6使用<strong>16个字节</strong>表示IP地址，它所拥有的地址容量约是IPv4的8×1028倍，达到2128个（算上全零的），这样就解决了网络地址资源数量不够的问题。</li>
<li>通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，<strong>不同的应用程序是通过端口号区分</strong>的。端口号是用<strong>两个字节</strong>（16位的二进制数）表示的，它的取值范围是0<del>65535，其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用。</li>
<li>接下来通过一个图例来描述IP地址和端口号的作用，如下图所示。<br><img src="https://i.loli.net/2021/04/25/uP8qJtYjdcSEfkC.jpg" alt="IP地址和端口号的作用.jpg"></li>
<li>从上图中可以清楚地看到，位于网络中一台计算机可以通过IP地址去访问另一台计算机，并通过端口号访问目标计算机中的某个应用程序。</li>
</ul>
</li>
<li>InetAddress:<ul>
<li>了解了IP地址的作用，我们看学习下JDK中提供了一个InetAdderss类，该类用于封装一个IP地址，并提供了一系列与IP地址相关的方法，下面列出了InetAddress类的一些常用方法。<ul>
<li><code>static InetAddress getByName(String host)</code>:在给定主机名的情况下确定主机的IP地址</li>
<li><code>static InetAddress getLocalHost()</code>:返回本地主机</li>
<li><code>String getHostName()</code>:获取此IP地址的主机名</li>
<li><code>String getHostAddress()</code>:返回IP地址字符串(以文本表现形式)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line"><span class="comment">//        InetAddress address = InetAddress.getByName(&quot;DESKTOP-IHI76E3&quot;);</span></span><br><span class="line"><span class="comment">//        InetAddress address = InetAddress.getByName(&quot;172.16.132.177&quot;);</span></span><br><span class="line">        InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(address.getHostAddress());<span class="comment">//172.16.132.177返回IP地址</span></span><br><span class="line">        System.out.println(address.getHostName());<span class="comment">//DESKTOP-IHI76E3返回主机名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3></li>
</ul>
</li>
</ul>
</li>
<li>概述：<ul>
<li>UDP是<strong>无连接通信协议</strong>，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</li>
<li>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</li>
<li>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，<strong>不能保证数据的完整性</strong>，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。<br><img src="https://i.loli.net/2021/04/25/ZeLuTz6WxB4P3kG.jpg" alt="UDP的交换过程.jpg"></li>
</ul>
</li>
<li>DatagramPacket类<ul>
<li>前面介绍了UDP是一种面向无连接的协议，因此，在通信时发送端和接收端不用建立连接。UDP通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用“<strong>集装箱</strong>”进行打包，为此JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，<strong>用于封装UDP通信中发送或者接收的数据</strong>。</li>
<li>想要创建一个DatagramPacket对象，首先需要了解一下它的构造方法。在创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同，接收端的构造方法只需要接收一个字节数组来存放接收到的数据，而发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定发送端IP地址和端口号。</li>
<li>接下来根据API文档的内容，对DatagramPacket的构造方法进行逐一详细地讲解。<ul>
<li><code>DatagramPacket(byte[] buf,int length)</code>:构造DatagramPacket，用来接收长度为length的数据包。<ul>
<li>使用该构造方法在创建DatagramPacket对象时，指定了封装数据的字节数组和数据的大小，没有指定IP地址和端口号。很明显，这样的对象只能用于接收端，不能用于发送端。因为发送端一定要明确指出数据的目的地(ip地址和端口号)，而接收端不需要明确知道数据的来源，只需要接收到数据即可。</li>
</ul>
</li>
<li><code>DatagramPacket(byte[] buf,int length,InetAddress address,int port)</code>:构造数据报包，用来将长度为length的包发送到指定主机的指定端口号。<ul>
<li>使用该构造方法在创建DatagramPacket对象时，不仅指定了封装数据的字节数组和数据的大小，还指定了数据包的目标IP地址（address）和端口号（port）。该对象通常用于发送端，因为在发送数据时必须指定接收端的IP地址和端口号，就好像发送货物的集装箱上面必须标明接收人的地址一样。</li>
</ul>
</li>
</ul>
</li>
<li>上面我们讲解了DatagramPacket的构造方法，接下来对DatagramPacket类中的常用方法进行详细地讲解，如下所示。<ul>
<li><code>InetAddress getAddress()</code>:返回某台机器的IP地址，此数据报将要发往该机器或者是从该机器接收到的</li>
<li><code>int getPort()</code>:返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的</li>
<li><code>byte[] getData()</code>:返回数据缓存区</li>
<li><code>int getLength()</code>:返回将要发送或者接收的数据长度</li>
</ul>
</li>
</ul>
</li>
<li>DatagramSocket类<ul>
<li>DatagramPacket数据包的作用就如同是“集装箱”，可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。DatagramSocket类的作用就<strong>类似于码头</strong>，使用这个类的实例对象就可以<strong>发送和接收DatagramPacket数据包</strong>，发送数据的过程如下图所示。<br><img src="https://i.loli.net/2021/04/25/xV87UpzObvKY3Nl.jpg" alt="DatagramPacket和DatagramSocket发送数据的过程.jpg"></li>
<li>在创建发送端和接收端的DatagramSocket对象时，使用的构造方法也有所不同，下面对DatagramSocket类中常用的构造方法进行讲解。<ul>
<li><code>DatagramSocket()</code>:构造数据报套接字并将其绑定到本机上任何可用的端口。<ul>
<li>该构造方法用于创建<strong>发送端</strong>的DatagramSocket对象，在创建DatagramSocket对象时，并没有指定端口号，此时，系统会分配一个没有被其它网络程序所使用的端口号。</li>
</ul>
</li>
<li><code>DatagramSocket(int port)</code>:构造数据报套接字并将其绑定到本机上的指定端口。<ul>
<li>该构造方法既可用于创建<strong>接收端</strong>的DatagramSocket对象，又可以创建<strong>发送端</strong>的DatagramSocket对象，在创建接收端的DatagramSocket对象时，必须要指定一个端口号，这样就可以监听指定的端口。</li>
</ul>
</li>
</ul>
</li>
<li>上面我们讲解了DatagramSocket的构造方法，接下来对DatagramSocket类中的常用方法进行详细地讲解。<ul>
<li><code>void receive(DatagramPacket p)</code>:从此套接字接收数据报包</li>
<li><code>void send(DatagramPacket p)</code>:从此套接字发送数据报包</li>
</ul>
</li>
</ul>
</li>
<li>UDP实现<br>先运行ReceiveDemo，试其进入到阻塞模式，以等待SendDemo发送数据报包。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建接收端Socket对象</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//接收数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收数据&quot;</span>);</span><br><span class="line">        ds.receive(dp);<span class="comment">//阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到数据了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析数据</span></span><br><span class="line">        InetAddress address = dp.getAddress();<span class="comment">//获取发送端的IP对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = dp.getData();<span class="comment">//获取接收到的数据，也可以直接使用创建包对象时的数组</span></span><br><span class="line">        <span class="keyword">int</span> length = dp.getLength();<span class="comment">//获取具体收到数据的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sender ---&gt; &quot;</span> + address.getHostAddress());</span><br><span class="line">        <span class="comment">//System.out.println(new String(data,0,length));</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, length));</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建发送端Socket对象</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="comment">//创建数据</span></span><br><span class="line">        String s = <span class="string">&quot;hello udp,i&#x27;m coming!&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bys = s.getBytes();</span><br><span class="line">        <span class="keyword">int</span> length = bys.length;</span><br><span class="line">        InetAddress address = InetAddress.getLocalHost();<span class="comment">//发送给当前设备</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8888</span>;</span><br><span class="line">        <span class="comment">//打包（数据内容，数据长度，ip，端口）</span></span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, length, address, port);</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3></li>
<li>概述：<ul>
<li>TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。</li>
<li>区别在于，<strong>UDP中只有发送端和接收端</strong>，<strong>不区分客户端与服务器端</strong>，计算机之间可以任意地发送数据。</li>
<li>而TCP通信是<strong>严格区分客户端与服务器端</strong>的，在通信时，必须先<strong>由客户端去连接服务器端</strong>才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。</li>
<li>在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。</li>
<li>通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。</li>
</ul>
</li>
<li>ServerSocket类<ul>
<li>在开发TCP程序时，首先需要创建服务器端程序。JDK的java.net包中提供了一个ServerSocket类，该类的实例对象可以实现一个服务器段的程序。</li>
<li>通过查阅API文档可知，ServerSocket类提供了多种构造方法，接下来就对ServerSocket的构造方法进行逐一地讲解。<ul>
<li><code>ServerSocket(int port)</code>:创建绑定到特定端口的服务器套接字。<ul>
<li>使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上（参数port就是端口号）。</li>
</ul>
</li>
</ul>
</li>
<li>接下来学习一下ServerSocket的常用方法，如下所示。<ul>
<li><code>Socket accept()</code>:侦听并接受到此套接字的连接。</li>
<li><code>InetAddress getInetAddress()</code>:返回此服务器套接字的本地地址。</li>
<li>ServerSocket对象负责监听某台计算机的某个端口号，在创建ServerSocket对象后，需要继续调用该对象的accept()方法，接收来自客户端的请求。当执行了accept()方法之后，服务器端程序会发生<strong>阻塞</strong>，直到客户端发出连接请求，accept()方法才会返回一个Scoket对象用于和客户端实现通信，程序才能继续向下执行。</li>
</ul>
</li>
</ul>
</li>
<li>Socket类<ul>
<li>讲解了ServerSocket对象可以实现服务端程序，但只实现服务器端程序还不能完成通信，此时还需要一个客户端程序与之交互，为此JDK提供了一个Socket类，用于实现TCP客户端程序。</li>
<li>通过查阅API文档可知Socket类同样提供了多种构造方法，接下来就对Socket的常用构造方法进行详细讲解。<ul>
<li><code>Socket(String host,int port)</code>:创建一个流套接字并将其连接到指定主机上的指定端口号。<ul>
<li>使用该构造方法在创建Socket对象时，会根据参数去连接在指定地址和端口上运行的服务器程序，其中参数host接收的是一个字符串类型的IP地址。</li>
</ul>
</li>
<li><code>Socket(InetAddress address,int port)</code>:创建一个流套接字并将其连接到指定IP地址的指定端口号。<ul>
<li>该方法在使用上与第一个构造方法类似，参数address用于接收一个InetAddress类型的对象，该对象用于封装一个IP地址。</li>
</ul>
</li>
<li>在以上Socket的构造方法中，最常用的是第一个构造方法。</li>
</ul>
</li>
<li>接下来学习一下Socket的常用方法，如下所示。<ul>
<li><code>int getPort()</code>:返回一个int类型对象，该对象是Socket对象与服务器端连接的端口号</li>
<li><code>InetAddress getLocalAddress()</code>:用于获取Socket对象绑定的本地IP地址，并将IP地址封装成InetAddress类型的对象返回</li>
<li><code>void close()</code>:用于关闭Socket连接，结束本次通信。在关闭socket之前，应将与socket相关的所有的输入/输出流全部关闭，这是因为一个良好的程序应该在执行完毕时释放所有的资源</li>
<li><code>InputStream getInputStream()</code>:返回一个InputStream类型的输入流对象，如果该对象是由服务器端的Socket返回，就用于读取客户端发送的数据，反之，用于读取服务器端发送的数据</li>
<li><code>OutputStream getOutputStream()</code>:返回一个OutputStream类型的输出流对象，如果该对象是由服务器端的Socket返回，就用于向客户端发送数据，反之，用于向服务器端发送数据</li>
<li>在Socket类的常用方法中，getInputStream()和getOutStream()方法分别用于获取输入流和输出流。当客户端和服务端建立连接后，<strong>数据是以IO流的形式</strong>进行交互的，从而实现通信。</li>
</ul>
</li>
<li>接下来通过一张图来描述服务器端和客户端的数据传输，如下图所示。<br><img src="https://i.loli.net/2021/04/25/3hlNw71XLtIBj5f.png" alt="服务器端和客户端的数据传输.png"></li>
</ul>
</li>
<li>TCP协议实现<br>先运行服务端(ServerDemo)，试其进入到阻塞模式，以等待客户端(ClientDemo)发送数据报包。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建接收端Socket对象</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10086</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收数据&quot;</span>);</span><br><span class="line">        <span class="comment">//监听（阻塞）</span></span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到数据了&quot;</span>);</span><br><span class="line">        <span class="comment">//获取输入流对象</span></span><br><span class="line">        InputStream is = s.getInputStream();</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;<span class="comment">//用于存储读到的字节个数</span></span><br><span class="line">        len = is.read(bys);</span><br><span class="line">        <span class="comment">//输出数据</span></span><br><span class="line">        InetAddress address = s.getInetAddress();</span><br><span class="line">        System.out.println(<span class="string">&quot;client ---&gt; &quot;</span> + address.getHostName());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, len));</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        s.close();</span><br><span class="line">        <span class="comment">//ss.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建发送端Socket对象（创建连接）</span></span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">10086</span>);</span><br><span class="line">        <span class="comment">//获取输出流对象</span></span><br><span class="line">        OutputStream os = s.getOutputStream();</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        String str = <span class="string">&quot;hello tcp,i&#x27;m coming!!!&quot;</span>;</span><br><span class="line">        os.write(str.getBytes());</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="comment">//os.close();</span></span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>TCP相关案例(见提高篇day12Word文档)</li>
</ul>
<h2 id="反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性"><a href="#反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性" class="headerlink" title="反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性"></a>反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性</h2><h3 id="反射机制的概述和字节码对象的获取方式"><a href="#反射机制的概述和字节码对象的获取方式" class="headerlink" title="反射机制的概述和字节码对象的获取方式"></a>反射机制的概述和字节码对象的获取方式</h3><ul>
<li>反射介绍：<ul>
<li>JAVA反射机制是在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法<ul>
<li>对于任意一个对象,都能够调用它的任意一个方法</li>
<li>这种动态获取的以及动态调用对象的方法的功能称为java语言的反射机制.</li>
</ul>
</li>
<li>简单来说, 就可以把.class文件比做动物的尸体, 而反射技术就是对尸体的一种解剖.</li>
<li>通过反射技术, 我们可以拿到该字节码文件中所有的东西, 例如成员变量, 成员方法, 构造方法, 而且还包括私有。</li>
</ul>
</li>
<li>字节码对象获取的三种方式<ul>
<li>1.<code>对象名.getCalss();</code>//此方法来自于Object—对象已经存在的情况下, 可以使用这种方式</li>
<li>2.<code>类名.class;</code>//类名.class这是一个静态的属性,只要知道类名, 就可以获取 </li>
<li>3.<code>Class.forName(&quot;com.lxy.Student&quot;);</code>//通过Class类中的静态方法, 指定字符串, 该字符串是类的全类名(包名+类名),此处将会抛出异常都系ClassNotFoundException防止传入错误的类名</li>
</ul>
</li>
<li>反射：<ul>
<li>在运行时，我们可以获取任意一个类的所有方法和属性</li>
<li>在运行时，让我们调用任意一个对象的所有方法和属性</li>
</ul>
</li>
<li>反射的前提：<ul>
<li>要获取类的对象（Class对象）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.通过Object的getClass()方法获取，必须要有对象</span></span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        Class clazz = s.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过类名获取字节码对象</span></span><br><span class="line">        Class clazz2 = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通过全类名获取字节码对象</span></span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazz2);</span><br><span class="line">        System.out.println(clazz == clazz3);</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>字节码对象是用来描述什么的?<ul>
<li>用来描述.class文件的.</li>
<li>面向对象阶段的时候讲过java中描述事物都是通过类的形式</li>
<li>而字节码文件也可以看做为一种事物, 如何描述这种事物? 那就看看这个事物是由什么组成的了<ul>
<li><ol>
<li>成员变量</li>
</ol>
</li>
<li><ol start="2">
<li>成员方法</li>
</ol>
</li>
<li><ol start="3">
<li>构造方法<h3 id="反射操作构造方法"><a href="#反射操作构造方法" class="headerlink" title="反射操作构造方法"></a>反射操作构造方法</h3></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>通过获取的构造创建对象<ul>
<li>步骤:<ul>
<li>1.获得Class对象</li>
<li>2.获得构造</li>
<li>3.通过构造对象获得实例化对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line"><span class="comment">//        method(clazz);</span></span><br><span class="line"><span class="comment">//        method2(clazz);</span></span><br><span class="line"><span class="comment">//        method3(clazz);</span></span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有public修饰的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Constructor&lt;?&gt;[] getConstructors() :</span></span><br><span class="line">        Constructor[] cs = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">            System.out.println(cs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取无参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">        Constructor c = clazz.getConstructor();<span class="comment">//获取无参构造</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line">        Object obj = c.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取有参构造，其参数1类型为String，参数2类型为Integer</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">        Constructor c = clazz.getConstructor(String.class, Integer.class);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        Object obj = c.newInstance(<span class="string">&quot;lisi&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li>直接通过Class类中的newInstance()和获取getConstructor()有什么区别?<ul>
<li><code>newInstance()</code>方法, 只能通过无参的构造方法创建对象</li>
<li><code>getConstructor(Class&lt;T&gt;… parameterTypes)</code>方法, 方法接受一个可变参数, 可以根据传入的类型来匹配对应的构造方法</li>
</ul>
</li>
<li>总结<ul>
<li><code>Constructor&lt;?&gt;[] getConstructors()</code>:获取该类中所有的构造方法, 返回的是一个数组</li>
<li><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code>: 方法接受一个可变参数, 可以根据传入的类型, 来匹配对应的构造方法<h3 id="反射操作公共成员变量"><a href="#反射操作公共成员变量" class="headerlink" title="反射操作公共成员变量"></a>反射操作公共成员变量</h3></li>
</ul>
</li>
<li>反射public成员变量(字段) <ul>
<li>通过反射运行public变量流程<ul>
<li><ol>
<li>通过反射获取该类的字节码对象:<code>Class clazz = Class.forName(&quot;com.lxy.Person&quot;);</code></li>
</ol>
</li>
<li><ol start="2">
<li>创建该类对象:<code>Object p = clazz.newInstance();</code></li>
</ol>
</li>
<li><ol start="3">
<li>获取该类中需要操作的字段(成员变量):<code>getField(String name)</code> –&gt; 方法传入字段的名称.</li>
</ol>
<ul>
<li>注意: 此方法只能获取公共的字段<br><code>Field f = clazz.getField(&quot;age&quot;);</code></li>
</ul>
</li>
<li><ol start="4">
<li>通过字段对象中的方法修改属性值:<code>void set(Object obj, Object value)</code></li>
</ol>
<ul>
<li>参数1: 要修改的对象。</li>
<li>参数2: 将字段修改为什么值。<br><code>f.set(p, 23);</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        method();</span></span><br><span class="line">        <span class="comment">//获取学生类的字节码对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        method2(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取学生类的字节码对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//获取学生类的对象</span></span><br><span class="line">        Object stu = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field getField(String name)  :根据字段名称获取公共的字段对象</span></span><br><span class="line">        Field f = clazz.getField(<span class="string">&quot;age&quot;</span>);<span class="comment">//获取成员变量对象(成员变量age需要是public的)</span></span><br><span class="line">        <span class="comment">//void set(Object obj, Object value)</span></span><br><span class="line">        f.set(stu, <span class="number">28</span>);<span class="comment">//通过成员变量对象，修改指定对为指定的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object get(Object obj)</span></span><br><span class="line">        Object age = f.get(stu);<span class="comment">//通过对象获取成员变量的值</span></span><br><span class="line">        System.out.println(age);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Field[] getFields()  :获取公共的成员变量</span></span><br><span class="line">        Field[] fs = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fs.length; i++) &#123;</span><br><span class="line">            System.out.println(fs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredFields()  ：获取所有的成员变量(包含私有的)</span></span><br><span class="line">        Field[] fs2 = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fs2.length; i++) &#123;</span><br><span class="line">            System.out.println(fs2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>总结:<ul>
<li>通过反射获取成员变量并使用:  <ul>
<li><code>Field[] getFields();</code>//返回该类所有(公共)的字段</li>
<li><code>Field getField(String name);</code>//返回指定名称字段</li>
<li><code>Field[] getDeclaredFields();</code>//暴力反射获取所有字段(包括私有) </li>
<li><code>Field getDeclaredField(String name);</code>//暴力反射获取指定名称字段</li>
<li>Field:<ul>
<li><code>Object get(Object obj);</code>//Field对象调用, 返回传入对象的具体字段</li>
<li><code>void set(Object obj, Object value);</code>//Field对象调用<ul>
<li>参数1: 要修改的对象。</li>
<li>参数2: 将此对象的字段修改为什么值。<h3 id="反射操作私有成员变量"><a href="#反射操作私有成员变量" class="headerlink" title="反射操作私有成员变量"></a>反射操作私有成员变量</h3></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>反射private成员变量(字段)<ul>
<li>执行流程<ul>
<li><ol>
<li>获取学生类字节码对象</li>
</ol>
</li>
<li><ol start="2">
<li>获取学生对象</li>
</ol>
</li>
<li><ol start="3">
<li>通过<code>Field[] getDeclaredFields();</code>方法获取私有字段</li>
</ol>
</li>
<li><ol start="4">
<li>通过<code>void setAccessible(boolean flag)</code>让jvm不检查权限</li>
</ol>
</li>
<li><ol start="5">
<li>通过set方法设置对象为具体的值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException </span>&#123;</span><br><span class="line">        <span class="comment">//获取学生类的字节码对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//获取学生对象</span></span><br><span class="line">        Object stu = clazz.newInstance();</span><br><span class="line">        <span class="comment">//获取私有的字段对象</span></span><br><span class="line">        Field f = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置反射时取消Java的访问检查,暴力访问</span></span><br><span class="line">        <span class="comment">//设置具体值</span></span><br><span class="line">        f.set(stu, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Object name = f.get(stu);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="通过反射获取成员方法并使用"><a href="#通过反射获取成员方法并使用" class="headerlink" title="通过反射获取成员方法并使用"></a>通过反射获取成员方法并使用</h3></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>反射获取普通成员方法<ul>
<li>执行流程:<ul>
<li><ol>
<li>获取学生类字节码对象</li>
</ol>
</li>
<li><ol start="2">
<li>反射手段创建学生对象</li>
</ol>
</li>
<li><ol start="3">
<li>调用getMethod方法获取Method对象, 方法形参接受方法的名字</li>
</ol>
</li>
<li><ol start="4">
<li>调用Method方法中的invoke()将方法<strong>运行</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.privateMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取学生类的字节码对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//获取学生类的对象</span></span><br><span class="line">        Object stu = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;获取无参无返回值的方法(public)&quot;</span>);</span><br><span class="line">        method(clazz,stu);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取有参无返回值的方法&quot;</span>);</span><br><span class="line">        method2(clazz,stu);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取无参有返回值的方法&quot;</span>);</span><br><span class="line">        method3(clazz,stu);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取无参无返回值的方法(private)&quot;</span>);</span><br><span class="line">        method4(clazz,stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Class clazz, Object stu)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取无参无返回值的方法</span></span><br><span class="line">        Method m = clazz.getMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        m.invoke(stu);<span class="comment">//并执行方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">(Class clazz, Object stu)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取无参无返回值的方法</span></span><br><span class="line">        <span class="comment">// 暴力反射获取方法</span></span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">        <span class="comment">// 让jvm不检查权限</span></span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        method.invoke(stu);<span class="comment">//并执行方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(Class clazz, Object stu)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取有参无返回值的方法</span></span><br><span class="line">        Method m = clazz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.invoke(stu, <span class="string">&quot;lisi&quot;</span>);<span class="comment">//并执行方法</span></span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(Class clazz, Object stu)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取无参有返回值的方法</span></span><br><span class="line">        Method m = clazz.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        Object obj = m.invoke(stu);<span class="comment">//并执行方法</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ul>
</li>
</ul>
</li>
<li>方法总结：<ul>
<li>Class:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;  </span><br><span class="line">    <span class="comment">// 此方法由字节码对象调用</span></span><br><span class="line">    <span class="comment">// 参数1: 要反射的方法名称</span></span><br><span class="line">    <span class="comment">// 参数2: 此方法需要接受的参数类型(注意,传入的都是字节码)</span></span><br></pre></td></tr></table></figure></li>
<li>Method:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>;  </span><br><span class="line">    <span class="comment">// 方法由Method对象调用</span></span><br><span class="line">    <span class="comment">// 参数1: 要由那个对象调用方法</span></span><br><span class="line">    <span class="comment">// 参数2: 方法需要的具体实参(实际参数)</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>私有的成员方法怎么玩?  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 获取字节码对象</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">&quot;com.lxy.Student&quot;</span>);</span><br><span class="line"><span class="comment">// 创建学生对象</span></span><br><span class="line">Object stu = clazz.newInstance();</span><br><span class="line"><span class="comment">// 暴力反射获取方法</span></span><br><span class="line">Method method = clazz.getDeclaredMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line"><span class="comment">// 让jvm不检查权限</span></span><br><span class="line">method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line">method.invoke(stu);</span><br></pre></td></tr></table></figure>
<h2 id="JavaBean的概述、BeanUtils的使用"><a href="#JavaBean的概述、BeanUtils的使用" class="headerlink" title="JavaBean的概述、BeanUtils的使用"></a>JavaBean的概述、BeanUtils的使用</h2><h3 id="JavaBean的概述和规范"><a href="#JavaBean的概述和规范" class="headerlink" title="JavaBean的概述和规范"></a>JavaBean的概述和规范</h3></li>
<li>JavaBean的概述:<ul>
<li>将需要操作的多个属性封装成JavaBean, 简单来说就是用于封装数据的.</li>
</ul>
</li>
<li>规范：<ul>
<li>类使用公共进行修饰</li>
<li>提供私有修饰的成员变量</li>
<li>为成员变量提供公共getter和setter方法</li>
<li>提供公共无参的构造<h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3></li>
</ul>
</li>
<li>BeanUtils的由来:<ul>
<li>Apache commons提供的一个组件，主要功能就是为了简化JavaBean封装数据的操作</li>
<li>之前我们使用的类都是来自Java编写好的源代码</li>
<li>而这个BeanUtils却是一个叫做Apache的组织编写.<ul>
<li>那么这个组织编写的代码当中, 有一个系列可以很方便的提高我们今后的开发效率.</li>
<li>这个系列为Commons, BeanUtils就是其中之一</li>
</ul>
</li>
</ul>
</li>
<li>BeanUtils的常用方法<ul>
<li><code>static void setProperty(Object bean, String name, Object value)</code> <ul>
<li>用来给对象中的属性赋值(了解)</li>
<li>参数1: 需要设置属性的对象</li>
<li>参数2: 需要修改的属性名称</li>
<li>参数3: 需要修改的具体元素    </li>
</ul>
</li>
<li><code>static String getProperty(Object bean, String name)</code> <ul>
<li>用来获取对象中的属性(了解)</li>
<li>参数1: 要获取的javaBean对象</li>
<li>参数2: 对象中的哪个属性</li>
</ul>
</li>
<li>注意：BeanUtils的setProperty和getProperty方法底层并不是直接操作成员变量，而是操作和成员变量名有关的get和set方法</li>
<li><code>static void populate(Object bean, Map properties)</code> <ul>
<li>用来给对象中的属性赋值(掌握)</li>
<li>参数1: 要设置属性的对象</li>
<li>参数2: 将属性以Map集合的形式传入<ul>
<li>Key : 属性的名称</li>
<li>Value:  属性具体的值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtilsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//通过static void setProperty(Object bean, String name, Object value)</span></span><br><span class="line">        <span class="comment">//和static String getProperty(Object bean, String name)</span></span><br><span class="line">        <span class="comment">//进行设置属性及获取属性</span></span><br><span class="line">        method();</span><br><span class="line">        <span class="comment">//通过static void populate(Object bean, Map properties)</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static void setProperty(Object bean, String name, Object value) ：给JavaBean对象的成员变量进行赋值</span></span><br><span class="line">        BeanUtils.setProperty(stu, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        BeanUtils.setProperty(stu, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static String getProperty(Object bean, String name)</span></span><br><span class="line">        String name = BeanUtils.getProperty(stu, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static void populate(Object bean, Map properties)</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        map.put(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BeanUtils.populate(stu, map);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>方法总结:<ul>
<li>三个方法底层是通过反射实现, 而且反射操作的是setXxx方法和getXxx方法.</li>
<li>所以编写JavaBean的时候一定要注意格式</li>
</ul>
</li>
</ul>
<h2 id="xml的概述与如何编写xml文件"><a href="#xml的概述与如何编写xml文件" class="headerlink" title="xml的概述与如何编写xml文件"></a>xml的概述与如何编写xml文件</h2><ul>
<li><p>xml语言的概述</p>
<ul>
<li>xml语言是具有<strong>结构性的标记语言</strong>,可以灵活的存储<strong>一对多</strong>的数据关系.</li>
<li>xml的使用场景:用来存储一对多的数据 </li>
</ul>
</li>
<li><p>xml是怎样存储数据的？</p>
<ul>
<li>以标签的形式存储。(例:  <name>Jack</name>)</li>
</ul>
</li>
<li><p>Xml文件的组成部分:</p>
<ul>
<li>文档声明</li>
<li>元素</li>
<li>元素的属性</li>
<li>注释</li>
<li>CDATA区：了解</li>
<li>特殊字符：了解</li>
<li>处理指令(PI:Processing Instruction)：了解</li>
</ul>
</li>
<li><p>xml的文档声明</p>
<ul>
<li>什么是文档声明?<ul>
<li>在编写XML文档时，需要先使用文档声明来声明XML文档。且必须出现在文档的第一行,这就好比我们在写java文件的时候需要声明class一样, 就是个硬性的规定.</li>
</ul>
</li>
<li>如何编写文档声明?  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span>`</span><br><span class="line">   //xml表示标签的名字</span><br><span class="line">//version表示当前文件的版本号</span><br><span class="line">//encoding表示当前编码, 需要跟文件的编码产生对应关系</span><br><span class="line">   //ps: standalone表示标记此文档是否独立</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>xml的元素</p>
<ul>
<li>什么是元素? <ul>
<li>xml中的元素其实就是一个个的标签</li>
<li>标签分为两种：<ul>
<li><strong>包含</strong>标签体<ul>
<li>尖括号全部成对儿出现, 所有的数据都用<strong>一对儿</strong>尖括号存储。<br>例如：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>不包含标签体<ul>
<li>只有最外层的一个尖括号,括号用/标识结束, 内部的数据都用属性来编写.<br>例如：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;zhangsan&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">age</span>=<span class="string">&quot;18&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li>两种方式都需要掌握, 但是第二种编写起来会更加方便.</li>
</ul>
</li>
</ul>
</li>
<li>标签(元素的书写规范)<ul>
<li>严格区分大小写；<p><P></li>
<li>只能以字母或下划线开头；abc _abc</li>
<li>不能以xml(或XML、Xml等)开头—-W3C保留日后使用；</li>
<li>名称字符之间不能有空格或制表符；</li>
<li>名称字符之间不能使用冒号 : (有特殊用途)</li>
</ul>
</li>
<li>元素中属性的注意事项<ul>
<li>一个元素可以有多个属性，每个属性都有它自己的名称和取值。</li>
<li>属性值一定要用引号(单引号或双引号)引起来。</li>
<li>属性名称的命名规范与元素的命名规范相同</li>
<li>元素中的属性是不允许重复的</li>
<li>在XML技术中，标签属性所代表的信息也可以被改成用子元素的形式来描述<br>例如：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">name</span>=<span class="string">&quot;zhangsan&quot;</span> <span class="attr">age</span>=<span class="string">&quot;18&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>xml的注释</p>
<ul>
<li>格式编写:<code>&lt;!--被注释的内容 --&gt;</code></li>
<li>注意事项:注释不能嵌套定义</li>
</ul>
</li>
<li><p>xml的其他组成部分</p>
<ul>
<li><p>引入CDATA区</p>
<ul>
<li>为什么要使用CDATA区域?<ul>
<li>如果我们在标签中写入的内容, 想要带有标签的标记符号的话, 就需要对这段内容进行转义,就好比java中的打印语句, 想要打印出”这个字符就必须用\进行转义.标签也是一样, 想要将<itheima>当做内容存储的话, 就需要对他进行转义.</li>
</ul>
</li>
</ul>
</li>
<li><p>如何转义? </p>
<table>
<thead>
<tr>
<th>特殊符号</th>
<th>替代符号</th>
</tr>
</thead>
<tbody><tr>
<td>&amp;</td>
<td>&amp;amp;</td>
</tr>
<tr>
<td>&lt;</td>
<td>&amp;lt;</td>
</tr>
<tr>
<td>&gt;</td>
<td>&amp;gt;</td>
</tr>
<tr>
<td>“</td>
<td>&amp;quot;</td>
</tr>
<tr>
<td>‘</td>
<td>&amp;apos;</td>
</tr>
</tbody></table>
</li>
<li><p>注意:这种转义可以达到效果,但是如果操作的数据过多,编写起来会非常痛苦,所以,可以使用CDATA区来解决此问题<br>实例代码:</p>
  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    如果有一个包含标签体的标签，</span></span><br><span class="line"><span class="comment">    他的标签体是一个普通文本，不是子标签，</span></span><br><span class="line"><span class="comment">    而普通文本中包含了一个标签，那这样可以吗？</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">            &lt;![CDATA[</span><br><span class="line">                &lt;lxy&gt;www.lxy.com&lt;/lxy&gt;</span><br><span class="line">                &lt;xy&gt;www.xy.cn&lt;/xy&gt;</span><br><span class="line">            ]]&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="symbol">&amp;lt;</span>lxy<span class="symbol">&amp;gt;</span>www.lxy.com<span class="symbol">&amp;lt;</span>/lxy<span class="symbol">&amp;gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>DTD</strong></p>
<ul>
<li>为什么要有约束 (DTD)?<ul>
<li>XML都是用户自定义的标签，若出现小小的错误，软件程序将不能正确地获取文件中的内容而报错。(如：Tomcat)</li>
<li>XML技术中，可以编写一个文档来约束一个XML的书写规范，这个文档称之为<strong>约束</strong>.</li>
</ul>
</li>
<li>如何使用DTD约束文件?<ul>
<li>1.编写DTD文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT 书架(书+)&gt;</span></span><br><span class="line">    <span class="meta">&lt;!ELEMENT 书 (书名,作者,售价)&gt;</span></span><br><span class="line">    <span class="meta">&lt;!ELEMENT 书名 (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span><br><span class="line">    <span class="meta">&lt;!ELEMENT 作者 (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span><br><span class="line">    <span class="meta">&lt;!ELEMENT 售价 (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>2.在xml文件中引入DTD文件:  <ul>
<li>引入了写好的DTD文件后, 格式就必须跟DTD文件保持一致<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 书架 <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;book.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>DTD的细节</p>
<ul>
<li>语法细节<ul>
<li>在DTD文档中使用ELEMENT关键字来声明一个XML元素。<ul>
<li>语法：<code>&lt;!ELEMENT 元素名称 使用规则&gt;</code></li>
<li>使用规则：<ul>
<li>(#PCDATA):指示元素的主体内容只能是普通的文本.(Parsed Character Data)</li>
<li>EMPTY：用于指示元素的主体为空。比如<br/></li>
<li>ANY:用于指示元素的主体内容为任意类型。</li>
<li>(子元素)：指示元素中包含的子元素</li>
</ul>
</li>
<li>定义子元素及描述它们的关系:<ul>
<li>如果子元素用逗号分开，说明必须按照声明顺序去编写XML文档。<ul>
<li>如:<code>&lt;!ELEMENT FILE (TITLE,AUTHOR,EMAIL)</code></li>
</ul>
</li>
<li>如果子元素用”|”分开，说明任选其一。<ul>
<li>如:<code>&lt;!ELEMENT FILE (TITLE|AUTHOR|EMAIL)</code></li>
</ul>
</li>
<li>用+、*、？来表示元素出现的次数<ul>
<li>如果元素后面没有+*?:表示必须且只能出现一次</li>
<li>+:表示至少出现一次，一次或多次</li>
<li>*：表示可有可无，零次、一次或多次</li>
<li>?:表示可以有也可以无，有的话只能有一次。零次或一次</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>定义属性<ul>
<li>在DTD文档中使用ATTLIST关键字来为一个元素声明属性。</li>
<li>语法：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ATTLIST 元素名</span></span><br><span class="line"><span class="meta">    属性名1 属性值类型 设置说明</span></span><br><span class="line"><span class="meta">    属性名2 属性值类型 设置说明</span></span><br><span class="line"><span class="meta">    …</span></span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>属性值类型：<ul>
<li>CDATA：表示属性的取值为普通的文本字符串</li>
<li>ENUMERATED (DTD没有此关键字)：表示枚举，只能从枚举列表中任选其一，如(鸡肉|牛肉|猪肉|鱼肉)</li>
<li>ID:表示属性的取值不能重复</li>
</ul>
</li>
<li>设置说明<ul>
<li>#REQUIRED：表示该属性必须出现</li>
<li>#IMPLIED：表示该属性可有可无</li>
<li>#FIXED:表示属性的取值为一个固定值。语法：#FIXED “固定值”</li>
</ul>
</li>
<li>直接值：表示属性的取值为该默认值</li>
</ul>
</li>
<li>实例代码1：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      <span class="meta">&lt;!ATTLIST 商品</span></span><br><span class="line"><span class="meta">类别 <span class="meta-keyword">CDATA</span> <span class="meta-keyword">#REQUIRED</span></span></span><br><span class="line"><span class="meta">颜色 <span class="meta-keyword">CDATA</span> <span class="meta-keyword">#IMPLIED</span></span></span><br><span class="line"><span class="meta">      &gt;</span></span><br><span class="line">      <span class="meta">&lt;?xml version = &quot;1.0&quot; encoding=&quot;GB2312&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line">          &lt;商品 类别=&quot;服装&quot;颜色=&quot;黄色&quot; /&gt;</span><br><span class="line">      ```   </span><br><span class="line">  - 实例代码2：</span><br><span class="line">      ```xml</span><br><span class="line">      <span class="meta">&lt;?xml version = &quot;1.0&quot; encoding=&quot;GB2312&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line">      <span class="meta">&lt;!DOCTYPE 购物篮 [</span></span><br><span class="line"><span class="meta">      <span class="meta">&lt;!ELEMENT 购物篮 (肉+)&gt;</span></span></span><br><span class="line"><span class="meta">          <span class="meta">&lt;!ELEMENT 肉 <span class="meta-keyword">EMPTY</span>&gt;</span></span></span><br><span class="line"><span class="meta">          <span class="meta">&lt;!ATTLIST 肉 品种 ( 鸡肉 | 牛肉 | 猪肉 | 鱼肉 ) <span class="meta-string">&quot;鸡肉&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">      ]&gt;</span> </span><br><span class="line">      &lt;购物篮&gt;</span><br><span class="line">          &lt;肉 品种=&quot;鱼肉&quot;/&gt;</span><br><span class="line">          &lt;肉 品种=&quot;牛肉&quot;/&gt;</span><br><span class="line">          &lt;肉/&gt;</span><br><span class="line">      &lt;/购物篮&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>Schema</p>
<ul>
<li>概述:<ul>
<li>Schema约束自身就是一个XML文件，但它的扩展名通常为.xsd</li>
<li>一个XML Schema文档通常称之为<strong>模式文档</strong>(约束文档)，遵循这个文档书写的xml文件称之为实例文档。</li>
<li>XML Schema对名称空间支持得非常好</li>
<li>理解:<ul>
<li>名称空间: 相当于package            </li>
<li>约束文档: 编写好的Person类         </li>
<li>实例文档: 通过Person类创建对象</li>
</ul>
</li>
</ul>
</li>
<li>Schema入门案例:  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">约束文档:</span><br><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27; ?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">&#x27;http://www.w3.org/2001/XMLSchema&#x27;</span> </span></span><br><span class="line"><span class="tag">                    //标准的名称空间</span></span><br><span class="line"><span class="tag">                    <span class="attr">targetNamespace</span>=<span class="string">&#x27;http://www.itheima.com&#x27;</span></span></span><br><span class="line"><span class="tag">                        //将该<span class="attr">schema</span>文档绑定到<span class="attr">http:</span>//<span class="attr">www.itheima.com</span>名称空间</span></span><br><span class="line"><span class="tag">                &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&#x27;书架&#x27;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:sequence</span> <span class="attr">maxOccurs</span>=<span class="string">&#x27;unbounded&#x27;</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&#x27;书&#x27;</span> &gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&#x27;书名&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;xs:string&#x27;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&#x27;作者&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;xs:string&#x27;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&#x27;售价&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;xs:string&#x27;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line">实例文档:</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">&lt;itheima:书架 xmlns:itheima=&quot;http://www.itheima.com&quot;</span><br><span class="line">                xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">                xsi:schemaLocation=&quot;http://www.itheima.com book.xsd&quot;&gt;</span><br><span class="line">    &lt;itheima:书&gt;</span><br><span class="line">        &lt;itheima:书名&gt;JavaScript网页开发&lt;/itheima:书名&gt;</span><br><span class="line">        &lt;itheima:作者&gt;张孝祥&lt;/itheima:作者&gt;</span><br><span class="line">        &lt;itheima:售价&gt;28.00元&lt;/itheima:售价&gt;</span><br><span class="line">    &lt;/itheima:书&gt;</span><br><span class="line">&lt;/itheima:书架&gt;</span><br><span class="line"></span><br><span class="line">名称空间:</span><br><span class="line">&lt;itheima:书架 xmlns:itheima=&quot;http://www.itheima.com&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.itheima.com book.xsd&quot;&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用默认名称空间：<ul>
<li>格式：<code>xmlns=&quot;URI&quot;</code></li>
<li>实例：<pre><code class="xml">&lt;书架 xmlns=&quot;http://www.it315.org/xmlbook/schema&quot;
    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
    xsi:schemaLocation=&quot;http://www.it315.org/xmlbook/schema book.xsd&quot;&gt;
    &lt;书&gt;
    &lt;书名&gt;JavaScript网页开发&lt;/书名&gt;
    &lt;作者&gt;张孝祥&lt;/作者&gt;
    &lt;售价&gt;28.00元&lt;/售价&gt;
    &lt;/书&gt;
&lt;书架&gt;
</code></pre>
<h2 id="解析xml文件"><a href="#解析xml文件" class="headerlink" title="解析xml文件"></a>解析xml文件</h2></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>XML解析的两种方式:</p>
<ul>
<li>DOM方式：Document Object Model，文档对象模型。这种方式是W3C推荐的处理XML的一种方式。</li>
<li>SAX方式：Simple API for XML。这种方式不是官方标准，属于开源社区XML-DEV，几乎所有的XML解析器都支持它。</li>
</ul>
</li>
<li><p>XML解析开发包</p>
<ul>
<li>JAXP：是SUN公司推出的解析标准实现。</li>
<li>Dom4J：是开源组织推出的解析开发包。(牛，大家都在用，包括SUN公司的一些技术的实现都在用。)</li>
<li>Dom for java four</li>
<li>Log4j</li>
</ul>
</li>
<li><p>总结:</p>
<ul>
<li>DOM: 将整棵树一口气全部加载到内存当中, 我们可以非常方便的操作任意的标签和属性。但是, 如果整棵树特别大的时候, 会出现内存溢出的问题。</li>
<li>节点: 标签、属性、文本、甚至是换行都称之为节点</li>
<li>SAX: 一个节点一个节点的进行解析(暂不掌握)</li>
</ul>
</li>
<li><p>Dom4J的方法</p>
<ul>
<li>Dom4J的常用方法：<ul>
<li>Document： <ul>
<li><code>Element getRootElement()</code>:获取根元素对象（根标签）</li>
</ul>
</li>
<li>Element:<ul>
<li><code>List elements()</code> ：获取所有的子元素</li>
<li><code>List elements(String name)</code>：根据指定的元素名称来获取相应的所有的子元素</li>
<li><code>Element element(String name)</code>：根据指定的元素名称来获取子元素对象,如果元素名称重复，则获取第一个元素 </li>
<li><code>String elementText(String name)</code> ：根据指定的子元素名称，来获取子元素中的文本</li>
<li><code>String getText()</code> ：获取当前元素对象的文本</li>
<li><code>void setText(String text)</code>：设置当前元素对象的文本</li>
<li><code>String attributeValue(String name)</code>：根据指定的属性名称获取其对应的值</li>
<li><code>public Element addAttribute(String name,String value)</code>：根据指定的属性名称和值进行添加或者修改BeanUtils的常用方法</li>
</ul>
</li>
</ul>
</li>
<li>Dom4J的案例—见提高篇Day14</li>
</ul>
</li>
</ul>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:aethon47@163.com">LXY</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://www.codingcode.cn/2021/04/25/Java/JAVA%E9%BB%91%E9%A9%AC%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/">http://www.codingcode.cn/2021/04/25/Java/JAVA黑马资料整理/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://www.codingcode.cn" target="_blank">LXY's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2021/11/26/FaCzDKS1dcpfihA.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/04/25/Java/Jdbc%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"><img class="prev-cover" src="https://i.loli.net/2021/11/26/P794pvMGm1UZjsf.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">JDBC基础教程</div></div></a></div><div class="next-post pull-right"><a href="/2021/04/23/database/ElasticSearch-Query_DSL%E6%95%99%E7%A8%8B/"><img class="next-cover" src="https://i.loli.net/2021/11/26/Om9RfUGqcarxyF3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Elasticsearch-Query DSL详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2019/11/18/ArrayList%E9%9B%86%E5%90%88%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8foreach%E5%A2%9E%E5%88%A0%E6%94%B9/" title="ArrayList集合为什么不能使用foreach增删改"><img class="cover" src="https://i.loli.net/2021/11/26/CWTnHVtGzSbQ1OP.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-11-18</div><div class="title">ArrayList集合为什么不能使用foreach增删改</div></div></a></div><div><a href="/2020/12/01/VO%E3%80%81DTO%E3%80%81BO%E3%80%81DO/" title="VO、DTO、DO、PO的概念"><img class="cover" src="https://i.loli.net/2021/11/26/EsvkB3ltIXhijuz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-12-01</div><div class="title">VO、DTO、DO、PO的概念</div></div></a></div><div><a href="/2020/01/16/%E4%B8%80%E6%96%87%E6%95%B4%E6%98%8E%E7%99%BDCookie%E3%80%81Session%E3%80%81Token/" title="一文整明白Cookie、Session、Token"><img class="cover" src="https://i.loli.net/2021/11/26/EsvkB3ltIXhijuz.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-01-16</div><div class="title">一文整明白Cookie、Session、Token</div></div></a></div><div><a href="/2021/03/24/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/" title="前后端学习路线"><img class="cover" src="https://i.loli.net/2021/11/26/FaCzDKS1dcpfihA.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-03-24</div><div class="title">前后端学习路线</div></div></a></div><div><a href="/2019/12/05/%E5%90%9E%E5%90%90%E9%87%8F%E3%80%81TPS%E3%80%81QPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%EF%BC%88RT%EF%BC%89%E6%A6%82%E5%BF%B5/" title="吞吐量、TPS、QPS、并发数、响应时间（RT）概念"><img class="cover" src="https://i.loli.net/2021/11/26/kvrJ4clafiRBKQy.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2019-12-05</div><div class="title">吞吐量、TPS、QPS、并发数、响应时间（RT）概念</div></div></a></div><div><a href="/2021/04/25/Java/Jdbc%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/" title="JDBC基础教程"><img class="cover" src="https://i.loli.net/2021/11/26/P794pvMGm1UZjsf.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-04-25</div><div class="title">JDBC基础教程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://i.loli.net/2021/11/26/WgScJEVydhutA7C.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">LXY</div><div class="author-info__description"></div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">147</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">30</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">38</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/Coding-Coder"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Coding-Coder" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:aethon47@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">本站仅供个人学习笔记使用！如有问题或文章存在错误，请联系aethon47@163.com。</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-number">1.</span> <span class="toc-text">JAVA基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E8%AF%AD%E8%A8%80%E5%B9%B3%E5%8F%B0"><span class="toc-number">1.1.</span> <span class="toc-text">JAVA语言平台</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JAVA%E5%B1%9E%E4%BA%8E%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">JAVA属于跨平台语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JVM%E3%80%81JRE%E3%80%81JDK%E8%AF%B4%E6%98%8E"><span class="toc-number">1.3.</span> <span class="toc-text">JVM、JRE、JDK说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C%E4%BB%A3%E7%A0%81"><span class="toc-number">1.4.</span> <span class="toc-text">运行代码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.5.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="toc-number">1.6.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.7.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-IDE"><span class="toc-number">1.8.</span> <span class="toc-text">集成开发环境(IDE)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%90%E7%AE%97%E7%AC%A6%E4%B8%8E%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">1.9.</span> <span class="toc-text">运算符与表达式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%AE%E7%9B%98%E5%BD%95%E5%85%A5"><span class="toc-number">1.10.</span> <span class="toc-text">键盘录入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.11.</span> <span class="toc-text">选择流程控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.12.</span> <span class="toc-text">循环流程控制语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%BE%AA%E7%8E%AF%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.13.</span> <span class="toc-text">控制循环语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A7%E7%94%9F%E9%9A%8F%E6%9C%BA%E6%95%B0-Random"><span class="toc-number">1.14.</span> <span class="toc-text">产生随机数(Random)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84"><span class="toc-number">1.15.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%86%85%E5%AD%98%E5%88%92%E5%88%86"><span class="toc-number">1.16.</span> <span class="toc-text">数组内存划分</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">1.17.</span> <span class="toc-text">二维数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95"><span class="toc-number">1.18.</span> <span class="toc-text">方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD%E5%8F%8A%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">1.19.</span> <span class="toc-text">方法的重载及参数传递</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E5%92%8C%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.20.</span> <span class="toc-text">面向过程和面向对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.21.</span> <span class="toc-text">类与对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.22.</span> <span class="toc-text">成员变量和局部变量的区别：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B0%81%E8%A3%85-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%80"><span class="toc-number">1.23.</span> <span class="toc-text">封装(面向对象三大特性之一)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">1.24.</span> <span class="toc-text">面向对象之构造方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#JAVA%E5%B8%B8%E7%94%A8API"><span class="toc-number">2.</span> <span class="toc-text">JAVA常用API</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#API%E6%A6%82%E8%BF%B0"><span class="toc-number">2.1.</span> <span class="toc-text">API概述</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="toc-number">2.2.</span> <span class="toc-text">对象数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88"><span class="toc-number">2.3.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IO%E6%B5%81%E5%8F%8AFileWriter%E7%B1%BB%E3%80%81FileReader%E7%B1%BB-%E5%9F%BA%E6%9C%AC%E6%B5%81-%E4%BD%BF%E7%94%A8"><span class="toc-number">2.4.</span> <span class="toc-text">IO流及FileWriter类、FileReader类(基本流)使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E6%B5%81%E4%BB%8B%E7%BB%8D%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">2.5.</span> <span class="toc-text">缓冲流介绍和使用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#static%E9%9D%99%E6%80%81%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.6.</span> <span class="toc-text">static静态关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E7%9A%84%E5%BA%94%E7%94%A8-Math%E7%B1%BB"><span class="toc-number">2.7.</span> <span class="toc-text">静态的应用(Math类)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%E4%B8%8E%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F%E8%BE%A8%E6%9E%90"><span class="toc-number">2.8.</span> <span class="toc-text">类变量与实例变量辨析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">2.9.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%80"><span class="toc-number">2.10.</span> <span class="toc-text">继承(面向对象三大特性之一)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E8%BF%B0%EF%BC%9A"><span class="toc-number">2.10.1.</span> <span class="toc-text">继承的概述：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8F%8A%E4%BD%BF%E7%94%A8%EF%BC%9A"><span class="toc-number">2.10.2.</span> <span class="toc-text">继承的格式及使用：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">2.10.3.</span> <span class="toc-text">继承的特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">2.10.4.</span> <span class="toc-text">继承中成员变量的特点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E7%9A%84%E7%89%B9%E7%82%B9%E5%8F%8A%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">2.10.5.</span> <span class="toc-text">继承中成员方法的特点及方法重写</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%8F%8A%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.10.6.</span> <span class="toc-text">方法重写的应用场景及注意事项</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%B8%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-number">2.10.7.</span> <span class="toc-text">继承中构造方法的执行顺序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E5%92%8Csuper%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">2.10.8.</span> <span class="toc-text">this和super的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.10.9.</span> <span class="toc-text">继承优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E5%8F%8Afinal"><span class="toc-number">2.11.</span> <span class="toc-text">匿名对象及final</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1%E5%AE%9A%E4%B9%89%E5%8F%8A%E4%BD%BF%E7%94%A8"><span class="toc-number">2.11.1.</span> <span class="toc-text">匿名对象定义及使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">2.11.2.</span> <span class="toc-text">final关键字</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.12.</span> <span class="toc-text">抽象类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%A5%E5%8F%A3"><span class="toc-number">2.13.</span> <span class="toc-text">接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7%E4%B9%8B%E4%B8%80"><span class="toc-number">2.14.</span> <span class="toc-text">多态(面向对象三大特性之一)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E5%92%8C%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6"><span class="toc-number">2.15.</span> <span class="toc-text">包和权限修饰符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">2.16.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object%E7%B1%BB"><span class="toc-number">2.17.</span> <span class="toc-text">Object类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#System%E7%B1%BB"><span class="toc-number">2.18.</span> <span class="toc-text">System类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%97%A5%E6%9C%9F%E7%9B%B8%E5%85%B3%E7%B1%BB"><span class="toc-number">2.19.</span> <span class="toc-text">日期相关类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Date%E7%B1%BB"><span class="toc-number">2.19.1.</span> <span class="toc-text">Date类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DateFormat%E7%B1%BB-amp-SimpleDateFormat%E7%B1%BB-%E6%97%A5%E6%9C%9F-%E6%97%B6%E9%97%B4%E6%A0%BC%E5%BC%8F%E5%8C%96%E7%B1%BB"><span class="toc-number">2.19.2.</span> <span class="toc-text">DateFormat类&amp;SimpleDateFormat类(日期&#x2F;时间格式化类)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Calendar%E7%B1%BB-%E6%97%A5%E5%8E%86%E7%B1%BB"><span class="toc-number">2.19.3.</span> <span class="toc-text">Calendar类(日历类)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB-amp-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.20.</span> <span class="toc-text">包装类&amp;正则表达式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">2.20.1.</span> <span class="toc-text">包装类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="toc-number">2.20.2.</span> <span class="toc-text">正则表达式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%86%E5%90%88-amp-%E8%BF%AD%E4%BB%A3%E5%99%A8"><span class="toc-number">2.21.</span> <span class="toc-text">集合&amp;迭代器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A2%9E%E5%BC%BAfor-amp-%E6%B3%9B%E5%9E%8B"><span class="toc-number">2.22.</span> <span class="toc-text">增强for&amp;泛型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%B8%E8%A7%81%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.23.</span> <span class="toc-text">常见的数据结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#List%E5%AD%90%E4%BD%93%E7%B3%BB"><span class="toc-number">2.24.</span> <span class="toc-text">List子体系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet%E9%9B%86%E5%90%88"><span class="toc-number">2.25.</span> <span class="toc-text">HashSet集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collections%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">2.26.</span> <span class="toc-text">Collections中的方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap%E9%9B%86%E5%90%88"><span class="toc-number">2.27.</span> <span class="toc-text">HashMap集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">2.28.</span> <span class="toc-text">可变参数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E4%BA%A7%E7%94%9F-amp-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.29.</span> <span class="toc-text">异常产生&amp;异常处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Throwable%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95-amp-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">2.30.</span> <span class="toc-text">Throwable常用方法&amp;自定义异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%92%E5%BD%92"><span class="toc-number">2.31.</span> <span class="toc-text">递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%8E%E5%AD%97%E8%8A%82%E6%B5%81"><span class="toc-number">2.32.</span> <span class="toc-text">字符流与字节流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E6%B5%81-amp-%E8%BD%AC%E6%8D%A2%E6%B5%81-amp-%E6%89%93%E5%8D%B0%E6%B5%81"><span class="toc-number">2.33.</span> <span class="toc-text">标准输入流 &amp; 转换流 &amp; 打印流</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%B5%81"><span class="toc-number">2.34.</span> <span class="toc-text">对象操作流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%BA%8F%E5%88%97%E5%8C%96%E6%B5%81%E8%AF%BB%E5%86%99%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.34.1.</span> <span class="toc-text">利用序列化流读写对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E5%AF%B9%E8%B1%A1%E8%BE%93%E5%85%A5%E6%B5%81%E8%AF%BB%E5%8F%96%E5%AF%B9%E8%B1%A1%E5%87%BA%E7%8E%B0%E5%BC%82%E5%B8%B8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">2.34.2.</span> <span class="toc-text">解决对象输入流读取对象出现异常的问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E8%AF%BB%E5%86%99%E5%AF%B9%E8%B1%A1%E7%89%88%E6%9C%AC%E4%B8%8D%E4%B8%80%E8%87%B4%E9%97%AE%E9%A2%98-%E8%A7%A3%E5%86%B3%E5%AF%B9%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E6%8E%A5%E5%8F%A3%E5%87%BA%E7%8E%B0%E7%9A%84%E9%BB%84%E8%89%B2%E8%AD%A6%E5%91%8A%E9%97%AE%E9%A2%98"><span class="toc-number">2.34.3.</span> <span class="toc-text">解决读写对象版本不一致问题(解决对实现序列化接口出现的黄色警告问题)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Properties%E9%9B%86%E5%90%88"><span class="toc-number">2.35.</span> <span class="toc-text">Properties集合</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E8%A1%A8"><span class="toc-number">2.36.</span> <span class="toc-text">编码表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">2.37.</span> <span class="toc-text">多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">2.38.</span> <span class="toc-text">面向网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">2.38.1.</span> <span class="toc-text">网络编程概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.38.2.</span> <span class="toc-text">UDP协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE"><span class="toc-number">2.38.3.</span> <span class="toc-text">TCP协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0%E3%80%81%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F%E3%80%81%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E3%80%81%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E3%80%81%E6%88%90%E5%91%98%E5%B1%9E%E6%80%A7"><span class="toc-number">2.39.</span> <span class="toc-text">反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E5%AD%97%E8%8A%82%E7%A0%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%8E%B7%E5%8F%96%E6%96%B9%E5%BC%8F"><span class="toc-number">2.39.1.</span> <span class="toc-text">反射机制的概述和字节码对象的获取方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-number">2.39.2.</span> <span class="toc-text">反射操作构造方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E5%85%AC%E5%85%B1%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.39.3.</span> <span class="toc-text">反射操作公共成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8D%E5%B0%84%E6%93%8D%E4%BD%9C%E7%A7%81%E6%9C%89%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F"><span class="toc-number">2.39.4.</span> <span class="toc-text">反射操作私有成员变量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E8%8E%B7%E5%8F%96%E6%88%90%E5%91%98%E6%96%B9%E6%B3%95%E5%B9%B6%E4%BD%BF%E7%94%A8"><span class="toc-number">2.39.5.</span> <span class="toc-text">通过反射获取成员方法并使用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaBean%E7%9A%84%E6%A6%82%E8%BF%B0%E3%80%81BeanUtils%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">2.40.</span> <span class="toc-text">JavaBean的概述、BeanUtils的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaBean%E7%9A%84%E6%A6%82%E8%BF%B0%E5%92%8C%E8%A7%84%E8%8C%83"><span class="toc-number">2.40.1.</span> <span class="toc-text">JavaBean的概述和规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#BeanUtils"><span class="toc-number">2.40.2.</span> <span class="toc-text">BeanUtils</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#xml%E7%9A%84%E6%A6%82%E8%BF%B0%E4%B8%8E%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99xml%E6%96%87%E4%BB%B6"><span class="toc-number">2.41.</span> <span class="toc-text">xml的概述与如何编写xml文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90xml%E6%96%87%E4%BB%B6"><span class="toc-number">2.42.</span> <span class="toc-text">解析xml文件</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/06/04/git/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%A2%E5%A4%B1%E7%9A%84GitHub_Contributions%E7%BB%BF%E6%A0%BC/" title="记一次丢失的GitHub Contributions绿格"><img src="https://i.loli.net/2021/11/26/EsvkB3ltIXhijuz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记一次丢失的GitHub Contributions绿格"/></a><div class="content"><a class="title" href="/2021/06/04/git/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%A2%E5%A4%B1%E7%9A%84GitHub_Contributions%E7%BB%BF%E6%A0%BC/" title="记一次丢失的GitHub Contributions绿格">记一次丢失的GitHub Contributions绿格</a><time datetime="2021-06-04T06:07:00.000Z" title="发表于 2021-06-04 14:07:00">2021-06-04</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/25/git/Git_%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B/" title="Git 常见案例"><img src="https://i.loli.net/2021/11/26/FaCzDKS1dcpfihA.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 常见案例"/></a><div class="content"><a class="title" href="/2021/05/25/git/Git_%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B/" title="Git 常见案例">Git 常见案例</a><time datetime="2021-05-25T10:09:00.000Z" title="发表于 2021-05-25 18:09:00">2021-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/25/git/Git_%E6%95%99%E7%A8%8B/" title="Git 教程"><img src="https://i.loli.net/2021/11/26/zi1NLHo4YrewMt8.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Git 教程"/></a><div class="content"><a class="title" href="/2021/05/25/git/Git_%E6%95%99%E7%A8%8B/" title="Git 教程">Git 教程</a><time datetime="2021-05-25T10:09:00.000Z" title="发表于 2021-05-25 18:09:00">2021-05-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/06/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Ruby/" title="Linux安装Ruby"><img src="https://i.loli.net/2021/11/26/EsvkB3ltIXhijuz.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux安装Ruby"/></a><div class="content"><a class="title" href="/2021/05/06/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Ruby/" title="Linux安装Ruby">Linux安装Ruby</a><time datetime="2021-05-06T06:47:00.000Z" title="发表于 2021-05-06 14:47:00">2021-05-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/05/06/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Redis/" title="Linux安装Redis"><img src="https://i.loli.net/2021/11/26/Om9RfUGqcarxyF3.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux安装Redis"/></a><div class="content"><a class="title" href="/2021/05/06/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Redis/" title="Linux安装Redis">Linux安装Redis</a><time datetime="2021-05-06T03:10:00.000Z" title="发表于 2021-05-06 11:10:00">2021-05-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://i.loli.net/2021/11/26/FaCzDKS1dcpfihA.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2021 By LXY</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text"><span>备案号:浙ICP备19049962号</span></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="/js/search/local-search.js"></script><script>var preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',preloader.endLoading())</script><div class="js-pjax"></div><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>