<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>记一次丢失的GitHub Contributions绿格</title>
      <link href="/2021/06/04/git/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%A2%E5%A4%B1%E7%9A%84GitHub_Contributions%E7%BB%BF%E6%A0%BC/"/>
      <url>/2021/06/04/git/%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%A2%E5%A4%B1%E7%9A%84GitHub_Contributions%E7%BB%BF%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h4 id="为什么绿格子会丢失"><a href="#为什么绿格子会丢失" class="headerlink" title="为什么绿格子会丢失"></a>为什么绿格子会丢失</h4><p>首先要分析为什么你的提交记录没有被github识别：</p><ul><li>进行Commits的用户没有被关联到你的Github帐号中。</li><li>不是在这个版本库的默认分支进行的Commit。</li><li>这个仓库是一个Fork仓库，而不是独立仓库。</li></ul><p>我估计很多人和我一样都是第一个原因，初用github远程管理代码或者那些经常更换使用机器的猿极有可能用错账户名和邮箱，其实我就是在修改自己原来的用户名和邮箱时才发现的。</p><p>下面是解决的办法：</p><p>这是github官方的办法(全英文):<a href="https://help.github.com/articles/changing-author-info/">https://help.github.com/articles/changing-author-info/</a></p><h4 id="1、在git项目目录下创建一个脚本文件email-sh，内容如下（请按说明修改5-6-7行的内容）"><a href="#1、在git项目目录下创建一个脚本文件email-sh，内容如下（请按说明修改5-6-7行的内容）" class="headerlink" title="1、在git项目目录下创建一个脚本文件email.sh，内容如下（请按说明修改5,6,7行的内容）"></a>1、在git项目目录下创建一个脚本文件<code>email.sh</code>，内容如下（请按说明修改5,6,7行的内容）</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">git filter-branch --env-filter &#x27;</span><br><span class="line"></span><br><span class="line">OLD_EMAIL=&quot;原邮箱地址&quot;</span><br><span class="line">CORRECT_NAME=&quot;新用户名&quot;</span><br><span class="line">CORRECT_EMAIL=&quot;新邮箱地址&quot;</span><br><span class="line"></span><br><span class="line">if [ &quot;$GIT_COMMITTER_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_COMMITTER_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_COMMITTER_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;$OLD_EMAIL&quot; ]</span><br><span class="line">then</span><br><span class="line">    export GIT_AUTHOR_NAME=&quot;$CORRECT_NAME&quot;</span><br><span class="line">    export GIT_AUTHOR_EMAIL=&quot;$CORRECT_EMAIL&quot;</span><br><span class="line">fi</span><br><span class="line">&#x27; --tag-name-filter cat -- --branches --tags</span><br></pre></td></tr></table></figure><h4 id="2、创建临时文件夹并clone项目"><a href="#2、创建临时文件夹并clone项目" class="headerlink" title="2、创建临时文件夹并clone项目"></a>2、创建临时文件夹并clone项目</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在bash里执行如下代码，user替换成你的github账户名，repo替换成你的repo的名字</span></span><br><span class="line">git clone https://github.com/user/repo.git</span><br><span class="line">cd repo</span><br></pre></td></tr></table></figure><h4 id="3、执行email-sh，windows环境可通过git-bash-exe执行脚本"><a href="#3、执行email-sh，windows环境可通过git-bash-exe执行脚本" class="headerlink" title="3、执行email.sh，windows环境可通过git-bash.exe执行脚本"></a>3、执行<code>email.sh</code>，windows环境可通过git-bash.exe执行脚本</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sh email.sh</span><br></pre></td></tr></table></figure><h4 id="4、通过git-log查看是否已修改完毕"><a href="#4、通过git-log查看是否已修改完毕" class="headerlink" title="4、通过git log查看是否已修改完毕"></a>4、通过git log查看是否已修改完毕</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">git log --pretty=&quot;%h %ce %an ==&gt; %s&quot;</span><br></pre></td></tr></table></figure><h4 id="5、同步至远程仓库"><a href="#5、同步至远程仓库" class="headerlink" title="5、同步至远程仓库"></a>5、同步至远程仓库</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin --force --all</span><br></pre></td></tr></table></figure><h4 id="6、最后把这个临时clone下来的repo目录删掉就行"><a href="#6、最后把这个临时clone下来的repo目录删掉就行" class="headerlink" title="6、最后把这个临时clone下来的repo目录删掉就行"></a>6、最后把这个临时clone下来的repo目录删掉就行</h4><p>现在一切大功告成，再去看的你的github首页，丢失的绿格子都回来了。</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 常见案例</title>
      <link href="/2021/05/25/git/Git_%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B/"/>
      <url>/2021/05/25/git/Git_%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E6%A1%88%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Git操作场景示例"><a href="#Git操作场景示例" class="headerlink" title="Git操作场景示例"></a>Git操作场景示例</h2><h3 id="1-删除掉本地不存在的远程分支"><a href="#1-删除掉本地不存在的远程分支" class="headerlink" title="1. 删除掉本地不存在的远程分支"></a>1. 删除掉本地不存在的远程分支</h3><p>多人合作开发时,如果远程的分支被其他开发删除掉,在本地执行<code>git branch --all</code>依然会显示该远程分支,可使用下列的命令进行删除：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用 pull 命令,添加 -p 参数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull -p</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于下面的命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch -p</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch --prune origin</span></span><br></pre></td></tr></table></figure><h3 id="2-创建自己的分支"><a href="#2-创建自己的分支" class="headerlink" title="2.创建自己的分支"></a>2.创建自己的分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从develop分支导出自己的分支dev</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev-lxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地分支提交到远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin dev-lxy:dev-lxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地分支和远程分支绑定</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -u origin/dev-lxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br></pre></td></tr></table></figure><h3 id="3-切换远程分支"><a href="#3-切换远程分支" class="headerlink" title="3.切换远程分支"></a>3.切换远程分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加一个远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add origin-devops http://ip/**/**.git</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看远程分支信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更新远程分支到本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin-devops</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地分支绑定远程origin-devops/develop-lxy分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -u origin-devops/develop-lxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支状态</span></span><br><span class="line">git branch -vv</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切回去</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -u origin/develop-lxy</span></span><br></pre></td></tr></table></figure><h3 id="4-修改远程分支名称：origin-dev-a—-gt-origin-dev-lxy"><a href="#4-修改远程分支名称：origin-dev-a—-gt-origin-dev-lxy" class="headerlink" title="4.修改远程分支名称：origin/dev-a—&gt;origin/dev-lxy"></a>4.修改远程分支名称：origin/dev-a—&gt;origin/dev-lxy</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先checkout到要修改的远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout dev-a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建本地分支的名称</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev-lxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地的代码提交到远程分支（冒号右边为远程分支，不存在则会自动创建）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin dev-lxy:dev-lxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改正在跟踪的上游分支(将当前的本地分支绑定(track)到远程分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -u origin/dev-lxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :dev-a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后删除本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev-a</span></span><br></pre></td></tr></table></figure><h3 id="5-修改之前的提交文件（Commit-Id）"><a href="#5-修改之前的提交文件（Commit-Id）" class="headerlink" title="5.修改之前的提交文件（Commit Id）"></a>5.修改之前的提交文件（Commit Id）</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 回退到之前的提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后新增一个本地分支并切换到新增的分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;新的分支名&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后修改代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后提交并推送</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add .</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;desc&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin &lt;新的分支名&gt;:&lt;新的分支名&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样代码就提交到远程的新分支名称了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后切回到正常的开发分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout develop-lxy</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回到最新的提交记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 接下来就是愉快的继续开发了</span></span><br></pre></td></tr></table></figure><h3 id="5-当前节点打TAG"><a href="#5-当前节点打TAG" class="headerlink" title="5.当前节点打TAG"></a>5.当前节点打TAG</h3><ul><li>1.添加标签<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加标签(默认对当前版本)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;标签名称&gt;</span> </span><br><span class="line">or</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加带有描述信息的附注标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;标签名称&gt; -m <span class="string">&quot;&lt;标签描述信息&gt;&quot;</span></span> </span><br></pre></td></tr></table></figure></li><li>2.提交TAG到远程分支<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将本地所有的标签全部提交到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; –-tags</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="6-git多路径-remote-切换"><a href="#6-git多路径-remote-切换" class="headerlink" title="6.git多路径(remote)切换"></a>6.git多路径(remote)切换</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除本地远程git路径</span></span><br><span class="line">git remote rm origin </span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加新的远程分支</span></span><br><span class="line">git remote add origin http://&lt;IP&gt;:&lt;PORT&gt;/auth/authcenter.git </span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换远程仓库地址：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式一：修改远程仓库地址</span></span><br><span class="line">【git remote set-url origin URL】 更换远程仓库地址，URL为新地址。</span><br><span class="line"><span class="meta">#</span><span class="bash"> 方式二：先删除远程仓库地址，然后再添加</span></span><br><span class="line">【git remote rm origin】 删除现有远程仓库 </span><br><span class="line">【git remote add origin url】添加新远程仓库</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看远程仓库的地址</span></span><br><span class="line">git remote -v</span><br></pre></td></tr></table></figure><h3 id="7-更改本地和远程分支的名称"><a href="#7-更改本地和远程分支的名称" class="headerlink" title="7.更改本地和远程分支的名称"></a>7.更改本地和远程分支的名称</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git branch -m old_branch new_branch # Rename branch locally </span><br><span class="line">git push origin :old_branch # Delete the old branch </span><br><span class="line">git push --set-upstream origin new_branch # Push the new branch, set local branch to track the new remote</span><br></pre></td></tr></table></figure><h3 id="8-删除本地和远程分支"><a href="#8-删除本地和远程分支" class="headerlink" title="8.删除本地和远程分支"></a>8.删除本地和远程分支</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1. 切换到要操作的项目文件夹</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> &lt;ProjectPath&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看项目的分支们(包括本地和远程)</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 3. 删除本地分支</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;BranchName&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 4. 删除远程分支</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;BranchName&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 5. 查看删除后分支们</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br></pre></td></tr></table></figure><h3 id="9-合并分支到mater"><a href="#9-合并分支到mater" class="headerlink" title="9.合并分支到mater"></a>9.合并分支到mater</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br><span class="line">git pull origin master</span><br><span class="line">git merge dev</span><br><span class="line">git status</span><br><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h3 id="10-如果有些文件我不想添加到暂存区，但是不小心添加了怎么解决？"><a href="#10-如果有些文件我不想添加到暂存区，但是不小心添加了怎么解决？" class="headerlink" title="10.如果有些文件我不想添加到暂存区，但是不小心添加了怎么解决？"></a>10.如果有些文件我不想添加到暂存区，但是不小心添加了怎么解决？</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将文件从暂存区中删除</span></span><br><span class="line">git rm --cached &lt;文件名&gt;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 教程</title>
      <link href="/2021/05/25/git/Git_%E6%95%99%E7%A8%8B/"/>
      <url>/2021/05/25/git/Git_%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Git教程"><a href="#Git教程" class="headerlink" title="Git教程"></a><a href="https://mp.weixin.qq.com/s/gDsZuwaHVFr9B2wWJ_df5w">Git教程</a></h1><h2 id="Git简介"><a href="#Git简介" class="headerlink" title="Git简介"></a>Git简介</h2><p>Git 是一种<strong>分布式版本控制系统</strong>，它可以不受网络连接的限制，加上其它众多优点，目前已经成为程序开发人员做项目版本管理时的首选，非开发人员也可以用 Git 来做自己的文档版本管理工具。</p><h2 id="SVN与Git最主要的区别"><a href="#SVN与Git最主要的区别" class="headerlink" title="SVN与Git最主要的区别"></a>SVN与Git最主要的区别</h2><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。</p><p>Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><h2 id="工作原理-流程："><a href="#工作原理-流程：" class="headerlink" title="工作原理 / 流程："></a>工作原理 / 流程：</h2><p><img src="https://i.loli.net/2021/05/25/Doy93UcpSN4unVI.png" alt="image.png"></p><ul><li><strong>Workspace</strong>：工作区(working directory)<ul><li>就是你在电脑上看到的目录里的文件(.git隐藏目录版本库除外)</li></ul></li><li><strong>Index / Stage</strong>：暂存区</li><li><strong>Repository</strong>：仓库区（或本地仓库/版本库）<ul><li>工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。</li></ul></li><li><strong>Remote</strong>：远程仓库</li></ul><h2 id="HEAD"><a href="#HEAD" class="headerlink" title="HEAD"></a>HEAD</h2><p>在掌握具体命令前，先理解下HEAD。</p><p>HEAD，它始终指向当前所处分支的最新的提交点。你所处的分支变化了，或者产生了新的提交点，HEAD就会跟着改变。</p><h2 id="安装后需设置用户信息"><a href="#安装后需设置用户信息" class="headerlink" title="安装后需设置用户信息"></a>安装后需设置用户信息</h2><p>第一次使用git的时候需要设置。因为Git是分布式版本控制系统，所以需要填写用户名和邮箱作为一个标识。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置用户名：</span></span><br><span class="line">git config --global user.name &quot;&lt;用户名&gt;&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置邮箱：</span></span><br><span class="line">git config --global user.email &quot;&lt;邮箱地址&gt;&quot;</span><br></pre></td></tr></table></figure><p>注：<code>--global</code>参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然你也可以对某个仓库指定的不同的用户名和邮箱。</p><h2 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化一个git仓库</span></span><br><span class="line">git init</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交文件(添加到暂存区)</span></span><br><span class="line">git add readme.md</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把暂存区中的文件提交到本地仓库的当前分支上，并添加描述信息</span></span><br><span class="line">git commit -m &quot;&lt;提交的描述信息&gt;&quot;</span><br></pre></td></tr></table></figure><h2 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h2><p><code>git reset --hard HEAD^</code>那么如果要回退到上上个版本只需把HEAD^ 改成 HEAD^^ 以此类推。那如果要回退到前100个版本的话，使用上面的方法肯定不方便，我们可以使用下面的简便命令操作：<code>git reset --hard HEAD~100</code>即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 回退到上个版本(如果工作区有内容修改的话也会被覆盖，即该命令会将工作区变成和上个版本一模一样的代码，没提交的代码会丢失)</span></span><br><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure><p>现在我们已经还原到上个版本了，但是怎么变回去呢？</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用reflog查看还原前的版本号</span></span><br><span class="line">git reflog</span><br><span class="line"><span class="meta">#</span><span class="bash"> 然后通过命令进行恢复</span></span><br><span class="line">git reset --hard 44c44fc</span><br></pre></td></tr></table></figure><h2 id="Git撤销修改"><a href="#Git撤销修改" class="headerlink" title="Git撤销修改"></a>Git撤销修改</h2><p>在工作区已经修改了文件，但是希望恢复到以前的版本。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用git checkout -- &lt;fileName&gt; 可以丢弃工作区的修改</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 注意：命令git checkout -- readme.md 中的 -- 很重要，如果没有 -- 的话，那么命令就变成创建分支了。</span></span><br><span class="line">git checkout -- readme.md</span><br></pre></td></tr></table></figure><p>上面的命令的作用是把readme.md文件在工作区做的修改全部撤销</p><p>这里有2种情况，如下：</p><ul><li>1、readme.md自动修改后，还没有放到暂存区，使用撤销修改就会到<strong>和版本库一模一样的状态</strong>。</li><li>2、另外一种是readme.md已经放入暂存区了，接着又作了修改，撤销修改就回到<strong>添加暂存区后的状态</strong>。</li></ul><h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加远程仓库</span></span><br><span class="line">git remote add origin https://github.com/Coding-Coder/testGit.git</span><br><span class="line"><span class="meta">#</span><span class="bash"> 把本地仓库分支提交到远程仓库</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 加了参数-u:会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令,以后即可直接用git push 代替git push origin master</span></span><br><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure><h2 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建并切换到指定的分支,保留所有的提交记录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> –b参数表示创建并切换，等同于 <span class="string">&quot;git branch &lt;分支名&gt;&quot;</span> 和 <span class="string">&quot;git checkout &lt;分支名&gt;&quot;</span> 两个命令合并</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出本地的所有分支,当前所在分支以 <span class="string">&quot;*&quot;</span> 标出</span></span><br><span class="line">git branch</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到已存在的指定分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并指定分支到当前分支上(在master分支上合并dev分支的内容)</span></span><br><span class="line">git merge dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除分支</span></span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure><h2 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h2><p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，其中<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</code>是指主分支修改的内容，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt; fenzhi1</code> 是指fenzhi1上修改的内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">999999</span><br><span class="line">======</span><br><span class="line">888888</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt; fenzhi1</span><br></pre></td></tr></table></figure><p>手动解决冲突后，然后执行2个命令进行提交：<code>git add .</code>&amp;<code>git commit -m &quot;解决冲突&quot;</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以图片且单行的形式查看提交记录</span></span><br><span class="line">git log --pretty=oneline --graph</span><br></pre></td></tr></table></figure><h2 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h2><p>通常合并分支时，git一般使用<code>&quot;Fast forward&quot;</code>模式，在这种模式下，<strong>删除分支后，会丢掉分支信息</strong>，现在我们来使用带参数<code>–no-ff</code>来<code>禁用&quot;Fast forward&quot;</code>模式。首先我们来做demo演示下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建并切换到新分支fenzhi2</span></span><br><span class="line">git checkout -b fenzhi2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改readme.md内容。</span></span><br><span class="line">手动修改内容</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加到暂存区</span></span><br><span class="line">git add .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交到本地仓库</span></span><br><span class="line">git commit -m &quot;fenzhi2添加内容aaaaa&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换回主分支(master)。</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并dev分支，使用命令 git merge –no-ff -m “注释” fenzhi2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --no-ff参数：表示禁用fast forward</span></span><br><span class="line">git merge --no-ff -m &quot;merge with no-ff&quot; fenzhi2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除fenzhi2</span></span><br><span class="line">git branch -d fenzhi2</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看历史记录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -–graph:图形展示</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -–pretty=oneline：单行显示，减少数据</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -–abbrev-commit：头部数据减少(commit id变短)</span></span><br><span class="line">git log --pretty=oneline --graph --abbrev-commit</span><br></pre></td></tr></table></figure><p>可以看到被删除的分支的提交记录还存在。</p><p>分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p><h2 id="bug分支-使用stash进行隐藏工作现场"><a href="#bug分支-使用stash进行隐藏工作现场" class="headerlink" title="bug分支(使用stash进行隐藏工作现场)"></a>bug分支(使用stash进行隐藏工作现场)</h2><p>在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。</p><p>比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的dev分支上的工作还没有提交。比如如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当前工作区已经有修改了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换分支</span></span><br><span class="line">git checkout dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改readme.md的内容</span></span><br><span class="line">手动修改</span><br></pre></td></tr></table></figure><p>并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支dev要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场**”隐藏起来”**，等以后恢复现场后继续工作。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将当前的工作现场隐藏起来</span></span><br><span class="line">git stash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态，是干净的(之前修改的代码也看不到了，被隐藏了，已经恢复的和分支上的代码一样了)</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p>所以现在我可以通过创建<code>issue-404</code>分支来修复bug了。</p><p>首先我们要确定在那个分支上修复bug，比如我现在是在主分支master上来修复的，现在我要在master分支上创建一个临时分支，演示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果要在master分支上创建分支，需要先切换到master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在当前分支的基础上创建并切换到新分支issue-404</span></span><br><span class="line">git checkout -b issue-404</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解决bug</span></span><br><span class="line">一顿操作</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交代码</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;fix bug 404&quot;</span><br></pre></td></tr></table></figure><p>修复完成后，切换到<code>master</code>分支上，并完成合并，最后删除<code>issue-404</code>分支。演示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换回master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="meta">#</span><span class="bash"> 合并代码</span></span><br><span class="line">git merge --no-ff -m &quot;merge fix bug 404&quot; issue-404</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后删除临时分支issue-404</span></span><br><span class="line">git branch -d issue-404</span><br></pre></td></tr></table></figure><p>最后，我们回到dev分支上干活。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切回到dev分支</span></span><br><span class="line">git checkout dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态，目前还是干净的</span></span><br><span class="line">git status</span><br></pre></td></tr></table></figure><p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，可以使用如下2个方法：</p><ul><li>1、<code>git stash apply</code>恢复，恢复后，stash<strong>内容并不删除</strong>，你需要使用命令<code>git stash drop</code>来删除。</li><li>2、另一种方式是使用<code>git stash pop</code>,恢复的同时把stash内容也<strong>删除</strong>了。<br>演示如下:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看stash列表内容</span></span><br><span class="line">git stash list</span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复工作现场</span></span><br><span class="line">git stash pop</span><br></pre></td></tr></table></figure></li></ul><h2 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h2><p>当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。</p><ul><li>1、要查看远程库的信息 使用<code>git remote</code></li><li>2、要查看远程库的详细信息 使用<code>git remote –v</code><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 详细信息里包含有2条信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line">origin  https://github.com/Coding-Coder/testGit.git (fetch)</span><br><span class="line">origin  https://github.com/Coding-Coder/testGit.git (push)</span><br></pre></td></tr></table></figure><h3 id="1-推送-push-分支："><a href="#1-推送-push-分支：" class="headerlink" title="1. 推送(push)分支："></a>1. 推送(push)分支：</h3>推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上： </li></ul><p>使用命令<code>git push origin master</code>，如果我们现在要推送到其他分支，比如dev分支上，我们还是那个命令<code>git push origin dev</code></p><h3 id="2-抓取-fetch-分支："><a href="#2-抓取-fetch-分支：" class="headerlink" title="2.抓取(fetch)分支："></a>2.抓取(fetch)分支：</h3><p>多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫testGit2</p><p>但是我首先要把dev分支也要推送到远程去，如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin dev</span><br></pre></td></tr></table></figure><p>接着进入testgit2目录，进行克隆远程的库到本地来，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/Coding-Coder/testGit.git</span><br></pre></td></tr></table></figure><p>现在我们的小伙伴要在dev分支上做开发，就必须把远程的origin的dev分支拉取到本地来，于是可以使用命令创建本地dev分支：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建远程origin的dev分支到本地的dev分支</span></span><br><span class="line">git checkout -b dev origin/dev</span><br></pre></td></tr></table></figure><p>现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时。如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 小伙伴在dev进行开发</span></span><br><span class="line">一顿操作</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交代码</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;增加内容bbbbbb&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送到远程</span></span><br><span class="line">git push orgin dev 或者 git push </span><br></pre></td></tr></table></figure><p>小伙伴们已经向<code>origin/dev</code>分支上推送了提交，而我在我的目录文件下也对同样的文件同个地方作了修改，也试图推送到远程库时，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 我在dev进行开发</span></span><br><span class="line">一顿操作</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交代码</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;增加内容cccccc&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送到远程仓库(推送时会发生错误，不同的人推送同样的文件，修改同个文件同个地方报错)</span></span><br><span class="line">git push orgin dev</span><br></pre></td></tr></table></figure><p>根据git的提示，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure><p>发现git pull也失败了，原因是没有指定本地dev分支与远程origin/dev分支的链接，根据提示，设置dev和origin/dev的链接：如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将本地的dev与远程origin/dev分支进行链接</span></span><br><span class="line">git branch --set-upstream-to=origin/dev dev</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次尝试拉取</span></span><br><span class="line">git pull</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发现可以拉取了，但是存在冲突，需要手动解决冲突</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 手动解决完冲突后进行代码提交</span></span><br><span class="line">git add .</span><br><span class="line">git commit -m &quot;合并并解决冲突&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 最后推送到远程仓库(可以不用git push origin dev，因为之前已经将本地dev与远程origin dev进行链接了)</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure><p>因此：多人协作工作模式一般是这样的：首先，可以试图用git push origin branch-name推送自己的修改.如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。</p><h2 id="合并-merge-和变基-rebase"><a href="#合并-merge-和变基-rebase" class="headerlink" title="合并(merge)和变基(rebase)"></a>合并(merge)和变基(rebase)</h2><p>到底什么时候使用 merge 操作，什么时候使用 rebase 操作呢？</p><h3 id="使用-merge-操作-保留合并的痕迹"><a href="#使用-merge-操作-保留合并的痕迹" class="headerlink" title="使用 merge 操作(保留合并的痕迹)"></a>使用 merge 操作(保留合并的痕迹)</h3><p>支持使用 merge 的开发者，他们认为仓库的提交历史就是记录实际发生过什么，它是针对于历史的一个文档，本身其实是有价值的，我们不应该随意修改。我们改变历史的话，就相当于使用“谎言”来掩盖实际发生过的事情，而这些痕迹是应该被保留的。可能，这样并不是很好。</p><h3 id="使用-rebase-操作-不保留合并的痕迹"><a href="#使用-rebase-操作-不保留合并的痕迹" class="headerlink" title="使用 rebase 操作(不保留合并的痕迹)"></a>使用 rebase 操作(不保留合并的痕迹)</h3><p>支持使用 rebase 的开发者，他们认为提交历史是项目过程中发生过的事情，需要项目的主干非常的干净。而使用 merge 操作会生成一个 merge 的 commit 对象，让提交历史多了一些非常多余的内容。</p><p>当我们后期，使用 log 命令参看提交历史的话，会发现主干的提交历史非常的尴尬。比如，同样的修改内容重复提交了两次，这显然是分支合并导致的问题。</p><h3 id="两者的使用原则"><a href="#两者的使用原则" class="headerlink" title="两者的使用原则"></a>两者的使用原则</h3><p>总的原则就是，只对尚未推送或分享给其他人的本地修改执行变基操作清理历史，从不对已经推送到仓库的提交记录执行变基操作，这样，你才可能享受到两种方式带来的便利。</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="记住这些常用命令即可"><a href="#记住这些常用命令即可" class="headerlink" title="记住这些常用命令即可"></a>记住这些常用命令即可</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 工作区 -&gt; 暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file/dir&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂存区 -&gt; 本地仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;some info&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地仓库 -&gt; 远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin master <span class="comment"># 本地master分支推送到远程origin仓库</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作区 &lt;- 暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;  <span class="comment"># 暂存区文件内容覆盖工作区文件内容</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂存区 &lt;- 本地仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD &lt;file&gt;   <span class="comment"># 本地仓库文件内容覆盖暂存区文件内容</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 本地仓库 &lt;- 远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;git_url&gt;        <span class="comment"># 克隆远程仓库</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch upstream master  <span class="comment"># 拉取远程代码到本地但不应用在当前分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull upstream master   <span class="comment"># 拉取远程代码到本地但应用在当前分支</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull --rebase upstream master  <span class="comment"># 如果平时使用rebase合并代码则加上</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 工作区 &lt;- 本地仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset &lt;commit ID&gt;          <span class="comment"># 本地仓库覆盖到工作区(保存回退文件内容修改)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --mixed &lt;commit ID&gt;  <span class="comment"># 本地仓库覆盖到工作区(保存回退文件内容修改)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --soft &lt;commit ID&gt;   <span class="comment"># 本地仓库覆盖到工作区(保留修改并加到暂存区)</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard &lt;commit ID&gt;   <span class="comment"># 本地仓库覆盖到工作区(不保留修改直接删除掉)</span></span></span><br></pre></td></tr></table></figure><h3 id="Git命令速查表"><a href="#Git命令速查表" class="headerlink" title="Git命令速查表"></a>Git命令速查表</h3><p><img src="https://i.loli.net/2021/05/25/cRJ7zXEKOMo3lDa.png" alt="image.png"></p><h3 id="Git工作流程图"><a href="#Git工作流程图" class="headerlink" title="Git工作流程图"></a>Git工作流程图</h3><p><img src="https://i.loli.net/2021/05/25/6bIHSrWdUoAXKxe.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Ruby</title>
      <link href="/2021/05/06/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Ruby/"/>
      <url>/2021/05/06/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Ruby/</url>
      
        <content type="html"><![CDATA[<h2 id="安装ruby"><a href="#安装ruby" class="headerlink" title="安装ruby"></a><a href="https://www.cnblogs.com/xuliangxing/p/7132656.html">安装ruby</a></h2><p>去官网下载：<a href="http://www.ruby-lang.org/en/downloads/">http://www.ruby-lang.org/en/downloads/</a>  最新的版本<br>并上传到<code>/usr/local/ruby</code>目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">mkdir /usr/local/ruby</span><br><span class="line">cd ruby</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压</span></span><br><span class="line">tar -zxvf ruby-3.0.1.tar.gz</span><br><span class="line">cd ruby-3.0.1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置安装到/usr/<span class="built_in">local</span>/ruby</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -prefix是将ruby安装到指定目录，也可以自定义</span></span><br><span class="line">./configure –-prefix=/usr/local/ruby</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装ruby(安装过程可能有点长)</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装后，通过在命令行中输入以下命令来确保一切工作正常：</span></span><br><span class="line">ruby -v</span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果提示 -bash: ruby: <span class="built_in">command</span> not found，则需要手动配置环境变量</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 加入如下配置</span></span><br><span class="line">export PATH=/usr/local/ruby/bin:$PATH</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使配置生效</span></span><br><span class="line">source /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再次验证</span></span><br><span class="line">ruby -v</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux软件安装 </tag>
            
            <tag> Ruby </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Redis</title>
      <link href="/2021/05/06/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Redis/"/>
      <url>/2021/05/06/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Redis/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis单机安装"><a href="#Redis单机安装" class="headerlink" title="Redis单机安装"></a>Redis单机安装</h2><p>以目前最新版本为例，目前最新版本为Redis6.2.3</p><h3 id="1-redis6-2-3-安装"><a href="#1-redis6-2-3-安装" class="headerlink" title="1.redis6.2.3 安装"></a>1.redis6.2.3 安装</h3><p>前往<a href="https://redis.io/download">官网</a>下载6.2.3版本，并上传至Linux。或者使用wget直接下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.3.tar.gz</span><br></pre></td></tr></table></figure><p>将压缩包移动到<code>/usr/local</code>下，解压缩，并改名为redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mv redis-6.2.3.tar.gz /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩</span></span><br><span class="line">tar xzf redis-6.2.3.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除压缩包</span></span><br><span class="line">rm -rf redis-6.2.3.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重命名</span></span><br><span class="line">mv redis-6.2.3 redis</span><br></pre></td></tr></table></figure><h3 id="2-编译Redis源码"><a href="#2-编译Redis源码" class="headerlink" title="2.编译Redis源码"></a>2.编译Redis源码</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入 redis 主目录</span></span><br><span class="line">cd redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译成功后，进入src文件夹，执行make install进行Redis安装</span></span><br><span class="line">cd src</span><br><span class="line"><span class="meta">#</span><span class="bash"> PREFIX参数指定redis的安装目录</span></span><br><span class="line">make install PREFIX=/usr/local/redis</span><br></pre></td></tr></table></figure><h3 id="3-Redis的部署"><a href="#3-Redis的部署" class="headerlink" title="3.Redis的部署"></a>3.Redis的部署</h3><p>安装成功后进行配置部署  </p><h4 id="3-1-配置redis为后台启动"><a href="#3-1-配置redis为后台启动" class="headerlink" title="3.1 配置redis为后台启动"></a>3.1 配置redis为后台启动</h4><p>（默认是前台直接运行的，如果Linux关闭当前会话，则Redis服务也随即关闭。正常情况下，启动Redis服务需要从后台启动，并且制定启动配置文件）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ..</span><br><span class="line">vim redis.conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> Redis默认不是以守护进程的方式运行，可以通过该配置项修改，使用yes启用守护进程</span></span><br><span class="line">将daemonize no改成daemonize yes（表明需要再后台运行）</span><br></pre></td></tr></table></figure><h4 id="3-2-修改端口-默认6379"><a href="#3-2-修改端口-默认6379" class="headerlink" title="3.2 修改端口(默认6379)"></a>3.2 修改端口(默认6379)</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">port 6379改成port 7000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 当Redis以守护进程方式运行时，Redis默认会把pid写入/var/run/redis.pid文件，可以通过pidfile指定</span></span><br><span class="line">pidfile /var/run/redis_6379.pid改成pidfile /var/run/redis_7000.pid</span><br></pre></td></tr></table></figure><h4 id="3-3-安全配置"><a href="#3-3-安全配置" class="headerlink" title="3.3 安全配置"></a>3.3 安全配置</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">注释bind 127.0.0.1</span><br><span class="line">如果不需要密码:将protected-mode yes改成protected-mode no</span><br><span class="line">如果需要密码：添加requirepass password（后面的即为密码）</span><br></pre></td></tr></table></figure><h4 id="3-4-启动Redis服务，并指定启动服务的配置文件"><a href="#3-4-启动Redis服务，并指定启动服务的配置文件" class="headerlink" title="3.4 启动Redis服务，并指定启动服务的配置文件"></a>3.4 启动Redis服务，并指定启动服务的配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看redis端口号7000占用情况</span></span><br><span class="line">netstat -tunpl|grep 7000</span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动Redis</span></span><br><span class="line">src/redis-server redis.conf</span><br></pre></td></tr></table></figure><h4 id="3-5-查看Redis是否已启动"><a href="#3-5-查看Redis是否已启动" class="headerlink" title="3.5 查看Redis是否已启动"></a>3.5 查看Redis是否已启动</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef | grep redis</span><br></pre></td></tr></table></figure><p>6 将Redis加入到开机启动</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/rc.local</span><br><span class="line">在里面添加内容：/usr/local/redis/src/redis-server /usr/local/redis/redis.conf (意思就是开机调用这段开启redis的命令)</span><br></pre></td></tr></table></figure><h3 id="4-测试连接"><a href="#4-测试连接" class="headerlink" title="4.测试连接"></a>4.测试连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">src/redis-cli -p 7000 -a &#x27;password&#x27;</span><br><span class="line">set hello world</span><br><span class="line">get hello</span><br></pre></td></tr></table></figure><h3 id="5-安全组"><a href="#5-安全组" class="headerlink" title="5.安全组"></a>5.安全组</h3><p>控制台（阿里云ESC-&gt;安全组-&gt;配置管理）查看安全组是否放行了redis的端口6379(可以更改，本次安装改成了7000端口)。</p><h3 id="6-usr-local-redis-src目录下的几个关键文件"><a href="#6-usr-local-redis-src目录下的几个关键文件" class="headerlink" title="6./usr/local/redis/src目录下的几个关键文件"></a>6./usr/local/redis/src目录下的几个关键文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">redis-benchmark：redis性能测试工具</span><br><span class="line">redis-check-aof：检查aof日志的工具</span><br><span class="line">redis-check-dump：检查rdb日志的工具</span><br><span class="line">redis-cli：连接用的客户端</span><br><span class="line">redis-server：redis服务进程</span><br></pre></td></tr></table></figure><h3 id="7-常用命令"><a href="#7-常用命令" class="headerlink" title="7.常用命令"></a>7.常用命令</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 启动redis</span><br><span class="line">redis-server /usr/local/redis/etc/redis.conf</span><br><span class="line"># 停止redis</span><br><span class="line">pkill redis</span><br><span class="line">或者：./bin/redis-cli shutdown</span><br><span class="line"># 卸载redis</span><br><span class="line">rm -rf /usr/local/redis //删除安装目录</span><br></pre></td></tr></table></figure><p>其他命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">find / -name redis-cli</span><br><span class="line">find / -name redis-server</span><br></pre></td></tr></table></figure><p>在最后提供一个redis的在线测试的网站，适合初学者使用，不需要安装自己的环境：<a href="http://try.redis.io/">redis测试网站</a></p><h2 id="Redis-集群安装"><a href="#Redis-集群安装" class="headerlink" title="Redis 集群安装"></a><a href="https://blog.csdn.net/u010395496/article/details/79858798">Redis 集群安装</a></h2><p>以目前最新版本为例，目前最新版本为Redis6.2.3</p><h3 id="1-redis6-2-3-安装-1"><a href="#1-redis6-2-3-安装-1" class="headerlink" title="1.redis6.2.3 安装"></a>1.redis6.2.3 安装</h3><p>前往<a href="https://redis.io/download">官网</a>下载6.2.3版本，并上传至Linux。或者使用wget直接下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://download.redis.io/releases/redis-6.2.3.tar.gz</span><br></pre></td></tr></table></figure><p>将压缩包移动到<code>/usr/local</code>下，解压缩，并改名为redis</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">mv redis-6.2.3.tar.gz /usr/local</span><br><span class="line">cd /usr/local</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解压缩</span></span><br><span class="line">tar xzf redis-6.2.3.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除压缩包</span></span><br><span class="line">rm -rf redis-6.2.3.tar.gz</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入 redis 主目录</span></span><br><span class="line">cd redis-6.2.3</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译</span></span><br><span class="line">make</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译成功后，进入src文件夹，执行make install进行Redis安装</span></span><br><span class="line">cd src</span><br><span class="line"><span class="meta">#</span><span class="bash"> PREFIX参数指定redis的安装目录</span></span><br><span class="line">make install PREFIX=/usr/local/redis-6.2.3</span><br></pre></td></tr></table></figure><h3 id="2-准备redisCluster所需的配置文件及脚本"><a href="#2-准备redisCluster所需的配置文件及脚本" class="headerlink" title="2.准备redisCluster所需的配置文件及脚本"></a>2.准备redisCluster所需的配置文件及脚本</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建所需要的以端口为区别的文件夹7001-7006</span></span><br><span class="line">mkdir -p /usr/local/redisCluster/700&#123;1,2,3,4,5,6&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将redis.conf分别复制到7001-7006的文件夹内</span></span><br><span class="line">cp redis-6.2.3/redis.conf /usr/local/redisCluster/7001</span><br><span class="line">cp redis-6.2.3/redis.conf /usr/local/redisCluster/7002</span><br><span class="line">cp redis-6.2.3/redis.conf /usr/local/redisCluster/7003</span><br><span class="line">cp redis-6.2.3/redis.conf /usr/local/redisCluster/7004</span><br><span class="line">cp redis-6.2.3/redis.conf /usr/local/redisCluster/7005</span><br><span class="line">cp redis-6.2.3/redis.conf /usr/local/redisCluster/7006</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置文件</span></span><br><span class="line">cd /usr/local/redisCluster/7001</span><br><span class="line">vim redis.conf</span><br></pre></td></tr></table></figure><p>修改如下配置：</p><p>找到以下几处进行修改(修改这10处就基本满足集群启动条件了，其他参数可自行百度)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">第1处： port 6379    ————&gt; 值 改成 7001</span><br><span class="line">第2处： daemonize no             ————&gt; 值 改成 yes</span><br><span class="line">第3处： pidfile /var/run/redis_6379.pid      ————&gt; 值 改成 ./redis_7001.pid</span><br><span class="line">第4处： logfile &quot;&quot;     ————&gt; 值 改成 &quot;./logs/redis_7001.log&quot;</span><br><span class="line">第5处： bind 127.0.0.1             ————&gt; 值 改成 本机IP（如我这里是192.168.25.129）</span><br><span class="line">第6处： protected-mode yes     ————&gt; 值 改成 no</span><br><span class="line">第7处： # cluster-enabled yes            ————&gt; 去掉注释</span><br><span class="line">第8处： # cluster-config-file ./nodes-conf/nodes-6379.conf    ————&gt; 去掉注释 并把数字改成对应端口号，如这里是7001,并增加保存路径./nodes-conf</span><br><span class="line">第9处： # cluster-node-timeout 15000            ————&gt; 去掉注释</span><br><span class="line">第10处：  appendonly no            ————&gt; 值 改成 yes</span><br></pre></td></tr></table></figure><p>重命名配置文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重命名redis.conf为7001.conf</span></span><br><span class="line">mv redis.conf 7001.conf</span><br></pre></td></tr></table></figure><p>然后复制5份分别放到7002、7003、7004、7005、7006文件夹下面，然后再对每个文件夹下的.conf文件重命名为对应端口号.conf，接着编辑里面的内容，将之前修改为7001的全部修改成对应端口号保存即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 创建文件夹(redis.conf中指定的路径，需要手动创建)</span></span><br><span class="line">mkdir logs</span><br><span class="line">mkdir nodes-conf</span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建redis集群启动、停止的脚本以及ruby创建集群的脚本并授权</span></span><br><span class="line">touch /usr/local/redisCluster/startCluster.sh</span><br><span class="line">touch /usr/local/redisCluster/shutdownCluster.sh</span><br><span class="line">touch /usr/local/redisCluster/createCluster.sh</span><br><span class="line">chmod 777 /usr/local/redisCluster/*.sh</span><br></pre></td></tr></table></figure><p>内容分别如下：<br>startCluster.sh：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/redis-6.2.3/src/redis-server /usr/local/redisCluster/7001/7001.conf</span><br><span class="line">/usr/local/redis-6.2.3/src/redis-server /usr/local/redisCluster/7002/7002.conf</span><br><span class="line">/usr/local/redis-6.2.3/src/redis-server /usr/local/redisCluster/7003/7003.conf</span><br><span class="line">/usr/local/redis-6.2.3/src/redis-server /usr/local/redisCluster/7004/7004.conf</span><br><span class="line">/usr/local/redis-6.2.3/src/redis-server /usr/local/redisCluster/7005/7005.conf</span><br><span class="line">/usr/local/redis-6.2.3/src/redis-server /usr/local/redisCluster/7006/7006.conf</span><br></pre></td></tr></table></figure><p>shutdownCluster.sh：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/redis-6.2.3/src/redis-cli -h 192.168.25.129 -p 7001 shutdown</span><br><span class="line">/usr/local/redis-6.2.3/src/redis-cli -h 192.168.25.129 -p 7002 shutdown</span><br><span class="line">/usr/local/redis-6.2.3/src/redis-cli -h 192.168.25.129 -p 7003 shutdown</span><br><span class="line">/usr/local/redis-6.2.3/src/redis-cli -h 192.168.25.129 -p 7004 shutdown</span><br><span class="line">/usr/local/redis-6.2.3/src/redis-cli -h 192.168.25.129 -p 7005 shutdown</span><br><span class="line">/usr/local/redis-6.2.3/src/redis-cli -h 192.168.25.129 -p 7006 shutdown</span><br></pre></td></tr></table></figure><p>createCluster.sh:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli --cluster create 192.168.25.129:7001 192.168.25.129:7002 192.168.25.129:7003 192.168.25.129:7004 192.168.25.129:7005 192.168.25.129:7006 --cluster-replicas 1</span><br></pre></td></tr></table></figure><h3 id="3-启动redisCluster"><a href="#3-启动redisCluster" class="headerlink" title="3. 启动redisCluster"></a>3. 启动redisCluster</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">./startCluster.sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看进程：</span></span><br><span class="line">ps -ef | grep redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 再创建集群(中途需要输入<span class="string">&#x27;yes&#x27;</span>)</span></span><br><span class="line">./createCluster.sh</span><br></pre></td></tr></table></figure><h3 id="4-验证"><a href="#4-验证" class="headerlink" title="4. 验证"></a>4. 验证</h3><p>这样集群就搭建成功了。登录任意一个节点客户端验证(-c 表示以集群方式登录)，也可以用redis客户端工具RedisDesktopManager来可视化地管理redis数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h 192.168.25.129 -p 7001 -c</span><br></pre></td></tr></table></figure><h3 id="5-查看集群信息"><a href="#5-查看集群信息" class="headerlink" title="5. 查看集群信息"></a>5. 查看集群信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看主从信息(集群里有多少个节点)</span></span><br><span class="line">redis-cli -h 192.168.25.129 -p 7001 cluster nodes</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看集群信息</span></span><br><span class="line">redis-cli -h 192.168.25.129 -p 7001 cluster info</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux软件安装 </tag>
            
            <tag> Redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令大全-目录</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/Linux%E5%91%BD%E4%BB%A4%E7%B3%BB%E5%88%97%E6%80%BB%E7%9B%AE%E5%BD%95/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/Linux%E5%91%BD%E4%BB%A4%E7%B3%BB%E5%88%97%E6%80%BB%E7%9B%AE%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<p>查看命令的帮助信息使用<code>命令 --help</code>如<code>ls --help</code></p><h2 id="文件和目录操作命令"><a href="#文件和目录操作命令" class="headerlink" title="文件和目录操作命令:"></a>文件和目录操作命令:</h2><ul><li>列出目录下的文件和目录 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ls%E5%91%BD%E4%BB%A4">ls</a></li><li>切换工作目录 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cd%E5%91%BD%E4%BB%A4">cd</a></li><li>查看当前工作目录的绝对路径 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-pwd%E5%91%BD%E4%BB%A4">pwd</a></li><li>创建目录 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-mkdir%E5%91%BD%E4%BB%A4">mkdir</a></li><li>删除文件或目录 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rm%E5%91%BD%E4%BB%A4">rm</a></li><li>删除空目录 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rmdir%E5%91%BD%E4%BB%A4">rmdir</a></li><li>移动文件或目录、重命名文件或目录 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-mv%E5%91%BD%E4%BB%A4">mv</a></li><li>复制文件或目录 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cp%E5%91%BD%E4%BB%A4">cp</a></li><li>新建文件、修改文件时间戳 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-touch%E5%91%BD%E4%BB%A4">touch</a></li><li>计算文件中行号 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-nl%E5%91%BD%E4%BB%A4">nl</a></li><li>查看文件内容 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cat%E5%91%BD%E4%BB%A4">cat</a></li><li>截取文件内容 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cut%E5%91%BD%E4%BB%A4">cut</a></li><li>分页查看文件内容(一开始加载全文) : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-more%E5%91%BD%E4%BB%A4">more</a></li><li>分页查看文件内容(一开始不加载全文) : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-less%E5%91%BD%E4%BB%A4">less</a></li><li>从文件头开始查看 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-head%E5%91%BD%E4%BB%A4">head</a></li><li>从指定位置到文件尾 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-tail%E5%91%BD%E4%BB%A4">tail</a></li><li>以树状图列出目录内容 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-tree%E5%91%BD%E4%BB%A4">tree</a></li><li>文本处理工具(增删改) : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-sed%E5%91%BD%E4%BB%A4">sed</a></li><li>文本分析工具 : <a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-awk%E5%91%BD%E4%BB%A4">awk</a></li><li>文本编辑器 ：<a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-vim%E5%91%BD%E4%BB%A4">vi/vim</a></li></ul><hr><h2 id="文件查找命令"><a href="#文件查找命令" class="headerlink" title="文件查找命令"></a>文件查找命令</h2><ul><li>我们经常在Linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： <ul><li><code>which</code>:查看可执行文件的位置。</li><li><code>whereis</code>:查看文件的位置。 </li><li><code>locate</code>：配合数据库查看文件位置。</li><li><code>find</code>:实际搜寻硬盘查询文件名称。</li></ul></li><li>查找指令对应的执行程序文件 : <a href="../%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-which%E5%91%BD%E4%BB%A4">which</a></li><li>查看文件的位置 : <a href="../%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-whereis%E5%91%BD%E4%BB%A4">whereis</a></li><li>配合数据库查看文件位置 : <a href="../%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-locate%E5%91%BD%E4%BB%A4">locate</a></li><li>实际搜寻硬盘查询文件名称 : <a href="../%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4">find</a></li><li><a href="../%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%E4%B9%8Bexec">Linux命令-find命令之exec</a></li><li><a href="../%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%E4%B9%8Bxargs">Linux命令-find命令之xargs</a></li><li><a href="../%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3">Linux命令-find命令的参数详解</a></li></ul><hr><h2 id="文件和目录属性"><a href="#文件和目录属性" class="headerlink" title="文件和目录属性"></a>文件和目录属性</h2><ul><li><a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7/Linux%E5%91%BD%E4%BB%A4-Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84">Linux命令-Linux目录结构</a></li><li><a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7/Linux%E5%91%BD%E4%BB%A4-Linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E5%90%8D">Linux命令-Linux文件类型与扩展名</a></li><li><a href="../%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7/Linux%E5%91%BD%E4%BB%A4-Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3">Linux命令-Linux文件属性详解</a></li></ul><hr><h2 id="文件打包上传和下载"><a href="#文件打包上传和下载" class="headerlink" title="文件打包上传和下载"></a>文件打包上传和下载</h2><ul><li>Linux压缩解压常用命令合集 : <a href="../%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86">Linux压缩解压常用命令合集</a></li><li>拷贝本地文件到远程服务器 : <a href="../%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-sz&rz%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6">sz&amp;rz上传和下载文件</a></li><li>打包文件/目录 : <a href="../%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-tar%E5%91%BD%E4%BB%A4">tar</a></li><li>压缩/解压工具 : <a href="../%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-gzip%E5%91%BD%E4%BB%A4">gzip</a></li><li>xz压缩/解压工具 : <a href="../%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-xz%E5%91%BD%E4%BB%A4">xz</a></li></ul><hr><h2 id="文件权限命令"><a href="#文件权限命令" class="headerlink" title="文件权限命令"></a>文件权限命令</h2><ul><li>改变文件/目录的访问权限 : <a href="../%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-chmod%E5%91%BD%E4%BB%A4">chmod</a></li><li>改变文件/目录的所属群组 : <a href="../%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-chgrp%E5%91%BD%E4%BB%A4">chgrp</a></li><li>改变文件/目录的拥有者和群组 : <a href="../%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-chown%E5%91%BD%E4%BB%A4">chown</a></li></ul><hr><h2 id="磁盘存储相关"><a href="#磁盘存储相关" class="headerlink" title="磁盘存储相关"></a>磁盘存储相关</h2><ul><li>查看文件/目录占据磁盘空间大小 : <a href="../%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3/Linux%E5%91%BD%E4%BB%A4-du%E5%91%BD%E4%BB%A4">du</a></li><li>显示指定磁盘的可用空间 : <a href="../%E7%A3%81%E7%9B%98%E5%AD%98%E5%82%A8%E7%9B%B8%E5%85%B3/Linux%E5%91%BD%E4%BB%A4-df%E5%91%BD%E4%BB%A4">df</a></li></ul><hr><h2 id="性能监控和优化命令"><a href="#性能监控和优化命令" class="headerlink" title="性能监控和优化命令"></a>性能监控和优化命令</h2><ul><li>显示当前系统正在执行的进程的相关信息 : <a href="../%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-top%E5%91%BD%E4%BB%A4">top</a></li><li>显示系统使用和空闲的内存情况 : <a href="../%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-free%E5%91%BD%E4%BB%A4">free</a></li><li>显示虚拟内存的信息 : <a href="../%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-vmstat%E5%91%BD%E4%BB%A4">vmstat</a></li><li>显示磁盘的活动统计情况 : <a href="../%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-iostat%E5%91%BD%E4%BB%A4">iostat</a></li><li>列出当前系统打开的文件 : <a href="../%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-lsof%E5%91%BD%E4%BB%A4">lsof</a></li></ul><hr><h2 id="网络命令"><a href="#网络命令" class="headerlink" title="网络命令"></a>网络命令</h2><ul><li>查看和配置当前系统的网卡信息 : <a href="../%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ifconfig%E5%91%BD%E4%BB%A4">ifconfig</a></li><li>显示和操作IP路由表 : <a href="../%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-route%E5%91%BD%E4%BB%A4">route</a></li><li>测试与目标主机的连通性 : <a href="../%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ping%E5%91%BD%E4%BB%A4">ping</a></li><li>查看计算机到互联网另一端的主机是走的什么路径 : <a href="../%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-traceroute%E5%91%BD%E4%BB%A4">traceroute</a></li><li>查看端口占用情况 : <a href="../%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-netstat%E5%91%BD%E4%BB%A4">netstat</a></li><li>获取socket统计信息 : <a href="../%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ss%E5%91%BD%E4%BB%A4">ss</a></li><li>远程登录(也可以用于确定远程服务的状态、确定远程服务器的某个端口是否能访问) : <a href="../%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-telnet%E5%91%BD%E4%BB%A4">telnet</a></li><li>远程拷贝文件 : <a href="../%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rcp%E5%91%BD%E4%BB%A4">rcp</a></li><li>远程拷贝文件(rcp的升级版,加密的) : <a href="../%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-scp%E5%91%BD%E4%BB%A4">scp</a></li></ul><hr><h2 id="用户权限命令"><a href="#用户权限命令" class="headerlink" title="用户权限命令"></a>用户权限命令</h2><ul><li>用户切换 : <a href="../%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-su%E5%91%BD%E4%BB%A4">su</a></li><li>查看当前操纵者信息 : <a href="../%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-whoami%E5%91%BD%E4%BB%A4">whoami</a></li><li>用户/组别管理(增/改/删) : <a href="../%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86">用户和用户组管理</a></li></ul><hr><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><ul><li>下载文件的工具 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-wget%E5%91%BD%E4%BB%A4">wget</a></li><li>软件管理 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rpm%E5%91%BD%E4%BB%A4">rpm</a></li><li>软件安装方式(包管理器) : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-yum%E5%91%BD%E4%BB%A4">yum</a></li><li>建立同步链接(目录/文件) : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ln%E5%91%BD%E4%BB%A4">ln</a></li><li>比较文件/目录的内容 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-diff%E5%91%BD%E4%BB%A4">diff</a></li><li>显示或设定系统的日期与时间 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-date%E5%91%BD%E4%BB%A4">date</a></li><li>查看日历等时间信息 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cal%E5%91%BD%E4%BB%A4">cal</a></li><li>文件内容查找 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-grep%E5%91%BD%E4%BB%A4">grep</a></li><li>统计文件中的字节数、字数、行数 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-wc%E5%91%BD%E4%BB%A4">wc</a></li><li>用来显示当前进程的状态 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ps%E5%91%BD%E4%BB%A4">ps</a></li><li>监测一个命令的运行结果(可周期性/定时执行命令) : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-watch%E5%91%BD%E4%BB%A4">watch</a></li><li>安排一个定时执行的临时任务(只执行一次) : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-at%E5%91%BD%E4%BB%A4">at</a></li><li>周期性执行任务 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-crontab%E5%91%BD%E4%BB%A4">crontab</a></li><li>显示指定命令的类型 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-type%E5%91%BD%E4%BB%A4">type</a></li><li>显示文本、打印信息 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-echo%E5%91%BD%E4%BB%A4">echo</a></li><li>目前登入系统的用户信息,以及他们正在执行的程序 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-w%E5%91%BD%E4%BB%A4">w</a></li><li>去掉文件名的目录和后缀 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-basename%E5%91%BD%E4%BB%A4">basename</a></li><li>截取给定路径的目录部分 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-dirname%E5%91%BD%E4%BB%A4">dirname</a></li><li>杀死指定PID的进程 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-kill%E5%91%BD%E4%BB%A4">kill</a></li><li>杀死指定名字的进程 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-killall%E5%91%BD%E4%BB%A4">killall</a></li><li>实现自动的交互式任务 : <a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-expect%E5%91%BD%E4%BB%A4">expect</a></li></ul><hr><h2 id="Linux操作"><a href="#Linux操作" class="headerlink" title="Linux操作"></a>Linux操作</h2><p>多个命令完成一个操作</p><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><p><a href="https://www.cnblogs.com/wangqiguo/p/6464234.html">xargs命令详解，xargs与管道的区别</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-chown命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-chown%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-chown%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;chown(Change owner)命令将指定文件的拥有者改为指定的用户或组，用户可以是<strong>用户名</strong>或者<strong>用户ID</strong>；组可以是<strong>组名</strong>或者<strong>组ID</strong>；文件是以空格分开的要改变权限的文件列表，支持<strong>通配符</strong>。系统管理员经常使用chown命令，在将文件拷贝到另一个用户的名录下之后，让用户拥有使用该文件的权限。 </p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown [选项] [所有者][:[组]] 文件...</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;通过chown改变文件的拥有者和群组。在更改文件的所有者或所属群组时，可以使用用户名称和用户识别码设置。普通用户不能将自己的文件改变成其他的拥有者。其操作权限<strong>一般为管理员</strong>。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p>必要参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c, 显示更改的部分的信息</span><br><span class="line">-f, 忽略错误信息</span><br><span class="line">-h, 修复符号链接</span><br><span class="line">-R, 处理指定目录以及其子目录下的所有文件</span><br><span class="line">-v, 显示详细的处理信息</span><br><span class="line">-deference, 作用于符号链接的指向，而不是链接文件本身</span><br></pre></td></tr></table></figure><p>选择参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">--reference=&lt;目录或文件&gt;, 把指定的目录/文件作为参考，把操作的文件/目录设置成参考文件/目录相同拥有者和群组</span><br><span class="line">--from=&lt;当前用户：当前群组&gt;, 只有当前用户和群组跟指定的用户和群组相同时才进行改变</span><br><span class="line">--help, 显示帮助信息</span><br><span class="line">--version, 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：改变拥有者和群组:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chown lxy:lxy log.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或：</span></span><br><span class="line">chown lxy: log.log</span><br></pre></td></tr></table></figure><p>实例2：改变文件拥有者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown lxy log.log</span><br></pre></td></tr></table></figure><p>实例3：改变文件群组:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown :lxy log.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件权限命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-chmod命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-chmod%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-chmod%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;chmod(Change mode)命令用于改变linux系统文件或目录的访问权限。用它控制文件或目录的<strong>访问权限</strong>。该命令有两种用法。一种是包含字母和操作符表达式的文字设定法；另一种是包含数字的数字设定法。</p><p>&emsp;Linux系统中的每个文件和目录都有访问许可权限，用它来确定谁可以通过何种方式对文件和目录进行访问和操作。</p><p>&emsp;文件或目录的访问权限分为<strong>只读</strong>，<strong>只写</strong>和<strong>可执行</strong>三种。以文件为例，只读权限表示只允许读其内容，而禁止对其做任何的更改操作。可执行权限表示允许将该文件作为一个程序执行。</p><p>&emsp;文件被创建时，文件所有者自动拥有对该文件的读、写和可执行权限，以便于对文件的阅读和修改。用户也可根据需要把访问权限设置为需要的任何组合。</p><p>&emsp;有三种不同类型的用户可对文件或目录进行访问：<strong>文件所有者</strong>，<strong>同组用户</strong>、<strong>其他用户</strong>。所有者一般是文件的创建者。所有者可以允许同组用户有权访问文件，还可以将文件的访问权限赋予系统中的其他用户。在这种情况下，系统中每一位用户都能访问该用户拥有的文件或目录。</p><p>&emsp;每一文件或目录的访问权限都有三组，每组用三位表示，分别为文件属主的读、写和执行权限；与属主同组的用户的读、写和执行权限；系统中其他用户的读、写和执行权限。当用ls -l命令显示文件或目录的详细信息时，最左边的一列为文件的访问权限。 例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-r--r--</span><br></pre></td></tr></table></figure><p>&emsp;表示该文件是一个普通文件；其属主有读写权限；与其属主同组的用户只有读权限；其他用户也只有读权限。</p><p>&emsp;确定了一个文件的访问权限后，用户可以利用Linux系统提供的<code>chmod</code>命令来重新<strong>设定</strong>不同的<strong>访问权限</strong>。也可以利用<code>chown</code>命令来<strong>更改</strong>某个文件或目录的<strong>所有者</strong>。利用<code>chgrp</code>命令来<strong>更改</strong>某个文件或目录的<strong>用户组</strong>。 </p><p>chmod命令是非常重要的，用于改变文件或目录的访问权限。用户用它控制文件或目录的访问权限。chmod命令详细情况如下。</p><h3 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1. 命令格式:"></a>1. 命令格式:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 只有文件拥有者或root才能进行权限设置</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第一种：</span></span><br><span class="line">chmod [&#123;ugoa&#125;&#123;+-=&#125;&#123;rwx&#125;] [文件或目录]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 备注：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      u：所有者     g：所属组     o：其他人    a：所有人</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      +：为用户增加权限   -：为用户减少权限   =：为用户赋予权限</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      r：读权限          w：写权限           x：执行权限</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 第二种：</span></span><br><span class="line">chmod [mode=777] [文件或目录]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 备注：</span> </span><br><span class="line"><span class="meta">#</span><span class="bash">      r：4   w：2   x：1</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      r为读权限，用4来表示</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      w为写权限，用2来表示，</span></span><br><span class="line"><span class="meta">#</span><span class="bash">      x为执行权限，用1来表示。</span></span><br></pre></td></tr></table></figure><h3 id="2-命令功能："><a href="#2-命令功能：" class="headerlink" title="2. 命令功能："></a>2. 命令功能：</h3><p>&emsp;用于改变文件或目录的访问权限，用它控制文件或目录的访问权限。</p><h3 id="3-命令参数："><a href="#3-命令参数：" class="headerlink" title="3. 命令参数："></a>3. 命令参数：</h3><p>必要参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-c, 当发生改变时，报告处理信息</span><br><span class="line">-f, 错误信息不输出</span><br><span class="line">-R, 处理指定目录以及其子目录下的所有文件(即递归修改所有文件的权限)</span><br><span class="line">-v, 运行时显示详细处理信息</span><br></pre></td></tr></table></figure><p>选择参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">--reference=&lt;目录或者文件&gt; 设置成具有指定目录或者文件具有相同的权限</span><br><span class="line">--version 显示版本信息</span><br><span class="line">--help 帮助文档</span><br><span class="line">&lt;权限范围&gt;+&lt;权限设置&gt; 使权限范围内的目录或者文件具有指定的权限</span><br><span class="line">&lt;权限范围&gt;-&lt;权限设置&gt; 删除权限范围的目录或者文件的指定权限</span><br><span class="line">&lt;权限范围&gt;=&lt;权限设置&gt; 设置权限范围内的目录或者文件的权限为指定的值</span><br><span class="line"></span><br><span class="line">权限范围：</span><br><span class="line">u ：(owner)目录或者文件的拥有者</span><br><span class="line">g ：(group)目录或者文件的当前的群组</span><br><span class="line">o ：(other)除了目录或者文件的当前用户或群组之外的用户或者群组</span><br><span class="line">a ：(all)所有的用户及群组</span><br><span class="line"></span><br><span class="line">权限代号：</span><br><span class="line">r ：读权限，用数字4表示</span><br><span class="line">w ：写权限，用数字2表示</span><br><span class="line">x ：执行权限，用数字1表示</span><br><span class="line">- ：删除权限，用数字0表示</span><br><span class="line">s ：特殊权限 </span><br></pre></td></tr></table></figure><p>该命令有两种用法。一种是包含字母和操作符表达式的<strong>文字设定法</strong>；另一种是包含数字的<strong>数字设定法</strong>。</p><ul><li>文字设定法:  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ［who］ ［+ | - | =］ ［mode］ 文件名</span><br></pre></td></tr></table></figure></li><li>数字设定法:<br>我们必须首先了解用数字表示的属性的含义：0表示没有权限，1表示可执行权限，2表示可写权限，4表示可读权限，然后将其相加。所以数字属性的格式应为3个从0到7的八进制数，其顺序是（u）（g）（o）。<br>例如，如果想让某个文件的属主有“读/写”二种权限，需要把4（可读）+2（可写）＝6（读/写）。<br>数字设定法的一般形式为：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod [mode] 文件名</span><br></pre></td></tr></table></figure>  数字与字符对应关系如下：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r=4，w=2，x=1</span><br><span class="line">若要rwx属性则4+2+1=7</span><br><span class="line">若要rw-属性则4+2+0=6</span><br><span class="line">若要r-x属性则4+0+1=5 </span><br></pre></td></tr></table></figure></li></ul><h3 id="4-使用实例："><a href="#4-使用实例：" class="headerlink" title="4. 使用实例："></a>4. 使用实例：</h3><p>实例1：增加文件所有用户组可执行权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a+x log.log</span><br></pre></td></tr></table></figure><p>实例2：同时修改不同用户权限(拥有者和分组增加写权限，其他人删除执行权限)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod ug+w,o-x log.log</span><br></pre></td></tr></table></figure><p>实例3：删除文件权限(删除所有人的可执行权限):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod a-x log.log</span><br></pre></td></tr></table></figure><p>实例4：使用“=”设置权限(撤销原来所有的权限，然后使拥有者具有可读权限):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod u=x log.log</span><br></pre></td></tr></table></figure><p>实例5：对一个目录及其子目录所有文件添加权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R u+x lxy</span><br></pre></td></tr></table></figure><p>实例6：通过数字设定法设置权限(给file的属主分配读、写、执行(7)的权限，给file的所在组分配读、执行(5)的权限，给其他用户分配执行(1)的权限):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 751 file</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或：</span></span><br><span class="line">chmod u=rwx,g=rx,o=x file</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件权限命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-chgrp命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-chgrp%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-chgrp%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;在linux系统里，文件或目录的权限的掌控以拥有者及所属群组来管理。可以使用chgrp(Change group)指令去变更文件与目录所属群组，这种方式采用群组名称或群组识别码都可以。<code>要被改变的组名必须要在/etc/group文件内存在才行</code>。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp [选项] [组] [文件]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;chgrp命令可采用群组名称或群组识别码的方式改变文件或目录的所属群组。使用权限是超级用户(root)。 </p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p>必要参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-c, 当发生改变时输出调试信息</span><br><span class="line">-f, 不显示错误信息</span><br><span class="line">-R, 处理指定目录以及其子目录下的所有文件</span><br><span class="line">-v, 运行时显示详细的处理信息</span><br><span class="line">--dereference, 作用于符号链接的指向，而不是符号链接本身</span><br><span class="line">--no-dereference, 作用于符号链接本身</span><br></pre></td></tr></table></figure><p>选择参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--reference=&lt;文件或者目录&gt;</span><br><span class="line">--help 显示帮助信息</span><br><span class="line">--version 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：改变文件的群组属性:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp -v lxy log.log</span><br></pre></td></tr></table></figure><p>实例2：根据指定文件改变文件的群组属性(改变文件log2.log的群组属性，使得文件log2.log的群组属性和参考文件log1.log的群组属性相同): </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chgrp --reference=log1.log log2.log</span><br></pre></td></tr></table></figure><p>实例3：通过<strong>群组识别码</strong>改变文件群组属性</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 具体群组和群组识别码可以去/etc/group文件中查看</span></span><br><span class="line">chgrp -R 100 lxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件权限命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-whoami命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-whoami%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-whoami%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux whoami命令用于<strong>显示自身用户名称</strong>。显示自身的用户名称，本指令相当于执行”id -un”指令。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用于<strong>显示自身用户名称</strong>。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">--help, 在线帮助。</span><br><span class="line">--version, 显示版本信息。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示用户名(我是谁):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 用户权限命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-su命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-su%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-su%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su [-fmp] [-c command] [-s shell] [--help] [--version] [-] [USER [ARG]]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;Linux su(switch user)命令用于<strong>变更为其他使用者的身份</strong>，除root外，需要键入该使用者的密码。</p><p>&emsp;使用权限：所有使用者。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-f或--fast, 不必读启动档（如csh.cshrc等），仅用于csh或tcsh</span><br><span class="line">-m -p或--preserve-environment, 执行su时不改变环境变数</span><br><span class="line">-c command或--command=command, 变更为帐号为USER的使用者并执行指令（command）后再变回原来使用者</span><br><span class="line">-s shell或--shell=shell, 指定要执行的shell（bash csh tcsh 等），预设值为/etc/passwd内的该使用者（USER） shell</span><br><span class="line">--help, 显示说明文件</span><br><span class="line">--version, 显示版本资讯</span><br><span class="line">--l或--login, 这个参数加了之后，就好像是重新 login 为该使用者一样，大部份环境变数（HOME SHELL USER等等）都是以该使用者（USER）为主，并且工作目录也会改变，如果没有指定USER，内定是root</span><br><span class="line">USER, 欲变更的使用者帐号</span><br><span class="line">ARG, 传入新的shell参数</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：切换成lxy用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su lxy</span><br></pre></td></tr></table></figure><p>实例2：切换回root用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">su -</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或：</span></span><br><span class="line">su - root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或(在有的linux系统效果是：用户是root，权限是普通的)</span></span><br><span class="line">su root</span><br></pre></td></tr></table></figure><p>实例3：切换回上一个用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exit</span><br></pre></td></tr></table></figure><p>实例4：显示当前用户</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whoami</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 用户权限命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-用户和用户组管理</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%94%A8%E6%88%B7%E6%9D%83%E9%99%90%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-%E7%94%A8%E6%88%B7%E5%92%8C%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux系统是一个<strong>多用户多任务</strong>的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>&emsp;用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p>&emsp;每个用户账号都拥有一个唯一的用户名和各自的口令(密码)。</p><p>&emsp;用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p><p>&emsp;实现用户账号的管理，要完成的工作主要有如下几个方面：<br>&emsp;&emsp;1.用户账号的添加、删除与修改。<br>&emsp;&emsp;2.用户口令的管理。<br>&emsp;&emsp;3.用户组的管理。  </p><hr><h2 id="一、Linux系统用户账号的管理："><a href="#一、Linux系统用户账号的管理：" class="headerlink" title="一、Linux系统用户账号的管理："></a>一、Linux系统用户账号的管理：</h2><p>&emsp;用户账号的管理工作主要涉及到用户账号的<strong>添加</strong>、<strong>修改</strong>和<strong>删除</strong>。</p><p>&emsp;添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。<em>刚添加的账号是被锁定的，无法使用</em>。</p><h3 id="1-添加用户-useradd-："><a href="#1-添加用户-useradd-：" class="headerlink" title="1. 添加用户(useradd)："></a>1. 添加用户(useradd)：</h3><h4 id="1-1-命令格式："><a href="#1-1-命令格式：" class="headerlink" title="1.1. 命令格式："></a>1.1. 命令格式：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd [选项] [用户名]</span><br></pre></td></tr></table></figure><h4 id="1-2．命令参数："><a href="#1-2．命令参数：" class="headerlink" title="1.2．命令参数："></a>1.2．命令参数：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-c, 指定一段注释性描述。</span><br><span class="line">-e, 指定帐号的有效期限。</span><br><span class="line">-f, 指定在密码过期后多少天即关闭该帐号。</span><br><span class="line">-d, 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。</span><br><span class="line">-m, 自动建立用户的登入目录。</span><br><span class="line">-g, 指定用户所属的用户组。</span><br><span class="line">-G, 指定用户所属的附加组。</span><br><span class="line">-s, 指定用户的登录Shell。</span><br><span class="line">-u, 指定用户的用户编号(uid)，如果同时有-o选项，则可以重复使用其他用户的标识号。</span><br></pre></td></tr></table></figure><h4 id="1-3-使用实例："><a href="#1-3-使用实例：" class="headerlink" title="1.3. 使用实例："></a>1.3. 使用实例：</h4><p>实例1：创建用户lxy，默认用户主目录为/home/lxy</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 没有设置用户的组别，就会创建同名组</span></span><br><span class="line">useradd lxy</span><br></pre></td></tr></table></figure><p>实例2：创建用户lxy，并设置其组别(避免创建同名组)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置了用户组别，就不会创建同名组</span></span><br><span class="line">useradd -g test lxy</span><br></pre></td></tr></table></figure><p>实例3：创建用户sam，并指定用户主目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 其中-d和-m选项用来为登录名sam产生一个主目录/home/sam(/home为默认的用户主目录所在的父目录)</span></span><br><span class="line">useradd –d /home/sam -m sam</span><br></pre></td></tr></table></figure><p>实例4：创建用户gem，并指定用户的登录Shell是/bin/sh,设置所属用户组为group，同时又属于adm和root用户组，其中group用户组是其主组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -s /bin/sh -g group –G adm,root gem</span><br></pre></td></tr></table></figure><p>这里可能需要新建组：<code>groupadd group</code>及<code>groupadd adm</code></p><p>增加用户账号就是在<code>/etc/passwd</code>文件中<strong>为新用户增加一条记录</strong>，同时<strong>更新其他系统文件</strong>如<code>/etc/shadow</code>, <code>/etc/group</code>等。</p><p>Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。</p><h3 id="2．修改用户-usermod-："><a href="#2．修改用户-usermod-：" class="headerlink" title="2．修改用户(usermod)："></a>2．修改用户(usermod)：</h3><p>修改用户账号就是根据实际情况更改用户的有关属性，如<em>用户号</em>、<em>主目录</em>、<em>用户组</em>、<em>登录Shell</em>等。</p><h4 id="2-1-命令格式："><a href="#2-1-命令格式：" class="headerlink" title="2.1. 命令格式："></a>2.1. 命令格式：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod [选项] [用户名]</span><br></pre></td></tr></table></figure><h4 id="2-2-命令参数："><a href="#2-2-命令参数：" class="headerlink" title="2.2. 命令参数："></a>2.2. 命令参数：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常用的选项包括-c, -d, -m, -e, -f, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样,</span><br><span class="line">另外：</span><br><span class="line">-l&lt;帐号名称&gt;, 修改用户帐号名称。</span><br><span class="line">-L, 锁定用户密码，使密码无效。</span><br><span class="line">-U, 解除密码锁定。</span><br></pre></td></tr></table></figure><h4 id="2-3-使用实例："><a href="#2-3-使用实例：" class="headerlink" title="2.3. 使用实例："></a>2.3. 使用实例：</h4><p>实例1：将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">usermod -s /bin/ksh -d /home/z –g developer sam</span><br></pre></td></tr></table></figure><h3 id="3．删除用户-userdel-："><a href="#3．删除用户-userdel-：" class="headerlink" title="3．删除用户(userdel)："></a>3．删除用户(userdel)：</h3><p>&emsp;如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将<code>/etc/passwd</code>等系统文件中的该用户记录删除，必要时还删除用户的主目录。</p><h4 id="3-1-命令格式："><a href="#3-1-命令格式：" class="headerlink" title="3.1. 命令格式："></a>3.1. 命令格式：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel [选项] [用户名]</span><br></pre></td></tr></table></figure><h4 id="3-2-命令参数："><a href="#3-2-命令参数：" class="headerlink" title="3.2. 命令参数："></a>3.2. 命令参数：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-r, 删除用户登入目录以及目录中所有文件。</span><br></pre></td></tr></table></figure><h4 id="3-3-使用实例："><a href="#3-3-使用实例：" class="headerlink" title="3.3. 使用实例："></a>3.3. 使用实例：</h4><p>实例1：删除用户sam，并删除其家目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">userdel -r sam</span><br></pre></td></tr></table></figure><p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p><h3 id="4．用户口令-密码-的管理："><a href="#4．用户口令-密码-的管理：" class="headerlink" title="4．用户口令(密码)的管理："></a>4．用户口令(密码)的管理：</h3><p>&emsp;用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。</p><p>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p><h4 id="4-1-命令格式："><a href="#4-1-命令格式：" class="headerlink" title="4.1. 命令格式："></a>4.1. 命令格式：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd [选项] [用户名]</span><br></pre></td></tr></table></figure><h4 id="4-2-命令参数："><a href="#4-2-命令参数：" class="headerlink" title="4.2. 命令参数："></a>4.2. 命令参数：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-l, 锁定口令,即禁用账号。</span><br><span class="line">-u, 口令解锁,启用已被停止的账户。</span><br><span class="line">-d, 使账号无口令。</span><br><span class="line">-f, 强迫用户下次登录时修改口令。</span><br><span class="line">-x, 设置密码的有效期。</span><br><span class="line">-S, 显示密码信息</span><br></pre></td></tr></table></figure><p>如果默认用户名，则修改当前用户的口令。</p><h4 id="4-3-使用实例："><a href="#4-3-使用实例：" class="headerlink" title="4.3. 使用实例："></a>4.3. 使用实例：</h4><p>实例1：修改该用户自己的口令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost lxy]# passwd </span><br><span class="line">Old password:****** </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure><p>实例2：如果是超级用户，可以用下列形式指定任何用户的口令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# passwd lxy </span><br><span class="line">New password:******* </span><br><span class="line">Re-enter new password:*******</span><br></pre></td></tr></table></figure><p>普通用户修改自己的口令时，passwd命令会先询问<strong>原口令</strong>，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。<br>实例3：为用户指定空口令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此命令将用户lxy的口令删除，这样用户lxy下一次登录时，系统就不再允许该用户登录了</span></span><br><span class="line">passwd -d lxy</span><br></pre></td></tr></table></figure><p>实例3：用-l(lock)选项锁定某一用户，使其不能登录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd -l lxy</span><br></pre></td></tr></table></figure><h2 id="二、Linux系统用户组的管理"><a href="#二、Linux系统用户组的管理" class="headerlink" title="二、Linux系统用户组的管理"></a>二、Linux系统用户组的管理</h2><p>&emsp;每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>&emsp;用户组的管理涉及用户组的<strong>添加</strong>、<strong>删除</strong>和<strong>修改</strong>。组的增加、删除和修改实际上就是对<code>/etc/group</code>文件的更新。</p><h3 id="1-增加组别-groupadd-："><a href="#1-增加组别-groupadd-：" class="headerlink" title="1. 增加组别(groupadd)："></a>1. 增加组别(groupadd)：</h3><h4 id="1-1-命令格式：-1"><a href="#1-1-命令格式：-1" class="headerlink" title="1.1. 命令格式："></a>1.1. 命令格式：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupadd [选项] [用户组]</span><br></pre></td></tr></table></figure><h4 id="1-2-命令参数："><a href="#1-2-命令参数：" class="headerlink" title="1.2. 命令参数："></a>1.2. 命令参数：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-g GID, 指定新用户组的组标识号(GID)。</span><br><span class="line">-o, 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。</span><br></pre></td></tr></table></figure><h4 id="1-3-使用实例：-1"><a href="#1-3-使用实例：-1" class="headerlink" title="1.3. 使用实例："></a>1.3. 使用实例：</h4><p>实例1：新增分组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。</span></span><br><span class="line">groupadd group1</span><br></pre></td></tr></table></figure><p>实例2：新增分组,并指定新组的识别号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 增加了一个新组group2，同时指定新组的组标识号是101</span></span><br><span class="line">groupadd -g 101 group2</span><br></pre></td></tr></table></figure><h3 id="2-修改组别-groupmod-："><a href="#2-修改组别-groupmod-：" class="headerlink" title="2. 修改组别(groupmod)："></a>2. 修改组别(groupmod)：</h3><h4 id="2-1-命令格式：-1"><a href="#2-1-命令格式：-1" class="headerlink" title="2.1. 命令格式："></a>2.1. 命令格式：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod [选项] [用户组]</span><br></pre></td></tr></table></figure><h4 id="2-2-命令参数：-1"><a href="#2-2-命令参数：-1" class="headerlink" title="2.2. 命令参数："></a>2.2. 命令参数：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-g GID, 为用户组指定新的组标识号。</span><br><span class="line">-o, 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。</span><br><span class="line">-n 新用户组, 将用户组的名字改为新名字</span><br></pre></td></tr></table></figure><h4 id="2-3-使用实例：-1"><a href="#2-3-使用实例：-1" class="headerlink" title="2.3. 使用实例："></a>2.3. 使用实例：</h4><p>实例1：修改用户组的组标识号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupmod -g 102 group2</span><br></pre></td></tr></table></figure><p>实例2：修改用户组的组标识号，并改名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将组group2的标识号改为10000，组名修改为group3</span></span><br><span class="line">groupmod –g 10000 -n group3 group2</span><br></pre></td></tr></table></figure><h3 id="3-删除组别-groupdel-："><a href="#3-删除组别-groupdel-：" class="headerlink" title="3. 删除组别(groupdel)："></a>3. 删除组别(groupdel)：</h3><h4 id="3-1-命令格式：-1"><a href="#3-1-命令格式：-1" class="headerlink" title="3.1. 命令格式："></a>3.1. 命令格式：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">groupdel [用户组]</span><br></pre></td></tr></table></figure><h4 id="3-2-命令参数：-1"><a href="#3-2-命令参数：-1" class="headerlink" title="3.2. 命令参数："></a>3.2. 命令参数：</h4><p>无</p><h4 id="3-3-使用实例：-1"><a href="#3-3-使用实例：-1" class="headerlink" title="3.3. 使用实例："></a>3.3. 使用实例：</h4><p>实例1：删除组别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果组下存在对应的用户信息，禁止删除</span></span><br><span class="line">groupdel group1</span><br></pre></td></tr></table></figure><h3 id="4-切换用户组-newgrp-："><a href="#4-切换用户组-newgrp-：" class="headerlink" title="4. 切换用户组(newgrp)："></a>4. 切换用户组(newgrp)：</h3><p>&emsp;如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。</p><p>&emsp;用户可以在登录后，使用命令<code>newgrp</code>切换到其他用户组.</p><h4 id="4-1-命令格式：-1"><a href="#4-1-命令格式：-1" class="headerlink" title="4.1. 命令格式："></a>4.1. 命令格式：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newgrp [群组名称]</span><br></pre></td></tr></table></figure><h4 id="4-2-命令格式："><a href="#4-2-命令格式：" class="headerlink" title="4.2. 命令格式："></a>4.2. 命令格式：</h4><p>&emsp;Linux newgrp命令用于<strong>登入另一个群组</strong>。</p><h4 id="4-3-命令参数："><a href="#4-3-命令参数：" class="headerlink" title="4.3. 命令参数："></a>4.3. 命令参数：</h4><p>无</p><h4 id="4-4-使用实例："><a href="#4-4-使用实例：" class="headerlink" title="4.4. 使用实例："></a>4.4. 使用实例：</h4><p>实例1：改变群组</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组</span></span><br><span class="line">newgrp root</span><br></pre></td></tr></table></figure><p>类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。</p><h2 id="三、与用户账号有关的系统文件"><a href="#三、与用户账号有关的系统文件" class="headerlink" title="三、与用户账号有关的系统文件"></a>三、与用户账号有关的系统文件</h2><p>完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。</p><p>与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括<code>/etc/passwd</code>, <code>/etc/shadow</code>, <code>/etc/group</code>等。</p><p>下面分别介绍这些文件的内容:</p><h3 id="1-etc-passwd文件-用户管理相关"><a href="#1-etc-passwd文件-用户管理相关" class="headerlink" title="1. /etc/passwd文件(用户管理相关)"></a>1. /etc/passwd文件(用户管理相关)</h3><p>Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。</p><p>这个文件对所有用户都是可读的。它的内容类似下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost lxy]# cat /etc/passwd</span><br><span class="line">root:x:0:0:Superuser:/:</span><br><span class="line">daemon:x:1:1:System daemons:/etc:</span><br><span class="line">bin:x:2:2:Owner of system commands:/bin:</span><br><span class="line">sys:x:3:3:Owner of system files:/usr/sys:</span><br><span class="line">adm:x:4:4:System accounting:/usr/adm:</span><br><span class="line">uucp:x:5:5:UUCP administrator:/usr/lib/uucp:</span><br><span class="line">auth:x:7:21:Authentication administrator:/tcb/files/auth:</span><br><span class="line">cron:x:9:16:Cron daemon:/usr/spool/cron:</span><br><span class="line">listen:x:37:4:Network daemon:/usr/net/nls:</span><br><span class="line">lp:x:71:18:Printer administrator:/usr/spool/lp:</span><br><span class="line">sam:x:200:50:Sam san:/home/sam:/bin/sh</span><br></pre></td></tr></table></figure><p>从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(:)分隔为7个字段，其格式和具体含义如下：</p><blockquote><p>用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell</p></blockquote><h4 id="1）”用户名”是代表用户账号的字符串。"><a href="#1）”用户名”是代表用户账号的字符串。" class="headerlink" title="1）”用户名”是代表用户账号的字符串。"></a>1）”用户名”是代表用户账号的字符串。</h4><p>通常长度不超过8个字符，并且由大小写字母和/或数字组成。<em>登录名中不能有冒号</em>(:)，因为冒号在这里是分隔符。</p><p>为了兼容起见，登录名中<em>最好不要包含点字符</em>(.)，并且<em>不使用连字符</em>(-)和<em>加号</em>(+)<em>打头</em>。</p><h4 id="2）”口令”一些系统中，存放着加密后的用户口令字。"><a href="#2）”口令”一些系统中，存放着加密后的用户口令字。" class="headerlink" title="2）”口令”一些系统中，存放着加密后的用户口令字。"></a>2）”口令”一些系统中，存放着加密后的用户口令字。</h4><p>虽然这个字段存放的只是用户口令的加密串，不是明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多Linux系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到<code>/etc/shadow</code>文件中，而在<code>/etc/passwd</code>文件的口令字段中只存放一个特殊的字符，例如”x”或者”*”。</p><h4 id="3）”用户标识号”是一个整数，系统内部用它来标识用户。"><a href="#3）”用户标识号”是一个整数，系统内部用它来标识用户。" class="headerlink" title="3）”用户标识号”是一个整数，系统内部用它来标识用户。"></a>3）”用户标识号”是一个整数，系统内部用它来标识用户。</h4><p>一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。</p><p>通常用户标识号的取值范围是0～65535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。</p><h4 id="4）”组标识号”字段记录的是用户所属的用户组。"><a href="#4）”组标识号”字段记录的是用户所属的用户组。" class="headerlink" title="4）”组标识号”字段记录的是用户所属的用户组。"></a>4）”组标识号”字段记录的是用户所属的用户组。</h4><p>它对应着<code>/etc/group</code>文件中的一条记录。</p><h4 id="5-”注释性描述”字段记录着用户的一些个人情况。"><a href="#5-”注释性描述”字段记录着用户的一些个人情况。" class="headerlink" title="5)”注释性描述”字段记录着用户的一些个人情况。"></a>5)”注释性描述”字段记录着用户的一些个人情况。</h4><p>例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。</p><h4 id="6-”主目录”，也就是用户的起始工作目录。"><a href="#6-”主目录”，也就是用户的起始工作目录。" class="headerlink" title="6)”主目录”，也就是用户的起始工作目录。"></a>6)”主目录”，也就是用户的起始工作目录。</h4><p>它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。</p><h4 id="7-用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。"><a href="#7-用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。" class="headerlink" title="7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。"></a>7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。</h4><p>Shell是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有<code>sh(Bourne Shell)</code>,<code>csh(C Shell)</code>,<code>ksh(Korn Shell)</code>,<code>tcsh(TENEX/TOPS-20 type C Shell)</code>,<code>bash(Bourne Again Shell)</code>等。</p><p>系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用<em>sh为默认</em>的登录Shell，即这个字段的值为<code>/bin/sh</code>。</p><p>用户的登录Shell也可以指定为某个特定的程序(此程序不是一个命令解释器)。</p><p>利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux系统要求只有那些在系统中登记了的程序才能出现在这个字段中。</p><h4 id="8-系统中有一类用户称为伪用户-pseudo-users-。"><a href="#8-系统中有一类用户称为伪用户-pseudo-users-。" class="headerlink" title="8)系统中有一类用户称为伪用户(pseudo users)。"></a>8)系统中有一类用户称为伪用户(pseudo users)。</h4><p>这些用户在<code>/etc/passwd</code>文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是<strong>方便系统管理</strong>，满足相应的系统进程对文件属主的要求。</p><p>常见的伪用户如下所示：<br>|伪用户  |含义|<br>|——–|—|<br>|bin     |拥有可执行的用户命令文件|<br>|sys     |拥有系统文件|<br>|adm     |拥有帐户文件|<br>|uucp    |UUCP使用|<br>|lp      |lp或lpd子系统使用|<br>|nobody  |NFS使用|</p><h3 id="2-etc-shadow文件"><a href="#2-etc-shadow文件" class="headerlink" title="2. /etc/shadow文件"></a>2. /etc/shadow文件</h3><p>1、除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。</p><p>由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是<code>/etc/shadow</code>文件。只有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。</p><p>2、<code>/etc/shadow</code>中的记录行与<code>/etc/passwd</code>中的一一对应，它由<code>pwconv</code>命令根据<code>/etc/passwd</code>中的数据自动产生</p><p>它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用”:”隔开。这些字段是：</p><blockquote><p>登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志</p></blockquote><h4 id="1-”登录名”"><a href="#1-”登录名”" class="headerlink" title="1)”登录名”"></a>1)”登录名”</h4><p>与/etc/passwd文件中的登录名相一致的用户账号</p><h4 id="2-”口令”"><a href="#2-”口令”" class="headerlink" title="2)”口令”"></a>2)”口令”</h4><p>存放的是加密后的用户口令字,长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合{ ./0-9A-Za-z}中的字符，则对应的用户不能登录。</p><h4 id="3-”最后一次修改时间”"><a href="#3-”最后一次修改时间”" class="headerlink" title="3)”最后一次修改时间”"></a>3)”最后一次修改时间”</h4><p>从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux中，这个时间起点是1970年1月1日。</p><h4 id="4-”最小时间间隔”"><a href="#4-”最小时间间隔”" class="headerlink" title="4)”最小时间间隔”"></a>4)”最小时间间隔”</h4><p>指的是两次修改口令之间所需的最小天数。</p><h4 id="5-”最大时间间隔”"><a href="#5-”最大时间间隔”" class="headerlink" title="5)”最大时间间隔”"></a>5)”最大时间间隔”</h4><p>指的是口令保持有效的最大天数。</p><h4 id="6-”警告时间”"><a href="#6-”警告时间”" class="headerlink" title="6)”警告时间”"></a>6)”警告时间”</h4><p>从系统开始警告用户到用户密码正式失效之间的天数。</p><h4 id="7-”不活动时间”"><a href="#7-”不活动时间”" class="headerlink" title="7)”不活动时间”"></a>7)”不活动时间”</h4><p>用户没有登录活动但账号仍能保持有效的最大天数。</p><h4 id="8-”失效时间”"><a href="#8-”失效时间”" class="headerlink" title="8)”失效时间”"></a>8)”失效时间”</h4><p>是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。</p><h3 id="3-etc-group文件"><a href="#3-etc-group文件" class="headerlink" title="3. /etc/group文件"></a>3. /etc/group文件</h3><p>将用户分组是Linux系统中对用户进行管理及控制访问权限的一种手段。</p><p>每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。</p><p>当一个用户同时是多个组中的成员时，在<code>/etc/passwd</code>文件中记录的是用户所属的<strong>主组</strong>，也就是登录时所属的<strong>默认组</strong>，而其他组称为<strong>附加组</strong>。</p><p><em>用户要访问属于附加组的文件</em>时，必须首先使用<code>newgrp</code>命令使自己成为所要访问的组中的成员。</p><p>用户组的所有信息都存放在<code>/etc/group</code>文件中。此文件的格式也类似于<code>/etc/passwd</code>文件，由冒号(:)隔开若干个字段，这些字段有：</p><blockquote><p>组名:口令:组标识号:组内用户列表</p></blockquote><h4 id="1-”组名”"><a href="#1-”组名”" class="headerlink" title="1)”组名”"></a>1)”组名”</h4><p>用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。</p><h4 id="2-”口令”-1"><a href="#2-”口令”-1" class="headerlink" title="2)”口令”"></a>2)”口令”</h4><p>存放的是用户组加密后的口令字。一般Linux系统的用户组都没有口令，即这个字段一般为空，或者是*。</p><h4 id="3-”组标识号”"><a href="#3-”组标识号”" class="headerlink" title="3)”组标识号”"></a>3)”组标识号”</h4><p>与用户标识号类似，也是一个整数，被系统内部用来标识组。</p><h4 id="4-”组内用户列表”"><a href="#4-”组内用户列表”" class="headerlink" title="4)”组内用户列表”"></a>4)”组内用户列表”</h4><p>是属于这个组的所有用户的列表，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。</p><h2 id="四、添加批量用户"><a href="#四、添加批量用户" class="headerlink" title="四、添加批量用户"></a>四、添加批量用户</h2><p>添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：</p><h3 id="（1）先编辑一个文本用户文件。"><a href="#（1）先编辑一个文本用户文件。" class="headerlink" title="（1）先编辑一个文本用户文件。"></a>（1）先编辑一个文本用户文件。</h3><p>每一列按照<code>/etc/passwd</code>密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user001::600:100:user:/home/user001:/bin/bash</span><br><span class="line">user002::601:100:user:/home/user002:/bin/bash</span><br><span class="line">user003::602:100:user:/home/user003:/bin/bash</span><br><span class="line">user004::603:100:user:/home/user004:/bin/bash</span><br><span class="line">user005::604:100:user:/home/user005:/bin/bash</span><br><span class="line">user006::605:100:user:/home/user006:/bin/bash</span><br></pre></td></tr></table></figure><h3 id="（2）以root身份执行命令-usr-sbin-newusers，从刚创建的用户文件user-txt中导入数据，创建用户："><a href="#（2）以root身份执行命令-usr-sbin-newusers，从刚创建的用户文件user-txt中导入数据，创建用户：" class="headerlink" title="（2）以root身份执行命令/usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户："></a>（2）以root身份执行命令/usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newusers &lt; user.txt</span><br></pre></td></tr></table></figure><p>然后可以执行命令<code>cat /etc/passwd</code>检查<code>/etc/passwd</code>文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。</p><h3 id="（3）执行命令-usr-sbin-pwunconv。"><a href="#（3）执行命令-usr-sbin-pwunconv。" class="headerlink" title="（3）执行命令/usr/sbin/pwunconv。"></a>（3）执行命令/usr/sbin/pwunconv。</h3><p>将<code>/etc/shadow</code>产生的shadow密码解码，然后回写到<code>/etc/passwd</code>中，并将<code>/etc/shadow</code>的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消shadow password功能。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwunconv</span><br></pre></td></tr></table></figure><h3 id="（4）编辑每个用户的密码对照文件。"><a href="#（4）编辑每个用户的密码对照文件。" class="headerlink" title="（4）编辑每个用户的密码对照文件。"></a>（4）编辑每个用户的密码对照文件。</h3><p>格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用户名:密码</span><br></pre></td></tr></table></figure><p>实例文件 passwd.txt 内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">user001:123456</span><br><span class="line">user002:123456</span><br><span class="line">user003:123456</span><br><span class="line">user004:123456</span><br><span class="line">user005:123456</span><br><span class="line">user006:123456</span><br></pre></td></tr></table></figure><h3 id="（5）以root身份执行命令-usr-sbin-chpasswd。"><a href="#（5）以root身份执行命令-usr-sbin-chpasswd。" class="headerlink" title="（5）以root身份执行命令/usr/sbin/chpasswd。"></a>（5）以root身份执行命令/usr/sbin/chpasswd。</h3><p>创建用户密码，<code>chpasswd</code>会将经过<code>/usr/bin/passwd</code>命令编码过的密码写入<code>/etc/passwd</code>的密码栏。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chpasswd &lt; passwd.txt</span><br></pre></td></tr></table></figure><h3 id="（6）确定密码经编码写入-etc-passwd的密码栏后。"><a href="#（6）确定密码经编码写入-etc-passwd的密码栏后。" class="headerlink" title="（6）确定密码经编码写入/etc/passwd的密码栏后。"></a>（6）确定密码经编码写入/etc/passwd的密码栏后。</h3><p>执行命令<code>/usr/sbin/pwconv</code>将密码编码为shadow password，并将结果写入<code>/etc/shadow</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwconv</span><br></pre></td></tr></table></figure><p>这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 用户权限命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-vmstat命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-vmstat%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-vmstat%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;vmstat(Virtual Meomory Statistics)(虚拟内存统计)的缩写，可对操作系统的<strong>虚拟内存</strong>、<strong>进程</strong>、<strong>CPU活动</strong>进行监控。他是对<strong>系统的整体情况</strong>进行统计，不足之处是无法对某个进程进行深入分析。<code>vmstat</code>工具提供了一种<strong>低开销</strong>的系统性能观察方式。因为<code>vmstat</code>本身就是低开销工具，在非常高负荷的服务器上，你需要查看并监控系统的健康情况,在控制窗口还是能够使用vmstat输出结果。在学习vmstat命令前，我们先了解一下Linux系统中关于物理内存和虚拟内存相关信息。</p><p><strong>物理内存</strong>和<strong>虚拟内存</strong>区别：</p><p>我们知道，直接从物理内存读写数据要比从硬盘读写数据要快的多，因此，我们希望所有数据的读取和写入都在内存完成，而内存是有限的，这样就引出了物理内存与虚拟内存的概念。</p><p><strong>物理内存</strong>就是系统硬件提供的内存大小，是真正的内存，相对于物理内存，在linux下还有一个虚拟内存的概念，<strong>虚拟内存</strong>就是为了满足物理内存的不足而提出的策略，它是利用磁盘空间虚拟出的一块<strong>逻辑内存</strong>，用作虚拟内存的磁盘空间被称为<strong>交换空间</strong>（Swap Space）。</p><p>作为物理内存的扩展，linux会在物理内存不足时，使用交换分区的虚拟内存，更详细的说，就是<strong>内核会将暂时不用的内存块信息写到交换空间</strong>，这样以来，物理内存得到了释放，这块内存就可以用于其它目的，当需要用到原始的内容时，这些信息会被重新从交换空间读入物理内存。</p><p>linux的内存管理采取的是<strong>分页存取机制</strong>，为了保证物理内存能得到充分的利用，内核会在适当的时候将物理内存中不经常使用的数据块自动交换到虚拟内存中，而将经常使用的信息保留到物理内存。</p><p>要深入了解linux内存运行机制，需要知道下面提到的几个方面：</p><p>首先，Linux系统会不时的进行<strong>页面交换操作</strong>，以保持尽可能多的空闲物理内存，即使并没有什么事情需要内存，Linux也会交换出暂时不用的内存页面。这可以避免等待交换所需的时间。</p><p>其次，linux进行页面交换是有条件的，不是所有页面在不用时都交换到虚拟内存，linux内核根据”最近最经常使用”算法，仅仅将一些不经常使用的页面文件交换到虚拟内存，有时我们会看到这么一个现象：linux物理内存还有很多，但是交换空间也使用了很多。其实，这并不奇怪，例如，一个占用很大内存的进程运行时，需要耗费很多内存资源，此时就会有一些不常用页面文件被交换到虚拟内存中，但后来这个占用很多内存资源的进程结束并释放了很多内存时，刚才被交换出去的页面文件并不会自动的交换进物理内存，除非有这个必要，那么此刻系统物理内存就会空闲很多，同时交换空间也在被使用，就出现了刚才所说的现象了。关于这点，不用担心什么，只要知道是怎么一回事就可以了。</p><p>最后，交换空间的页面在使用时会首先被交换到物理内存，如果此时没有足够的物理内存来容纳这些页面，它们又会被马上交换出去，如此以来，虚拟内存中可能没有足够空间来存储这些交换页面，最终会导致linux出现假死机、服务异常等问题，linux虽然可以在一段时间内自行恢复，但是恢复后的系统已经基本不可用了。</p><p>因此，合理规划和设计linux内存的使用，是非常重要的。</p><p><strong>虚拟内存原理</strong>：</p><p>在系统中运行的每个进程都需要使用到内存，但不是每个进程都需要每时每刻使用系统分配的内存空间。当系统运行所需内存超过实际的物理内存，内核会释放某些进程所占用但未使用的部分或所有物理内存，将这部分资料存储在磁盘上直到进程下一次调用，并将释放出的内存提供给有需要的进程使用。</p><p>在Linux内存管理中，主要是通过”调页Paging”和”交换Swapping”来完成上述的内存调度。调页算法是将内存中最近不常使用的页面换到磁盘上，把活动页面保留在内存中供进程使用。交换技术是将整个进程，而不是部分页面，全部交换到磁盘上。</p><p>分页(Page)写入磁盘的过程被称作Page-Out，分页(Page)从磁盘重新回到内存的过程被称作Page-In。当内核需要一个分页时，但发现此分页不在物理内存中(因为已经被Page-Out了)，此时就发生了分页错误（Page Fault）。</p><p>当系统内核发现可运行内存变少时，就会通过Page-Out来释放一部分物理内存。尽管Page-Out不是经常发生，但是如果Page-out频繁不断的发生，直到当内核管理分页的时间超过运行程式的时间时，系统效能会急剧下降。这时的系统已经运行非常慢或进入暂停状态，这种状态亦被称作<code>thrashing(颠簸)</code>。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vmstat [-a] [-n] [-S unit] [delay [ count]]</span><br><span class="line">vmstat [-s] [-n] [-S unit]</span><br><span class="line">vmstat [-m] [-n] [delay [ count]]</span><br><span class="line">vmstat [-d] [-n] [delay [ count]]</span><br><span class="line">vmstat [-p disk partition] [-n] [delay [ count]]</span><br><span class="line">vmstat [-f]</span><br><span class="line">vmstat [-V]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用来显示虚拟内存的信息.</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-a, 显示活跃和非活跃内存</span><br><span class="line">-f, 显示从系统启动至今的fork数量 。</span><br><span class="line">-m, 显示slabinfo</span><br><span class="line">-n, 只在开始时显示一次各字段名称。</span><br><span class="line">-s, 显示内存相关统计信息及多种系统活动数量。</span><br><span class="line">delay, 刷新时间间隔。如果不指定，只显示一条结果。</span><br><span class="line">count, 刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷。</span><br><span class="line">-d, 显示磁盘相关统计信息。</span><br><span class="line">-p, 显示指定磁盘分区统计信息</span><br><span class="line">-S, 使用指定单位显示。参数有 k 、K 、m 、M ，分别代表1000、1024、1000000、1048576字节（byte）。默认单位为K（1024 bytes）</span><br><span class="line">-V, 显示vmstat版本信息。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示虚拟内存使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# vmstat</span><br><span class="line">procs -----------memory-------------- ---swap-- -----io---- -system-- ------cpu-----</span><br><span class="line"> r  b   swpd     free   buff    cache   si   so    bi    bo   in   cs us sy id wa st</span><br><span class="line"> 1  0      0 35206224     56 10380712    0    0   506   249  951 1483  9  2 84  5  0</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">字段说明：</span><br><span class="line">Procs（进程）：</span><br><span class="line">r: 运行队列中进程数量</span><br><span class="line">b: 等待IO的进程数量</span><br><span class="line"></span><br><span class="line">Memory（内存）：</span><br><span class="line">swpd: 使用虚拟内存大小</span><br><span class="line">free: 可用内存大小</span><br><span class="line">buff: 用作缓冲的内存大小</span><br><span class="line">cache: 用作缓存的内存大小</span><br><span class="line"></span><br><span class="line">Swap：</span><br><span class="line">si: 每秒从交换区写到内存的大小</span><br><span class="line">so: 每秒写入交换区的内存大小</span><br><span class="line">IO：（现在的Linux版本块的大小为1024bytes）</span><br><span class="line">bi: 每秒读取的块数</span><br><span class="line">bo: 每秒写入的块数</span><br><span class="line"></span><br><span class="line">system(系统)：</span><br><span class="line">in: 每秒中断数，包括时钟中断。</span><br><span class="line">cs: 每秒上下文切换数。</span><br><span class="line"></span><br><span class="line">CPU（以百分比表示）：</span><br><span class="line">us: 用户进程执行时间(user time)</span><br><span class="line">sy: 系统进程执行时间(system time)</span><br><span class="line">id: 空闲时间(包括IO等待时间),中央处理器的空闲时间 。以百分比表示。</span><br><span class="line">wa: 等待IO时间</span><br><span class="line"></span><br><span class="line">备注： 如果r经常大于4 ，且id经常少于40，表示cpu的负荷很重。如果pi，po长期不等于0，表示内存不足。如果disk经常不等于0，且在b中的队列大于3，表示io性能不好。Linux在具有高稳定性、可靠性的同时，具有很好的可伸缩性和扩展性，能够针对不同的应用和硬件环境调整，优化出满足当前应用需要的最佳性能。因此企业在维护Linux系统、进行系统调优时，了解系统性能分析工具是至关重要的。</span><br></pre></td></tr></table></figure><p>实例2：表示在5秒时间内进行5次采样。将得到一个数据汇总他能够反映真正的系统情况:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vmstat 5 5</span><br></pre></td></tr></table></figure><p>实例3：显示活跃和非活跃内存:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vmstat -a 2 5</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line">使用-a选项显示活跃和非活跃内存时，所显示的内容除增加inact和active外，其他显示内容与例子1相同。</span><br><span class="line">字段说明：</span><br><span class="line">Memory（内存）：</span><br><span class="line">inact: 非活跃内存大小（当使用-a选项时显示）</span><br><span class="line">active: 活跃的内存大小（当使用-a选项时显示）</span><br></pre></td></tr></table></figure><p>查看系统已经fork了多少次:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这个数据是从/proc/<span class="built_in">stat</span>中的processes字段里取得的</span></span><br><span class="line">vmstat -f</span><br></pre></td></tr></table></figure><p>实例4：查看内存使用的详细信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出的信息分别来自于/proc/meminfo,/proc/<span class="built_in">stat</span>和/proc/vmstat</span></span><br><span class="line">vmstat -s</span><br></pre></td></tr></table></figure><p>实例5：查看磁盘的读/写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这些信息主要来自于/proc/diskstats.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> merged:表示一次来自于合并的写/读请求,一般系统会把多个连接/邻近的读/写请求合并到一起来操作.</span></span><br><span class="line">vmstat -d</span><br></pre></td></tr></table></figure><p>实例6：查看/dev/sda1磁盘的读/写:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vmstat -p /dev/sda1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line">这些信息主要来自于/proc/diskstats。</span><br><span class="line">reads:来自于这个分区的读的次数。</span><br><span class="line">read sectors:来自于这个分区的读扇区的次数。</span><br><span class="line">writes:来自于这个分区的写的次数。</span><br><span class="line">requested writes:来自于这个分区的写请求次数。</span><br></pre></td></tr></table></figure><p>实例7：查看系统的slab信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vmstat -m</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明</span></span><br><span class="line"></span><br><span class="line">这组信息来自于/proc/slabinfo。</span><br><span class="line"></span><br><span class="line">slab:由于内核会有许多小对象，这些对象构造销毁十分频繁，比如i-node，dentry，这些对象如果每次构建的时候就向内存要一个页(4kb)，而其实只有几个字节，这样就会非常浪费，为了解决这个问题，就引入了一种新的机制来处理在同一个页框中如何分配小存储区，而slab可以对小对象进行分配,这样就不用为每一个对象分配页框，从而节省了空间，内核对一些小对象创建析构很频繁，slab对这些小对象进行缓冲,可以重复利用,减少内存分配次数。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 性能监控和优化命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-top命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-top%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-top%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;top命令是Linux下常用的<strong>性能分析工具</strong>，能够实时显示系统中各个进程的资源占用状况，类似于Windows的任务管理器。下面详细介绍它的使用方法。top是一个动态显示过程,即可以通过用户按键来不断刷新当前状态.如果在前台执行该命令,它将独占前台,直到用户终止该程序为止.比较准确的说,top命令提供了实时的对系统处理器的状态监视.它将显示系统中CPU最“敏感”的任务列表.该命令可以按CPU使用.内存使用和执行时间对任务进行排序；而且该命令的很多特性都可以通过交互式命令或者在个人定制文件中进行设定.</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top [参数]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;显示当前系统正在执行的进程的相关信息，包括进程ID、内存占用率、CPU占用率等</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b, 批处理</span><br><span class="line">-c, 显示完整的治命令</span><br><span class="line">-I, 忽略失效过程</span><br><span class="line">-s, 保密模式</span><br><span class="line">-S, 累积模式</span><br><span class="line">-i&lt;时间&gt;, 设置间隔时间</span><br><span class="line">-u&lt;用户名&gt;, 指定用户名</span><br><span class="line">-p&lt;进程号&gt;, 指定进程</span><br><span class="line">-n&lt;次数&gt;, 循环显示的次数</span><br></pre></td></tr></table></figure><h3 id="4-top交互命令"><a href="#4-top交互命令" class="headerlink" title="4.top交互命令"></a>4.top交互命令</h3><p>在top命令执行过程中可以使用的一些交互命令。这些命令都是单字母的，如果在命令行中使用了s选项，其中一些命令可能会被屏蔽。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">h, 显示帮助画面，给出一些简短的命令总结说明</span><br><span class="line">k, 终止一个进程。</span><br><span class="line">i, 忽略闲置和僵死进程。这是一个开关式命令。</span><br><span class="line">q, 退出程序</span><br><span class="line">r, 重新安排一个进程的优先级别</span><br><span class="line">S, 切换到累计模式</span><br><span class="line">s, 改变两次刷新之间的延迟时间（单位为s），如果有小数，就换算成m s。输入0值则系统将不断刷新，默认值是5 s</span><br><span class="line">f或者F, 从当前显示中添加或者删除项目</span><br><span class="line">o或者O, 改变显示项目的顺序</span><br><span class="line">l, 切换显示平均负载和启动时间信息</span><br><span class="line">m, 切换显示内存信息</span><br><span class="line">t, 切换显示进程和CPU状态信息</span><br><span class="line">c, 切换显示命令名称和完整命令行</span><br><span class="line">M, 根据驻留内存大小进行排序</span><br><span class="line">P, 根据CPU使用百分比大小进行排序</span><br><span class="line">T, 根据时间/累计时间进行排序</span><br><span class="line">W, 将当前设置写入~/.toprc文件中 </span><br></pre></td></tr></table></figure><h3 id="5．使用实例："><a href="#5．使用实例：" class="headerlink" title="5．使用实例："></a>5．使用实例：</h3><p>实例1：显示进程信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">top</span><br></pre></td></tr></table></figure><p>输出信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">top - 15:12:01 up 71 days,  6:24,  1 user,  load average: 4.11, 4.96, 5.00</span><br><span class="line">Tasks: 255 total,   1 running, 254 sleeping,   0 stopped,   0 zombie</span><br><span class="line">Cpu(s):  3.9%us,  0.9%sy,  0.0%ni, 83.7%id, 11.4%wa,  0.0%hi,  0.0%si,  0.0%st</span><br><span class="line">Mem:  16158120k total, 15495920k used,   662200k free,     5860k buffers</span><br><span class="line">Swap:  8232956k total,  2091284k used,  6141672k free,  3661840k cached</span><br><span class="line"></span><br><span class="line">  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND</span><br><span class="line">31556 lxy       20   0 15.5g 4.0g 2904 S 61.3 25.8 920:38.38 java </span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">统计信息区：</span><br><span class="line">前五行是当前系统情况整体的统计信息区。下面我们看每一行信息的具体意义。</span><br><span class="line"></span><br><span class="line">第一行，任务队列信息，同uptime命令的执行结果，具体参数说明情况如下：</span><br><span class="line">15:12:01 — 当前系统时间</span><br><span class="line">up 71 days, 6:24 — 系统已经运行了71天6小时24分钟（在这期间系统没有重启过的吆！）</span><br><span class="line">1 users — 当前有1个用户登录系统</span><br><span class="line">load average: 4.11, 4.96, 5.00 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</span><br><span class="line">load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</span><br><span class="line"></span><br><span class="line">第二行，Tasks — 任务(进程)，具体信息说明如下：</span><br><span class="line">系统现在共有255个进程，其中处于运行中的有1个，254个在休眠(sleep)，stoped状态的有0个，zombie状态(僵尸)的有0个。</span><br><span class="line"></span><br><span class="line">第三行，cpu状态信息，具体属性说明如下：</span><br><span class="line">3.9%us — 用户空间占用CPU的百分比。</span><br><span class="line">0.9%sy — 内核空间占用CPU的百分比。</span><br><span class="line">0.0%ni — 改变过优先级的进程占用CPU的百分比</span><br><span class="line">83.7%id — 空闲CPU的百分比</span><br><span class="line">11.4%wa — IO等待占用CPU的百分比</span><br><span class="line">0.0%hi — 硬中断(Hardware IRQ)占用CPU的百分比</span><br><span class="line">0.0%si — 软中断(Software Interrupts)占用CPU的百分比</span><br><span class="line">0.0%st — 虚拟机(虚拟化技术)占用CPU的百分比</span><br><span class="line"></span><br><span class="line">备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</span><br><span class="line"></span><br><span class="line">第四行,内存状态，具体信息如下：</span><br><span class="line">16158120k total — 物理内存总量（15.4GB）</span><br><span class="line">15495920k used — 使用中的内存总量（14.7GB）</span><br><span class="line">662200k free — 空闲内存总量（0.63GB）</span><br><span class="line">5860k buffers — 缓存的内存量 （5.7M）</span><br><span class="line"></span><br><span class="line">第五行，swap交换分区信息，具体信息说明如下：</span><br><span class="line">8232956k total — 交换区总量（7.85GB）</span><br><span class="line">2091284k used — 使用的交换区总量（1.99GB）</span><br><span class="line">6141672k free — 空闲交换区总量（5.86GB）</span><br><span class="line">3661840k cached — 缓冲的交换区总量（3.49GB）</span><br><span class="line"></span><br><span class="line">备注：</span><br><span class="line">第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，空闲内存总量（free）是内核还未纳入其管控范围的数量。纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。</span><br><span class="line"></span><br><span class="line">如果出于习惯去计算可用内存数，这里有个近似的计算公式：第四行的free+第四行的buffers+ 第五行的cached，按这个公式此台服务器的可用内存：662200k + 5860k + 3661840k = 4.13GB左右。</span><br><span class="line"></span><br><span class="line">对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。</span><br><span class="line"></span><br><span class="line">第六行，空行。</span><br><span class="line"></span><br><span class="line">第七行以下：各进程（任务）的状态监控，项目列信息说明如下：</span><br><span class="line">PID — 进程id</span><br><span class="line">USER — 进程所有者</span><br><span class="line">PR — 进程优先级</span><br><span class="line">NI — nice值。负值表示高优先级，正值表示低优先级</span><br><span class="line">VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES</span><br><span class="line">RES(程序当前占用的内存) — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA</span><br><span class="line">SHR — 共享内存大小，单位kb</span><br><span class="line">S — 进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程</span><br><span class="line">%CPU(程序当前占用程序的逻辑单核的百分比) — 上次更新到现在的CPU时间占用百分比</span><br><span class="line">%MEM — 进程使用的物理内存百分比</span><br><span class="line">TIME+ — 进程使用的CPU时间总计，单位1/100秒</span><br><span class="line">COMMAND — 进程名称（命令名/命令行）</span><br></pre></td></tr></table></figure><h3 id="6-其他使用技巧："><a href="#6-其他使用技巧：" class="headerlink" title="6.其他使用技巧："></a>6.其他使用技巧：</h3><h4 id="1-多U多核CPU监控"><a href="#1-多U多核CPU监控" class="headerlink" title="1.多U多核CPU监控"></a>1.多U多核CPU监控</h4><p>在top基本视图中，按键盘数字“1”，可监控每个逻辑CPU的状况：</p><h4 id="2-高亮显示当前运行进程"><a href="#2-高亮显示当前运行进程" class="headerlink" title="2.高亮显示当前运行进程"></a>2.高亮显示当前运行进程</h4><p>敲击键盘“b”（打开/关闭加亮效果），top的视图变化如下：<br>top进程就是视图第二行显示的唯一的运行态（runing）的那个进程，可以通过敲击“y”键关闭或打开运行态进程的加亮效果。</p><h4 id="3-进程字段排序"><a href="#3-进程字段排序" class="headerlink" title="3.进程字段排序"></a>3.进程字段排序</h4><p>默认进入top时，各进程是按照<strong>CPU的占用量</strong>来排序的，在下图中进程ID为31556的java进程排在第一（cpu占用61.3%），进程ID为5174的java进程排在第二（cpu占用16%）。</p><p>敲击键盘“x”（打开/关闭排序列的加亮效果）</p><p>top默认的排序列是“%CPU”。</p><h4 id="4-通过”shift-gt-”或”shift-lt-”可以向右或左改变排序列"><a href="#4-通过”shift-gt-”或”shift-lt-”可以向右或左改变排序列" class="headerlink" title="4.通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列"></a>4.通过”shift + &gt;”或”shift + &lt;”可以向右或左改变排序列</h4><h4 id="5-显示完整命令-top-c"><a href="#5-显示完整命令-top-c" class="headerlink" title="5.显示完整命令:top -c"></a>5.显示完整命令:top -c</h4><h4 id="6-以批处理模式显示程序信息-top-b"><a href="#6-以批处理模式显示程序信息-top-b" class="headerlink" title="6.以批处理模式显示程序信息:top -b"></a>6.以批处理模式显示程序信息:top -b</h4><h4 id="7-以累积模式显示程序信息-top-S"><a href="#7-以累积模式显示程序信息-top-S" class="headerlink" title="7.以累积模式显示程序信息:top -S"></a>7.以累积模式显示程序信息:top -S</h4><h4 id="8-设置信息循环更新次数-top-n-2"><a href="#8-设置信息循环更新次数-top-n-2" class="headerlink" title="8.设置信息循环更新次数:top -n 2"></a>8.设置信息循环更新次数:top -n 2</h4><p>表示更新两次后终止更新显示</p><h4 id="9-设置信息更新时间：top-d-3"><a href="#9-设置信息更新时间：top-d-3" class="headerlink" title="9.设置信息更新时间：top -d 3"></a>9.设置信息更新时间：top -d 3</h4><p>表示更新周期为3秒</p><h4 id="10-显示指定的进程信息：top-p-574"><a href="#10-显示指定的进程信息：top-p-574" class="headerlink" title="10.显示指定的进程信息：top -p 574"></a>10.显示指定的进程信息：top -p 574</h4><p>表示仅显示pid为574的进程信息</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 性能监控和优化命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-lsof命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-lsof%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-lsof%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;lsof（list open files）是一个列出<strong>当前系统打开文件</strong>的工具。在linux环境下，任何事物都以<strong>文件</strong>的形式存在，通过文件不仅仅可以访问常规数据，还可以访问网络连接和硬件。所以如传输控制协议 (TCP) 和用户数据报协议 (UDP) 套接字等，系统在后台都为该应用程序分配了一个文件描述符，无论这个文件的本质如何，该文件描述符为应用程序与基础操作系统之间的交互提供了通用接口。因为应用程序打开文件的描述符列表提供了大量关于这个应用程序本身的信息，因此通过lsof工具能够查看这个列表对系统监测以及排错将是很有帮助的。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof [参数] [文件]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用于查看你进程打开的文件，打开文件的进程，进程打开的端口(TCP、UDP)。找回/恢复删除的文件。是十分方便的系统监视工具，因为lsof需要访问核心内存和各种文件，所以需要<strong>root</strong>用户执行。</p><p>lsof打开的文件可以是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1.普通文件</span><br><span class="line">2.目录</span><br><span class="line">3.网络文件系统的文件</span><br><span class="line">4.字符或设备文件</span><br><span class="line">5.(函数)共享库</span><br><span class="line">6.管道，命名管道</span><br><span class="line">7.符号链接</span><br><span class="line">8.网络文件（例如：NFS file、网络socket，unix域名socket）</span><br><span class="line">9.还有其它类型的文件，等等</span><br></pre></td></tr></table></figure><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-a, 列出打开文件存在的进程</span><br><span class="line">-c&lt;进程名&gt;, 列出指定进程所打开的文件</span><br><span class="line">-g, 列出GID号进程详情</span><br><span class="line">-d&lt;文件号&gt;, 列出占用该文件号的进程</span><br><span class="line">+d&lt;目录&gt;, 列出目录下被打开的文件</span><br><span class="line">+D&lt;目录&gt;, 递归列出目录下被打开的文件</span><br><span class="line">-n&lt;目录&gt;, 列出使用NFS的文件</span><br><span class="line">-i&lt;条件&gt;, 列出符合条件的进程。（4、6、协议、:端口、 @ip ）</span><br><span class="line">-p&lt;进程号&gt;, 列出指定进程号所打开的文件</span><br><span class="line">-u, 列出UID号进程详情</span><br><span class="line">-h, 显示帮助信息</span><br><span class="line">-v, 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：无任何参数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[lxy@localhost log]$ lsof</span><br><span class="line">COMMAND     PID      USER   FD      TYPE             DEVICE    SIZE/OFF       NODE NAME</span><br><span class="line">init          1      root  cwd       DIR              252,0        4096          2 /</span><br><span class="line">init          1      root  rtd       DIR              252,0        4096          2 /</span><br><span class="line">init          1      root  txt       REG              252,0      150352    2103120 /sbin/init</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">lsof输出各列信息的意义如下：</span><br><span class="line">COMMAND：进程的名称</span><br><span class="line">PID：进程标识符</span><br><span class="line">PPID：父进程标识符（需要指定-R参数）</span><br><span class="line">USER：进程所有者</span><br><span class="line">PGID：进程所属组</span><br><span class="line">FD：文件描述符，应用程序通过文件描述符识别该文件。如cwd、txt等</span><br><span class="line">（1）cwd：表示current work dirctory，即：应用程序的当前工作目录，这是该应用程序启动的目录，除非它本身对这个目录进行更改</span><br><span class="line">（2）txt ：该类型的文件是程序代码，如应用程序二进制文件本身或共享库，如上列表中显示的 /sbin/init 程序</span><br><span class="line">（3）lnn：library references (AIX);</span><br><span class="line">（4）er：FD information error (see NAME column);</span><br><span class="line">（5）jld：jail directory (FreeBSD);</span><br><span class="line">（6）ltx：shared library text (code and data);</span><br><span class="line">（7）mxx ：hex memory-mapped type number xx.</span><br><span class="line">（8）m86：DOS Merge mapped file;</span><br><span class="line">（9）mem：memory-mapped file;</span><br><span class="line">（10）mmap：memory-mapped device;</span><br><span class="line">（11）pd：parent directory;</span><br><span class="line">（12）rtd：root directory;</span><br><span class="line">（13）tr：kernel trace file (OpenBSD);</span><br><span class="line">（14）v86  VP/ix mapped file;</span><br><span class="line">（15）0：表示标准输出</span><br><span class="line">（16）1：表示标准输入</span><br><span class="line">（17）2：表示标准错误</span><br><span class="line"></span><br><span class="line">一般在标准输出、标准错误、标准输入后还跟着文件状态模式：r、w、u等</span><br><span class="line">（1）u：表示该文件被打开并处于读取/写入模式</span><br><span class="line">（2）r：表示该文件被打开并处于只读模式</span><br><span class="line">（3）w：表示该文件被打开并处于</span><br><span class="line">（4）空格：表示该文件的状态模式为unknow，且没有锁定</span><br><span class="line">（5）-：表示该文件的状态模式为unknow，且被锁定</span><br><span class="line"></span><br><span class="line">同时在文件状态模式后面，还跟着相关的锁</span><br><span class="line">（1）N：for a Solaris NFS lock of unknown type;</span><br><span class="line">（2）r：for read lock on part of the file;</span><br><span class="line">（3）R：for a read lock on the entire file;</span><br><span class="line">（4）w：for a write lock on part of the file;（文件的部分写锁）</span><br><span class="line">（5）W：for a write lock on the entire file;（整个文件的写锁）</span><br><span class="line">（6）u：for a read and write lock of any length;</span><br><span class="line">（7）U：for a lock of unknown type;</span><br><span class="line">（8）x：for an SCO OpenServer Xenix lock on part of the file;</span><br><span class="line">（9）X：for an SCO OpenServer Xenix lock on the entire file;</span><br><span class="line">（10）space：if there is no lock.</span><br><span class="line"></span><br><span class="line">TYPE：文件类型，如DIR、REG等，常见的文件类型</span><br><span class="line">（1）DIR：表示目录</span><br><span class="line">（2）CHR：表示字符类型</span><br><span class="line">（3）BLK：块设备类型</span><br><span class="line">（4）UNIX： UNIX 域套接字</span><br><span class="line">（5）FIFO：先进先出 (FIFO) 队列</span><br><span class="line">（6）IPv4：网际协议 (IP) 套接字</span><br><span class="line">DEVICE：指定磁盘的名称</span><br><span class="line">SIZE：文件的大小</span><br><span class="line">NODE：索引节点（文件在磁盘上的标识）</span><br><span class="line">NAME：打开文件的确切名称</span><br></pre></td></tr></table></figure><p>实例2：查看谁正在使用某个文件，也就是说查找某个文件相关的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof /bin/bash</span><br></pre></td></tr></table></figure><p>实例3：递归查看某个目录的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof test/test3</span><br></pre></td></tr></table></figure><p>实例5：列出某个用户打开的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -u 选项，u其实是user的缩写</span></span><br><span class="line">lsof -u username</span><br></pre></td></tr></table></figure><p>实例6：列出某个程序进程所打开的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -c 选项将会列出所有以mysql这个进程开头的程序的文件，其实你也可以写成 lsof | grep mysql, 但是第一种方法明显比第二种方法要少打几个字符了</span></span><br><span class="line">lsof -c mysql</span><br></pre></td></tr></table></figure><p>实例7：列出多个进程多个打开的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -c mysql -c apache</span><br></pre></td></tr></table></figure><p>实例8：列出某个用户以及某个进程所打开的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 用户与进程可相关，也可以不相关</span></span><br><span class="line">lsof  -u test -c mysql </span><br></pre></td></tr></table></figure><p>实例9：列出除了某个用户外的被打开的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ^这个符号在用户名之前，将会把是root用户打开的进程不让显示</span></span><br><span class="line">lsof -u ^root</span><br></pre></td></tr></table></figure><p>实例10：通过某个进程号显示该进行打开的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p 1</span><br></pre></td></tr></table></figure><p>实例11：列出多个进程号对应的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p 1,2,3</span><br></pre></td></tr></table></figure><p>实例12：列出<strong>除了</strong>某个进程号，其他进程号所打开的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -p ^1</span><br></pre></td></tr></table></figure><p>实例13：列出所有的网络连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i</span><br></pre></td></tr></table></figure><p>实例14：列出所有tcp 网络连接信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp</span><br></pre></td></tr></table></figure><p>实例15：列出所有udp网络连接信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i udp</span><br></pre></td></tr></table></figure><p>实例16：列出谁在使用某个端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:3306</span><br></pre></td></tr></table></figure><p>实例17：列出谁在使用某个特定的udp端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i udp:55</span><br></pre></td></tr></table></figure><p>或者：特定的tcp端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i tcp:80</span><br></pre></td></tr></table></figure><p>实例18：列出某个用户的所有活跃的网络端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -a -u test -i</span><br></pre></td></tr></table></figure><p>实例19：列出所有网络文件系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -N</span><br></pre></td></tr></table></figure><p>实例20：域名socket文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -u</span><br></pre></td></tr></table></figure><p>实例21：某个用户组所打开的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -g 5555</span><br></pre></td></tr></table></figure><p>实例22：根据文件描述列出对应的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">lsof -d description(like 2)</span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：lsof -d txt</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：lsof -d 1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 例如：lsof -d 2</span></span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0表示标准输入，1表示标准输出，2表示标准错误，从而可知：所以大多数应用程序所打开的文件的 FD 都是从 3 开始</span><br></pre></td></tr></table></figure><p>实例23：根据文件描述范围列出文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -d 2-3</span><br></pre></td></tr></table></figure><p>实例24：列出COMMAND列中包含字符串”sshd”，且文件描符的类型为txt的文件信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -c sshd -a -d txt</span><br></pre></td></tr></table></figure><p>实例25：列出被进程号为1234的进程所打开的所有IPV4 network files </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i 4 -a -p 1234</span><br></pre></td></tr></table></figure><p>实例26：列出目前连接主机peida.linux上端口为：20，21，22，25，53，80相关的所有文件信息，且每隔3秒不断的执行lsof指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i @peida.linux:20,21,22,25,53,80  -r  3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 性能监控和优化命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-iostat命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-iostat%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-iostat%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux系统中的<code>iostat</code>是<code>I/O statistics</code>（输入/输出统计）的缩写，iostat工具将对系统的磁盘操作活动进行监视。它的特点是汇报磁盘活动统计情况，同时也会汇报出CPU使用情况。同vmstat一样，iostat也有一个弱点，就是它不能对某个进程进行深入分析，仅对系统的整体情况进行分析。<code>iostat</code>属于<code>sysstat软件包</code>。可以用<code>yum install sysstat</code>直接安装。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat [参数] [时间] [次数]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;通过iostat方便查看CPU、网卡、tty设备、磁盘、CD-ROM 等等设备的活动情况, 负载信息。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-C, 显示CPU使用情况</span><br><span class="line">-d, 显示磁盘使用情况</span><br><span class="line">-k, 以 KB 为单位显示</span><br><span class="line">-m, 以 M 为单位显示</span><br><span class="line">-N, 显示磁盘阵列(LVM) 信息</span><br><span class="line">-n, 显示NFS 使用情况</span><br><span class="line">-p[磁盘], 显示磁盘和分区的情况</span><br><span class="line">-t, 显示终端和CPU的信息</span><br><span class="line">-x, 显示详细信息</span><br><span class="line">-V, 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示所有设备负载情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[alarm@localhost log]$ iostat</span><br><span class="line">Linux 3.8.13-68.3.4.el6uek.x86_64 (localhost) 12/13/2019 _x86_64_(16 CPU)</span><br><span class="line"></span><br><span class="line">avg-cpu:  %user   %nice %system %iowait  %steal   %idle</span><br><span class="line">           5.31    0.00    0.51    3.93    0.00   90.25</span><br><span class="line"></span><br><span class="line">Device:            tps   Blk_read/s   Blk_wrtn/s   Blk_read   Blk_wrtn</span><br><span class="line">sda             125.02      1904.20     14948.80 11852743135 93048985376</span><br><span class="line">dm-0            141.48      1814.09     14929.46 11291824530 92928658968</span><br><span class="line">dm-1             13.68        90.11        19.34  560883552  120378072</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">cpu属性值说明：</span><br><span class="line">%user：CPU处在用户模式下的时间百分比。</span><br><span class="line">%nice：CPU处在带NICE值的用户模式下的时间百分比。</span><br><span class="line">%system：CPU处在系统模式下的时间百分比。</span><br><span class="line">%iowait：CPU等待输入输出完成时间的百分比。</span><br><span class="line">%steal：管理程序维护另一个虚拟处理器时，虚拟CPU的无意识等待时间百分比。</span><br><span class="line">%idle：CPU空闲时间百分比。</span><br><span class="line">备注：如果%iowait的值过高，表示硬盘存在I/O瓶颈，%idle值高，表示CPU较空闲，如果%idle值高但系统响应慢时，有可能是CPU等待分配内存，此时应加大内存容量。%idle值如果持续低于10，那么系统的CPU处理能力相对较低，表明系统中最需要解决的资源是CPU。</span><br><span class="line"></span><br><span class="line">disk属性值说明：</span><br><span class="line">rrqm/s:  每秒进行 merge 的读操作数目。即 rmerge/s</span><br><span class="line">wrqm/s:  每秒进行 merge 的写操作数目。即 wmerge/s</span><br><span class="line">r/s:  每秒完成的读 I/O 设备次数。即 rio/s</span><br><span class="line">w/s:  每秒完成的写 I/O 设备次数。即 wio/s</span><br><span class="line">rsec/s:  每秒读扇区数。即 rsect/s</span><br><span class="line">wsec/s:  每秒写扇区数。即 wsect/s</span><br><span class="line">rkB/s:  每秒读K字节数。是 rsect/s 的一半，因为每扇区大小为512字节。</span><br><span class="line">wkB/s:  每秒写K字节数。是 wsect/s 的一半。</span><br><span class="line">avgrq-sz:  平均每次设备I/O操作的数据大小 (扇区)。</span><br><span class="line">avgqu-sz:  平均I/O队列长度。</span><br><span class="line">await:  平均每次设备I/O操作的等待时间 (毫秒)。</span><br><span class="line">svctm: 平均每次设备I/O操作的服务时间 (毫秒)。</span><br><span class="line">%util:  一秒中有百分之多少的时间用于 I/O 操作，即被io消耗的cpu百分比</span><br><span class="line">备注：如果 %util 接近 100%，说明产生的I/O请求太多，I/O系统已经满负荷，该磁盘可能存在瓶颈。如果 svctm 比较接近 await，说明 I/O 几乎没有等待时间；如果 await 远大于 svctm，说明I/O 队列太长，io响应太慢，则需要进行必要优化。如果avgqu-sz比较大，也表示有当量io在等待。</span><br></pre></td></tr></table></figure><p>实例2：定时显示所有信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每隔2秒刷新显示，且显示3次</span></span><br><span class="line">iostat 2 3</span><br></pre></td></tr></table></figure><p>实例3：显示指定磁盘信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d sda1</span><br></pre></td></tr></table></figure><p>实例4：显示tty和Cpu信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -t</span><br></pre></td></tr></table></figure><p>实例5：以M为单位显示所有信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -m</span><br></pre></td></tr></table></figure><p>实例6：查看TPS和吞吐量信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -d -k 1 1</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[alarm@localhost log]$ iostat -d -k 1 1</span><br><span class="line">Linux 3.8.13-68.3.4.el6uek.x86_64 (localhost) 12/13/2019 _x86_64_(16 CPU)</span><br><span class="line"></span><br><span class="line">Device:            tps    kB_read/s    kB_wrtn/s    kB_read    kB_wrtn</span><br><span class="line">sda             125.06       952.21      7477.47 5927533391 46547573904</span><br><span class="line">dm-0            141.52       907.15      7467.81 5647074089 46487398540</span><br><span class="line">dm-1             13.68        45.05         9.67  280441776   60189036</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tps：该设备每秒的传输次数（Indicate the number of transfers per second that were issued to the device.）。“一次传输”意思是“一次I/O请求”。多个逻辑请求可能会被合并为“一次I/O请求”。“一次传输”请求的大小是未知的。</span><br><span class="line">kB_read/s：每秒从设备（drive expressed）读取的数据量；</span><br><span class="line">kB_wrtn/s：每秒向设备（drive expressed）写入的数据量；</span><br><span class="line">kB_read：读取的总数据量；kB_wrtn：写入的总数量数据量；</span><br><span class="line">这些单位都为Kilobytes。</span><br><span class="line">上面的例子中，我们可以看到磁盘sda以及它的各个分区的统计数据，当时统计的磁盘总TPS是125.06，下面是各个分区的TPS。（因为是瞬间值，所以总TPS并不严格等于各个分区TPS的总和）</span><br></pre></td></tr></table></figure><p>实例7：查看cpu状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">iostat -c 1 3</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 性能监控和优化命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-free命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-free%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E5%92%8C%E4%BC%98%E5%8C%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-free%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;free命令可以显示Linux系统中空闲的、已用的物理内存及swap内存,及被内核使用的buffer。在Linux系统监控的工具中，free命令是最经常使用的命令之一。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free [参数]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;free命令显示系统使用和空闲的内存情况，包括物理内存、交互区内存(swap)和内核缓冲区内存。共享内存将被忽略</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-b, 以Byte为单位显示内存使用情况。 </span><br><span class="line">-k, 以KB为单位显示内存使用情况。 </span><br><span class="line">-m, 以MB为单位显示内存使用情况。</span><br><span class="line">-g,  以GB为单位显示内存使用情况。 </span><br><span class="line">-o, 不显示缓冲区调节列。 </span><br><span class="line">-s&lt;间隔秒数&gt;, 持续观察内存使用状况。 </span><br><span class="line">-t, 显示内存总和列。 </span><br><span class="line">-V, 显示版本信息。 </span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示内存使用情况:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@spxn61 bin]# free -h</span><br><span class="line">        total      used      free    shared  buff/cache   available</span><br><span class="line">Mem:      31G      931M       26G      8.9M        3.8G         27G</span><br><span class="line">Swap:      0B        0B        0B</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">下面是对这些数值的解释：</span><br><span class="line">total:总计物理内存的大小。</span><br><span class="line">used:已使用多大。</span><br><span class="line">free:可用有多少。</span><br><span class="line">shared:多个进程共享的内存总额。</span><br><span class="line">buffer/cache:磁盘缓存的大小。</span><br><span class="line">available:还可以被应用程序使用的物理内存大小</span><br><span class="line"></span><br><span class="line">available = free + buffer + cache。请注意，这只是一个很理想的计算方式，实际中的数据往往有较大的误差。</span><br><span class="line"></span><br><span class="line">第三行是交换分区SWAP的，也就是我们通常所说的虚拟内存。</span><br></pre></td></tr></table></figure><p>实例2：以总和的形式显示内存的使用信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -t </span><br></pre></td></tr></table></figure><p>实例3：周期性的查询内存使用信息(每10s执行一次命令):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">free -s 10</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 性能监控和优化命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-vim命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-vim%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-vim%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<code>Vim</code>是从<code>vi</code>发展出来的一个<strong>文本编辑器</strong>。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。</p><p>&emsp;简单的来说，<code>vi</code>是老式的字处理器，不过功能已经很齐全了，但是还是有可以进步的地方。<code>vim</code>则可以说是程序开发者的一项很好用的工具。</p><p>&emsp;连<code>vim</code>的<a href="http://www.vim.org/">官方网站</a> 自己也说<code>vim</code>是一个程序开发工具而不是文字处理软件。</p><p>&emsp;安装vim:<code>yum install vim</code></p><p>vim键盘图：<br><img src="https://i.loli.net/2021/04/28/C3g2pABm9LqQ7cH.gif" alt="vim键盘图.png"><br><img src="https://i.loli.net/2021/04/28/u2UzQve7yCNX9fD.png" alt="vim键盘图详细版.png"></p><h3 id="vi-vim的使用"><a href="#vi-vim的使用" class="headerlink" title="vi/vim的使用"></a>vi/vim的使用</h3><p>基本上<code>vi/vim</code>共分为三种模式，分别是<code>命令模式</code>（Command mode），<code>输入模式</code>（Insert mode）和<code>底线命令模式</code>（Last line mode）。</p><p>这三种模式的作用分别是：</p><h4 id="命令模式："><a href="#命令模式：" class="headerlink" title="命令模式："></a>命令模式：</h4><p>用户刚刚启动<code>vi/vim</code>，便进入了命令模式。</p><p>此状态下<em>敲击键盘</em>动作会被Vim识别为<em>命令</em>，而非输入字符。比如我们此时按下i，并不会输入一个字符，i被当作了一个命令。</p><p>以下是常用的几个命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">i, 切换到输入模式，以输入字符。</span><br><span class="line">x, 删除当前光标所在处的字符。</span><br><span class="line">:, 切换到底线命令模式，以在最底一行输入命令。</span><br></pre></td></tr></table></figure><p>若想要编辑文本：启动Vim，进入了命令模式，按下<code>i</code>，切换到输入模式。</p><p>命令模式只有一些最基本的命令，因此仍要依靠底线命令模式输入更多命令。</p><h4 id="输入模式："><a href="#输入模式：" class="headerlink" title="输入模式："></a>输入模式：</h4><p>在命令模式下按下<code>i</code>、<code>a</code>、<code>o</code>就进入了输入模式。</p><p>在输入模式中，可以使用以下按键：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">字符按键以及Shift组合，输入字符</span><br><span class="line">ENTER, 回车键、换行</span><br><span class="line">BACK SPACE, 退格键删除光标前一个字符</span><br><span class="line">DEL, 删除键，删除光标后一个字符</span><br><span class="line">方向键, 在文本中移动光标</span><br><span class="line">HOME/END, 移动光标到行首/行尾</span><br><span class="line">Page Up/Page Down, 上/下翻页</span><br><span class="line">Insert, 切换光标为输入/替换模式，光标将变成竖线/下划线</span><br><span class="line">ESC, 退出输入模式，切换到命令模式</span><br></pre></td></tr></table></figure><h4 id="底线命令模式："><a href="#底线命令模式：" class="headerlink" title="底线命令模式："></a>底线命令模式：</h4><p>在命令模式下按下<code>:</code>（英文冒号）就进入了底线命令模式。</p><p>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。</p><p>在底线命令模式中，基本的命令有（已经省略了冒号）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q, 退出程序</span><br><span class="line">w, 保存文件</span><br></pre></td></tr></table></figure><p>按<code>ESC</code>键可随时退出底线命令模式。</p><h3 id="vi-vim-按键说明："><a href="#vi-vim-按键说明：" class="headerlink" title="vi/vim 按键说明："></a>vi/vim 按键说明：</h3><h4 id="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"><a href="#第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等" class="headerlink" title="第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等"></a>第一部分：一般模式可用的光标移动、复制粘贴、搜索替换等</h4><p>移动光标的方法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">h 或 向左箭头键(←), 光标向左移动一个字符</span><br><span class="line">j 或 向下箭头键(↓), 光标向下移动一个字符</span><br><span class="line">k 或 向上箭头键(↑), 光标向上移动一个字符</span><br><span class="line">l 或 向右箭头键(→),光标向右移动一个字符</span><br><span class="line">[Ctrl] + [f], 屏幕『向下』移动一页，相当于 [Page Down]按键 (常用)</span><br><span class="line">[Ctrl] + [b], 屏幕『向上』移动一页，相当于 [Page Up] 按键 (常用)</span><br><span class="line">[Ctrl] + [d], 屏幕『向下』移动半页</span><br><span class="line">[Ctrl] + [u], 屏幕『向上』移动半页</span><br><span class="line">+, 光标移动到非空格符的下一行</span><br><span class="line">-, 光标移动到非空格符的上一行</span><br><span class="line">n&lt;space&gt;, 那个n表示『数字』，例如20。按下数字后再按空格键，光标会向右移动这一行的n个字符。例如20&lt;space&gt;则光标会向后面移动20个字符距离。</span><br><span class="line">0 或功能键[Home], 这是数字『 0 』：移动到这一行的最前面字符处 (常用)</span><br><span class="line">$ 或功能键[End], 移动到这一行的最后面字符处(常用)</span><br><span class="line">H, 光标移动到这个屏幕的最上方那一行的第一个字符</span><br><span class="line">M, 光标移动到这个屏幕的中央那一行的第一个字符</span><br><span class="line">L, 光标移动到这个屏幕的最下方那一行的第一个字符</span><br><span class="line">G, 移动到这个档案的最后一行(常用)</span><br><span class="line">nG, n为数字。移动到这个档案的第n行。例如20G则会移动到这个档案的第20行(可配合 :set nu)</span><br><span class="line">gg, 移动到这个档案的第一行，相当于1G(常用)</span><br><span class="line">n&lt;Enter&gt;, n为数字。光标向下移动n行(常用)</span><br></pre></td></tr></table></figure><p>搜索替换:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/word, 向光标之下寻找一个名称为word的字符串。(常用)</span><br><span class="line">?word, 向光标之上寻找一个名称为word的字符串。</span><br><span class="line">n, 这个n是英文按键。代表重复前一个搜寻的动作。</span><br><span class="line">N, 这个N是英文按键。与n刚好相反，为『反向』进行前一个搜寻动作。</span><br><span class="line">:n1,n2s/word1/word2/g, n1与n2为数字。在第n1与n2行之间寻找word1这个字符串，并将该字符串取代为word2！举例来说，在100到200行之间搜寻vbird并取代为VBIRD则：</span><br><span class="line">『:100,200s/vbird/VBIRD/g』。(常用)</span><br><span class="line">:1,$s/word1/word2/g 或 :%s/word1/word2/g, 从第一行到最后一行寻找word1字符串，并将该字符串取代为word2！(常用)</span><br><span class="line">:1,$s/word1/word2/gc 或 :%s/word1/word2/gc, 从第一行到最后一行寻找word1字符串，并将该字符串取代为word2！且在取代前显示提示字符给用户确认(confirm)是否需要取代！(常用)</span><br></pre></td></tr></table></figure><p>删除、复制与贴上:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">x和X, 在一行字当中，x为向后删除一个字符(相当于[del]按键)，X为向前删除一个字符(相当于[backspace]亦即是退格键) (常用)</span><br><span class="line">nx, n为数字，连续向后删除n个字符。举例来说，我要连续删除10个字符，『10x』。</span><br><span class="line">dd, 删除游标所在的那一整行(常用)</span><br><span class="line">ndd, n为数字。删除光标所在的向下n行，例如20dd则是删除20行(常用)</span><br><span class="line">d1G, 删除光标所在到第一行的所有数据</span><br><span class="line">dG, 删除光标所在到最后一行的所有数据</span><br><span class="line">d$,删除游标所在处，到该行的最后一个字符</span><br><span class="line">d0,那个是数字0，删除游标所在处，到该行的最前面一个字符</span><br><span class="line">yy, 复制游标所在的那一行(常用)</span><br><span class="line">nyy, n为数字。复制光标所在的向下n行，例如20yy则是复制20行(常用)</span><br><span class="line">y1G, 复制游标所在行到第一行的所有数据</span><br><span class="line">yG, 复制游标所在行到最后一行的所有数据</span><br><span class="line">y0, 复制光标所在的那个字符到该行行首的所有数据</span><br><span class="line">y$, 复制光标所在的那个字符到该行行尾的所有数据</span><br><span class="line">p和P, p为将已复制的数据在光标下一行贴上，P则为贴在游标上一行！ 举例来说，我目前光标在第20行，且已经复制了10行数据。则按下p后，那10行数据会贴在原本的20行之后，亦即由21行开始贴。但如果是按下P呢？那么原本的第20行会被推到变成30行。 (常用)</span><br><span class="line">J, 将光标所在行与下一行的数据结合成同一行</span><br><span class="line">c, 重复删除多个数据，例如向下删除10行，[10cj]</span><br><span class="line">u, 复原前一个动作。(常用)</span><br><span class="line">[Ctrl]+r, 重做上一个动作。(常用)</span><br><span class="line">这个u与[Ctrl]+r是很常用的指令！一个是复原，另一个则是重做一次～利用这两个功能按键，你的编辑，嘿嘿！很快乐的啦！</span><br><span class="line">., 不要怀疑！这就是小数点！意思是重复前一个动作的意思。如果你想要重复删除、重复贴上等等动作，按下小数点『.』就好了！ (常用)</span><br></pre></td></tr></table></figure><h4 id="第二部分：一般模式切换到编辑模式的可用的按钮说明"><a href="#第二部分：一般模式切换到编辑模式的可用的按钮说明" class="headerlink" title="第二部分：一般模式切换到编辑模式的可用的按钮说明"></a>第二部分：一般模式切换到编辑模式的可用的按钮说明</h4><p>进入输入或取代的编辑模式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">i或I, 进入输入模式(Insert mode),i为『从目前光标所在处输入』,I为『在目前所在行的第一个非空格符处开始输入』。(常用)</span><br><span class="line">a或A, 进入输入模式(Insert mode),a为『从目前光标所在的下一个字符处开始输入』,A为『从光标所在行的最后一个字符处开始输入』。(常用)</span><br><span class="line">o或O, 进入输入模式(Insert mode),o为『在目前光标所在的下一行处输入新的一行』,O为『在目前光标所在处的上一行输入新的一行』。(常用)</span><br><span class="line">r或R, 进入取代模式(Replace mode),r只会取代光标所在的那一个字符一次；R会一直取代光标所在的文字，直到按下ESC为止；(常用)</span><br><span class="line">[Esc], 退出编辑模式，回到一般模式中(常用)</span><br></pre></td></tr></table></figure><p>上面这些按键中，在<code>vi</code>画面的左下角处会出现<code>『--INSERT--』</code>或<code>『--REPLACE--』</code>的字样。由名称就知道该动作了吧！！特别注意的是，我们上面也提过了，你想要在档案里面输入字符时，一定要在左下角处看到<code>INSERT</code>或<code>REPLACE</code>才能输入喔！</p><h4 id="第三部分：一般模式切换到指令行模式的可用的按钮说明"><a href="#第三部分：一般模式切换到指令行模式的可用的按钮说明" class="headerlink" title="第三部分：一般模式切换到指令行模式的可用的按钮说明"></a>第三部分：一般模式切换到指令行模式的可用的按钮说明</h4><p>指令行的储存、离开等指令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">:w, 将编辑的数据写入硬盘档案中(常用)</span><br><span class="line">:w!, 若文件属性为『只读』时，强制写入该档案。不过，到底能不能写入，还是跟你对该档案的档案权限有关！</span><br><span class="line">:q, 离开vi(常用)</span><br><span class="line">:q!, 若曾修改过档案，又不想储存，使用!为强制离开不储存档案。注意一下啊，那个惊叹号(!)在vi当中，常常具有『强制』的意思～</span><br><span class="line">:wq, 储存后离开，若为:wq!则为强制储存后离开 (常用)</span><br><span class="line">ZZ, 若档案没有更动，则不储存离开，若档案已经被更动过，则储存后离开！</span><br><span class="line">:w [filename], 将编辑的数据储存成另一个档案（类似另存新档）</span><br><span class="line">:r [filename], 在编辑的数据中，读入另一个档案的数据。亦即将『filename』这个档案内容加到游标所在行后面</span><br><span class="line">:n1,n2 w [filename], 将n1到n2的内容储存成filename这个档案。</span><br><span class="line">:! command, 暂时离开vi到指令行模式下执行command的显示结果！例如『:! ls /home』即可在vi当中察看/home底下以ls输出的档案信息！</span><br></pre></td></tr></table></figure><p>vim 环境的变更:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:set nu, 显示行号，设定之后，会在每一行的前缀显示该行的行号</span><br><span class="line">:set nonu, 与set nu相反，为取消行号</span><br></pre></td></tr></table></figure><p>特别注意，在<code>vi/vim</code>中，数字是很有意义的！数字通常代表重复做几次的意思！ 也有可能是代表去到第几个什么什么的意思。</p><p>举例来说，要删除50行，则是用『50dd』对吧！数字加在动作之前，如我要向下移动20行呢？那就是『20j』或者是『20↓』即可。</p><h2 id="附录：vim命令合集"><a href="#附录：vim命令合集" class="headerlink" title="附录：vim命令合集"></a>附录：vim命令合集</h2><p><img src="https://i.loli.net/2021/04/28/XAs9P5cwBJ6yGC1.png" alt="vim-command.png"></p><ul><li>命令历史<ul><li>以:和/开头的命令都有历史纪录，可以首先键入:或/然后按上下箭头来选择某个历史命令。</li></ul></li><li>启动vim<ul><li>在命令行窗口中输入以下命令即可<ul><li>vim 直接启动vim</li><li>vim filename 打开vim并创建名为filename的文件</li></ul></li></ul></li><li>文件命令<ul><li>打开单个文件：vim file</li><li>同时打开多个文件：vim file1 file2 file3 …</li><li>在vim窗口中打开一个新文件：:open file</li><li>在新窗口中打开文件：:split file</li><li>切换到下一个文件:bn</li><li>切换到上一个文件:bp</li><li>查看当前打开的文件列表，当前正在编辑的文件会用[]括起来。:args</li><li>打开远程文件，比如ftp或者share folder<ul><li>1.:e <a href="ftp://192.168.10.76/abc.txt">ftp://192.168.10.76/abc.txt</a></li><li>2.:e \qadrive\test\1.txt</li></ul></li></ul></li><li>vim的模式<ul><li>正常模式（按Esc或Ctrl+[进入） 左下角显示文件名或为空</li><li>插入模式（按i键进入） 左下角显示–INSERT–</li><li>可视模式（正常模式下 按v进入） 左下角显示–VISUAL–</li></ul></li><li>导航命令<ul><li>% 括号匹配</li></ul></li><li>插入命令<ul><li>i 在当前位置生前插入</li><li>I 在当前行首插入</li><li>a 在当前位置后插入</li><li>A 在当前行尾插入</li><li>o 在当前行之后插入一行</li><li>O 在当前行之前插入一行</li></ul></li><li>查找命令<ul><li>/text　　查找text，按n健查找下一个，按N健查找前一个。</li><li>?text　　查找text，反向查找，按n健查找下一个，按N健查找前一个。</li><li>vim中有一些特殊字符在查找时需要转义　　.*[]^%/?~$</li><li>:set ignorecase　　忽略大小写的查找</li><li>:set noignorecase　　不忽略大小写的查找<br>查找很长的词，如果一个词很长，键入麻烦，可以将光标移动到该词上，按*或#键即可以该单词进行搜索，相当于/搜索。而#命令相当于?搜索。</li><li>:set hlsearch　　高亮搜索结果，所有结果都高亮显示，而不是只显示一个匹配。</li><li>:set nohlsearch　　关闭高亮搜索显示</li><li>:nohlsearch　　关闭当前的高亮显示，如果再次搜索或者按下n或N键，则会再次高亮。</li><li>:set incsearch　　逐步搜索模式，对当前键入的字符进行搜索而不必等待键入完成。</li><li>:set wrapscan　　重新搜索，在搜索到文件头或尾时，返回继续搜索，默认开启。</li></ul></li><li>替换命令<ul><li>ra 将当前字符替换为a，当期字符即光标所在字符。</li><li>:s/old/new/ 用old替换new，替换当前行的第一个匹配</li><li>:s/old/new/g 用old替换new，替换当前行的所有匹配</li><li>:%s/old/new/ 用old替换new，替换所有行的第一个匹配</li><li>:%s/old/new/g 用old替换new，替换整个文件的所有匹配</li><li>:10,20 s/^/ /g 在第10行知第20行每行前面加四个空格，用于缩进。</li><li>ddp 交换光标所在行和其下紧邻的一行。</li></ul></li><li>移动命令<ul><li>h 左移一个字符</li><li>l 右移一个字符，这个命令很少用，一般用w代替。</li><li>k 上移一个字符</li><li>j 下移一个字符<br>以上四个命令可以配合数字使用，比如20j就是向下移动20行，5h就是向左移动5个字符，在Vim中，很多命令都可以配合数字使用，比如删除10个字符10x，在当前位置后插入3个！，3a！，这里的Esc是必须的，否则命令不生效。</li><li>w 向前移动一个单词（光标停在单词首部），如果已到行尾，则转至下一行行首。此命令快，可以代替l命令。</li><li>b 向后移动一个单词 2b 向后移动2个单词</li><li>e，同w，只不过是光标停在单词尾部</li><li>ge，同b，光标停在单词尾部。</li><li>^ 移动到本行第一个非空白字符上。</li><li>0（数字0）移动到本行第一个字符上，</li><li><HOME>移动到本行第一个字符。同0健。</li><li>移动到行尾3 移动到下面3行的行尾</li><li>gg 移动到文件头。 = [[</li><li>G（shift + g） 移动到文件尾。 = ]]</li><li>f（find）命令也可以用于移动，fx将找到光标后第一个为x的字符，3fd将找到第三个为d的字符。</li><li>F 同f，反向查找。</li><li>跳到指定行，冒号+行号，回车，比如跳到240行就是 :240回车。另一个方法是行号+G，比如230G跳到230行。</li><li>Ctrl + e 向下滚动一行</li><li>Ctrl + y 向上滚动一行</li><li>Ctrl + d 向下滚动半屏</li><li>Ctrl + u 向上滚动半屏</li><li>Ctrl + f 向下滚动一屏</li><li>Ctrl + b 向上滚动一屏</li></ul></li><li>撤销和重做<ul><li>u 撤销（Undo）</li><li>U 撤销对整行的操作</li><li>Ctrl + r 重做（Redo），即撤销的撤销。</li></ul></li><li>删除命令<ul><li>x 删除当前字符</li><li>3x 删除当前光标开始向后三个字符</li><li>X 删除当前字符的前一个字符。X=dh</li><li>dl 删除当前字符， dl=x</li><li>dh 删除前一个字符</li><li>dd 删除当前行</li><li>dj 删除本行及下一行</li><li>dk 删除本行及上一行</li><li>10d 删除当前行开始的10行。</li><li>D 删除当前字符至行尾。D=d$</li><li>d$ 删除当前字符之后的所有字符（本行）</li><li>kdgg 删除当前行之前所有行（不包括当前行）</li><li>jdG（jd shift + g） 删除当前行之后所有行（不包括当前行）</li><li>:1,10d 删除1-10行</li><li>:11,$d 删除11行及以后所有的行</li><li>:1,$d 删除所有行</li><li>J(shift + j)　　删除两行之间的空行，实际上是合并两行。</li></ul></li><li>拷贝和粘贴<ul><li>yy 拷贝当前行</li><li>nyy 拷贝当前后开始的n行，比如2yy拷贝当前行及其下一行。</li><li>p 在当前光标后粘贴,如果之前使用了yy命令来复制一行，那么就在当前行的下一行粘贴。</li><li>shift+p 在当前行前粘贴</li><li>:1,10 co 20 将1-10行插入到第20行之后。</li><li>:1,$ co $ 将整个文件复制一份并添加到文件尾部。</li><li>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按y即可复制</li><li>ddp交换当前行和其下一行</li><li>xp交换当前字符和其后一个字符</li></ul></li><li>剪切命令<ul><li>正常模式下按v（逐字）或V（逐行）进入可视模式，然后用jklh命令移动即可选择某些行或字符，再按d即可剪切</li><li>ndd 剪切当前行之后的n行。利用p命令可以对剪切的内容进行粘贴</li><li>:1,10d 将1-10行剪切。利用p命令可将剪切后的内容进行粘贴。</li><li>:1, 10 m 20 将第1-10行移动到第20行之后。</li></ul></li><li>退出命令<ul><li>:wq 保存并退出</li><li>ZZ 保存并退出</li><li>:q! 强制退出并忽略所有更改</li><li>:e! 放弃所有修改，并打开原来文件。</li></ul></li><li>窗口命令<ul><li>:split或new 打开一个新窗口，光标停在顶层的窗口上</li><li>:split file或:new file 用新窗口打开文件</li><li>split打开的窗口都是横向的，使用vsplit可以纵向打开窗口。</li><li>Ctrl+ww 移动到下一个窗口</li><li>Ctrl+wj 移动到下方的窗口</li><li>Ctrl+wk 移动到上方的窗口</li></ul></li><li>关闭窗口<ul><li>:close 最后一个窗口不能使用此命令，可以防止意外退出vim。</li><li>:q 如果是最后一个被关闭的窗口，那么将退出vim。</li><li>ZZ 保存并退出。</li><li>:only 关闭所有窗口，只保留当前窗口</li></ul></li><li>录制宏<ul><li>录制宏：按q键加任意字母开始录制，再按q键结束录制（这意味着vim中的宏不可嵌套），使用的时候@加宏名，比如qa。。。q录制名为a的宏，@a使用这个宏。</li></ul></li><li>执行shell命令<ul><li>:!command</li><li>:!ls 列出当前目录下文件</li><li>:!perl -c script.pl 检查perl脚本语法，可以不用退出vim，非常方便。</li><li>:!perl script.pl 执行perl脚本，可以不用退出vim，非常方便。</li><li>:suspend或Ctrl - Z 挂起vim，回到shell，按fg可以返回vim。</li></ul></li><li>注释命令<ul><li>perl程序中#开始的行为注释，所以要注释某些行，只需在行首加入#</li><li>3,5 s/^/#/g 注释第3-5行</li><li>3,5 s/^#//g 解除3-5行的注释</li><li>1,$ s/^/#/g 注释整个文档。</li><li>:%s/^/#/g注释整个文档，此法更快。</li></ul></li><li>其他非编辑命令<ul><li>. 重复前一次命令</li><li>:set ruler?　　查看是否设置了ruler，在.vimrc中，使用set命令设制的选项都可以通过这个命令查看</li><li>:scriptnames　　查看vim脚本文件的位置，比如.vimrc文件，语法文件及plugin等。</li><li>:set list 显示非打印字符，如tab，空格，行尾等。如果tab无法显示，请确定用set lcs=tab:&gt;-命令设置了.vimrc文件，并确保你的文件中的确有tab，如果开启了expandtab，那么tab将被扩展为空格。</li></ul></li><li>Vim教程<ul><li>在Unix系统上 $ vimtutor</li><li>在Windows系统上 :help tutor</li><li>:syntax 列出已经定义的语法项</li><li>:syntax clear 清除已定义的语法规则</li><li>:syntax case match 大小写敏感，int和Int将视为不同的语法元素</li><li>:syntax case ignore 大小写无关，int和Int将视为相同的语法元素，并使用同样的配色方案</li></ul></li></ul><h2 id="附录：常用命令："><a href="#附录：常用命令：" class="headerlink" title="附录：常用命令："></a>附录：常用命令：</h2><ul><li>查找字符串(多条件)(高亮)：<code>/aaa\|bbb</code><ul><li>向上查找：<code>N</code></li><li>向下查找：<code>n</code></li></ul></li><li>取消高亮：<code>:noh</code></li><li>达到文件低端：<code>:$</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-tree命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-tree%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-tree%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;tree命令以树状图列出目录的内容（list contents of directories in a tree-like format.）。通常在写文档时需要列一下文件目录结构，这个时候tree命令就能帮个忙了。某些Linux上没有tree命令，使用安装命令:<code>sudo yum -y install tree</code>。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree [-aACdDfFgilnNpqstux][-I &lt;范本样式&gt;][-P &lt;范本样式&gt;][目录...]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;Linux tree命令用于以树状图列出目录的内容。执行tree指令，它会列出指定目录下的所有文件，包括子目录里的文件。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">-a, 显示所有文件和目录。</span><br><span class="line">-A, 使用ASNI绘图字符显示树状图而非以ASCII字符组合。</span><br><span class="line">-C, 在文件和目录清单加上色彩，便于区分各种类型。</span><br><span class="line">-d, 显示目录名称而非内容。</span><br><span class="line">-D, 列出文件或目录的更改时间。</span><br><span class="line">-f, 在每个文件或目录之前，显示完整的相对路径名称。</span><br><span class="line">-F, 在执行文件，目录，Socket，符号连接，管道名称名称，各自加上&quot;*&quot;,&quot;/&quot;,&quot;=&quot;,&quot;@&quot;,&quot;|&quot;号。</span><br><span class="line">-g, 列出文件或目录的所属群组名称，没有对应的名称时，则显示群组识别码。</span><br><span class="line">-i, 不以阶梯状列出文件或目录名称。</span><br><span class="line">-I&lt;范本样式&gt;, 不显示符合范本样式的文件或目录名称。</span><br><span class="line">-L n, 只显示n层目录。</span><br><span class="line">-l, 如遇到性质为符号连接的目录，直接列出该连接所指向的原始目录。</span><br><span class="line">-n, 不在文件和目录清单加上色彩。</span><br><span class="line">-N, 直接列出文件和目录名称，包括控制字符。</span><br><span class="line">-p, 列出权限标示。</span><br><span class="line">-P&lt;范本样式&gt;, 只显示符合范本样式的文件或目录名称。</span><br><span class="line">-q, 用&quot;?&quot;号取代控制字符，列出文件和目录名称。</span><br><span class="line">-s, 列出文件或目录大小。</span><br><span class="line">-t, 用文件和目录的更改时间排序。</span><br><span class="line">-u, 列出文件或目录的拥有者名称，没有对应的名称时，则显示用户识别码。</span><br><span class="line">-x, 将范围局限在现行的文件系统中，若指定目录下的某些子目录，其存放于另一个文件系统上，则将该子目录予以排除在寻找范围外。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：以树状图列出当前目录的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br></pre></td></tr></table></figure><p>实例2：以树状图列出lxy目录的内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree lxy</span><br></pre></td></tr></table></figure><p>实例3：以树状图列出lxy目录的内容(仅显示2层目录)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tree -L 2 lxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-touch命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-touch%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-touch%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch [选项]... 文件...</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。 </p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a, 改变档案的读取时间记录</span><br><span class="line">-c, 假如目的档案不存在，不会建立新的档案。</span><br><span class="line">-d, 使用指定的日期时间，而非现在的时间，可以使用各种不同的格式。</span><br><span class="line">-f, 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。</span><br><span class="line">-m, 或--time=mtime或--time=modify 　只更改变动时间。</span><br><span class="line">-r, 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。</span><br><span class="line">-t, 使用指定的日期时间，而非现在的时间。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：创建不存在的文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch log2020.log log2021.log</span><br></pre></td></tr></table></figure><p>实例2：将log2021.log时间戳更新成和log.log的时间戳相同:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch -r log.log log2021.log</span><br></pre></td></tr></table></figure><p>实例3：设定文件的时间戳:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">touch -t 202104282234.50 log.log</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line">-t  time 使用指定的时间值 time 作为指定文件相应时间戳记的新值．此处的 time规定为如下形式的十进制数:      </span><br><span class="line">  [[CC]YY]MMDDhhmm[.SS]   </span><br><span class="line">  这里，CC为年数中的前两位，即&quot;世纪数&quot;；YY为年数的后两位，即某世纪中的年数．如果不给出CC的值，则touch将把年数CCYY限定在1969--2068之内．MM为月数，DD为天数，hh为小时数(几点)，mm为分钟数，SS为秒数．此处秒的设定范围是0-61，这样可以处理闰秒．这些数字组成的时间是环境变量TZ指定的时区中的一个时间．由于系统的限制，早于1970年1月1日的时间是错误的。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-tail命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-tail%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-tail%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;tail命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且<strong>不断刷新</strong>,使你看到最新的文件内容. </p><h3 id="1．命令格式"><a href="#1．命令格式" class="headerlink" title="1．命令格式;"></a>1．命令格式;</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail [必要参数] [选择参数] [文件]   </span><br></pre></td></tr></table></figure><blockquote><p>tail -200f log.log</p></blockquote><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-f, 循环读取</span><br><span class="line">-q, 不显示处理信息</span><br><span class="line">-v, 显示详细的处理信息</span><br><span class="line">-c&lt;数目&gt;, 显示的字节数</span><br><span class="line">-n&lt;行数&gt;, 显示行数</span><br><span class="line">    --pid=PID, 与-f合用,表示在进程ID,PID死掉之后结束. </span><br><span class="line">-q, --quiet, --silent 从不输出给出文件名的首部 </span><br><span class="line">-s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 </span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示文件最后n行内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n 5 log2014.log</span><br></pre></td></tr></table></figure><p>实例2：循环查看文件内容:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -f test.log</span><br></pre></td></tr></table></figure><p>实例3：从第5行开始显示文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tail -n +5 log2014.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-sed命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-sed%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-sed%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;sed(stream editor)对文本的处理很强大，并且sed非常小，参数少，容易掌握，他的操作方式跟<code>awk</code>有点像。sed按顺序<strong>逐行</strong>读取文件。然后，它执行为该行指定的所有操作，并在完成请求的修改之后的内容显示出来，也可以存放到文件中。完成了一行上的所有操作之后，它读取文件的下一行，然后重复该过程直到它完成该文件。在这里要注意一点，源文件（默认地）保持不被修改。sed默认读取整个文件并对其中的每一行进行修改。说白了就是一行一行的操作。sed命令中用的最多的就是<strong>替换</strong>功能，真的很强大。下面以实例，详细的说一下，先从替换开始，最常用的。</p><p>&emsp;sed命令是一个面向字符流的非交互式编辑器，也就是说sed不允许用户与它进行交互操作。在shell中，使用sed来批量修改文本内容是非常方便的。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed [选项] [动作] [文件]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;sed可依照脚本的指令来处理、编辑文本文件。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p>选项与参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-n, 使用安静(silent)模式。在一般sed的用法中，所有来自STDIN的数据一般都会被列出到终端上。但如果加上-n参数后，则只有经过sed特殊处理的那一行(或者动作)才会被列出来。</span><br><span class="line">-e, 直接在命令列模式上进行sed的动作编辑；</span><br><span class="line">-f, 直接将sed的动作写在一个文件内，-f filename则可以运行filename内的sed动作；</span><br><span class="line">-r, sed的动作支持的是延伸型正规表示法的语法。(默认是基础正规表示法语法)</span><br><span class="line">-i, 直接修改读取的文件内容，而不是输出到终端。</span><br></pre></td></tr></table></figure><p>动作(function)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a, 新增行，a的后面可以是字串，而这些字串会在新的一行出现(目前的下一行)</span><br><span class="line">c, 取代行，c的后面可以接字串，这些字串可以取代n1,n2之间的行</span><br><span class="line">d, 删除行，因为是删除，所以d后面通常不接任何参数，直接删除地址表示的行；</span><br><span class="line">i, 插入行，i的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；</span><br><span class="line">p, 列印(输出print)，亦即将某个选择的数据印出。通常p会与参数sed -n一起运行</span><br><span class="line">s, 替换，可以直接进行替换的工作,通常这个s的动作可以搭配正规表示法，例如 1,20s/old/new/g 一般是替换符合条件的字符串而不是整行</span><br></pre></td></tr></table></figure><p>一般function的前面会有一个地址的限制，例如:[地址]function，表示我们的动作要操作的行。下面我们通过具体的例子直观的看看sed的使用方法。</p><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><h4 id="4-1-删除行："><a href="#4-1-删除行：" class="headerlink" title="4.1 删除行："></a>4.1 删除行：</h4><p>实例1：删除第一行和第二行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1,2d&#x27; test.txt</span><br></pre></td></tr></table></figure><p>其中1,2d中的d表示删除，而d前面的表示删除的行的地址，而1,2表示一个地址范围，也就是删除第1行和第2行。</p><p>地址范围的表示一般是<code>m,n</code>表示对<strong>m和n行之间</strong>的所有行进行操作，也<strong>包含</strong>第m行和第n行。</p><p>sed的地址寻址中可以使用<code>$</code>表示<strong>最后一行</strong>，例如<code>m,$</code>表示<strong>对m行以及其后面的所有行</strong>进行操作，包括最后一样。<code>m,$d</code>就是删除m行以及其后面的所有行内容。</p><p>当然我们还可以对<strong>某一行</strong>进行操作，例如<code>2d</code>表示仅仅删除第2行。除了使用数字范围<code>m,n</code>表示<em>多行区间</em>，以及<code>m</code>表示<em>单行</em>以外，我们还可以使用<em>正则表达式</em>选出符合条件的行，并对这些行进行操作，同样的是上面的文件：</p><p>实例2：删除内容包含2的所有行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/2/d&#x27; test.txt</span><br></pre></td></tr></table></figure><p>上面的命令中<code>/2/</code>是一个正则表达式，在sed中<strong>正则表达式</strong>是写在<code>/.../</code>两个斜杠中间的，这个正则的意思是<strong>寻找所有包含2的行</strong>，执行相应的操作，也就是删除所有包含2的行，如果我们只想删除以2开头的行呢，只需要修改一下正则表达式就可以了：</p><p>实例3：删除内容以2开头的行:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^2/d&#x27; test.txt</span><br></pre></td></tr></table></figure><h4 id="4-2-新增行："><a href="#4-2-新增行：" class="headerlink" title="4.2 新增行："></a>4.2 新增行：</h4><p>实例4：在第一行后面新增一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1a hello world&#x27; test.txt</span><br></pre></td></tr></table></figure><p><code>a</code>命令表示在<strong>指定行</strong>的<strong>后面</strong>附加一行，<code>1a</code>则是<strong>在第一行的后面添加一行</strong>，添加的内容就是a后面的内容，如果a的前面<em>没有地址限定</em>则在<em>所有行</em>的后面都会添加指定的字符串.<br>实例5：在第一行前面增加一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1i hello world&#x27; test.txt</span><br></pre></td></tr></table></figure><p><code>i</code>命令表示在<strong>指定行</strong>的<strong>前面</strong>插入一行，插入的内容为其后面的字符串。</p><h4 id="4-3-替换行："><a href="#4-3-替换行：" class="headerlink" title="4.3 替换行："></a>4.3 替换行：</h4><p>实例5：替换第一行的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1c hello world&#x27; test.txt</span><br></pre></td></tr></table></figure><p><code>c</code>命令会<strong>替换指定的行的所有内容</strong>，<strong>替换成其后面的字符串</strong>，所有的新增，删除，替换行，这些命令前面的地址修饰都可以指定地址空间，也<em>都可以使用正则表达式</em>，命令会应用在选出的符合地址条件的所有行上面，例如：<br>实例6：替换内容以2开头的行，其内容是c命令后面的字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^2/c hello world&#x27; test.txt</span><br></pre></td></tr></table></figure><h4 id="4-4-替换部分字符串而不是整行"><a href="#4-4-替换部分字符串而不是整行" class="headerlink" title="4.4 替换部分字符串而不是整行"></a>4.4 替换部分字符串而不是整行</h4><p>sed中除了上面的命令是针对整行进行操作的之外，还提供一个替换命令，该命令对某一行中的<strong>部分字符串</strong>进行操作，下面举一个简单的例子，还是同样的文本内容，执行下面的命令：<br>实例7：将aa替换成AA(仅替换每一行遇到的第一个aa)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/aa/AA/&#x27; test.txt</span><br></pre></td></tr></table></figure><p>我们这里说的就是<code>s</code>命令，执行的结果是我们文件中的aa被替换成AA，我们看一下s命令后面接的是3个斜杠分隔的两串字符串，其含义是<code>s/待替换的字符串/新字符串/</code>也就是说使用后面的AA替换文件中出现的前面的aa。实际上这里的替换<strong>仅仅替换每一行遇到的第一个</strong>aa。<br>实例8：将aa替换成AA(对一行里面的所有的符合条件的字符串都做替换操作)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;s/aa/AA/g&#x27; test.txt</span><br></pre></td></tr></table></figure><p>在最后一个斜杠后面加上<code>g</code>选项之后，表示进行<strong>全局替换</strong>，也就是说一行中<strong>所有</strong>符合条件的旧字符串都会被替换成新字符串，而不仅仅是第一个。与其他针对行的操作一样，s命令也可以进行地址选择，其地址使用方法与我们之前的一样，也就是在s的前面加上地址空间限定，例如：</p><p>实例9：将aa替换成AA(对第一行里面的所有的符合条件的字符串都做替换操作)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;1s/aa/AA/g&#x27; test.txt</span><br></pre></td></tr></table></figure><p>仅仅对第一行进行了替换操作，其他的地址限定方法同样也是可以使用的，我们可以使用<code>m,n</code>的限定，例如：</p><p>实例10：对第5行直到文件末尾的所有行进行搜索替换操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;5,$s/aa/AA/g&#x27; test.txt</span><br></pre></td></tr></table></figure><p>同样s命令的地址限定也支持使用<strong>正则表达式</strong>限定符合条件的行，然后在这些行中进行字符串的搜索替换操作，例如：</p><p>实例10：对以数字开头的行进行搜索替换操作</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;/^[0-9]/s/aa/AA/g&#x27; test.txt</span><br></pre></td></tr></table></figure><p>我们在s命令前面添加了<code>/^[0-9]/</code>这个修饰，该正则表达式表示对所有以数字开头的行，执行s操作</p><p>另外一个要说明的是<code>s/待替换的字符串/新字符串/</code>这种格式中<code>/</code>作为分隔符并不是一定的，当使用s命令时候，我们可以使用别的分隔符，实际上<em>s后面紧接着的字符</em>就是<strong>分隔符</strong>，所以不一定是<code>/</code>符号。例如：</p><p>实例11：将echo输出的内容进行替换(以#为分隔符)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这里s命令后面跟着的<span class="comment">#符号被当作分隔符了</span></span></span><br><span class="line">echo &#x27;aabbccaadd&#x27; | sed s#aa#AA#g</span><br></pre></td></tr></table></figure><h4 id="4-5-搜索并输出行内容"><a href="#4-5-搜索并输出行内容" class="headerlink" title="4.5 搜索并输出行内容"></a>4.5 搜索并输出行内容</h4><p>sed还提供一个p命令用于搜索符合条件的行，并输出该行的内容，而不做其他的任何修改.</p><p>实例12：输出第二行内容(sed命令默认会输出文件的所有内容)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed &#x27;2p&#x27; test.txt</span><br></pre></td></tr></table></figure><p>可以看到第二行被输出来了，但是sed好像将文件的所有内容输出了一遍，而第2行则多输出了一次，<strong>实际上sed默认情况下是会将所有标准输入的数据又重新输出到标准输出</strong>的，我们可以加上<code>-n</code>选项让sed仅仅是输出经过处理之后的那些行，而不是输出之前从标准输入中获取到的所有行内容，例如：</p><p>实例13：输出第二行内容(使用安静模式，只输出经过特殊处理的内容)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -n选项一般是与p命令联合使用的，其他的增加，删除，替换行的命令是不需要-n选项的</span></span><br><span class="line">sed -n &#x27;2p&#x27; test.txt</span><br></pre></td></tr></table></figure><h4 id="4-6-将修改应用到文件中"><a href="#4-6-将修改应用到文件中" class="headerlink" title="4.6 将修改应用到文件中"></a>4.6 将修改应用到文件中</h4><p>我们之前做的所有实验，实际上<strong>并没有修改test.txt文件的内容</strong>，也就是说我们看到的修改结果仅仅输出到控制台上，而文件test.txt的内容是没有修改的，我们可以使用<code>-i</code>选项告诉sed<strong>直接修改文件的内容</strong>，而不是将修改结果输出到终端上，例如：</p><p>实例13：直接删除文件的第二行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;2d&#x27; test.txt </span><br></pre></td></tr></table></figure><h4 id="4-7-sed正则中的元字符"><a href="#4-7-sed正则中的元字符" class="headerlink" title="4.7 sed正则中的元字符"></a>4.7 sed正则中的元字符</h4><p>我们知道sed中的命令前面可以使用<strong>地址范围</strong>进行限制，表示对文件的某些符合条件的行执行相应的操作，其中我们可以<em>使用正则表达式选出要操作的行</em>，而sed中正则的语法可能与我们其他命令的正则语法有一些<em>不同</em>，这里我们有必要列出sed中常用的正则元字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$, 表示行尾</span><br><span class="line">^, 表示行首</span><br><span class="line">[a-z0-9], 表示字符范围</span><br><span class="line">[^], 表示除了字符集中的字符以外的字符</span><br><span class="line"></span><br><span class="line">sed的正则中 \(\) 和 \&#123;m,n\&#125; 需要转义 </span><br><span class="line">., 表示任意字符 </span><br><span class="line">*, 表示零个或者多个 </span><br><span class="line">\+, 一次或多次　　</span><br><span class="line">\?, 零次或一次    </span><br><span class="line">\|, 表示或语法</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-rmdir命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rmdir%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rmdir%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;rmdir(Remove directory)命令。rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意，rm -r dirName命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir [选项]... 目录...</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。 </p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-p, 递归删除目录，是当子目录被删除后使它也成为空目录的话，则顺便一并删除。如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 </span><br><span class="line">-v, --verbose 显示指令执行过程 </span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：rmdir命令不能直接删除非空目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir lxy</span><br></pre></td></tr></table></figure><p>实例2：rmdir -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir -p lxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-rm命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rm%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rm%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;rm(Remove file)命令是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于<strong>链接文件</strong>，只是删除了<strong>链接</strong>，原有文件均保持不变。</p><p>&emsp;rm是一个<strong>危险</strong>的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm -rf *）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm [选项] 文件… </span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;删除一个目录中的一个或多个文件或目录，如果没有使用-r选项，则rm不会删除目录。如果使用rm来删除文件，通常仍可以将该文件恢复原状。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-f, --force 忽略不存在的文件，从不给出提示。</span><br><span class="line">-i, --interactive 进行交互式删除(删除时询问是否确认删除)</span><br><span class="line">-r,-R, --recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。</span><br><span class="line">-v, --verbose 详细显示进行的步骤</span><br><span class="line">--help, 显示此帮助信息并退出</span><br><span class="line">--version, 输出版本信息并退出</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：查看rm的真实身份:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# type -a rm</span><br><span class="line">rm 是 &#x27;rm -i&#x27; 的别名</span><br><span class="line">rm 是 /usr/bin/rm</span><br></pre></td></tr></table></figure><p><a href="./%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-type%E5%91%BD%E4%BB%A4.md">type命令</a><br>实例2：删除文件file，系统会先询问是否删除。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm &lt;文件名&gt;</span><br></pre></td></tr></table></figure><p>实例3：强行删除file，系统不再提示。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -f &lt;文件名&gt;</span><br></pre></td></tr></table></figure><p>实例4：删除任何*.log文件；删除前逐一询问确认 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -i *.log</span><br></pre></td></tr></table></figure><p>实例5：将lxy目录及子目录中所有内容删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -r lxy</span><br></pre></td></tr></table></figure><p>实例6：将lxy目录及子目录中所有档案删除,并且不用一一确认</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf lxy</span><br></pre></td></tr></table></figure><p>实例7：删除以-f开头的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">rm -- -f</span><br><span class="line"><span class="meta">#</span><span class="bash"> 操作示例：</span></span><br><span class="line">step1:touch -- -f</span><br><span class="line">step2:ls -- -f</span><br><span class="line">step3:rm -- -f</span><br><span class="line"><span class="meta">#</span><span class="bash"> 也可以使用下面的操作步骤:</span></span><br><span class="line">step1:touch ./-f</span><br><span class="line">step2:ls ./-f</span><br><span class="line">step3:rm ./-f</span><br></pre></td></tr></table></figure><h3 id="5-扩展"><a href="#5-扩展" class="headerlink" title="5.扩展"></a>5.扩展</h3><p>自定义回收站功能<br>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myrm()&#123; D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &quot;$@&quot; $D &amp;&amp; echo &quot;moved to $D ok&quot;; &#125;</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# myrm()&#123; D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D;  mv &quot;$@&quot; $D &amp;&amp; echo &quot;moved to $D ok&quot;; &#125;</span><br><span class="line">[root@localhost test]# alias rm=&#x27;myrm&#x27;</span><br><span class="line">[root@localhost test]# touch 1.log 2.log 3.log</span><br><span class="line">[root@localhost test]# ll</span><br><span class="line">总计 16</span><br><span class="line">-rw-r--r-- 1 root root    0 10-26 15:08 1.log</span><br><span class="line">-rw-r--r-- 1 root root    0 10-26 15:08 2.log</span><br><span class="line">-rw-r--r-- 1 root root    0 10-26 15:08 3.log</span><br><span class="line">drwxr-xr-x 7 root root 4096 10-25 18:07 scf</span><br><span class="line">drwxrwxrwx 2 root root 4096 10-25 17:46 test3</span><br><span class="line">drwxr-xr-x 2 root root 4096 10-25 17:56 test4</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:56 test5</span><br><span class="line"></span><br><span class="line">[root@localhost test]# rm [123].log</span><br><span class="line">moved to /tmp/20121026150901 ok</span><br><span class="line"></span><br><span class="line">[root@localhost test]# ll</span><br><span class="line">总计 16</span><br><span class="line">drwxr-xr-x 7 root root 4096 10-25 18:07 scf</span><br><span class="line">drwxrwxrwx 2 root root 4096 10-25 17:46 test3</span><br><span class="line">drwxr-xr-x 2 root root 4096 10-25 17:56 test4</span><br><span class="line">drwxr-xr-x 3 root root 4096 10-25 17:56 test5</span><br><span class="line"></span><br><span class="line">[root@localhost test]# ls /tmp/20121026150901/</span><br><span class="line">1.log  2.log  3.log</span><br></pre></td></tr></table></figure><p>说明：</p><p>上面的操作过程模拟了回收站的效果，即删除文件的时候只是把文件放到一个临时目录中，这样在需要的时候还可以恢复过来。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-pwd命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-pwd%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-pwd%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux中用pwd(PrintWorkingDirectory)命令来查看”当前工作目录”的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 </p><p>&emsp;在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。</p><h3 id="1-命令格式："><a href="#1-命令格式：" class="headerlink" title="1. 命令格式："></a>1. 命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd [选项]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;查看”当前工作目录”的绝对路径</p><h3 id="3．常用参数："><a href="#3．常用参数：" class="headerlink" title="3．常用参数："></a>3．常用参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-L, --logical，显示当前的路径，有连接文件时，直接显示连接文件的路径，(不加参数时默认此方式)</span><br><span class="line">-P, --physical，显示当前的路径，有连接文件时，不使用连接路径，直接显示连接文件所指向的文件</span><br><span class="line">--help, 显示帮助信息。 </span><br><span class="line">--version, 显示版本信息。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：目录是链接时，pwd -P显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pwd -P</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-nl命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-nl%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-nl%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;nl(Number of Lines)命令在linux系统中用来<strong>计算文件中行号</strong>。nl可以将输出的文件内容自动的加上行号！其默认的结果与cat -n有点不太一样，nl可以将行号做比较多的显示设计，包括位数与是否自动补齐0等等的功能。  </p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl [选项]... [文件]...</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;nl命令读取File参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 </p><p>&emsp;在输出中，nl命令根据您在命令行中指定的标志来计算左边的行。 </p><p>&emsp;输入文本必须写在逻辑页中。每个逻辑页有头、主体和页脚节（可以有空节）。 除非使用-p标志，nl命令在每个逻辑页开始的地方重新设置行号。 </p><p>&emsp;可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-b, 指定行号指定的方式，主要有两种：</span><br><span class="line">    -b a, 表示不论是否为空行，也同样列出行号(类似 cat -n)</span><br><span class="line">    -b t, 如果有空行，空的那一行不要列出行号(默认值)</span><br><span class="line">-n, 列出行号表示的方法，主要有三种：</span><br><span class="line">    -n ln, 行号在萤幕的最左方显示</span><br><span class="line">    -n rn, 行号在自己栏位的最右方显示，且不加0</span><br><span class="line">    -n rz, 行号在自己栏位的最右方显示，且加0</span><br><span class="line">-w, 行号栏位的占用的位数。</span><br><span class="line">-p, 在逻辑定界符处不重新开始计算。 </span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：列出log2021.log的内容(文件中的空白行，nl不会加上行号)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nl log2021.log</span><br></pre></td></tr></table></figure><p>实例2：列出log2021.log的内容(空本行也加上行号)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nl -b a log2021.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">nl -ba log2021.log</span><br></pre></td></tr></table></figure><p>实例3：让行号前面自动补上0,统一输出格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 共6位行号</span></span><br><span class="line">nl -b a -n rz log2021.log </span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定3位行号</span></span><br><span class="line">nl -b a -n rz -w 3 log2021.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-mv命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-mv%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-mv%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;mv(move)命令，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv [选项] 源文件或目录 目标文件或目录</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;依据mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件<strong>重命名</strong>或将其<strong>移至一个新的目录</strong>中。</p><p>&emsp;当第二个参数类型是<strong>文件</strong>时，mv命令完成文件<strong>重命名</strong>，此时，源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标文件名。</p><p>&emsp;当第二个参数是已存在的<strong>目录名称</strong>时，源文件或目录参数可以有多个，mv命令将各参数指定的源文件均<strong>移至目标目录</strong>中。在跨文件系统移动文件时，mv先拷贝，再将原有文件删除，而链至该文件的链接也将丢失。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-b, 若需覆盖文件，则覆盖前先行备份。 </span><br><span class="line">-f, force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖；</span><br><span class="line">-i, 若目标文件 (destination) 已经存在时，就会询问是否覆盖！</span><br><span class="line">-n, 不覆盖已存在文件</span><br><span class="line">-u, 若目标文件已经存在，且 source 比较新，才会更新(update)</span><br><span class="line">-t, --target-directory=DIRECTORY 移动所有源文件到指定目录，即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情况，此时目标目录在前，源文件在后。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：文件改名,将文件test.log重命名为test.txt:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv test.log test.txt</span><br></pre></td></tr></table></figure><p>实例2：移动文件,将test.txt文件移到目录test3中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv test.txt test3</span><br></pre></td></tr></table></figure><p>实例3：将文件log1.txt,log2.txt,log3.txt移动到目录test3中。 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mv log1.txt log2.txt log3.txt test3</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 或者：</span></span></span><br><span class="line">mv -t /opt/soft/test/test4/ log1.txt log2.txt  log3.txt </span><br></pre></td></tr></table></figure><p>实例4：将文件log1.txt改名为log2.txt，如果log2.txt已经存在，则询问是否覆盖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -i log1.txt log2.txt</span><br></pre></td></tr></table></figure><p>实例5：将文件log3.txt改名为log2.txt，即使log2.txt存在，也是直接覆盖掉。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv -f log3.txt log2.txt</span><br></pre></td></tr></table></figure><p>实例6：目录的移动,如果目录dir2不存在，将目录dir1改名为dir2；否则，将dir1移动到dir2中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv dir1 dir2</span><br></pre></td></tr></table></figure><p>实例7：移动当前文件夹下的所有文件到上一级目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv * ../</span><br></pre></td></tr></table></figure><p>实例8：把当前目录的一个子目录里的文件移动到另一个子目录里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv test3/*.txt test5</span><br></pre></td></tr></table></figure><p>实例9：文件被覆盖前做简单备份，前面加参数-b</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mv log1.txt -b log2.txt</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line">-b 不接受参数，mv会去读取环境变量VERSION_CONTROL来作为备份策略。</span><br><span class="line">--backup该选项指定如果目标文件存在时的动作，共有四种备份策略：</span><br><span class="line">1.CONTROL=none或off : 不备份。</span><br><span class="line">2.CONTROL=numbered或t：数字编号的备份</span><br><span class="line">3.CONTROL=existing或nil：如果存在以数字编号的备份，则继续编号备份m+1...n：</span><br><span class="line">执行mv操作前已存在以数字编号的文件log2.txt.~1~，那么再次执行将产生log2.txt~2~，以次类推。如果之前没有以数字编号的文件，则使用下面讲到的简单备份。</span><br><span class="line">4.CONTROL=simple或never：使用简单备份：在被覆盖前进行了简单备份，简单备份只能有一份，再次被覆盖时，简单备份也会被覆盖。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-more命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-more%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-more%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;more命令，功能类似cat，cat命令是<strong>整个文件的内容</strong>从上到下显示在屏幕上。more会以<strong>一页一页</strong>的显示方便使用者<strong>逐页阅读</strong>，而最基本的指令就是按<strong>空白键</strong>（space）就往下一页显示，按<strong>b键</strong>就会往回（back）一页显示，而且还有<strong>搜寻</strong>字串的功能。more命令从前向后读取文件，因此在启动时就加载整个文件。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] </span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持<strong>直接跳转行</strong>等功能。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+n, 从第n行开始显示</span><br><span class="line">-n, 定义屏幕大小为n行</span><br><span class="line">+/pattern, 在每个档案显示前搜寻该字串(pattern)，然后从该字串前两行之后开始显示 </span><br><span class="line">-c, 从顶部清屏，然后显示</span><br><span class="line">-d, 提示“Press space to continue，’q’ to quit(按空格键继续，按q键退出)”，禁用响铃功能</span><br><span class="line">-l, 忽略Ctrl+l（换页）字符</span><br><span class="line">-p, 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似</span><br><span class="line">-s, 把连续的多个空行显示为一行</span><br><span class="line">-u, 把文件内容中的下画线去掉</span><br></pre></td></tr></table></figure><h3 id="4．常用操作命令："><a href="#4．常用操作命令：" class="headerlink" title="4．常用操作命令："></a>4．常用操作命令：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Enter:向下n行，需要定义。默认为1行</span><br><span class="line">空格键/Ctrl+F:向下滚动一屏</span><br><span class="line">Ctrl+B/b:返回上一屏</span><br><span class="line">=:输出当前行的行号</span><br><span class="line">:f:输出文件名和当前行的行号</span><br><span class="line">V:调用vi编辑器</span><br><span class="line">!命令:调用Shell，并执行命令 </span><br><span class="line">q:退出more</span><br></pre></td></tr></table></figure><h3 id="5．使用实例："><a href="#5．使用实例：" class="headerlink" title="5．使用实例："></a>5．使用实例：</h3><p>实例1：显示文件中从第3行起的内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more +3 log2021.log</span><br></pre></td></tr></table></figure><p>实例2：从文件中查找第一个出现”day3”字符串的行，并从该处前两行开始显示输出 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more +/day3 log2021.log</span><br></pre></td></tr></table></figure><p>实例3：设定每屏显示行数 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -5 log2021.log</span><br></pre></td></tr></table></figure><p>实例4：列一个目录下的文件，由于内容太多，我们应该学会用more来分页显示。这得和管道<code>|</code>结合起来 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l|more -5</span><br></pre></td></tr></table></figure><p>实例5：逐页显示a.txt文档内容，如有连续两行以上空白行则以一行空白行显示。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">more -s a.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-mkdir命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-mkdir%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-mkdir%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;linux mkdir(Make Directory)命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中<strong>具有写权限</strong>，并且指定的目录名不能是当前目录中已有的目录。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir [选项] dirName</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;通过 mkdir 命令可以实现在指定位置创建以dirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。 </p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx - umask</span><br><span class="line">-p, --parents  可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后,系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; </span><br><span class="line">-v, --verbose  每次创建新目录都显示创建信息</span><br><span class="line">--help, 显示此帮助信息并退出</span><br><span class="line">--version, 输出版本信息并退出</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：创建一个空目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir lxy</span><br></pre></td></tr></table></figure><p>实例2：递归创建多个目录 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p lxy/lxy2</span><br></pre></td></tr></table></figure><p>实例3：创建权限为777的目录 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -m 777 lxy</span><br></pre></td></tr></table></figure><p>实例4：创建新目录并显示创建信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -v lxy</span><br></pre></td></tr></table></figure><p>实例5：一个命令创建项目的目录结构</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">mkdir -vp lxy/&#123;lib/,bin/,doc/&#123;info,product&#125;,logs/&#123;info,product&#125;,service/deploy/&#123;info,product&#125;&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出日志：</span></span><br><span class="line">mkdir: 已创建目录 &quot;lxy&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/lib/&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/bin/&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/doc&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/doc/info&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/doc/product&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/logs&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/logs/info&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/logs/product&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/service&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/service/deploy&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/service/deploy/info&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;lxy/service/deploy/product&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看创建情况，命令：tree lxy</span></span><br><span class="line">lxy</span><br><span class="line">├── bin</span><br><span class="line">├── doc</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── product</span><br><span class="line">├── lib</span><br><span class="line">├── logs</span><br><span class="line">│   ├── info</span><br><span class="line">│   └── product</span><br><span class="line">└── service</span><br><span class="line">    └── deploy</span><br><span class="line">        ├── info</span><br><span class="line">        └── product</span><br><span class="line">12 directories, 0 files</span><br></pre></td></tr></table></figure><p><a href="../%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-type%E5%91%BD%E4%BB%A4.md">tree命令介绍</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-ls命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ls%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ls%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;ls命令是linux下最常用的命令。</p><p>&emsp;ls(list)命令,通过ls命令不仅可以查看Linux文件夹包含的文件,而且可以查看文件权限(包括目录、文件夹、文件权限)查看目录信息等等。</p><h3 id="1-命令格式："><a href="#1-命令格式：" class="headerlink" title="1. 命令格式："></a>1. 命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls [选项] [目录名]</span><br></pre></td></tr></table></figure><h3 id="2-命令功能："><a href="#2-命令功能：" class="headerlink" title="2. 命令功能："></a>2. 命令功能：</h3><p>&emsp;列出目标目录中所有的子目录和文件。</p><h3 id="3-常用参数："><a href="#3-常用参数：" class="headerlink" title="3. 常用参数："></a>3. 常用参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">-a, –all 列出目录下的所有文件，包括以 . 开头的隐含文件</span><br><span class="line">-A, 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。</span><br><span class="line">-c, 配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间)配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序</span><br><span class="line">-C, 每栏由上至下列出项目</span><br><span class="line">    –color[=WHEN], 控制是否使用色彩分辨文件。WHEN 可以是&#x27;never&#x27;、&#x27;always&#x27;或&#x27;auto&#x27;其中之一</span><br><span class="line">-d, –directory 将目录象文件一样显示，而不是显示其下的文件。</span><br><span class="line">-D, –dired 产生适合 Emacs 的 dired 模式使用的结果</span><br><span class="line">-F, 在列出的文件名称后加一符号；例如可执行档则加 &quot;*&quot;, 目录则加 &quot;/&quot;</span><br><span class="line">-f, 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效</span><br><span class="line">-g, 类似 -l,但不列出所有者</span><br><span class="line">-G, –no-group 不列出任何有关组的信息</span><br><span class="line">-h, –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G)</span><br><span class="line">    –si, 类似 -h,但文件大小取 1000 的次方而不是 1024</span><br><span class="line">-H, –dereference-command-line 使用命令列中的符号链接指示的真正目的地</span><br><span class="line">    –indicator-style=方式, 指定在每个项目名称后加上指示符号&lt;方式&gt;：none (默认)，classify (-F)，file-type (-p)</span><br><span class="line">-i, –inode 印出每个文件的 inode 号</span><br><span class="line">-I, –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目</span><br><span class="line">-k, 即 –block-size=1K,以 k 字节的形式表示文件的大小。</span><br><span class="line">-l, 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。</span><br><span class="line">-L, –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号链接本身的信息</span><br><span class="line">-m, 所有项目以逗号分隔，并填满整行行宽</span><br><span class="line">-o, 类似 -l,显示文件的除组信息外的详细信息。   </span><br><span class="line">-r, –reverse 以相反次序排列</span><br><span class="line">-R, –recursive 同时列出所有子目录层</span><br><span class="line">-s, –size 以块大小为单位列出所有文件的大小</span><br><span class="line">-S, 根据文件大小排序</span><br><span class="line">    –sort=WORD, 以下是可选用的 WORD 和它们代表的相应选项：</span><br><span class="line">        extension -X status -c</span><br><span class="line">        none -U time -t</span><br><span class="line">        size -S atime -u</span><br><span class="line">        time -t access -u</span><br><span class="line">        version -v use -u</span><br><span class="line">-t, 以文件修改时间排序</span><br><span class="line">-u, 配合 -lt:显示访问时间而且依访问时间排序</span><br><span class="line">    配合 -l:显示访问时间但根据名称排序</span><br><span class="line">    否则：根据访问时间排序</span><br><span class="line">-U, 不进行排序;依文件系统原有的次序列出项目</span><br><span class="line">-v, 根据版本进行排序</span><br><span class="line">-w, –width=COLS 自行指定屏幕宽度而不使用目前的数值</span><br><span class="line">-x, 逐行列出项目而不是逐栏列出</span><br><span class="line">-X, 根据扩展名排序</span><br><span class="line">-1, 每行只列出一个文件</span><br><span class="line">–help, 显示此帮助信息并离开</span><br><span class="line">–version, 显示版本信息并离开</span><br></pre></td></tr></table></figure><h3 id="4-使用实例："><a href="#4-使用实例：" class="headerlink" title="4. 使用实例："></a>4. 使用实例：</h3><p>实例1：列出<code>/home/lxy</code>文件夹下的所有文件和目录的详细资料:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -lR /home/lxy</span><br></pre></td></tr></table></figure><p>实例2：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ls -l t*</span><br><span class="line">```   </span><br><span class="line">实例3：只列出文件下的子目录:</span><br><span class="line">```shell</span><br><span class="line">ls -F [目录] |grep /$</span><br></pre></td></tr></table></figure><p>实例4：列出指定目录下的子目录详细情况：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -l [目录] | grep &quot;^d&quot;</span><br></pre></td></tr></table></figure><p>实例5：列出目前工作目录下所有名称是s开头的档案，越新的排越后面，可以使用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -ltr s*</span><br></pre></td></tr></table></figure><p>实例6：计算当前目录下的文件数和目录数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 文件个数(当前目录)</span></span><br><span class="line">ls -l * |grep &quot;^-&quot;|wc -l </span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件个数(当前目录以及子目录中)</span></span><br><span class="line">ls -l |grep &quot;^-&quot;|wc -l </span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录个数(当前目录的子目录中)</span></span><br><span class="line">ls -l * |grep &quot;^d&quot;|wc -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录个数(当前目录)</span></span><br><span class="line">ls -l |grep &quot;^d&quot;|wc -l</span><br></pre></td></tr></table></figure><p>实例7：在ls中列出文件的绝对路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls | sed &quot;s:^:`pwd`/:&quot;</span><br></pre></td></tr></table></figure><p>实例8：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find $PWD -maxdepth 1 | xargs ls -ld</span><br></pre></td></tr></table></figure><p>实例9：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find $PWD | xargs ls -ld</span><br></pre></td></tr></table></figure><p>实例10：指定文件时间输出格式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 时间格式：2021-04-28 10:44:53.775401289 +0800</span></span><br><span class="line">ls -tl --time-style=full-iso</span><br><span class="line"><span class="meta">#</span><span class="bash"> 时间格式：2021-04-28 10:44</span></span><br><span class="line">ls -ctl --time-style=long-iso</span><br></pre></td></tr></table></figure><h3 id="5-扩展："><a href="#5-扩展：" class="headerlink" title="5.扩展："></a>5.扩展：</h3><ul><li>显示彩色目录列表<ul><li>打开/etc/bashrc, 加入如下一行:<code>alias ls=&quot;ls --color&quot;</code></li><li>下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下:<ul><li>蓝色–&gt;目录</li><li>绿色–&gt;可执行文件</li><li>红色–&gt;压缩文件</li><li>浅蓝色–&gt;链接文件</li><li>灰色–&gt;其他文件</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-less命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-less%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-less%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;less工具也是对文件或其它输出进行<strong>分页显示</strong>的工具，应该说是linux正统查看文件内容的工具，功能极其强大。</p><p>&emsp;less的用法比起more更加的有弹性。在more的时候，我们并没有办法向前面翻，只能往后面看，但若使用了less时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在less里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less [参数] 文件 </span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;less与more类似，但使用less可以随意浏览文件，而more仅能向前移动，却不能向后移动，而且less在查看之前不会加载整个文件。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-b, &lt;缓冲区大小&gt; 设置缓冲区的大小</span><br><span class="line">-e, 当文件显示结束后，自动离开</span><br><span class="line">-f, 强迫打开特殊文件，例如外围设备代号、目录和二进制文件</span><br><span class="line">-g, 只标志最后搜索的关键词</span><br><span class="line">-i, 忽略搜索时的大小写</span><br><span class="line">-m, 显示类似more命令的百分比</span><br><span class="line">-N, 显示每行的行号</span><br><span class="line">-o, &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来</span><br><span class="line">-Q, 不使用警告音</span><br><span class="line">-s, 显示连续空行为一行</span><br><span class="line">-S, 行过长时间将超出部分舍弃</span><br><span class="line">-x, &lt;数字&gt; 将“tab”键显示为规定的数字空格</span><br><span class="line">/字符串, 向下搜索“字符串”的功能</span><br><span class="line">?字符串, 向上搜索“字符串”的功能</span><br><span class="line">n, 重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">N, 反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">b, 向后翻一页</span><br><span class="line">d, 向后翻半页</span><br><span class="line">h, 显示帮助界面</span><br><span class="line">Q, 退出less 命令</span><br><span class="line">u, 向前滚动半页</span><br><span class="line">y, 向前滚动一行</span><br><span class="line">空格键, 滚动一行</span><br><span class="line">回车键, 滚动一页</span><br><span class="line">[pagedown], 向下翻动一页</span><br><span class="line">[pageup], 向上翻动一页</span><br></pre></td></tr></table></figure><h3 id="4．常用操作命令："><a href="#4．常用操作命令：" class="headerlink" title="4．常用操作命令："></a>4．常用操作命令：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">1.全屏导航</span><br><span class="line">ctrl + F - 向前移动一屏</span><br><span class="line">ctrl + B - 向后移动一屏</span><br><span class="line">ctrl + D - 向前移动半屏</span><br><span class="line">ctrl + U - 向后移动半屏</span><br><span class="line"></span><br><span class="line">2.单行导航</span><br><span class="line">j - 向前移动一行</span><br><span class="line">k - 向后移动一行</span><br><span class="line"></span><br><span class="line">3.其它导航</span><br><span class="line">G - 移动到最后一行</span><br><span class="line">g - 移动到第一行</span><br><span class="line">q / ZZ - 退出 less 命令</span><br><span class="line"></span><br><span class="line">4.其它有用的命令</span><br><span class="line">v - 使用配置的编辑器编辑当前文件</span><br><span class="line">h - 显示 less 的帮助文档</span><br><span class="line">&amp;pattern - 仅显示匹配模式的行，而不是整个文件</span><br><span class="line"></span><br><span class="line">5.标记导航</span><br><span class="line">当使用 less 查看大文件时，可以在任何一个位置作标记，可以通过命令导航到标有特定标记的文本位置：</span><br><span class="line">ma - 使用 a 标记文本的当前位置</span><br><span class="line">&#x27;a - 导航到标记 a 处</span><br></pre></td></tr></table></figure><h3 id="5．使用实例："><a href="#5．使用实例：" class="headerlink" title="5．使用实例："></a>5．使用实例：</h3><p>实例1：查看文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">less a.txt</span><br></pre></td></tr></table></figure><p>实例2：ps查看进程信息并通过less分页显示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|less</span><br></pre></td></tr></table></figure><p>实例3：查看命令历史使用记录并通过less分页显示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history | less</span><br></pre></td></tr></table></figure><p>实例4：浏览多个文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">less log2020.log log2021.log</span><br><span class="line"><span class="meta">#</span><span class="bash">说明：</span></span><br><span class="line">输入:n后,切换到log2021.log</span><br><span class="line">输入:p后,切换到log2020.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-head命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-head%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-head%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;head与tail就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head用来显示档案的开头至标准输出中，而tail想当然尔就是看档案的结尾。 </p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head [参数]... [文件]...  </span><br></pre></td></tr></table></figure><blockquote><p>查看文件头10行 : head -n 10 file.txt</p></blockquote><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;head用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 </p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-q, 隐藏文件名</span><br><span class="line">-v, 显示文件名</span><br><span class="line">-c&lt;字节&gt;, 显示字节数</span><br><span class="line">-n&lt;行数&gt;, 显示的行数</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示文件的前n行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n 5 log.log</span><br></pre></td></tr></table></figure><p>实例2：显示文件前n个字节:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -c 20 log.log</span><br></pre></td></tr></table></figure><p>实例3：输出文件的<strong>除了</strong>最后n个字节以外的内容 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -c -32 log2014.log</span><br></pre></td></tr></table></figure><p>实例4：输出文件<strong>除了</strong>最后n行的全部内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head -n -6 log2021.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-cut命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cut%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cut%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;cut命令在Linux和Unix中的作用是从文件中的每一行中截取出一些部分，并输出到标准输出中。我们可以使用cut命令从一行字符串中于以字节，字符，字段（分隔符）等单位截取一部分内容出来。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cut [选项] [文件]...</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p><p>&emsp;如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-f, 提取指定的字段，cut 命令使用 Tab 作为默认的分隔符。</span><br><span class="line">-d, Tab 是默认的分隔符，使用这一选项可以指定自己的分隔符。</span><br><span class="line">-b, 提取指定的字节，也可以指定一个范围。</span><br><span class="line">-c, 提取指定的字符，可以是以逗号分隔的数字的列表，也可以是以连字符分隔的数字的范围。</span><br><span class="line">–complement, 补充选中的部分，即**反选**。</span><br><span class="line">–output-delimiter, 修改输出时使用的分隔符。</span><br><span class="line">--only-delimited, 不输出不包含分隔符的列。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：打印出/etc/passwd文件每一行的第一个字段，用的分隔符是’:’</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -d:指定分隔符；-f指定打印第几个字段</span></span><br><span class="line">cut -d &#x27;:&#x27; -f 1 /etc/passwd</span><br><span class="line">或</span><br><span class="line">cut -d&#x27;:&#x27; -f1 /etc/passwd</span><br><span class="line">cut -d: -f1 /etc/passwd</span><br></pre></td></tr></table></figure><p>实例2：提取多个字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从 /etc/passwd 中包含字符串 /bin/bash 的行提取第一和第六个字段。</span></span><br><span class="line">grep &quot;/bin/bash&quot; /etc/passwd | cut -d&#x27;:&#x27; -f1,6</span><br><span class="line"><span class="meta">#</span><span class="bash"> 要显示字段的某个范围，可以指定开始和结束的字段，中间用连字符（-）连接，如下所示：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示1-4,6,7字段</span></span><br><span class="line">grep &quot;/bin/bash&quot; /etc/passwd | cut -d&#x27;:&#x27; -f1-4,6,7</span><br></pre></td></tr></table></figure><p>实例3：要补全选择输出的字段（即反选），使用 –complement 选项。这一选项输出所有的字段，除了指定的字段。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 要补全选择输出的字段（即反选），使用 --complement 选项。这一选项输出所有的字段，除了指定的字段。</span></span><br><span class="line">grep &quot;/bin/bash&quot; /etc/passwd | cut -d&#x27;:&#x27; --complement -f2</span><br></pre></td></tr></table></figure><p>实例4：指定输出的分隔符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加上--output-delimiter选项，将输出分隔符指定为空格</span></span><br><span class="line">cut -d: -f1,7 --output-delimiter &#x27; &#x27; /etc/passwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 用分隔符让每一行打印一个字段,将 --output-delimiter 指定为 $<span class="string">&#x27;\n&#x27;</span> 表换行。</span></span><br><span class="line">grep &quot;/bin/bash&quot; /etc/passwd | cut -d&#x27;:&#x27; -f1,6,7 --output-delimiter=$&#x27;\n&#x27;</span><br></pre></td></tr></table></figure><p>实例5：以字符的方式提取内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打印 context.txt 文件每一行的第一个字符</span></span><br><span class="line">cut -c 1 content.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印 context.txt 文件每一行的第一至七个字符</span></span><br><span class="line">cut -c 1-7 content.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提取第二个到最后一个字符</span></span><br><span class="line">cut -c 2- content.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 提取第一到第四个字符</span></span><br><span class="line">cut -c -4 content.txt</span><br></pre></td></tr></table></figure><p>实例6：根据字节提取</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用-b 选项通过指定字节的位置来选择一行的某一部分，使用逗号分隔每个指定位置，或用连字符 - 指定一个范围</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提取 content.txt 文件每一行的第一，二，三个字节</span></span><br><span class="line">cut -b 1,2,3 content.txt </span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出一个范围</span></span><br><span class="line">cut -b 1-3,5-7 content.txt </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-cp命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cp%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cp%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;cp(copy)命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 </p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cp [选项]... [-T] 源 目的</span><br><span class="line">或：cp [选项]... 源... 目录</span><br><span class="line">或：cp [选项]... -t 目录 源...</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;将源文件复制至目标文件，或将多个源文件复制至目标目录。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-a, 此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。</span><br><span class="line">-d, 复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。</span><br><span class="line">-f, 覆盖已经存在的目标文件而不给出提示。</span><br><span class="line">-i, 与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答&quot;y&quot;时目标文件将被覆盖。</span><br><span class="line">-p, 除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。</span><br><span class="line">-r, 若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。</span><br><span class="line">-l, 不复制文件，只是生成链接文件。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：复制单个文件到目标目录，文件在目标文件中不存在(在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp log.log test5</span><br></pre></td></tr></table></figure><p>实例2：目标文件存在时，会询问是否覆盖(目标文件存在时，会询问是否覆盖。这是因为cp是cp -i的别名。目标文件存在时，即使加了-f标志，也还会询问是否覆盖):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp log.log test5</span><br></pre></td></tr></table></figure><p>实例3：复制log.log建立一个连结档log_link.log(log_link.log是由-s的参数造成的，建立的是一个『快捷方式』，所以您会看到在文件的最右边，会显示这个文件是『连结』到哪里去):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp -s log.log log_link.log</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-cd命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cd%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cd%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux cd(CahngeDirectory)命令用于切换当前工作目录至 dirName(目录参数)。</p><h3 id="1-命令格式："><a href="#1-命令格式：" class="headerlink" title="1. 命令格式："></a>1. 命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd [dirName]</span><br></pre></td></tr></table></figure><p>dirName：要切换的目标目录。</p><p>其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</p><p>另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。</p><h3 id="2-命令功能："><a href="#2-命令功能：" class="headerlink" title="2. 命令功能："></a>2. 命令功能：</h3><p>&emsp;切换当前目录至dirName</p><h3 id="3-使用实例："><a href="#3-使用实例：" class="headerlink" title="3. 使用实例："></a>3. 使用实例：</h3><p>实例1：返回进入此目录之前所在的目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd -</span><br></pre></td></tr></table></figure><p>实例2：切换到用户主目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd ~</span><br></pre></td></tr></table></figure><p>实例3：把上个命令的参数作为cd参数使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd !$</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-cat命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cat%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cat%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;cat命令是Concatenate的缩写，cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 </p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat [选项] [文件]...</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;cat主要有三大功能：</p><ul><li>1.一次显示整个文件:cat filename</li><li>2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件.</li><li>3.将几个文件合并为一个文件:cat file1 file2 &gt; file</li></ul><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-A, --show-all           等价于 -vET</span><br><span class="line">-b, --number-nonblank    对非空输出行编号</span><br><span class="line">-e                       等价于 -vE</span><br><span class="line">-E, --show-ends          在每行结束处显示$</span><br><span class="line">-n, --number     对输出的所有行编号,由1开始对所有输出的行数编号</span><br><span class="line">-s, --squeeze-blank  有连续两行以上的空白行，就代换为一行的空白行 </span><br><span class="line">-t                       与 -vT 等价</span><br><span class="line">-T, --show-tabs          将TAB字符显示为 ^I</span><br><span class="line">-u                       (被忽略)</span><br><span class="line">-v, --show-nonprinting   使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：把log2020.log和log2021.log的文件内容加上行号后输出到控制台(空行会编号)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n log2020.log log2021.log </span><br></pre></td></tr></table></figure><p>实例2：把log2020.log和log2021.log的文件内容加上行号后输出到控制台(空行不会编号)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -b log2020.log log2021.log </span><br></pre></td></tr></table></figure><p>实例3：把log2021.log的文件内容加上行号后输入log.log这个文件里</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat -n log2021.log &gt; log.log</span><br></pre></td></tr></table></figure><p>实例4：使用here doc来生成文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;log.txt &lt;&lt;EOF</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在屏幕输入内容，最后</span></span><br></pre></td></tr></table></figure><p>实例5：<strong>tac</strong> (反向列示)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tac log.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line">tac是将cat反写过来，所以他的功能就跟cat相反，cat是由第一行到最后一行连续显示在萤幕上，而tac则是由最后一行到第一行反向在萤幕上显示出来！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-awk命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-awk%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-awk%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<a href="https://www.cnblogs.com/wangqiguo/p/5863266.html">awk</a>是一种处理<strong>文本文件的语言</strong>，是一个强大的<strong>文本分析工具</strong>。awk其实不仅仅是工具软件，还是一种<strong>编程</strong>语言。awk是以<strong>文件的一行内容</strong>为处理单位的。awk读取一行内容，然后根据指定条件判断是否处理此行内容，若此行文本符合条件，则按照动作处理文本，否则跳过此行文本，读取下一行进行判断。</p><p>&emsp;awk是”Aho Weiberger and Kernighan”三个作者的姓的第一个字母。</p><p>&emsp;由于awk天生提供对文件中文本分列进行处理，所以如果一个文件中的每行都被特定的<strong>分隔符</strong>(常见的是空格)隔开，我们可以将这个文件看成是由很多列的文本组成，这样的文件最适合用awk进行处理，其实awk在工作中很多时候被用来处理log文件，进行一些<strong>统计</strong>工作等。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">awk [选项] &#x27;BEGIN&#123;commands&#125; pattern&#123;commands&#125; END&#123;commands&#125;&#x27; file</span><br><span class="line"></span><br><span class="line">awk [选项] &#x27;脚本命令&#x27; 文件名</span><br></pre></td></tr></table></figure><blockquote><p>echo ‘1|2|3|4’ | awk -F ‘|’ ‘{print $3}’<br>echo | awk ‘{print “hello world!”}’</p></blockquote><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;awk是一种处理<strong>文本文件的语言</strong>，是一个强大的<strong>文本分析工具</strong>。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-F fs, 指定以fs作为输入行的分隔符，awk命令默认分隔符为空格或制表符。</span><br><span class="line">-f file, 从脚本文件中读取awk脚本指令，以取代直接在命令行中输入指令。</span><br><span class="line">-v var=val, 在执行处理过程之前，设置一个变量var，并给其设备初始值为val。</span><br><span class="line"></span><br><span class="line">Begin&#123;&#125;, 初始化代码块，在对每一行进行处理之前，初始化代码，主要是引用全局变量，设置FS分隔符</span><br><span class="line">//, 匹配代码块，可以是字符串或正则表达式</span><br><span class="line">&#123;&#125;, 命令代码块，包含一条或多条命令,多条命令用;隔开</span><br><span class="line">END&#123;&#125;, 结尾代码块，在对每一行进行处理之后再执行的代码块，主要是进行最终计算或输出结尾摘要信息</span><br></pre></td></tr></table></figure><h3 id="4．awk变量"><a href="#4．awk变量" class="headerlink" title="4．awk变量:"></a>4．awk变量:</h3><p>awk内建变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$0, 当前记录，当前行所有列</span><br><span class="line">$1~$n, 当前记录的第n个字段，字段间由FS分隔</span><br><span class="line">FS, 输入域分隔符，等价于命令行-F，默认为空格</span><br><span class="line">NF, 当前记录中的字段个数，就是有多少列，列总数，$NF则表示最后一列</span><br><span class="line">NR, 已经读取的记录数，就是第几行，从1开始</span><br><span class="line">FNR, 当前记录数</span><br><span class="line">RS, 控制记录分隔符，默认为换行符</span><br><span class="line">OFS, 输出字段分隔符 默认也是空格</span><br><span class="line">ARGC, 命令行参数个数</span><br><span class="line">ARGV, 命令行参数排列</span><br><span class="line">FILENAME awk浏览的文件名</span><br></pre></td></tr></table></figure><p>自定义变量类型:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo | awk &#x27;i=&quot;hello world&quot;&#123;print i&#125;&#x27;</span><br><span class="line">echo | awk &#x27;i=1122 &#123;print i&#125;&#x27;</span><br></pre></td></tr></table></figure><p>数组:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo | awk &#x27;&#123;a[1]=&quot;hello&quot;;a[2]=&quot;world!&quot;;print a[1],a[2]&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="5．awk常用逻辑运算"><a href="#5．awk常用逻辑运算" class="headerlink" title="5．awk常用逻辑运算"></a>5．awk常用逻辑运算</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">?                       条件表达操作符</span><br><span class="line">|| &amp;&amp; !                 并、与、非</span><br><span class="line">~  !~                   匹配操作符，包括匹配 不匹配</span><br><span class="line">\+ - * / % ^            算术操作符</span><br><span class="line">++ --                   前缀和后缀</span><br><span class="line">= += *= / = %= ^ =      赋值操作符 </span><br><span class="line">&lt; &lt;= == != &gt;= &gt;         关系操作符     </span><br><span class="line">BEGIN                   在输出界面第一行输出相关</span><br><span class="line">END                     在输出界面最后一行输出相关</span><br></pre></td></tr></table></figure><h3 id="6-awk条件判断"><a href="#6-awk条件判断" class="headerlink" title="6. awk条件判断"></a>6. awk条件判断</h3><p>1.直接在最外层:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;11 22&#x27; | awk &#x27;$1==11&#123;print $2&#125;&#x27;</span><br></pre></td></tr></table></figure><p>2.使用if语句:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;11 22&#x27; | awk &#x27;&#123;if($1==11) print $2&#125;&#x27;</span><br></pre></td></tr></table></figure><p>3.与或非:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 与</span></span><br><span class="line">echo &#x27;11 22&#x27; | awk &#x27;&#123;if(($1==11) &amp;&amp; ($2==22)) print $2&#125;&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">echo &#x27;11 22&#x27; | awk &#x27;&#123;if(($1==10) || ($2==22)) print $2&#125;&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 非</span></span><br><span class="line">echo &#x27;11 22&#x27; | awk &#x27;&#123;if($1!=10) print $2&#125;&#x27;</span><br></pre></td></tr></table></figure><p>4.匹配:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">~      模糊匹配</span><br><span class="line">==     精确匹配</span><br><span class="line">!~     不匹配</span><br><span class="line"><span class="meta">#</span><span class="bash"> 不懂？？？？？？为啥</span></span><br><span class="line">echo &#x27;ansible new switf&#x27; | awk &#x27;&#123;if($1 ~ i) print $1&#125;&#x27;</span><br><span class="line">echo &#x27;ansible new switf&#x27; | awk &#x27;&#123;if($1 !~ 0) print $1&#125;&#x27;</span><br></pre></td></tr></table></figure><p>5.正则匹配</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看包含root的行</span></span><br><span class="line">last |awk &#x27;/root/&#123;print $0&#125;&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看roo出现0次或多次的行</span></span><br><span class="line">last |awk &#x27;/roo*/&#123;print $0&#125;&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看已root开头的行</span></span><br><span class="line">last |awk &#x27;/^root /&#123;print $0&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="7-awk循环"><a href="#7-awk循环" class="headerlink" title="7. awk循环"></a>7. awk循环</h3><p><code>for(i=1;i&lt;=10;i++)</code>:类似C等语言的循环</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用awk将每行插入一个符号<span class="string">&quot;|&quot;</span>和tab建</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> NF:每一行所拥有的总字段数</span></span><br><span class="line">last |awk &#x27;&#123;for(i=1;i&lt;=NF;i++)&#123;printf $i &quot;|\t&quot;&#125; print &quot;&quot;&#125;&#x27;</span><br></pre></td></tr></table></figure><p><code>for(i in 数组)</code>:类似shell</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo|awk &#x27;BEGIN&#123;a[1]=1;a[2]=2&#125;END&#123;for(i in a) print i,a[i]&#125;&#x27;</span><br></pre></td></tr></table></figure><h3 id="8-常用内置函数"><a href="#8-常用内置函数" class="headerlink" title="8. 常用内置函数"></a>8. 常用内置函数</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gsub(r,s)          在整个$0中用s替代r，相当于sed &#x27;s///g&#x27;</span><br><span class="line">gsub(r,s,t)        在整个t中用s替代r</span><br><span class="line">index(s,t)         返回s中字符串t的第一位置</span><br><span class="line">length(s)          返回s长度</span><br><span class="line">match(s,r)         测试s是否包含匹配r的字符串</span><br><span class="line">split(s,a,fs)      在fs上将s分成序列a </span><br><span class="line">sprint(fmt,exp)    返回经fmt格式化后的exp</span><br><span class="line">sub(r,s)           用$0中最左边最长的子串代替s，相当于 sed &#x27;s///&#x27;</span><br><span class="line">substr(s,p)        返回字符串s中从p开始的后缀部分</span><br><span class="line">substr(s,p,n)      返回字符串s中从p开始长度为n的后缀部分</span><br></pre></td></tr></table></figure><h3 id="9-格式化输出"><a href="#9-格式化输出" class="headerlink" title="9.格式化输出"></a>9.格式化输出</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;printf  &quot;%-5s %.2d&quot;,$1,$2&#125;&#x27; file</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">printf 表示格式输出</span><br><span class="line">% 格式化输出分隔符</span><br><span class="line">-8 表示长度为8个字符</span><br><span class="line">s 表示字符串类型</span><br><span class="line">d 表示小数</span><br></pre></td></tr></table></figure><h3 id="10．使用实例："><a href="#10．使用实例：" class="headerlink" title="10．使用实例："></a>10．使用实例：</h3><p>实例1：打印指定倒数字段数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 利用NF打印倒数字段，比如打印倒数第2行</span></span><br><span class="line">last |awk &#x27;&#123;print $(NF-1)&#125;&#x27;</span><br></pre></td></tr></table></figure><p>实例2：打印文件第1000行到2000行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;1000&lt;=FNR &amp;&amp; FNR &lt;=2000&#x27; file</span><br><span class="line">awk &#x27;&#123;if(1000&lt;=FNR &amp;&amp; FNR&lt;=2000) print $0&#125;&#x27; file</span><br></pre></td></tr></table></figure><p>实例3：使用for循环、数组、自加对netstat的tcp状态统计</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -an |awk &#x27;/^tcp/ BEGIN&#123;s[$NF]++&#125; END&#123;for(a in s) print a,s[a]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>实例4：替换</p><p>eg: test.txt:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangsan 70 99 88 77 good</span><br><span class="line">lisi 90 77 66 88 good</span><br><span class="line">sansan 80 88 78 89 good</span><br></pre></td></tr></table></figure><p>命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">awk &#x27;&#123;if($2&gt;=90) gsub($NF,&quot;Very Good&quot;)&#125; &#123;print $0&#125;&#x27; test.txt</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">zhangsan 70 99 88 77 good</span><br><span class="line">lisi 90 77 66 88 Very Good</span><br><span class="line">sansan 80 88 78 89 good</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录操作命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-Linux文件属性详解</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7/Linux%E5%91%BD%E4%BB%A4-Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7/Linux%E5%91%BD%E4%BB%A4-Linux%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux文件或目录的属性主要包括：文件或目录的节点、种类、权限模式、链接数量、所归属的用户和用户组、最近访问或修改的时间等内容。具体情况如下：</p><p>命令：<code>ls -lih</code></p><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ls -lih</span><br><span class="line">总计 316K</span><br><span class="line">2095120 lrwxrwxrwx 1 root root   11 11-22 06:58 linklog.log -&gt; log2012.log</span><br><span class="line">2095112 -rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</span><br><span class="line">2095110 -rw-r--r-- 1 root root   61 11-13 06:03 log2013.log</span><br><span class="line">2095107 -rw-r--r-- 1 root root    0 11-13 06:03 log2014.log</span><br><span class="line">2095117 -rw-r--r-- 1 root root    0 11-13 06:06 log2015.log</span><br><span class="line">2095118 -rw-r--r-- 1 root root    0 11-16 14:41 log2016.log</span><br><span class="line">2095119 -rw-r--r-- 1 root root    0 11-16 14:43 log2017.log</span><br><span class="line">2095113 drwxr-xr-x 6 root root 4.0K 10-27 01:58 scf</span><br><span class="line">2095109 drwxrwxr-x 2 root root 4.0K 11-13 06:08 test3</span><br><span class="line">2095131 drwxrwxr-x 2 root root 4.0K 11-13 05:50 test4</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一列：inode</span><br><span class="line">第二列：文件种类和权限</span><br><span class="line">第三列：硬链接个数</span><br><span class="line">第四列：属主</span><br><span class="line">第五列：所归属的组</span><br><span class="line">第六列：文件或目录的大小</span><br><span class="line">第七列：最后访问时间</span><br><span class="line">第八列：最后修改时间</span><br><span class="line">第九列：文件名或目录名</span><br></pre></td></tr></table></figure><p>关于inode：</p><p>inode 译成中文就是<strong>索引节点</strong>。每个存储设备或存储设备的分区（存储设备是硬盘、软盘、U盘等等）被格式化为文件系统后，应该有两部份，一部份是inode，另一部份是Block，Block是用来存储数据用的。而inode呢，就是用来存储这些数据的信息，这些信息包括文件大小、属主、归属的用户组、读写权限等。inode为每个文件进行信息索引，所以就有了inode的数值。操作系统根据指令， 能通过inode值最快的找到相对应的文件。</p><p>做个比喻，比如一本书，存储设备或分区就相当于这本书，Block相当于书中的每一页，inode就相当于这本书前面的目录，一本书有很多的内容，如果想查找某部份的内容，我们可以先查目录，通过目录能最快的找到我们想要看的内容。虽然不太恰当，但还是比较形象。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录属性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-Linux文件类型与扩展名</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7/Linux%E5%91%BD%E4%BB%A4-Linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E5%90%8D/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7/Linux%E5%91%BD%E4%BB%A4-Linux%E6%96%87%E4%BB%B6%E7%B1%BB%E5%9E%8B%E4%B8%8E%E6%89%A9%E5%B1%95%E5%90%8D/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux文件类型和Linux文件的文件名所代表的意义是两个不同的概念。我们通过一般应用程序而创建的比如file.txt、file.tar.gz ，这些文件虽然要用不同的程序来打开，但放在Linux文件类型中衡量的话，大多是<strong>常规文件</strong>（也被称为<strong>普通文件</strong>）。</p><h3 id="一-文件类型"><a href="#一-文件类型" class="headerlink" title="一. 文件类型"></a>一. 文件类型</h3><p>&emsp;Linux文件类型常见的有：普通文件、目录文件、字符设备文件和块设备文件、符号链接文件等，现在我们进行一个简要的说明。</p><h4 id="1-普通文件"><a href="#1-普通文件" class="headerlink" title="1.普通文件:"></a>1.<strong>普通文件</strong>:</h4><p>我们用ls -lh来查看某个文件的属性，可以看到有类似-rwxrwxrwx，值得注意的是第一个符号是<code>-</code>，这样的文件在Linux中就是普通文件。这些文件一般是用一些相关的应用程序创建，比如图像工具、文档工具、归档工具…或cp工具等。这类文件的删除方式是用rm命令。另外，依照文件的内容，又大略可以分为：</p><ul><li>1.**纯文本档(ASCII)**：<br>这是Linux系统中最多的一种文件类型，称为纯文本档是因为内容为我们人类可以直接读到的数据，例如数字、字母等等。几乎只要我们可以用来做为设定的文件都属于这一种文件类型。举例来说，你可以用命令：<code>cat ~/.bashrc</code>来看到该文件的内容。 (cat是将一个文件内容读出来的指令).</li><li>2.**二进制文件(binary)**：<br>Linux系统其实仅认识且可以执行二进制文件(binary file)。Linux当中的可执行文件(scripts, 文字型批处理文件不算)就是这种格式的文件。刚刚使用的命令<code>cat</code>就是一个binary file。</li><li>3.**数据格式文件(data)**：<br>有些程序在运作的过程当中会读取某些特定格式的文件，那些特定格式的文件可以被称为数据文件 (data file)。举例来说，我们的Linux在使用者登录时，都会将登录的数据记录在 /var/log/wtmp那个文件内，该文件是一个data file，他能够透过last这个指令读出来！但是使用cat时，会读出乱码～因为他是属于一种特殊格式的文件？</li></ul><h4 id="2-目录文件"><a href="#2-目录文件" class="headerlink" title="2.目录文件:"></a>2.<strong>目录文件</strong>:</h4><p>当我们在某个目录下执行，看到有类似 drwxr-xr-x ，这样的文件就是目录，目录在Linux是一个比较特殊的文件。注意它的第一个字符是<code>d</code>。创建目录的命令可以用<code>mkdir</code>命令，或<code>cp</code>命令，cp可以把一个目录复制为另一个目录。删除用<code>rm</code>或<code>rmdir</code>命令。 </p><h4 id="3-字符设备或块设备文件"><a href="#3-字符设备或块设备文件" class="headerlink" title="3.字符设备或块设备文件:"></a>3.<strong>字符设备或块设备文件</strong>:</h4><p>如时您进入/dev目录，列一下文件，会看到类似如下的:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -al /dev/tty</span><br><span class="line">crw-rw-rw- 1 root tty 5, 0 11-03 15:11 /dev/tty</span><br><span class="line">[root@localhost ~]# ls -la /dev/sda1</span><br><span class="line">brw-r----- 1 root disk 8, 1 11-03 07:11 /dev/sda1</span><br></pre></td></tr></table></figure><p>我们看到/dev/tty的属性是 crw-rw-rw- ，注意前面第一个字符是<code>c</code>，这表示<strong>字符设备文件</strong>。比如猫等串口设备。</p><p>我们看到 /dev/sda1 的属性是 brw-r—– ，注意前面的第一个字符是<code>b</code>，这表示<strong>块设备</strong>，比如硬盘，光驱等设备。</p><p>这个种类的文件，是用<code>mknode</code>来创建，用<code>rm</code>来删除。目前在最新的Linux发行版本中，我们一般不用自己来创建设备文件。因为这些文件是和内核相关联的。</p><p>与系统周边及储存等相关的一些文件，通常都集中在/dev这个目录之下！通常又分为两种：</p><p><strong>区块(block)设备档 ：</strong></p><p>就是一些储存数据，以提供系统随机存取的接口设备，举例来说，硬盘与软盘等就是啦！ 你可以随机的在硬盘的不同区块读写，这种装置就是成组设备！你可以自行查一下/dev/sda看看，会发现第一个属性为<code>[ b ]</code>。</p><p><strong>字符(character)设备文件：</strong></p><p>亦即是一些串行端口的接口设备，例如键盘、鼠标等等！这些设备的特色就是一次性读取的，不能够截断输出。举例来说，你不可能让鼠标跳到另一个画面，而是滑动到另一个地方！第一个属性为<code>[ c ]</code>。</p><h4 id="4-数据接口文件-sockets-："><a href="#4-数据接口文件-sockets-：" class="headerlink" title="4. 数据接口文件(sockets)："></a>4. 数据接口文件(sockets)：</h4><p><strong>数据接口文件</strong>（或者：套接口文件），这种类型的文件通常被用在网络上的数据承接了。我们可以启动一个程序来监听客户端的要求，而客户端就可以透过这个socket来进行数据的沟通了。第一个属性为<code>[ s ]</code>，最常在/var/run这个目录中看到这种文件类型了。</p><p>例如：当我们启动MySQL服务器时，会产生一个mysql.sock的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ls -lh /var/lib/mysql/mysql.sock </span><br><span class="line">srwxrwxrwx 1 mysql mysql 0 04-19 11:12 /var/lib/mysql/mysql.sock</span><br></pre></td></tr></table></figure><p>注意这个文件的属性的第一个字符是<code>s</code>。</p><h4 id="5-符号链接文件："><a href="#5-符号链接文件：" class="headerlink" title="5. 符号链接文件："></a>5. 符号链接文件：</h4><p>当我们查看文件属性时，会看到有类似 lrwxrwxrwx,注意第一个字符是l，这类文件是<strong>链接文件</strong>。是通过<code>ln -s 源文件名 新文件名</code>。上面是一个例子，表示setup.log是install.log的软链接文件。怎么理解呢？这和Windows操作系统中的快捷方式有点相似。</p><p>符号链接文件的创建方法举例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ls -lh log2012.log</span><br><span class="line">-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</span><br><span class="line">[root@localhost test]# ln -s log2012.log  linklog.log</span><br><span class="line">[root@localhost test]# ls -lh *.log</span><br><span class="line">lrwxrwxrwx 1 root root   11 11-22 06:58 linklog.log -&gt; log2012.log</span><br><span class="line">-rw-r--r-- 1 root root 296K 11-13 06:03 log2012.log</span><br></pre></td></tr></table></figure><h4 id="6-数据输送文件（FIFO-pipe）"><a href="#6-数据输送文件（FIFO-pipe）" class="headerlink" title="6. 数据输送文件（FIFO,pipe）:"></a>6. 数据输送文件（FIFO,pipe）:</h4><p>FIFO也是一种特殊的文件类型，他主要的目的在解决多个程序同时存取一个文件所造成的错误问题。 FIFO是first-in-first-out的缩写。第一个属性为<code>[p]</code>。</p><h3 id="二-Linux文件扩展名"><a href="#二-Linux文件扩展名" class="headerlink" title="二. Linux文件扩展名"></a>二. Linux文件扩展名</h3><h4 id="1-扩展名类型"><a href="#1-扩展名类型" class="headerlink" title="1. 扩展名类型"></a>1. 扩展名类型</h4><p>基本上，Linux的文件是<strong>没有所谓的扩展名</strong>的，一个Linux文件能不能被执行，与他的第一栏的十个属性有关，与档名根本一点关系也没有。这个观念跟Windows的情况不相同喔！在Windows底下,能被执行的文件扩展名通常是<code>.com .exe .bat</code>等等，而在Linux底下，只要你的权限当中具有x的话，例如<code>[-rwx-r-xr-x]</code>即代表这个文件可以被执行。</p><p>不过，<strong>可以被执行跟可以执行成功是不一样</strong>的～举例来说，在root家目录下的install.log 是一个纯文本档，如果经由修改权限成为<code>-rwxrwxrwx</code>后，这个文件能够真的执行成功吗？ 当然不行～因为他的内容根本就没有可以执行的数据。所以说，这个x代表这个文件<strong>具有可执行的能力</strong>，但是能不能执行成功，当然就得要看该文件的内容.</p><p>虽然如此，不过我们仍然希望<strong>可以藉由扩展名来了解该文件是什么东西</strong>，所以，通常我们还是会以适当的扩展名来表示该文件是什么种类的。底下有数种常用的扩展名：</p><p><code>*.sh</code>：脚本或批处理文件(scripts)，因为批处理文件为使用shell写成的，所以扩展名就编成<code>.sh</code> </p><p><code>*Z, *.tar, *.tar.gz, *.zip, *.tgz</code>：经过打包的压缩文件。这是因为压缩软件分别为 gunzip, tar 等等的，由于不同的压缩软件，而取其相关的扩展名！</p><p><code>*.html, *.php</code>：网页相关文件，分别代表HTML语法与PHP语法的网页文件。<code>.html</code>的文件可使用网页浏览器来直接开启，至于<code>.php</code>的文件，则可以透过client端的浏览器来server端浏览，以得到运算后的网页结果。</p><p>基本上，Linux系统上的文件名真的只是让你了解该文件可能的用途而已，真正的执行与否仍然需要权限的规范才行。例如虽然有一个文件为可执行文件，如常见的/bin/ls这个显示文件属性的指令，不过，如果这个文件的权限被修改成无法执行时，那么ls就变成不能执行。</p><p>上述的这种问题最常发生在文件传送的过程中。例如你在网络上下载一个可执行文件，但是偏偏在你的Linux系统中就是无法执行！呵呵！那么就是可能文件的属性被改变了。不要怀疑，从网络上传送到你的Linux系统中，文件的属性与权限确实是会被改变的。</p><h4 id="2-Linux文件名长度限制："><a href="#2-Linux文件名长度限制：" class="headerlink" title="2. Linux文件名长度限制："></a>2. Linux文件名长度限制：</h4><p>在Linux底下，使用预设的Ext2/Ext3文件系统时，针对文件名长度限制为：</p><p>单一文件或目录的最大容许文件名为 255 个字符</p><p>包含完整路径名称及目录 (/) 之完整档名为 4096 个字符</p><p>是相当长的档名！我们希望Linux的文件名可以一看就知道该文件在干嘛的，所以档名通常是很长很长。</p><h4 id="3-Linux文件名的字符的限制："><a href="#3-Linux文件名的字符的限制：" class="headerlink" title="3. Linux文件名的字符的限制："></a>3. Linux文件名的字符的限制：</h4><p>由于Linux在文字接口下的一些指令操作关系，一般来说，你在设定Linux底下的文件名时，最好可以避免一些特殊字符比较好！例如底下这些：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* ? &gt; &lt; ; &amp; ! [ ] | \ &#x27; &quot; ` ( ) &#123; &#125;</span><br></pre></td></tr></table></figure><p>因为这些符号在文字接口下，是<strong>有特殊意义</strong>的。另外，文件名的开头为小数点“.”时， 代表这个文件为<strong>隐藏文件</strong>！同时，由于指令下达当中，常常会使用到<code>-option</code>之类的选项，所以你最好也避免将文件档名的开头以<code>-</code>或<code>+</code>来命名。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录属性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-Linux目录结构</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7/Linux%E5%91%BD%E4%BB%A4-Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E5%92%8C%E7%9B%AE%E5%BD%95%E5%B1%9E%E6%80%A7/Linux%E5%91%BD%E4%BB%A4-Linux%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<p>&emsp;根据<a href="http://www.pathname.com/fhs/">FHS</a>(Filesystem Hierarchy Standard)的官方文件指出，他们的主要目的是希望让使用者可以了解到已安装软件通常放置于那个目录下，所以他们希望独立的软件开发商、操作系统制作者、以及想要维护系统的用户，都能够遵循FHS的标准。也就是说，FHS的重点在于规范每个特定的目录下应该要放置什么样子的数据而已。这样做好处非常多，因为Linux操作系统就能够在既有的面貌下(目录架构不变)发展出开发者想要的独特风格。</p><p>&emsp;事实上，FHS是根据过去的经验一直再持续的改版的，FHS依据文件系统使用的频繁与否与是否允许使用者随意更动，而将目录定义成为四种交互作用的形态，用表格来说有点像底下这样：</p><table class="tg">  <tr>    <th class="tg-0pky"></th>    <th class="tg-0pky">可分享的(shareable)</th>    <th class="tg-0pky">不可分享的(unshareable)</th>  </tr>  <tr>    <td class="tg-c3ow" rowspan="2">不变的(static)</td>    <td class="tg-0pky">/usr (软件放置处)</td>    <td class="tg-0pky">/etc (配置文件)</td>  </tr>  <tr>    <td class="tg-0pky">/opt (第三方协力软件)</td>    <td class="tg-0pky">/boot (开机与核心档)</td>  </tr>  <tr>    <td class="tg-c3ow" rowspan="2">可变动的(variable)</td>    <td class="tg-0pky">/var/mail (使用者邮件信箱)</td>    <td class="tg-0pky">/var/run (程序相关)</td>  </tr>  <tr>    <td class="tg-0pky">/var/spool/news (新闻组)</td>    <td class="tg-0pky">/var/lock (程序相关)</td>  </tr></table><p>四种类型:</p><ul><li>可分享的：<br>&emsp;可以分享给其他系统挂载使用的目录，所以包括执行文件与用户的邮件等数据，是能够分享给网络上其他主机挂载用的目录；</li><li>不可分享的：<br>&emsp;自己机器上面运作的装置文件或者是与程序有关的socket文件等，由于仅与自身机器有关，所以当然就不适合分享给其他主机了。</li><li>不变的：<br>&emsp;有些数据是不会经常变动的，跟随着distribution而不变动。例如函式库、文件说明文件、系统管理员所管理的主机服务配置文件等等；</li><li>可变动的：<br>&emsp;经常改变的数据，例如登录文件、一般用户可自行收受的新闻组等。</li></ul><p>事实上，FHS针对目录树架构仅定义出三层目录底下应该放置什么数据而已，分别是底下这三个目录的定义：</p><ul><li><code>/</code> (root, 根目录)：与开机系统有关；</li><li><code>/usr</code> (unix software resource)：与软件安装/执行有关；</li><li><code>/var</code> (variable)：与系统运作过程有关。</li></ul><h3 id="一-根目录-的意义与内容："><a href="#一-根目录-的意义与内容：" class="headerlink" title="一. 根目录 (/) 的意义与内容："></a>一. 根目录 (/) 的意义与内容：</h3><p>&emsp;根目录是整个系统最重要的一个目录，因为不但所有的目录都是由根目录衍生出来的，同时根目录也与开机/还原/系统修复等动作有关。由于系统开机时需要特定的开机软件、核心文件、开机所需程序、函式库等等文件数据，若系统出现错误时，根目录也必须要包含有能够修复文件系统的程序才行。因为根目录是这么的重要，所以在FHS的要求方面，他希望根目录不要放在非常大的分区，因为越大的分区内你会放入越多的数据，如此一来根目录所在分区就可能会有较多发生错误的机会。</p><p>&emsp;因此FHS标准建议：根目录(/)所在分区应该越小越好，且应用程序所安装的软件最好不要与根目录放在同一个分区内，保持根目录越小越好。如此不但效能较佳，根目录所在的文件系统也较不容易发生问题。说白了，就是根目录和Windows的C盘一个样。</p><p>&emsp;根据以上原因，FHS认为根目录(/)下应该包含如下子目录：<br>| 目录 | 应放置档案内容 |<br>|—|—|<br>| /bin | 系统有很多放置执行档的目录，但/bin比较特殊。因为/bin放置的是在单人维护模式下还能够被操作的指令。在/bin底下的指令可以被root与一般帐号所使用，主要有：cat,chmod(修改权限), chown, date, mv, mkdir, cp, bash等等常用的指令。 |<br>| /boot | 主要放置开机会使用到的档案，包括Linux核心档案以及开机选单与开机所需设定档等等。Linux kernel常用的档名为：vmlinuz ，如果使用的是grub这个开机管理程式，则还会存在/boot/grub/这个目录。 |<br>| /dev | 在Linux系统上，任何装置与周边设备都是以档案的型态存在于这个目录当中。 只要通过存取这个目录下的某个档案，就等于存取某个装置。比要重要的档案有/dev/null, /dev/zero, /dev/tty , /dev/lp*, / dev/hd*, /dev/sd*等等 |<br>| /etc | 系统主要的<strong>设定档</strong>几乎都放置在这个目录内，例如人员的帐号密码档、各种服务的启始档等等。 一般来说，这个目录下的各档案属性是可以让一般使用者查阅的，但是只有root有权力修改。 FHS建议不要放置可执行档(binary)在这个目录中。 比较重要的档案有：/etc/inittab, /etc/init.d/, /etc/modprobe.conf, /etc/X11/, /etc/fstab, /etc/sysconfig/等等。 另外，其下重要的目录有：/etc/init.d/ ：所有服务的预设启动script都是放在这里的，例如要启动或者关闭iptables的话： /etc/init.d/iptables start、/etc/init.d/ iptables stop/etc/xinetd.d/ ：这就是所谓的super daemon管理的各项服务的设定档目录。/etc/X11/ ：与X Window有关的各种设定档都在这里，尤其是xorg.conf或XF86Config这两个X Server的设定档。 |<br>| /home | 这是系统预设的使用者家目录(home directory)。 在你新增一个一般使用者帐号时，预设的使用者家目录都会规范到这里来。比较重要的是，家目录有两种代号： ~ ：代表当前使用者的家目录，而 ~guest：则代表用户名为guest的家目录。 |<br>| /lib | 系统的函式库非常的多，而/lib放置的则是在开机时会用到的函式库，以及在/bin或/sbin底下的指令会呼叫的函式库而已 。 什么是函式库呢？妳可以将他想成是外挂，某些指令必须要有这些外挂才能够顺利完成程式的执行之意。 尤其重要的是/lib/modules/这个目录，因为该目录会放置核心相关的模组(驱动程式)。 |<br>| /media | media是媒体的英文，顾名思义，这个/media底下放置的就是可移除的装置。 包括软碟、光碟、DVD等等装置都暂时挂载于此。 常见的档名有：/media/floppy, /media/cdrom等等。 |<br>| /mnt | 如果妳想要暂时挂载某些额外的装置，一般建议妳可以放置到这个目录中。在古早时候，这个目录的用途与/media相同啦。 只是有了/media之后，这个目录就用来暂时挂载用了。 |<br>| /opt | 这个是给第三方协力软体放置的目录 。 什么是第三方协力软体啊？举例来说，KDE这个桌面管理系统是一个独立的计画，不过他可以安装到Linux系统中，因此KDE的软体就建议放置到此目录下了。 另外，如果妳想要自行安装额外的软体(非原本的distribution提供的)，那么也能够将你的软体安装到这里来。 不过，以前的Linux系统中，我们还是习惯放置在/usr/local目录下。 |<br>| /root | 系统管理员(root)的家目录。 之所以放在这里，是因为如果进入单人维护模式而仅挂载根目录时，该目录就能够拥有root的家目录，所以我们会希望root的家目录与根目录放置在同一个分区中。 |<br>| /sbin | Linux有非常多指令是用来设定系统环境的，这些指令只有root才能够利用来设定系统，其他使用者最多只能用来查询而已。放在/sbin底下的为开机过程中所需要的，里面包括了开机、修复、还原系统所需要的指令。至于某些伺服器软体程式，一般则放置到/usr/sbin/当中。至于本机自行安装的软体所产生的系统执行档(system binary)，则放置到/usr/local/sbin/当中了。常见的指令包括：fdisk, fsck, ifconfig, init, mkfs等等。 |<br>| /srv | srv可以视为service的缩写，是一些网路服务启动之后，这些服务所需要取用的资料目录。 常见的服务例如WWW, FTP等等。 举例来说，WWW伺服器需要的网页资料就可以放置在/srv/www/里面。呵呵，看来平时我们编写的代码应该放到这里了。 |<br>| /tmp | 这是让一般使用者或者是正在执行的程序暂时放置档案的地方。这个目录是任何人都能够存取的，所以你需要定期的清理一下。当然，重要资料不可放置在此目录啊。 因为FHS甚至建议在开机时，应该要将/tmp下的资料都删除。 |<br>事实上FHS针对根目录所定义的标准就仅限于上表，不过仍旧有些目录也需要我们了解一下，具体如下：<br>| 目录 | 应放置文件内容 |<br>|—–|—-|<br>| /lost+found | 这个目录是使用标准的ext2/ext3档案系统格式才会产生的一个目录，目的在于当档案系统发生错误时，将一些遗失的片段放置到这个目录下。 这个目录通常会在分割槽的最顶层存在，例如你加装一个硬盘于/disk中，那在这个系统下就会自动产生一个这样的目录/disk/lost+found |<br>| /proc | 这个目录本身是一个虚拟文件系统(virtual filesystem)喔。 他放置的资料都是在内存当中，例如系统核心、行程资讯(process)（是进程吗?）、周边装置的状态及网络状态等等。因为这个目录下的资料都是在记忆体（内存）当中，所以本身不占任何硬盘空间。比较重要的档案（目录）例如： /proc/cpuinfo, /proc/dma, /proc/interrupts, /proc/ioports, /proc/net/*等等。呵呵，是虚拟内存吗[guest]？ |<br>| /sys | 这个目录其实跟/proc非常类似，也是一个虚拟的档案系统，主要也是记录与核心相关的资讯。 包括目前已载入的核心模组与核心侦测到的硬体装置资讯等等。 这个目录同样不占硬盘容量。 |</p><p>除了这些目录的内容之外，另外要注意的是，因为根目录与开机有关，开机过程中仅有根目录会被挂载，其他分区则是在开机完成之后才会持续的进行挂载的行为。就是因为如此，因此根目录下与开机过程有关的目录，就不能够与根目录放到不同的分区去。那哪些目录不可与根目录分开呢？有底下这些：</p><ul><li>/etc：配置文件</li><li>/bin：重要执行档</li><li>/dev：所需要的装置文件</li><li>/lib：执行档所需的函式库与核心所需的模块</li><li>/sbin：重要的系统执行文件</li></ul><p>这五个目录千万不可与根目录分开在不同的分区。请背下来啊。 </p><h3 id="二-usr-的意义与内容："><a href="#二-usr-的意义与内容：" class="headerlink" title="二. /usr 的意义与内容："></a>二. /usr 的意义与内容：</h3><p>&emsp;依据FHS的基本定义，/usr里面放置的数据属于可分享的与不可变动的(shareable, static)， 如果你知道如何透过网络进行分区的挂载(例如在服务器篇会谈到的NFS服务器)，那么/usr确实可以分享给局域网络内的其他主机来使用喔。</p><p>&emsp;/usr不是user的缩写，其实usr是Unix Software Resource的缩写， 也就是Unix操作系统软件资源所放置的目录，而不是用户的数据啦。这点要注意。 FHS建议所有软件开发者，应该将他们的数据合理的分别放置到这个目录下的次目录，而不要自行建立该软件自己独立的目录。</p><p>&emsp;因为是所有系统默认的软件(distribution发布者提供的软件)都会放置到/usr底下，因此这个目录有点类似Windows 系统的C:\Windows\ + C:\Program files\这两个目录的综合体，系统刚安装完毕时，这个目录会占用最多的硬盘容量。 一般来说，/usr的次目录建议有底下这些：<br>| 目录 | 应放置文件内容 |<br>|———-|———–|<br>| /usr/X11R6/ | 为X Window System重要数据所放置的目录，之所以取名为X11R6是因为最后的X版本为第11版，且该版的第6次释出之意。 |<br>| /usr/bin/ | 绝大部分的用户可使用指令都放在这里。请注意到他与/bin的不同之处。(是否与开机过程有关) |<br>| /usr/include/ | c/c++等程序语言的档头(header)与包含档(include)放置处，当我们以tarball方式 (*.tar.gz 的方式安装软件)安装某些数据时，会使用到里头的许多包含档。 |<br>| /usr/lib/ | 包含各应用软件的函式库、目标文件(object file)，以及不被一般使用者惯用的执行档或脚本(script)。 某些软件会提供一些特殊的指令来进行服务器的设定，这些指令也不会经常被系统管理员操作， 那就会被摆放到这个目录下啦。要注意的是，如果你使用的是X86_64的Linux系统， 那可能会有/usr/lib64/目录产生 |<br>| /usr/local/ | 系统管理员在本机自行安装自己下载的软件(非distribution默认提供者)，建议安装到此目录， 这样会比较便于管理。举例来说，你的distribution提供的软件较旧，你想安装较新的软件但又不想移除旧版， 此时你可以将新版软件安装于/usr/local/目录下，可与原先的旧版软件有分别啦。 你可以自行到/usr/local去看看，该目录下也是具有bin, etc, include, lib…的次目录 |<br>| /usr/sbin/ | 非系统正常运作所需要的系统指令。最常见的就是某些网络服务器软件的服务指令(daemon) |<br>| /usr/share/ | 放置共享文件的地方，在这个目录下放置的数据几乎是不分硬件架构均可读取的数据， 因为几乎都是文本文件嘛。在此目录下常见的还有这些次目录：/usr/share/man：联机帮助文件/usr/share/doc：软件杂项的文件说明/usr/share/zoneinfo：与时区有关的时区文件 |<br>| /usr/src/ | 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 |</p><h3 id="三-var-的意义与内容："><a href="#三-var-的意义与内容：" class="headerlink" title="三.  /var 的意义与内容："></a>三.  /var 的意义与内容：</h3><p>&emsp;如果/usr是安装时会占用较大硬盘容量的目录，那么/var就是在系统运作后才会渐渐占用硬盘容量的目录。 因为/var目录主要针对常态性变动的文件，包括缓存(cache)、登录档(log file)以及某些软件运作所产生的文件， 包括程序文件(lock file, run file)，或者例如MySQL数据库的文件等等。常见的次目录有：<br>| 目录 | 应放置文件内容 |<br>|———|———-|<br>| /var/cache/ | 应用程序本身运作过程中会产生的一些暂存档 |<br>| /var/lib/ | 程序本身执行的过程中，需要使用到的数据文件放置的目录。在此目录下各自的软件应该要有各自的目录。 举例来说，MySQL的数据库放置到/var/lib/mysql/而rpm的数据库则放到/var/lib/rpm去 |<br>| /var/lock/ | 某些装置或者是文件资源一次只能被一个应用程序所使用，如果同时有两个程序使用该装置时， 就可能产生一些错误的状况，因此就得要将该装置上锁(lock)，以确保该装置只会给单一软件所使用。 举例来说，刻录机正在刻录一块光盘，你想一下，会不会有两个人同时在使用一个刻录机烧片？ 如果两个人同时刻录，那片子写入的是谁的数据？所以当第一个人在刻录时该刻录机就会被上锁， 第二个人就得要该装置被解除锁定(就是前一个人用完了)才能够继续使用 |<br>| /var/log/ | 非常重要。这是登录文件放置的目录。里面比较重要的文件如/var/log/messages, /var/log/wtmp(记录登入者的信息)等。 |<br>| /var/mail/ | 放置个人电子邮件信箱的目录，不过这个目录也被放置到/var/spool/mail/目录中，通常这两个目录是互为链接文件。 |<br>| /var/run/ | 某些程序或者是服务启动后，会将他们的PID放置在这个目录下 |<br>| /var/spool/ | 这个目录通常放置一些队列数据，所谓的“队列”就是排队等待其他程序使用的数据。 这些数据被使用后通常都会被删除。举例来说，系统收到新信会放置到/var/spool/mail/中， 但使用者收下该信件后该封信原则上就会被删除。信件如果暂时寄不出去会被放到/var/spool/mqueue/中， 等到被送出后就被删除。如果是工作排程数据(crontab)，就会被放置到/var/spool/cron/目录中。 |<br>| /usr/src/ | 一般原始码建议放置到这里，src有source的意思。至于核心原始码则建议放置到/usr/src/linux/目录下。 |</p><p>由于FHS仅是定义出最上层(/)及次层(/usr, /var)的目录内容应该要放置的文件或目录数据， 因此，在其他次目录层级内，就可以随开发者自行来配置了。</p><h3 id="四-目录树-directory-tree"><a href="#四-目录树-directory-tree" class="headerlink" title="四. 目录树(directory tree) :"></a>四. 目录树(directory tree) :</h3><p>&emsp;在Linux底下，所有的文件与目录都是由根目录开始的。那是所有目录与文件的源头, 然后再一个一个的分支下来，因此，我们也称这种目录配置方式为：目录树(directory tree), 这个目录树的主要特性有：</p><p>&emsp;目录树的启始点为根目录 (/, root)；</p><p>&emsp;每一个目录不止能使用本地端的 partition 的文件系统，也可以使用网络上的 filesystem 。举例来说， 可以利用 Network File System (NFS) 服务器挂载某特定目录等。</p><p>&emsp;每一个文件在此目录树中的文件名(包含完整路径)都是独一无二的。</p><p>&emsp;如果我们将整个目录树以图的方法来显示，并且将较为重要的文件数据列出来的话，那么目录树架构就如下图所示：</p><p><img src="https://i.loli.net/2021/04/28/4PJlBTRjkwSqeLQ.png" alt="linux目录树.png"></p><h4 id="五-绝对路径与相对路径"><a href="#五-绝对路径与相对路径" class="headerlink" title="五. 绝对路径与相对路径"></a>五. 绝对路径与相对路径</h4><p>&emsp;除了需要特别注意的FHS目录配置外，在文件名部分我们也要特别注意。因为根据档名写法的不同，也可将所谓的路径(path)定义为绝对路径(absolute)与相对路径(relative)。 这两种文件名/路径的写法依据是这样的：</p><p><strong>绝对路径：</strong></p><p>&emsp;由根目录(/)开始写起的文件名或目录名称， 例如 /home/dmtsai/.bashrc；</p><p><strong>相对路径：</strong></p><p>&emsp;相对于目前路径的文件名写法。 例如 ./home/dmtsai 或 <a href="http://www.cnblogs.com/home/lxy/">http://www.cnblogs.com/home/lxy/</a> 等等。反正开头不是 / 就属于相对路径的写法</p><p>&emsp;而你必须要了解，相对路径是以你当前所在路径的相对位置来表示的。举例来说，你目前在 /home 这个目录下， 如果想要进入 /var/log 这个目录时，可以怎么写呢？</p><p>cd /var/log   (absolute)</p><p>cd ../var/log (relative)</p><p>因为你在/home底下，所以要回到上一层(../)之后，才能继续往/var来移动的，特别注意这两个特殊的目录：</p><p><code>.</code>：代表当前的目录，也可以使用 ./ 来表示；</p><p><code>..</code>：代表上一层目录，也可以 ../ 来代表。</p><p>这个 <code>.</code> 与 <code>..</code> 目录概念是很重要的，你常常会看到 <code>cd ..</code> 或 <code>./</code>command 之类的指令下达方式， 就是代表上一层与目前所在目录的工作状态。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件和目录属性 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-压缩解压常用命令合集</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%8E%8B%E7%BC%A9%E8%A7%A3%E5%8E%8B%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%90%88%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h3 id="归总"><a href="#归总" class="headerlink" title="归总"></a>归总</h3><ul><li>压缩<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">tar -cvf jpg.tar *.jpg      //打包成jpg.tar </span><br><span class="line">tar -czf jpg.tar.gz *.jpg   //打包成jpg.tar后，并用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz</span><br><span class="line">tar -cjf jpg.tar.bz2 *.jpg  //打包成jpg.tar后，并用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2</span><br><span class="line">tar -cZf jpg.tar.Z *.jpg    //打包成jpg.tar后，并用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z</span><br><span class="line">rar a jpg.rar *.jpg         //rar格式的压缩，需要先下载rar for linux</span><br><span class="line">zip jpg.zip *.jpg           //zip格式的压缩，需要先下载zip for linux</span><br></pre></td></tr></table></figure></li><li>解压缩<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">*.tar          用 tar -xvf 解压</span><br><span class="line">*.tar.gz/*.tgz 用 tar -zxvf 解压</span><br><span class="line">*.tar.bz2      用 tar -xjf 解压</span><br><span class="line">*.tar.Z        用 tar -xZf 解压</span><br><span class="line">*.gz           用 gzip -d 或者 gunzip 解压</span><br><span class="line">*.bz2          用 bzip2 -d 或者 bunzip2 解压</span><br><span class="line">*.Z            用 uncompress 解压</span><br><span class="line">*.rar          用 unrar e解压</span><br><span class="line">*.zip          用 unzip 解压</span><br></pre></td></tr></table></figure></li></ul><h3 id="tar"><a href="#tar" class="headerlink" title=".tar"></a>.tar</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">打包：tar cvf FileName.tar DirName</span><br><span class="line">解包：tar xvf FileName.tar</span><br><span class="line">（注：tar是打包，不是压缩！） </span><br></pre></td></tr></table></figure><h3 id="tar-gz-和-tgz"><a href="#tar-gz-和-tgz" class="headerlink" title=".tar.gz 和 .tgz"></a>.tar.gz 和 .tgz</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解压：tar zxvf FileName.tar.gz </span><br><span class="line">压缩：tar zcvf FileName.tar.gz DirName </span><br></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title=".zip"></a>.zip</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解压：unzip FileName.zip </span><br><span class="line"><span class="meta">#</span><span class="bash"> -r表示递归打包包含子目录的全部内容,-q表示安静模式</span></span><br><span class="line">压缩：zip -r -q FileName.zip DirName </span><br></pre></td></tr></table></figure><h3 id="tar-bz2"><a href="#tar-bz2" class="headerlink" title=".tar.bz2"></a>.tar.bz2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解压：tar jxvf FileName.tar.bz2 </span><br><span class="line">压缩：tar jcvf FileName.tar.bz2 DirName </span><br></pre></td></tr></table></figure><h3 id="tar-bz"><a href="#tar-bz" class="headerlink" title=".tar.bz"></a>.tar.bz</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解压：tar jxvf FileName.tar.bz </span><br><span class="line">压缩：未知 </span><br></pre></td></tr></table></figure><h3 id="tar-Z"><a href="#tar-Z" class="headerlink" title=".tar.Z"></a>.tar.Z</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解压：tar Zxvf FileName.tar.Z </span><br><span class="line">压缩：tar Zcvf FileName.tar.Z DirName </span><br></pre></td></tr></table></figure><h3 id="gz"><a href="#gz" class="headerlink" title=".gz"></a>.gz</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解压1：gunzip FileName.gz </span><br><span class="line">解压2：gzip -d FileName.gz </span><br><span class="line">压缩：gzip FileName</span><br></pre></td></tr></table></figure><h3 id="bz2"><a href="#bz2" class="headerlink" title=".bz2"></a>.bz2</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解压1：bzip2 -d FileName.bz2 </span><br><span class="line">解压2：bunzip2 FileName.bz2 </span><br><span class="line">压缩： bzip2 -z FileName</span><br></pre></td></tr></table></figure><h3 id="bz"><a href="#bz" class="headerlink" title=".bz"></a>.bz</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">解压1：bzip2 -d FileName.bz </span><br><span class="line">解压2：bunzip2 FileName.bz </span><br><span class="line">压缩：未知</span><br></pre></td></tr></table></figure><h3 id="Z"><a href="#Z" class="headerlink" title=".Z"></a>.Z</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解压：uncompress FileName.Z </span><br><span class="line">压缩：compress FileName </span><br></pre></td></tr></table></figure><h3 id="rar"><a href="#rar" class="headerlink" title=".rar"></a>.rar</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">解压：rar x FileName.rar </span><br><span class="line">压缩：rar a FileName.rar DirName </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件打包上传和下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-xz命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-xz%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-xz%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;xz压缩/解压</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xz [参数] [文件或者目录]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;以.xz格式压缩或解压缩文件,文件后缀为’.xz’。</p><ul><li>安装xz命令:<ul><li><code>yum install epel-release -y</code></li><li><code>yum install xz -y</code></li></ul></li></ul><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-z, --compress      强制压缩</span><br><span class="line">-d, --decompress    强制解压</span><br><span class="line">-t, --test          测试压缩文件完整性</span><br><span class="line">-l, --list          列出有关文件的信息</span><br><span class="line">-k, --keep          保留（不删除）输入文件</span><br><span class="line">-f, --force         强制覆盖输出文件和（取消）压缩链接</span><br><span class="line">-c, --stdout        写入标准输出，不删除输入文件</span><br><span class="line">-0 .. -9            压缩预设；0-2快速压缩，3-5良好</span><br><span class="line">                    压缩，6-9极好的压缩；默认值为6</span><br><span class="line">-e, --extreme       编码时使用更多的CPU时间来增加压缩</span><br><span class="line">                    不增加解码器内存使用率的比率</span><br><span class="line">-q, --quiet         取消警告；指定两次也可以取消错误</span><br><span class="line">-v, --verbose       详细；为更详细的内容指定两次</span><br><span class="line">-h, --help          显示此简短帮助</span><br><span class="line">-H, --long-help     显示长帮助（同时列出高级选项）</span><br><span class="line">-V, --version       显示版本号</span><br></pre></td></tr></table></figure><h3 id="4．常用命令："><a href="#4．常用命令：" class="headerlink" title="4．常用命令："></a>4．常用命令：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xz -z test.txt      压缩文件</span><br><span class="line">xz -d test.txt.xz   解压文件</span><br><span class="line">xz test.txt         压缩文件</span><br><span class="line">unxz test.txt.xz    解压文件</span><br><span class="line">xzcat test.txt.xz   查看文件内容</span><br></pre></td></tr></table></figure><p>压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方法一：也是用到两步命令，首先利用 tar 命令将 linux-3.12 文件夹打包成 linux-3.12.tar，其次用 xz-utils 的 xz 命令将 linux-3.12.tar 压缩成 linux-3.12.tar.xz。</span></span><br><span class="line">tar -cf linux-3.12.tar linux-3.12/</span><br><span class="line">xz -z linux-3.12.tar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法二（推荐）</span></span><br><span class="line">tar -Jcf linux-3.12.tar.xz linux-3.12/</span><br></pre></td></tr></table></figure><p>解压：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 方法一：需要用到两步命令，首先利用 xz-utils 的 xz 命令将 linux-3.12.tar.xz 解压为 linux-3.12.tar，其次用 tar 命令将 linux-3.12.tar 完全解压。</span></span><br><span class="line">xz -d linux-3.12.tar.xz</span><br><span class="line">tar -xf linux-3.12.tar</span><br><span class="line"><span class="meta">#</span><span class="bash"> 方法二（推荐）</span></span><br><span class="line">tar -Jxf linux-3.12.tar.xz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件打包上传和下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-tar打包命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-tar%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-tar%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;通过SSH访问服务器，难免会要用到压缩，解压缩，打包，解包等，这时候tar命令就是是必不可少的一个功能强大的工具。linux中最流行的tar是麻雀虽小，五脏俱全，功能强大。</p><p>&emsp;tar命令可以为linux的文件和目录创建档案。利用tar，可以为某一特定文件创建档案（<strong>备份</strong>文件），也可以<strong>在档案中改变文件</strong>，或者<strong>向档案中加入新的文件</strong>。tar最初被用来在磁带上创建档案，现在，用户可以在任何设备上创建档案。利用tar命令，可以把一大堆的文件和目录全部打包成一个文件，这对于备份文件或将几个文件组合成为一个文件以便于网络传输是非常有用的。</p><p>&emsp;首先要弄清两个概念：<strong>打包</strong>和<strong>压缩</strong>。</p><p>&emsp;<strong>打包</strong>是指将一大堆文件或目录变成一个总的文件</p><p>&emsp;<strong>压缩</strong>则是将一个大的文件通过一些压缩算法变成一个小文件。</p><p>&emsp;为什么要区分这两个概念呢？这源于Linux中很多压缩程序只能针对一个文件进行压缩，这样当你想要压缩一大堆文件时，你得先将这一大堆文件先打成一个包（tar命令），然后再用压缩程序进行压缩（gzip bzip2命令）。</p><p>linux下最常用的<strong>打包</strong>程序就是<code>tar</code>了，使用tar程序打出来的包我们常称为<code>tar包</code>，tar包文件的命令通常都是以<code>.tar</code>结尾的。生成tar包后，就可以用其它的程序来进行压缩。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [必要参数] [选择参数] [文件] </span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用来<em>压缩</em>和<em>解压</em>文件。tar<strong>本身不具有压缩功能</strong>。他是调用压缩功能实现的 </p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p>必要参数有如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-A, 新增压缩文件到已存在的压缩</span><br><span class="line">-B, 设置区块大小</span><br><span class="line">-c, 建立新的压缩文件</span><br><span class="line">-d, 记录文件的差别</span><br><span class="line">-r, 添加文件到已经压缩的文件</span><br><span class="line">-u, 添加改变了和现有的文件到已经存在的压缩文件</span><br><span class="line">-x, 从压缩的文件中提取文件</span><br><span class="line">-t, 显示压缩文件的内容</span><br><span class="line">-z, 支持gzip解压文件</span><br><span class="line">-j, 支持bzip2解压文件</span><br><span class="line">-Z, 支持compress解压文件</span><br><span class="line">-v, 显示操作过程</span><br><span class="line">-l, 文件系统边界设置</span><br><span class="line">-k, 保留原有文件不覆盖</span><br><span class="line">-m, 保留文件不被覆盖</span><br><span class="line">-N&lt;日期格式&gt;, 只将较指定日期更新的文件保存到备份文件里。</span><br><span class="line">-W, 确认压缩文件的正确性</span><br></pre></td></tr></table></figure><p>可选参数如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-b, 设置区块数目</span><br><span class="line">-C, 切换到指定目录</span><br><span class="line">-f, 指定压缩文件</span><br><span class="line">--help, 显示帮助信息</span><br><span class="line">--version, 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例"><a href="#4．使用实例" class="headerlink" title="4．使用实例"></a>4．使用实例</h3><p>实例1：将文件全部打包成tar包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 仅打包，不压缩</span></span><br><span class="line">tar -cvf log.tar log2021.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打包后，以gzip压缩</span></span><br><span class="line">tar -zcvf log.tar.gz log2021.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打包后，以bzip2压缩</span></span><br><span class="line">tar -jcvf log.tar.bz2 log2021.log</span><br><span class="line"><span class="meta">#</span><span class="bash"> 在参数f之后的文件档名是自己取的，我们习惯上都用.tar来作为辨识。</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果加z参数，则以.tar.gz或.tgz来代表gzip压缩过的tar包</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果加j参数，则以.tar.bz2来作为tar包名。</span></span><br></pre></td></tr></table></figure><p>实例2：查阅tar包内有哪些文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 由于使用gzip压缩的log.tar.gz，所以要查阅log.tar.gz包内的文件时，就得要加上z这个参数了。</span></span><br><span class="line">tar -ztvf log.tar.gz</span><br></pre></td></tr></table></figure><p>实例3：将tar包解压缩：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在预设的情况下，我们可以将压缩档在任何地方解开</span></span><br><span class="line">tar -zxvf log.tar.gz</span><br></pre></td></tr></table></figure><p>实例4：只将tar包内的部分文件解压出来:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf log30.tar.gz log2021.log</span><br></pre></td></tr></table></figure><p>实例5：文件备份下来，并且保存其权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这个-p的属性是很重要的，尤其是当您要保留原本文件的属性时</span></span><br><span class="line">tar -zcvpf log31.tar.gz log2019.log log2020.log log2021.log </span><br></pre></td></tr></table></figure><p>实例6：在文件夹当中，比某个日期新的文件才备份:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -N &quot;2021/04/28&quot; -zcvf log17.tar.gz test</span><br></pre></td></tr></table></figure><p>实例7：备份文件夹内容时排除部分文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar --exclude scf/service -zcvf scf.tar.gz scf/*</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件打包上传和下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-sz&amp;rz命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-sz&amp;rz%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-sz&amp;rz%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h3 id="安装lrzsz-rz-sz"><a href="#安装lrzsz-rz-sz" class="headerlink" title="安装lrzsz(rz/sz)"></a>安装lrzsz(rz/sz)</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">执行以下命令：</span></span><br><span class="line">yum install lrzsz -y</span><br></pre></td></tr></table></figure><h3 id="离线方式安装lrzsz"><a href="#离线方式安装lrzsz" class="headerlink" title="离线方式安装lrzsz"></a>离线方式安装lrzsz</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、下载 lrzsz-1.12.20.tar.gz</span><br><span class="line">http://www.filewatcher.com/m/lrzsz-0.12.20.tar.gz.280938.0.0.html</span><br><span class="line">2、解压文件:tar zxvf lrzsz-1.12.20.tar.gz</span><br><span class="line">3、进入目录 :cd lrzsz-1.12.20</span><br><span class="line">4、./configure --prefix=/usr/local/lrzsz</span><br><span class="line">5、make&amp;make install</span><br><span class="line">6、建立软链接</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">cd</span> /usr/bin</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ln -s /usr/<span class="built_in">local</span>/lrzsz/bin/lrz rz</span></span><br><span class="line"><span class="meta">#</span><span class="bash">ln -s /usr/<span class="built_in">local</span>/lrzsz/bin/lsz sz</span></span><br><span class="line">7、测试: 运行 rz 弹出上传窗口</span><br></pre></td></tr></table></figure><h3 id="1-rz命令"><a href="#1-rz命令" class="headerlink" title="1.rz命令"></a>1.rz命令</h3><p>rz命令(Receive ZMODEM)，使用ZMODEM协议，将本地文件批量上传到远程Linux/Unix服务器，注意不能上传文件夹。</p><p>当我们使用虚拟终端软件，如Xshell、SecureCRT或PuTTY来连接远程服务器后，使用rz命令可以上传本地文件到远程服务器。输入rz回车后，会出现文件选择对话框，选择需要上传文件，一次可以指定多个文件，上传到服务器的路径为当前执行rz命令的目录。</p><p>此外，可以在虚拟终端软件设置上传时默认加载的本地路径和下载的路径。如SecureCRT软件 -&gt; Options -&gt; session options -&gt; X/Y/Zmodem 下可以设置上传和下载的目录。</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rz [选项]</span><br></pre></td></tr></table></figure><p>选项说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-+, --append:将文件内容追加到已存在的同名文件</span><br><span class="line">-a,--ascii:以文本方式传输</span><br><span class="line">-b, --binary:以二进制方式传输，推荐使用</span><br><span class="line">--delay-startup N:等待N秒</span><br><span class="line">-e, --escape:对所有控制字符转义，建议使用</span><br><span class="line">-E, --rename:已存在同名文件则重命名新上传的文件，以点和数字作为后缀</span><br><span class="line">-p, --protect:对ZMODEM协议有效，如果目标文件已存在则跳过 -</span><br><span class="line">q, --quiet:安静执行，不输出提示信息</span><br><span class="line">-v, --verbose:输出传输过程中的提示信息</span><br><span class="line">-y, --overwrite:存在同名文件则替换</span><br><span class="line">-X, --xmodem:使用XMODEM协议</span><br><span class="line">--ymodem:使用YMODEM协议</span><br><span class="line">-Z, --zmodem:使用ZMODEM协议</span><br><span class="line">--version：显示版本信息</span><br><span class="line">--h, --help：显示帮助信息</span><br></pre></td></tr></table></figure><h3 id="2-sz命令"><a href="#2-sz命令" class="headerlink" title="2.sz命令"></a>2.sz命令</h3><p>sz命令(Send ZMODEM)通过ZMODEM协议，可将多个文件从远程服务器下载到本地。注意不能下载文件夹，如果下载文件夹，请先打包再下载</p><p>命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rz [选项] [filelist]</span><br></pre></td></tr></table></figure><p>命令选项基本与rz相同，请参考上文rz的命令选项或者sz的manual，或者运行命令sz -h查看。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件打包上传和下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-gzip命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-gzip%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%89%93%E5%8C%85%E4%B8%8A%E4%BC%A0%E5%92%8C%E4%B8%8B%E8%BD%BD/Linux%E5%91%BD%E4%BB%A4-gzip%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;减少文件大小有两个明显的好处，一是可以减少存储空间，二是通过网络传输文件时，可以减少传输的时间。gzip是在Linux系统中经常使用的一个对文件进行<strong>压缩</strong>和<strong>解压缩</strong>的命令，既方便又好用。gzip不仅可以用来压缩大的、较少使用的文件以节省磁盘空间，还可以和tar命令一起构成Linux操作系统中比较流行的压缩文件格式。据统计，gzip命令对文本文件有60%～70%的压缩率。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip [参数] [文件或者目录]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;gzip是个使用广泛的压缩程序，文件经它压缩过后，其名称后面会多出<code>.gz</code>的扩展名。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">-a或--ascii, 使用ASCII文字模式。 </span><br><span class="line">-c或--stdout或--to-stdout, 把压缩后的文件输出到标准输出设备，不去更动原始文件。</span><br><span class="line">-d或--decompress, 解开压缩文件。 </span><br><span class="line">-f或--force, 强行压缩文件。不理会文件名称或硬连接是否存在以及该文件是否为符号连接。 </span><br><span class="line">-l或--list, 列出压缩文件的相关信息。 </span><br><span class="line">-n或--no-name, 压缩文件时，不保存原来的文件名称及时间戳记。 </span><br><span class="line">-N或--name, 压缩文件时，保存原来的文件名称及时间戳记。 </span><br><span class="line">-q或--quiet, 不显示警告信息。 </span><br><span class="line">-r或--recursive, 递归处理，将指定目录下的所有文件及子目录一并处理。 </span><br><span class="line">-S&lt;压缩字尾字符串&gt;或----suffix&lt;压缩字尾字符串&gt;, 更改压缩字尾字符串。 </span><br><span class="line">-t或--test, 测试压缩文件是否正确无误。 </span><br><span class="line">-v或--verbose, 显示指令执行过程。 </span><br><span class="line">-num, 用指定的数字num调整压缩的速度，-1或--fast表示最快压缩方法（低压缩比），-9或--best表示最慢压缩方法（高压缩比）。系统缺省值为6。 </span><br><span class="line">-h或--help, 在线帮助。 </span><br><span class="line">-L或--license, 显示版本与版权信息。</span><br><span class="line">-V或--version, 显示版本信息。 </span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：把当前目录下的每个文件都压缩成.gz文件(压缩后每个文件都说一个压缩包)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip *</span><br></pre></td></tr></table></figure><p>实例2：把实例1中每个压缩的文件解压，并列出详细的信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dv *</span><br></pre></td></tr></table></figure><p>实例3：详细显示实例1中每个压缩的文件的信息，并不解压:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -l *</span><br></pre></td></tr></table></figure><p>实例4：压缩一个tar备份文件，此时压缩文件的扩展名为.tar.gz</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -r log.tar</span><br></pre></td></tr></table></figure><p>实例5：递归的压缩目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这样，所有<span class="built_in">test</span>下面的文件都变成了*.gz，目录依然存在只是目录里面的文件相应变成了*.gz.这就是压缩，和打包不同。因为是对目录操作，所以需要加上-r选项，这样也可以对子目录进行递归了。</span> </span><br><span class="line">gzip -rv lxy</span><br></pre></td></tr></table></figure><p>实例6：递归地解压目录:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip -dr lxy</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件打包上传和下载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-which命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-which%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-which%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索：<br>&emsp;&emsp;which：查看可执行文件的位置。<br>&emsp;&emsp;whereis：查看文件的位置。<br>&emsp;&emsp;locate:配合数据库查看文件位置。<br>&emsp;&emsp;find:实际搜寻硬盘查询文件名称。  </p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">which 可执行文件名称 </span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-n, 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。</span><br><span class="line">-p, 与-n参数相同，但此处的包括了文件的路径。</span><br><span class="line">-w, 指定输出时栏位的宽度。</span><br><span class="line">-V, 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：查找文件、显示命令路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">which pwd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line">which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！</span><br></pre></td></tr></table></figure><p>实例2：用which去找出which:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">which which</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line">竟然会有两个 which ，其中一个是 alias 这就是所谓的『命令别名』，意思是输入 which 会等於后面接的那串命令！</span><br></pre></td></tr></table></figure><p>实例3：找出cd这个命令:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">which cd</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line">cd 这个常用的命令可能会找不到！为什么呢？这是因为cd是bash内建的命令！但是 which默认是找PATH内所规范的目录，所以当然可能找不到！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件查找命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-whereis命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-whereis%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-whereis%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;whereis命令只能用于<strong>程序名</strong>的搜索，而且只搜索<strong>二进制文件</strong>（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p><p>&emsp;和find相比，whereis查找的速度非常快，这是因为linux系统会将系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通过遍历硬盘来查找，效率自然会很高。 </p><p>&emsp;但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 </p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis [-bmsu] [BMS 目录名 -f ] 文件名</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;whereis命令是定位<strong>可执行文件</strong>、<strong>源代码文件</strong>、<strong>帮助文件</strong>在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-b, 定位可执行文件。</span><br><span class="line">-m, 定位帮助文件。</span><br><span class="line">-s, 定位源代码文件。</span><br><span class="line">-u, 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。</span><br><span class="line">-B, 指定搜索可执行文件的路径。</span><br><span class="line">-M, 指定搜索帮助文件的路径。</span><br><span class="line">-S, 指定搜索源代码文件的路径。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：将和**文件相关的文件都查找出来:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis svn</span><br></pre></td></tr></table></figure><p>实例2：只将<strong>二进制文件</strong>查找出来: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -b svn</span><br></pre></td></tr></table></figure><p>实例3：查出说明文档路径:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -m svn</span><br></pre></td></tr></table></figure><p>实例4：找source源文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis -s svn</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件查找命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-locate命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-locate%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-locate%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;locate让使用者可以很快速的搜寻<strong>档案系统内</strong>是否有指定的<strong>档案</strong>。其方法是先建立一个包括系统内所有<strong>档案名称及路径</strong>的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的distribution之中，数据库的建立都被放在<code>crontab</code>中自动执行。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Locate [选择参数] [样式]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;locate命令可以在搜寻数据库时快速找到档案，数据库由<code>updatedb</code>程序来更新，<code>updatedb</code>是由<code>cron daemon</code>周期性建立的，locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案如果是最近才建立或刚更名的，可能会找不到，在内定值中，<code>updatedb</code>每天会跑一次，可以由修改<code>crontab</code>来更新设定值。(etc/crontab)</p><p>&emsp;locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录，可以使用特殊字元（如”*”或”?”等）来指定范本样式，如指定范本为<code>kcpa*ner</code>, locate会找出所有起始字串为kcpa且结尾为ner的档案或目录，如名称为kcpartner若目录录名称为kcpa_ner则会列出该目录下包括 子目录在内的所有档案。</p><p>&emsp;locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库，在执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立即修改索引数据库。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-e, 将排除在寻找的范围之外。</span><br><span class="line">-1, 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到 的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的 权限资料。</span><br><span class="line">-f, 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案 放在资料库中。</span><br><span class="line">-q, 安静模式，不会显示任何错误讯息。</span><br><span class="line">-n, 至多显示 n个输出。</span><br><span class="line">-r, 使用正规运算式 做寻找的条件。</span><br><span class="line">-o, 指定资料库存的名称。</span><br><span class="line">-d, 指定资料库的路径</span><br><span class="line">-h, 显示辅助讯息</span><br><span class="line">-V, 显示程式的版本讯息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：查找和pwd相关的所有文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate pwd</span><br></pre></td></tr></table></figure><p>实例2：搜索etc目录下所有以m开头的文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">locate /etc/m</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件查找命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-find命令之xargs</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%E4%B9%8Bxargs/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%E4%B9%8Bxargs/</url>
      
        <content type="html"><![CDATA[<p>&emsp;在使用find命令的-exec选项处理匹配到的文件时，find命令将所有匹配到的文件一起传递给exec执行。但有些系统对能够传递给exec的命令长度有限制，这样在find命令运行几分钟之后，就会出现溢出错误。错误信息通常是“<strong>参数列太长</strong>”或“<strong>参数列溢出</strong>”。这就是<code>xargs</code>命令的用处所在，特别是与find命令一起使用。  </p><p>&emsp;find命令把匹配到的文件传递给xargs命令，而xargs命令<strong>每次只获取一部分文件而不是全部</strong>，不像-exec选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。  </p><p>&emsp;在有些系统中，使用-exec选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高； </p><p>&emsp;而使用xargs命令则<strong>只有一个进程</strong>。另外，在使用xargs命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。</p><h3 id="使用实例："><a href="#使用实例：" class="headerlink" title="使用实例："></a>使用实例：</h3><p>实例1：查找系统中的每一个普通文件，然后使用xargs命令来测试它们分别属于哪类文件: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -print | xargs file</span><br></pre></td></tr></table></figure><p>实例2：在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &quot;core&quot; -print | xargs echo &quot;&quot; &gt;/tmp/core.log</span><br></pre></td></tr></table></figure><p>实例3：在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -perm -7 -print | xargs chmod o-w</span><br></pre></td></tr></table></figure><p>实例4：用grep命令在所有的普通<strong>文件中</strong>搜索hostname这个词</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -print | xargs grep &quot;hostname&quot;</span><br></pre></td></tr></table></figure><p>实例5：用grep命令在当前目录下的所有普通<strong>文件中</strong>搜索hostnames这个词</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> \用来取消find命令中的*在shell中的特殊含义。</span></span><br><span class="line">find . -name \* -type f -print | xargs grep &quot;hostnames&quot;</span><br></pre></td></tr></table></figure><p>实例6：使用xargs执行mv </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.log&quot; | xargs -i mv &#123;&#125; test4</span><br></pre></td></tr></table></figure><p>实例7：find后执行xargs提示xargs: argument line too long解决方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -l1是一次处理一个；-t是处理之前打印出命令</span></span><br><span class="line">find . -type f -atime +0 -print0 | xargs -0 -l1 -t rm -f</span><br></pre></td></tr></table></figure><p>实例8：使用-i参数默认的前面输出用{}代替，-I参数可以指定其他代替字符，如例子中的[]</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;file&quot; | xargs -I [] cp [] ..</span><br></pre></td></tr></table></figure><p>实例9：xargs的-p参数的使用: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -p参数会提示让你确认是否执行后面的命令,y执行,n不执行。</span></span><br><span class="line">find . -name &quot;*.log&quot; | xargs -p -i mv &#123;&#125; ..</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件查找命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-find命令之exec</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%E4%B9%8Bexec/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%E4%B9%8Bexec/</url>
      
        <content type="html"><![CDATA[<p>&emsp;find是我们很常用的一个Linux命令，但是我们一般查找出来的并不仅仅是看看而已，还会有进一步的操作，这个时候<code>exec</code>的作用就显现出来了。 </p><h3 id="exec解释："><a href="#exec解释：" class="headerlink" title="exec解释："></a>exec解释：</h3><p><code>-exec</code> 参数后面跟的是command命令，它的终止是以<code>;</code>为结束标志的，所以这句命令后面的分号是<strong>不可缺少</strong>的，考虑到各个系统中分号会有不同的意义，所以前面加反斜杠。</p><p><code>&#123;&#125;</code> 花括号代表<strong>前面find查找出来的文件名</strong>。</p><p>使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的。在有些操作系统中只允许-exec选项执行诸如l s或ls -l这样的命令。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行rm命令删除文件之前，最好先用ls命令看一下，确认它们是所要删除的文件。 </p><p>exec选项后面跟随着所要执行的命令或脚本，然后是一对<code>&#123; &#125;</code>，一个<code>空格</code>和一个<code>\</code>，最后是一个<code>分号</code>。为了使用exec选项，必须要同时使用print选项。如果验证一下find命令，会发现该命令只输出从当前路径起的相对路径及文件名。</p><p>任何形式的命令都可以在-exec选项中使用。</p><h3 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例:"></a>使用实例:</h3><p>实例1：ls -l命令放在find命令的-exec选项中(find命令匹配到了当前目录下的所有普通文件，并在-exec选项中使用ls -l命令将它们列出。) </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -exec ls -l &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>实例2：在目录中查找更改时间在n天以前的文件并删除它们</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -mtime +14 -exec rm &#123;&#125; \; </span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line">在shell中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如mv或rm命令时，可以使用-exec选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。</span><br></pre></td></tr></table></figure><p>实例3：在目录中查找更改时间在n天以前的文件并删除它们，在删除之前先给出提示</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.log&quot; -mtime +5 -ok rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>实例4：在find的-exec中使用grep命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc -name &quot;passwd*&quot; -exec grep &quot;root&quot; &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>实例5：查找文件移动到指定目录（将当前目录下的*.log文件移动到上一层目录）：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.log&quot; -exec mv &#123;&#125; .. \;</span><br></pre></td></tr></table></figure><p>实例6：用exec选项执行cp命令（将当前目录下的*.log文件复制到test3目录中）  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.log&quot; -exec cp &#123;&#125; test3 \;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件查找命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-find命令参数详解</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4%E7%9A%84%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>&emsp;find一些常用参数的一些常用实例和一些具体用法和注意事项。</p><h3 id="1．使用-name选项："><a href="#1．使用-name选项：" class="headerlink" title="1．使用-name选项："></a>1．使用-name选项：</h3><p>&emsp;文件名选项是find命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。  </p><p>&emsp;可以使用某种文件名模式来匹配文件，记住要用<strong>引号</strong>将文件名模式引起来。 </p><p>&emsp;不管当前路径是什么，如果想要在自己的根目录<code>$HOME</code>中查找文件名符合<code>*.log</code>的文件，使用<code>~</code>作为<code>&#39;pathname&#39;</code>参数，波浪号<code>~</code>代表了你的<code>$HOME</code>目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -name &quot;*.log&quot; -print  </span><br></pre></td></tr></table></figure><p>想要在当前目录及子目录中查找所有的’*.log’文件，可以用： </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.log&quot; -print  </span><br></pre></td></tr></table></figure><p>想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;[A-Z]*&quot; -print  </span><br></pre></td></tr></table></figure><p>想要在/etc目录中查找文件名以host开头的文件，可以用：  </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc -name &quot;host*&quot; -print  </span><br></pre></td></tr></table></figure><p>想要查找$HOME目录中的文件，可以用：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find ~ -name &quot;*&quot; -print</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或</span></span><br><span class="line">find . -print  </span><br></pre></td></tr></table></figure><p>要想让系统高负荷运行，就从根目录开始查找所有的文件。  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &quot;*&quot; -print  </span><br></pre></td></tr></table></figure><p>如果想在当前目录查找文件名以一个个小写字母开头，最后是4到9加上.log结束的文件：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;[a-z]*[4-9].log&quot; -print</span><br></pre></td></tr></table></figure><h3 id="2．用-perm选项："><a href="#2．用-perm选项：" class="headerlink" title="2．用-perm选项："></a>2．用-perm选项：</h3><p>&emsp;按照文件权限模式用-perm选项,按文件<strong>权限</strong>模式来查找文件的话。最好使用<strong>八进制的权限表示法</strong>。  </p><p>如在当前目录下查找文件权限位为755的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -perm 755 -print</span><br></pre></td></tr></table></figure><p>还有一种表达方法：在八进制数字前面要加一个横杠-，表示都匹配，如-007就相当于777，-005相当于555,</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -perm -005</span><br></pre></td></tr></table></figure><h3 id="3．使用-prune选项："><a href="#3．使用-prune选项：" class="headerlink" title="3．使用-prune选项："></a>3．使用-prune选项：</h3><p>&emsp;如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用<code>-prune</code>选项来<strong>指出需要忽略的目录</strong>。在使用-prune选项时要当心，因为如果你同时使用了<code>-depth</code>选项，那么<code>-prune</code>选项就会被find命令忽略。</p><p>如果希望在test目录下查找文件，但不希望在test/test3目录下查找：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">find test -path &quot;test/test3&quot; -prune -o -print</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明：</span></span><br><span class="line">find [-path ..] [expression] </span><br><span class="line">在路径列表的后面的是表达式 </span><br><span class="line">-path &quot;test&quot; -prune -o -print 是 -path &quot;test&quot; -a -prune -o -print 的简写表达式按顺序求值, -a 和 -o 都是短路求值，与 shell 的 &amp;&amp; 和 || 类似如果 </span><br><span class="line"></span><br><span class="line">-path &quot;test&quot; 为真，则求值-prune, -prune返回真，与逻辑表达式为真；否则不求值 -prune，与逻辑表达式为假。如果-path &quot;test&quot; -a -prune为假，则求值-print，-print返回真，或逻辑表达式为真；否则不求值 -print，或逻辑表达式为真。 </span><br><span class="line"></span><br><span class="line">这个表达式组合特例可以用伪码写为:</span><br><span class="line">if -path &quot;test&quot; then  </span><br><span class="line">    -prune  </span><br><span class="line">else  </span><br><span class="line">    -print  </span><br></pre></td></tr></table></figure><p><strong>避开多个文件夹</strong>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 圆括号表示表达式的结合。</span>  </span><br><span class="line"><span class="meta">#</span><span class="bash"> \ 表示引用，即指示shell不对后面的字符作特殊解释，而留给find命令去解释其意义。</span></span><br><span class="line">find test \( -path test/test4 -o -path test/test3 \) -prune -o -print </span><br></pre></td></tr></table></figure><p>查找某一确定文件，-name等选项加在-o之后</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find test \(-path test/test4 -o -path test/test3 \) -prune -o -name &quot;*.log&quot; -print</span><br></pre></td></tr></table></figure><h3 id="4．使用user和nouser选项："><a href="#4．使用user和nouser选项：" class="headerlink" title="4．使用user和nouser选项："></a>4．使用user和nouser选项：</h3><p>按<strong>文件属主</strong>查找文件：</p><p>在$HOME目录中查找文件属主为lxy的文件 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find ~ -user lxy -print  </span><br></pre></td></tr></table></figure><p>在/etc目录下查找文件属主为lxy的文件: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc -user lxy -print  </span><br></pre></td></tr></table></figure><p>为了查找属主帐户已经被删除的文件，可以使用-nouser选项。在/home目录下查找所有的这类文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find /home -nouser -print</span><br><span class="line"><span class="meta">#</span><span class="bash"> 说明</span></span><br><span class="line">这样就能够找到那些属主在/etc/passwd文件中没有有效帐户的文件。在使用-nouser选项时，不必给出用户名； find命令能够为你完成相应的工作。</span><br></pre></td></tr></table></figure><h3 id="5．使用group和nogroup选项："><a href="#5．使用group和nogroup选项：" class="headerlink" title="5．使用group和nogroup选项："></a>5．使用group和nogroup选项：</h3><p>就像user和nouser选项一样，针对文件<strong>所属于的用户组</strong>， find命令也具有同样的选项.</p><p>为了在/apps目录下查找属于gem用户组的文件，可以用：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /apps -group gem -print  </span><br></pre></td></tr></table></figure><p>要查找<strong>没有有效所属用户组</strong>的所有文件，可以使用nogroup选项。下面的find命令从文件系统的根目录处查找这样的文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -nogroup-print</span><br></pre></td></tr></table></figure><h3 id="6．按照更改时间或访问时间等查找文件："><a href="#6．按照更改时间或访问时间等查找文件：" class="headerlink" title="6．按照更改时间或访问时间等查找文件："></a>6．按照更改时间或访问时间等查找文件：</h3><p>如果希望按照<strong>更改时间</strong>来查找文件，可以使用mtime,atime,ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用mtime选项来查找这样的文件。  </p><p>用减号-来限定更改时间在距今n日<strong>以内</strong>的文件，而用加号+来限定更改时间在距今n日<strong>以前</strong>的文件。  </p><p>希望在系统根目录下查找更改时间在5日以内的文件，可以用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -mtime -5 -print</span><br></pre></td></tr></table></figure><p>为了在/var/adm目录下查找更改时间在3日以前的文件，可以用:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /var/adm -mtime +3 -print</span><br></pre></td></tr></table></figure><h3 id="7．查找比某个文件新或旧的文件："><a href="#7．查找比某个文件新或旧的文件：" class="headerlink" title="7．查找比某个文件新或旧的文件："></a>7．查找比某个文件新或旧的文件：</h3><p>如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用<code>-newer</code>选项。</p><p>它的一般形式为：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newest_file_name ! oldest_file_name  </span><br></pre></td></tr></table></figure><p>其中，！是逻辑非符号。  </p><p>查找更改时间比文件log2012.log新但比文件log2017.log旧的文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -newer log2012.log ! -newer log2017.log</span><br></pre></td></tr></table></figure><p>查找更改时间在比log2012.log文件新的文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -newer log2012.log -print</span><br></pre></td></tr></table></figure><h3 id="8．使用type选项："><a href="#8．使用type选项：" class="headerlink" title="8．使用type选项："></a>8．使用type选项：</h3><p>在/etc目录下查找所有的目录  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc -type d -print  </span><br></pre></td></tr></table></figure><p>在当前目录下查找除目录<strong>以外</strong>的所有类型的文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . ! -type d -print</span><br></pre></td></tr></table></figure><p>在/etc目录下查找所有的符号链接文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /etc -type l -print</span><br></pre></td></tr></table></figure><h3 id="9．使用size选项："><a href="#9．使用size选项：" class="headerlink" title="9．使用size选项："></a>9．使用size选项：</h3><p>可以按照<strong>文件长度</strong>来查找文件，这里所指的文件长度既可以用块（block）来计量，也可以用字节来计量。以字节计量文件长度的表达形式为N c；以块计量文件长度只用数字表示即可。  </p><p>在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。  </p><p>在当前目录下查找文件长度<strong>大于</strong>1 M字节的文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -size +1000000c -print</span><br></pre></td></tr></table></figure><p>在/home/apache目录下查找文件长度<strong>恰好</strong>为100字节的文件:  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /home/apache -size 100c -print  </span><br></pre></td></tr></table></figure><p>在当前目录下查找长度超过10块的文件（一块等于512字节） </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -size +10 -print</span><br></pre></td></tr></table></figure><h3 id="10．使用depth选项："><a href="#10．使用depth选项：" class="headerlink" title="10．使用depth选项："></a>10．使用depth选项：</h3><p>在使用find命令时，可能希望<strong>先匹配所有的文件，再在子目录中查找</strong>。使用depth选项就可以使find命令这样做。这样做的一个原因就是，当在使用find命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。  </p><p>find命令从文件系统的根目录开始，查找一个名为CON.FILE的文件。   </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 它将首先匹配所有的文件然后再进入子目录中查找</span></span><br><span class="line">find / -name &quot;CON.FILE&quot; -depth -print</span><br></pre></td></tr></table></figure><h3 id="11．使用mount选项："><a href="#11．使用mount选项：" class="headerlink" title="11．使用mount选项："></a>11．使用mount选项：</h3><p>在当前的文件系统中查找文件（不进入其他文件系统），可以使用find命令的mount选项。</p><p>从当前目录开始查找位于本文件系统中文件名以XC结尾的文件  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.XC&quot; -mount -print</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件查找命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-find命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-find%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux下find命令在目录结构中<strong>搜索文件</strong>，<strong>并执行指定的操作</strong>。Linux下find命令提供了相当多的查找条件，功能很强大。由于find具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( NFS)，find命令在该文件系统中同样有效，只要你具有相应的权限。 在运行一个非常消耗资源的find命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指30G字节以上的文件系统)。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find pathname -options [-print -exec -ok ...]</span><br></pre></td></tr></table></figure><blockquote><p>find /home/lxy -name “*.log”</p></blockquote><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用于在文件树种查找文件，并作出相应的处理. </p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">pathname: find命令所查找的目录路径。例如用&quot;.&quot;来表示当前目录，用&quot;/&quot;来表示系统根目录。 </span><br><span class="line">-print： find命令将匹配的文件输出到标准输出。 </span><br><span class="line">-exec： find命令对匹配的文件执行该参数所给出的shell命令。相应命令的形式为&#x27;command&#x27; &#123;  &#125; \;，注意&#123;   &#125;和\；之间的空格。 </span><br><span class="line">-ok： 和-exec的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。</span><br></pre></td></tr></table></figure><h3 id="4．命令选项："><a href="#4．命令选项：" class="headerlink" title="4．命令选项："></a>4．命令选项：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">-name, 按照文件名查找文件。</span><br><span class="line">-perm, 按照文件权限来查找文件。</span><br><span class="line">-prune, 使用这一选项可以使find命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被find命令忽略。</span><br><span class="line">-user, 按照文件属主来查找文件。</span><br><span class="line">-group, 按照文件所属的组来查找文件。</span><br><span class="line">-mtime -n +n, 按照文件的更改时间来查找文件，-n表示文件更改时间距现在n天以内，+n表示文件更改时间距现在n天以前。find命令还有-atime和-ctime选项，但它们都和-m time选项一样。</span><br><span class="line">-nogroup, 查找无有效所属组的文件，即该文件所属的组在/etc/groups中不存在。</span><br><span class="line">-nouser, 查找无有效属主的文件，即该文件的属主在/etc/passwd中不存在。</span><br><span class="line">-newer file1 ! file2, 查找更改时间比文件file1新但比文件file2旧的文件。</span><br><span class="line">-type, 查找某一类型的文件，诸如：</span><br><span class="line">    b - 块设备文件。</span><br><span class="line">    d - 目录。</span><br><span class="line">    c - 字符设备文件。</span><br><span class="line">    p - 管道文件。</span><br><span class="line">    l - 符号链接文件。</span><br><span class="line">    f - 普通文件。</span><br><span class="line">-size n[c], 查找文件长度为n块的文件，带有c时表示文件长度以字节计。</span><br><span class="line">    n[c], 字节：1字节</span><br><span class="line">    n[k], 千字节：n*1024字节。</span><br><span class="line">    n[M], 兆：n*1024*1024字节。</span><br><span class="line">-depth, 在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。</span><br><span class="line">-fstype, 查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/etc/fstab中找到，该配置文件中包含了本系统中有关文件系统的信息。</span><br><span class="line">-mount, 在查找文件时不跨越文件系统mount点。</span><br><span class="line">-follow, 如果find命令遇到符号链接文件，就跟踪至链接所指向的文件。</span><br><span class="line">-cpio, 对匹配的文件使用cpio命令，将这些文件备份到磁带设备中。</span><br><span class="line">-maxdepth n, 限制查找文件的最深目录层次,查n层。</span><br><span class="line">-mindepth n, 限制查找文件的最浅目录层次,查n层。</span><br><span class="line"></span><br><span class="line">另外,下面三个的区别:</span><br><span class="line">    -amin n   查找系统中最后N分钟访问的文件</span><br><span class="line">    -atime n  查找系统中最后n*24小时访问的文件</span><br><span class="line">    -cmin n   查找系统中最后N分钟被改变文件状态的文件</span><br><span class="line">    -ctime n  查找系统中最后n*24小时被改变文件状态的文件</span><br><span class="line">    -mmin n   查找系统中最后N分钟被改变文件数据的文件</span><br><span class="line">    -mtime n  查找系统中最后n*24小时被改变文件数据的文件</span><br></pre></td></tr></table></figure><h3 id="5．使用实例："><a href="#5．使用实例：" class="headerlink" title="5．使用实例："></a>5．使用实例：</h3><p>实例1：查找指定时间(2*24小时)内修改过的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find -atime -2</span><br></pre></td></tr></table></figure><p>实例2：根据关键字查找,在当前目录下查找以.log结尾的文件。 “. “代表当前目录: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.log&quot;</span><br></pre></td></tr></table></figure><p>实例3：根据关键字查找,在根目录下查找以.xml结尾的文件。 “/“代表根目录: </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find / -name &quot;*.xml&quot;</span><br></pre></td></tr></table></figure><p>实例4：按照目录或文件的权限来查找文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find /opt/soft/test/ -perm 777</span><br></pre></td></tr></table></figure><p>实例5：按类型查找：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type f -name &quot;*.log&quot;</span><br></pre></td></tr></table></figure><p>实例6：查找当前所有目录并排序:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -type d | sort</span><br></pre></td></tr></table></figure><p>实例7：按大小查找文件,查找当前目录大于1K的文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -size +1000c -print</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 文件查找命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-traceroute命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-traceroute%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-traceroute%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;通过<code>traceroute</code>我们可以知道信息从你的计算机到互联网另一端的主机是<strong>走的什么路径</strong>。当然每次数据包由某一同样的出发点（source）到达某一同样的目的地(destination)走的路径可能会不一样，但基本上来说大部分时候所走的路由是相同的。linux系统中，我们称之为traceroute,在MS Windows中为tracert。 </p><p>&emsp;traceroute通过发送小的数据包到目的设备直到其返回，来测量其需要多长时间。一条路径上的每个设备traceroute要测3次。输出结果中包括每次测试的时间(ms)和设备的名称（如有的话）及其IP地址。</p><p>在大多数情况下，我们会在linux主机系统下，直接执行命令行：<code>traceroute hostname</code></p><p>而在Windows系统下是执行tracert的命令：<code>tracert hostname</code></p><h3 id="1-命令格式："><a href="#1-命令格式：" class="headerlink" title="1.命令格式："></a>1.命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute [参数] [主机]</span><br></pre></td></tr></table></figure><h3 id="2-命令功能："><a href="#2-命令功能：" class="headerlink" title="2.命令功能："></a>2.命令功能：</h3><p>&emsp;traceroute指令让你追踪网络数据包的路由途径，预设数据包大小是40Bytes，用户可另行设置。</p><p>&emsp;具体参数格式：traceroute [-dFlnrvx][-f&lt;存活数值&gt;][-g&lt;网关&gt;…][-i&lt;网络界面&gt;][-m&lt;存活数值&gt;][-p&lt;通信端口&gt;][-s&lt;来源地址&gt;][-t&lt;服务类型&gt;][-w&lt;超时秒数&gt;][主机名称或IP地址][数据包大小]</p><h3 id="3-命令参数："><a href="#3-命令参数：" class="headerlink" title="3.命令参数："></a>3.命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-d, 使用Socket层级的排错功能。</span><br><span class="line">-f, 设置第一个检测数据包的存活数值TTL的大小。</span><br><span class="line">-F, 设置勿离断位。</span><br><span class="line">-g, 设置来源路由网关，最多可设置8个。</span><br><span class="line">-i, 使用指定的网络界面送出数据包。</span><br><span class="line">-I, 使用ICMP回应取代UDP资料信息。</span><br><span class="line">-m, 设置检测数据包的最大存活数值TTL的大小。</span><br><span class="line">-n, 直接使用IP地址而非主机名称。</span><br><span class="line">-p, 设置UDP传输协议的通信端口。</span><br><span class="line">-r, 忽略普通的Routing Table，直接将数据包送到远端主机上。</span><br><span class="line">-s, 设置本地主机送出数据包的IP地址。</span><br><span class="line">-t, 设置检测数据包的TOS数值。</span><br><span class="line">-v, 详细显示指令的执行过程。</span><br><span class="line">-w, 设置等待远端主机回报的时间。</span><br><span class="line">-x, 开启或关闭数据包的正确性检验。</span><br></pre></td></tr></table></figure><h3 id="4-使用实例："><a href="#4-使用实例：" class="headerlink" title="4.使用实例："></a>4.使用实例：</h3><p>实例1：traceroute用法简单、最常用的用法</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute www.baidu.com </span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">记录按序列号从1开始，每个纪录就是一跳，每跳表示一个网关，我们看到每行有三个时间，单位是ms，其实就是-q的默认参数。探测数据包向每个网关发送三个数据包后，网关响应后返回的时间；如果您用 traceroute -q 4 www.58.com ，表示向每个网关发送4个数据包。</span><br><span class="line"></span><br><span class="line">有时我们traceroute 一台主机时，会看到有一些行是以星号表示的。出现这样的情况，可能是防火墙封掉了ICMP的返回信息，所以我们得不到什么相关的数据包返回数据。</span><br><span class="line"></span><br><span class="line">有时我们在某一网关处延时比较长，有可能是某台网关比较阻塞，也可能是物理设备本身的原因。当然如果某台DNS出现问题时，不能解析主机名、域名时，也会 有延时长的现象；您可以加-n 参数来避免DNS解析，以IP格式输出数据。</span><br><span class="line"></span><br><span class="line">如果在局域网中的不同网段之间，我们可以通过traceroute 来排查问题所在，是主机的问题还是网关的问题。如果我们通过远程来访问某台服务器遇到问题时，我们用到traceroute 追踪数据包所经过的网关，提交IDC服务商，也有助于解决问题；但目前看来在国内解决这样的问题是比较困难的，就是我们发现问题所在，IDC服务商也不可能帮助我们解决。</span><br></pre></td></tr></table></figure><p>实例2：跳数设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -m 10 www.baidu.com</span><br></pre></td></tr></table></figure><p>实例3：显示IP地址，不查主机名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -n www.baidu.com</span><br></pre></td></tr></table></figure><p>实例4：探测包使用的基本UDP端口设置6888</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -p 6888 www.baidu.com</span><br></pre></td></tr></table></figure><p>实例5：把探测包的个数设置为值4</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -q 4 www.baidu.com</span><br></pre></td></tr></table></figure><p>实例6：绕过正常的路由表，直接发送到网络相连的主机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -r www.baidu.com</span><br></pre></td></tr></table></figure><p>实例7：把对外发探测包的等待响应时间设置为3秒</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute -w 3 www.baidu.com</span><br></pre></td></tr></table></figure><h3 id="Traceroute的工作原理："><a href="#Traceroute的工作原理：" class="headerlink" title="Traceroute的工作原理："></a>Traceroute的工作原理：</h3><p>Traceroute最简单的基本用法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">traceroute hostname</span><br></pre></td></tr></table></figure><p>Traceroute程序的设计是利用ICMP及IP header的TTL（Time To Live）栏位（field）。首先，traceroute送出一个TTL是1的IP datagram（其实，每次送出的为3个40字节的包，包括源地址，目的地址和包发出的时间标签）到目的地，当路径上的第一个路由器（router）收到这个datagram时，它将TTL减1。此时，TTL变为0了，所以该路由器会将此datagram丢掉，并送回一个「ICMP time exceeded」消息（包括发IP包的源地址，IP包的所有内容及路由器的IP地址），traceroute 收到这个消息后，便知道这个路由器存在于这个路径上，接着traceroute 再送出另一个TTL是2 的datagram，发现第2 个路由器…… traceroute 每次将送出的datagram的TTL 加1来发现另一个路由器，这个重复的动作一直持续到某个datagram 抵达目的地。当datagram到达目的地后，该主机并不会送回ICMP time exceeded消息，因为它已是目的地了，那么traceroute如何得知目的地到达了呢？</p><p>Traceroute在送出UDP datagrams到目的地时，它所选择送达的port number 是一个一般应用程序都不会用的号码（30000 以上），所以当此UDP datagram 到达目的地后该主机会送回一个「ICMP port unreachable」的消息，而当traceroute 收到这个消息时，便知道目的地已经到达了。所以traceroute 在Server端也是没有所谓的Daemon 程式。</p><p>Traceroute提取发 ICMP TTL到期消息设备的IP地址并作域名解析。每次 ，Traceroute都打印出一系列数据,包括所经过的路由设备的域名及 IP地址,三个包每次来回所花时间。</p><h3 id="windows之tracert"><a href="#windows之tracert" class="headerlink" title="windows之tracert:"></a>windows之tracert:</h3><p>格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert [-d] [-h maximum_hops] [-j host-list] [-w timeout] target_name</span><br></pre></td></tr></table></figure><p>参数说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tracert [-d] [-h maximum_hops] [-j computer-list] [-w timeout] target_name</span><br></pre></td></tr></table></figure><p>该诊断实用程序通过向目的地发送具有不同生存时间 (TL) 的 Internet 控制信息协议 (CMP) 回应报文，以确定至目的地的路由。路径上的每个路由器都要在转发该 ICMP 回应报文之前将其 TTL 值至少减 1，因此 TTL 是有效的跳转计数。当报文的 TTL 值减少到 0 时，路由器向源系统发回 ICMP 超时信息。通过发送 TTL 为 1 的第一个回应报文并且在随后的发送中每次将 TTL 值加 1，直到目标响应或达到最大 TTL 值，Tracert 可以确定路由。通过检查中间路由器发发回的 ICMP 超时 (ime Exceeded) 信息，可以确定路由器。注意，有些路由器“安静”地丢弃生存时间 (TLS) 过期的报文并且对 tracert 无效。</p><p>参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d, 指定不对计算机名解析地址。</span><br><span class="line">-h, maximum_hops 指定查找目标的跳转的最大数目。</span><br><span class="line">-jcomputer-list, 指定在 computer-list 中松散源路由。</span><br><span class="line">-w timeout, 等待由 timeout 对每个应答指定的毫秒数。</span><br><span class="line">target_name, 目标计算机的名称。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 网络命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-telnet命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-telnet%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-telnet%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;telnet(TEminaL over Network)命令通常用来远程登录。telnet程序是基于TELNET协议的远程登录客户端程序。Telnet协议是TCP/IP协议族中的一员，是Internet远程登陆服务的标准协议和主要方式。它为用户提供了在本地计算机上完成远程主机工作的 能力。在终端使用者的电脑上使用telnet程序，用它连接到服务器。终端使用者可以在telnet程序中输入命令，这些命令会在服务器上运行，就像直接在服务器的控制台上输入一样。可以在本地就能控制服务器。要开始一个telnet会话，必须输入用户名和密码来登录服务器。Telnet是常用的远程控制Web服务器的方法。</p><p>&emsp;但是，telnet因为采用明文传送报文，安全性不好，很多Linux服务器都不开放telnet服务，而改用更安全的ssh方式了。但仍然有很多别的系统可能采用了telnet方式来提供远程登录，因此弄清楚telnet客户端的使用方式仍是很有必要的。</p><p>&emsp;telnet命令还可做别的用途，比如确定远程服务的状态，比如确定远程服务器的某个端口是否能访问。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet[参数][主机]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;执行telnet指令开启终端机阶段作业，并登入远端主机。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">-8, 允许使用8位字符资料，包括输入与输出。</span><br><span class="line">-a, 尝试自动登入远端系统。</span><br><span class="line">-b&lt;主机别名&gt;, 使用别名指定远端主机名称。</span><br><span class="line">-c, 不读取用户专属目录里的.telnetrc文件。</span><br><span class="line">-d, 启动排错模式。</span><br><span class="line">-e&lt;脱离字符&gt;, 设置脱离字符。</span><br><span class="line">-E, 滤除脱离字符。</span><br><span class="line">-f, 此参数的效果和指定&quot;-F&quot;参数相同。</span><br><span class="line">-F, 使用Kerberos V5认证时，加上此参数可把本地主机的认证数据上传到远端主机。</span><br><span class="line">-k&lt;域名&gt;, 使用Kerberos认证时，加上此参数让远端主机采用指定的领域名，而非该主机的域名。</span><br><span class="line">-K, 不自动登入远端主机。</span><br><span class="line">-l&lt;用户名称&gt;, 指定要登入远端主机的用户名称。</span><br><span class="line">-L, 允许输出8位字符资料。</span><br><span class="line">-n&lt;记录文件&gt;, 指定文件记录相关信息。</span><br><span class="line">-r, 使用类似rlogin指令的用户界面。</span><br><span class="line">-S&lt;服务类型&gt;, 设置telnet连线所需的IP TOS信息。</span><br><span class="line">-x, 假设主机有支持数据加密的功能，就使用它。</span><br><span class="line">-X&lt;认证形态&gt;, 关闭指定的认证形态。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：远程服务器访问</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">telnet 192.168.120.206</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 网络命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-ss命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ss%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ss%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;ss是Socket Statistics的缩写。顾名思义，ss命令可以用来获取<strong>socket统计信息</strong>，它可以显示和netstat类似的内容。但ss的优势在于它能够显示更多更详细的有关TCP和连接状态的信息，而且比netstat更快速更高效。</p><p>&emsp;当服务器的socket连接数量变得非常大时，无论是使用netstat命令还是直接<code>cat /proc/net/tcp</code>，执行速度都会很慢。可能你不会有切身的感受，但请相信我，当服务器维持的连接达到上万个的时候，使用netstat等于浪费生命，而用ss才是节省时间。</p><p>&emsp;天下武功唯快不破。ss快的秘诀在于，它利用到了TCP协议栈中tcp_diag。tcp_diag是一个用于分析统计的模块，可以获得Linux 内核中第一手的信息，这就确保了ss的快捷高效。当然，如果你的系统中没有tcp_diag，ss也可以正常运行，只是效率会变得稍慢。（但仍然比netstat要快。）</p><h3 id="1-命令格式"><a href="#1-命令格式" class="headerlink" title="1.命令格式:"></a>1.命令格式:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss [参数]</span><br><span class="line"></span><br><span class="line">ss [参数] [过滤]</span><br></pre></td></tr></table></figure><h3 id="2-命令功能："><a href="#2-命令功能：" class="headerlink" title="2.命令功能："></a>2.命令功能：</h3><p>&emsp;ss(Socket Statistics的缩写)命令可以用来获取 socket统计信息，此命令输出的结果类似于 netstat输出的内容，但它能显示更多更详细的 TCP连接状态的信息，且比 netstat 更快速高效。它使用了 TCP协议栈中 tcp_diag（是一个用于分析统计的模块），能直接从获得第一手内核信息，这就使得 ss命令快捷高效。在没有 tcp_diag，ss也可以正常运行。</p><h3 id="3-命令参数："><a href="#3-命令参数：" class="headerlink" title="3.命令参数："></a>3.命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-h, --help 帮助信息</span><br><span class="line">-V, --version 程序版本信息</span><br><span class="line">-n, --numeric 不解析服务名称</span><br><span class="line">-r, --resolve        解析主机名</span><br><span class="line">-a, --all 显示所有套接字（sockets）</span><br><span class="line">-l, --listening 显示监听状态的套接字（sockets）</span><br><span class="line">-o, --options        显示计时器信息</span><br><span class="line">-e, --extended       显示详细的套接字（sockets）信息</span><br><span class="line">-m, --memory         显示套接字（socket）的内存使用情况</span><br><span class="line">-p, --processes 显示使用套接字（socket）的进程</span><br><span class="line">-i, --info 显示 TCP内部信息</span><br><span class="line">-s, --summary 显示套接字（socket）使用概况</span><br><span class="line">-4, --ipv4           仅显示IPv4的套接字（sockets）</span><br><span class="line">-6, --ipv6           仅显示IPv6的套接字（sockets）</span><br><span class="line">-0, --packet         显示 PACKET 套接字（socket）</span><br><span class="line">-t, --tcp 仅显示 TCP套接字（sockets）</span><br><span class="line">-u, --udp 仅显示 UCP套接字（sockets）</span><br><span class="line">-d, --dccp 仅显示 DCCP套接字（sockets）</span><br><span class="line">-w, --raw 仅显示 RAW套接字（sockets）</span><br><span class="line">-x, --unix 仅显示 Unix套接字（sockets）</span><br><span class="line">-f, --family=FAMILY  显示 FAMILY类型的套接字（sockets），FAMILY可选，支持  unix, inet, inet6, link, netlink</span><br><span class="line">-A, --query=QUERY, --socket=QUERY</span><br><span class="line">    QUERY := &#123;all|inet|tcp|udp|raw|unix|packet|netlink&#125;[,QUERY]</span><br><span class="line">-D, --diag=FILE     将原始TCP套接字（sockets）信息转储到文件</span><br><span class="line">-F, --filter=FILE   从文件中都去过滤器信息</span><br><span class="line">    FILTER := [ state TCP-STATE ] [ EXPRESSION ]</span><br></pre></td></tr></table></figure><h3 id="4-使用实例："><a href="#4-使用实例：" class="headerlink" title="4.使用实例："></a>4.使用实例：</h3><p>实例1：显示TCP连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -t -a</span><br></pre></td></tr></table></figure><p>实例2：显示 Sockets 摘要</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出当前的established, closed, orphaned and waiting TCP sockets</span></span><br><span class="line">ss -s</span><br></pre></td></tr></table></figure><p>实例3：列出所有打开的网络连接端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -l</span><br></pre></td></tr></table></figure><p>实例4：查看进程使用的socket</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -pl</span><br></pre></td></tr></table></figure><p>实例5：找出打开套接字/端口应用程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -lp | grep 3306</span><br></pre></td></tr></table></figure><p>实例6：显示所有UDP Sockets</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -u -a</span><br></pre></td></tr></table></figure><p>实例7：显示所有状态为established的SMTP连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -o state established &#x27;( dport = :smtp or sport = :smtp )&#x27; </span><br></pre></td></tr></table></figure><p>实例8：显示所有状态为Established的HTTP连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -o state established &#x27;( dport = :http or sport = :http )&#x27; </span><br></pre></td></tr></table></figure><p>实例9：列举出处于 FIN-WAIT-1状态的源端口为 80或者 443，目标网络为 193.233.7/24所有 tcp套接字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ss -o state fin-wait-1 &#x27;( sport = :http or sport = :https )&#x27; dst 193.233.7/24</span><br></pre></td></tr></table></figure><p>实例10：用TCP 状态过滤Sockets:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss -4 state FILTER-NAME-HERE </span><br><span class="line"></span><br><span class="line">ss -6 state FILTER-NAME-HERE</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">FILTER-NAME-HERE 可以代表以下任何一个：</span><br><span class="line">established</span><br><span class="line">syn-sent</span><br><span class="line">syn-recv</span><br><span class="line">fin-wait-1</span><br><span class="line">fin-wait-2</span><br><span class="line">time-wait</span><br><span class="line">closed</span><br><span class="line">close-wait</span><br><span class="line">last-ack</span><br><span class="line">listen</span><br><span class="line">closing</span><br><span class="line">all : 所有以上状态</span><br><span class="line">connected : 除了listen and closed的所有状态</span><br><span class="line">synchronized :所有已连接的状态除了syn-sent</span><br><span class="line">bucket : 显示状态为maintained as minisockets,如：time-wait和syn-recv.</span><br><span class="line">big : 和bucket相反.</span><br></pre></td></tr></table></figure><p>实例11：匹配远程地址和端口号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">命令：</span><br><span class="line">ss dst ADDRESS_PATTERN</span><br><span class="line">ss dst 192.168.1.5</span><br><span class="line">ss dst 192.168.119.113:http </span><br><span class="line">ss dst 192.168.119.113:smtp </span><br><span class="line">ss dst 192.168.119.113:443</span><br></pre></td></tr></table></figure><p>实例12：匹配本地地址和端口号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ss src ADDRESS_PATTERN</span><br><span class="line">ss src 192.168.119.103</span><br><span class="line">ss src 192.168.119.103:http</span><br><span class="line">ss src 192.168.119.103:80</span><br><span class="line">ss src 192.168.119.103:smtp</span><br><span class="line">ss src 192.168.119.103:25</span><br></pre></td></tr></table></figure><p>实例13：将本地或者远程端口和一个数比较</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ss dport OP PORT </span><br><span class="line"></span><br><span class="line">ss sport OP PORT</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ss dport OP PORT 远程端口和一个数比较；ss sport OP PORT 本地端口和一个数比较。</span><br><span class="line">OP 可以代表以下任意一个: </span><br><span class="line">&lt;= or le : 小于或等于端口号</span><br><span class="line">&gt;= or ge : 大于或等于端口号</span><br><span class="line">== or eq : 等于端口号</span><br><span class="line">!= or ne : 不等于端口号</span><br><span class="line">&lt; or gt : 小于端口号</span><br><span class="line">&gt; or lt : 大于端口号</span><br></pre></td></tr></table></figure><p>实例14：ss 和 netstat 效率对比</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">time netstat -at</span><br><span class="line"></span><br><span class="line">time ss</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用time 命令分别获取通过netstat和ss命令获取程序和概要占用资源所使用的时间。在服务器连接数比较多的时候，netstat的效率完全没法和ss比。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 网络命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-scp命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-scp%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-scp%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;scp是secure copy的简写，用于在Linux下进行<strong>远程拷贝文件</strong>的命令，和它类似的命令有cp，不过cp只是在本机进行拷贝不能跨服务器，而且scp传输是<strong>加密</strong>的。可能会稍微影响一下速度。当你服务器硬盘变为只读 read only system时，用scp可以帮你把文件移出来。另外，scp还非常不占资源，不会提高多少系统负荷，在这一点上，rsync就远远不及它了。虽然rsync比scp会快一点，但当小文件众多的情况下，rsync会导致硬盘I/O非常高，而scp基本不影响系统正常使用。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp [参数] [原路径] [目标路径]</span><br></pre></td></tr></table></figure><blockquote><p>scp -r local_file <a href="mailto:&#x72;&#111;&#111;&#x74;&#64;&#49;&#48;&#46;&#56;&#46;&#x78;&#x78;&#120;&#x2e;&#120;&#x78;&#120;">&#x72;&#111;&#111;&#x74;&#64;&#49;&#48;&#46;&#56;&#46;&#x78;&#x78;&#120;&#x2e;&#120;&#x78;&#120;</a>:/home/root/xxx</p></blockquote><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;scp是linux系统下基于ssh登陆进行安全的远程文件拷贝命令。linux的scp命令可以在linux服务器之间复制文件和目录。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-1, 强制scp命令使用协议ssh1</span><br><span class="line">-2, 强制scp命令使用协议ssh2</span><br><span class="line">-4, 强制scp命令只使用IPv4寻址</span><br><span class="line">-6, 强制scp命令只使用IPv6寻址</span><br><span class="line">-B, 使用批处理模式（传输过程中不询问传输口令或短语）</span><br><span class="line">-C, 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</span><br><span class="line">-p, 保留原文件的修改时间，访问时间和访问权限。</span><br><span class="line">-q, 不显示传输进度条。</span><br><span class="line">-r, 递归复制整个目录。</span><br><span class="line">-v, 详细方式显示输出。scp和ssh(1)会显示出整个过程的调试信息。这些信息用于调试连接，验证和配置问题。</span><br><span class="line">-c cipher, 以cipher将数据传输进行加密，这个选项将直接传递给ssh。</span><br><span class="line">-F ssh_config, 指定一个替代的ssh配置文件，此参数直接传递给ssh。</span><br><span class="line">-i identity_file, 从指定文件中读取传输时使用的密钥文件，此参数直接传递给ssh。</span><br><span class="line">-l limit, 限定用户所能使用的带宽，以Kbit/s为单位。</span><br><span class="line">-o ssh_option, 如果习惯于使用ssh_config(5)中的参数传递方式。</span><br><span class="line">-P port, 注意是大写的P, port是指定数据传输用到的端口号。</span><br><span class="line">-S program, 指定加密传输时所使用的程序。此程序必须能够理解ssh(1)的选项。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>scp命令的实际应用概述：</p><p>从本地服务器复制到远程服务器： </p><p>(1) 复制文件：  </p><p>命令格式：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder  </span><br></pre></td></tr></table></figure><p>或者  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_file  </span><br></pre></td></tr></table></figure><p>或者  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_ip:remote_folder  </span><br></pre></td></tr></table></figure><p>或者  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp local_file remote_ip:remote_file  </span><br></pre></td></tr></table></figure><p>第1,2个指定了用户名，命令执行后需要输入用户密码，第1个仅指定了远程的目录，文件名字不变，第2个指定了文件名  </p><p>第3,4个没有指定用户名，命令执行后需要输入用户名和密码，第3个仅指定了远程的目录，文件名字不变，第4个指定了文件名   </p><p>(2) 复制目录：  </p><p>命令格式：  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_folder remote_username@remote_ip:remote_folder  </span><br></pre></td></tr></table></figure><p>或者  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r local_folder remote_ip:remote_folder  </span><br></pre></td></tr></table></figure><p>第1个指定了用户名，命令执行后需要输入用户密码；  </p><p>第2个没有指定用户名，命令执行后需要输入用户名和密码；</p><p>从远程服务器复制到本地服务器： </p><p>从远程复制到本地的scp命令与上面的命令雷同，只要将从本地复制到远程的命令后面2个参数互换顺序就行了。</p><p>实例1：从远程复制文件到本地目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp root@192.168.120.204:/opt/soft/nginx-0.5.38.tar.gz /opt/soft/</span><br></pre></td></tr></table></figure><p>实例2：从远程复制目录到本地目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r root@192.168.120.204:/opt/soft/mongodb /opt/soft/</span><br></pre></td></tr></table></figure><p>实例3：上传本地文件到远程机器指定目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp /opt/soft/nginx-0.5.38.tar.gz root@192.168.120.204:/opt/soft/scptest</span><br></pre></td></tr></table></figure><p>实例4：上传本地目录到远程机器指定目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -r /opt/soft/mongodb root@192.168.120.204:/opt/soft/scptest</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 网络命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-route命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-route%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-route%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux系统的route命令用于<strong>显示和操作IP路由表</strong>(show/manipulate the IP routing table)。要实现两个不同的子网之间的通信，需要一台连接两个网络的路由器，或者同时位于两个网络的网关来实现。在Linux系统中，设置路由通常是为了解决以下问题：该Linux系统在一个局域网中，局域网中有一个网关，能够让机器访问Internet，那么就需要将这台机器的IP地址设置为Linux机器的默认路由。要注意的是，直接在命令行下执行route命令来添加路由，不会永久保存，当网卡重启或者机器重启之后，该路由就失效了；可以在<code>/etc/rc.local</code>中添加route命令来保证该路由设置永久有效。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route [-f] [-p] [Command [Destination] [mask Netmask] [Gateway] [metric Metric]] [if Interface]] </span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;Route命令是用于操作基于内核ip路由表，它的主要作用是创建一个静态路由让指定一个主机或者一个网络通过一个网络接口，如eth0。当使用”add”或者”del”参数时，路由表被修改，如果没有参数，则显示路由表当前的内容。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">-c, 显示更多信息</span><br><span class="line">-n, 不解析名字</span><br><span class="line">-v, 显示详细的处理信息</span><br><span class="line">-F, 显示发送信息</span><br><span class="line">-C, 显示路由缓存</span><br><span class="line">-f, 清除所有网关入口的路由表。 </span><br><span class="line">-p, 与 add 命令一起使用时使路由具有永久性。</span><br><span class="line">add, 添加一条新路由。</span><br><span class="line">del, 删除一条路由。</span><br><span class="line">-net, 目标地址是一个网络。</span><br><span class="line">-host, 目标地址是一个主机。</span><br><span class="line">netmask, 当添加一个网络路由时，需要使用网络掩码。</span><br><span class="line">gw, 路由数据包通过网关。注意，你指定的网关必须能够达到。</span><br><span class="line">metric, 设置路由跳数。</span><br><span class="line">Command, 指定您想运行的命令 (Add/Change/Delete/Print)。 </span><br><span class="line">Destination, 指定该路由的网络目标。 </span><br><span class="line">mask Netmask, 指定与网络目标相关的网络掩码（也被称作子网掩码）。 </span><br><span class="line">Gateway, 指定网络目标定义的地址集和子网掩码可以到达的前进或下一跃点 IP 地址。 </span><br><span class="line">metric Metric, 为路由指定一个整数成本值标（从 1 至 9999），当在路由表(与转发的数据包目标地址最匹配)的多个路由中进行选择时可以使用。 </span><br><span class="line">if Interface, 为可以访问目标的接口指定接口索引。若要获得一个接口列表和它们相应的接口索引，使用 route print 命令的显示功能。可以使用十进制或十六进制值进行接口索引。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示当前路由</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">route</span><br><span class="line"><span class="meta">#</span><span class="bash"> -n 表示不解析名字,列出速度会比route快</span></span><br><span class="line">route -n</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">第一行表示主机所在网络的地址为192.168.120.0，若数据传送目标是在本局域网内通信，则可直接通过eth0转发数据包;</span><br><span class="line"></span><br><span class="line">第四行表示数据传送目的是访问Internet，则由接口eth0，将数据包发送到网关192.168.120.240</span><br><span class="line"></span><br><span class="line">其中Flags为路由标志，标记当前网络节点的状态。</span><br><span class="line"></span><br><span class="line">Flags标志说明：</span><br><span class="line">U, Up表示此路由当前为启动状态</span><br><span class="line">H, Host，表示此网关为一主机</span><br><span class="line">G, Gateway，表示此网关为一路由器</span><br><span class="line">R, Reinstate Route，使用动态路由重新初始化的路由</span><br><span class="line">D, Dynamically,此路由是动态性地写入</span><br><span class="line">M, Modified，此路由是由路由守护程序或导向器动态修改</span><br><span class="line">!, 表示此路由当前为关闭状态</span><br></pre></td></tr></table></figure><p>实例2：添加网关/设置网关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 增加一条到达244.0.0.0的路由</span></span><br><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 dev eth0</span><br></pre></td></tr></table></figure><p>实例3：屏蔽一条路由</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 增加一条屏蔽的路由，目的地址为224.x.x.x将被拒绝</span></span><br><span class="line">route add -net 224.0.0.0 netmask 240.0.0.0 reject</span><br></pre></td></tr></table></figure><p>实例4：删除路由记录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0</span><br><span class="line"></span><br><span class="line">route del -net 224.0.0.0 netmask 240.0.0.0 reject</span><br></pre></td></tr></table></figure><p>实例5：删除和添加设置默认网关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除</span></span><br><span class="line">route del default gw 192.168.120.240</span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加</span></span><br><span class="line">route add default gw 192.168.120.240</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 网络命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-rcp命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rcp%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rcp%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;rcp代表“remote file copy”（远程文件拷贝）。该命令用于在计算机之间拷贝文件。rcp命令有两种格式。第一种格式用于文件到文件的拷贝；第二种格式用于把文件或目录拷贝到另一个目录中。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp [参数] [源文件] [目标文件]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;rcp命令用在<strong>远端复制文件或目录</strong>，如同时指定两个以上的文件或目录，且最后的目的地是一个<strong>已经存在的目录</strong>，则它会把前面指定的所有文件或目录复制到该目录中。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-r, 递归地把源目录中的所有内容拷贝到目的目录中。要使用这个选项，目的必须是一个目录。</span><br><span class="line">-p, 试图保留源文件的修改时间和模式，忽略umask。</span><br><span class="line">-k, 请求rcp获得在指定区域内的远程主机的Kerberos 许可，而不是获得由krb_relmofhost⑶确定的远程主机区域内的远程主机的Kerberos许可。</span><br><span class="line">-x, 为传送的所有数据打开DES加密。这会影响响应时间和CPU利用率，但是可以提高安全性。如果在文件名中指定的路径不是完整的路径名，那么这个路径被解释为相对远程机上同名用户的主目录。如果没有给出远程用户名，就使用当前用户名。如果远程机上的路径包含特殊shell字符，需要用反斜线（\\）、双引号（”）或单引号（’）括起来，使所有的shell元字符都能被远程地解释。需要说明的是，rcp不提示输入口令，它通过rsh命令来执行拷贝。</span><br><span class="line">directory, 每个文件或目录参数既可以是远程文件名也可以是本地文件名。远程文件名具有如下形式：rname@rhost：path，其中rname是远程用户名，rhost是远程计算机名，path是这个文件的路径。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>要使用rcp，需要具备以下条件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">如果系统中有`/etc/hosts`文件，系统管理员应确保该文件包含要与之进行通信的远程主机的项。</span><br><span class="line"></span><br><span class="line">/etc/hosts文件中有一行文字，其中包含每个远程系统的以下信息：</span><br><span class="line"></span><br><span class="line">internet_address   official_name   alias</span><br><span class="line"></span><br><span class="line">例如：</span><br><span class="line"></span><br><span class="line">9.186.10.***  webserver1.com.58.webserver</span><br><span class="line">.rhosts 文件</span><br><span class="line">.rhosts 文件位于远程系统的主目录下，其中包含本地系统的名称和本地登录名。</span><br><span class="line"></span><br><span class="line">例如，远程系统的 .rhosts 文件中的项可能是：</span><br><span class="line">webserver1 root</span><br><span class="line">其中，webserver1 是本地系统的名称，root 是本地登录名。这样，webserver1 上的 root 即可在包含 .rhosts 文件的远程系统中来回复制文件。</span><br><span class="line"></span><br><span class="line">配置过程:</span><br><span class="line">只对root用户生效</span><br><span class="line">1. 在双方root用户根目录下建立.rhosts文件,并将双方的hostname加进去.在此之前应在双方的 /etc/hosts文件中加入对方的IP和hostname</span><br><span class="line">2. 把rsh服务启动起来,redhat默认是不启动的。</span><br><span class="line">方法：用执行ntsysv命令,在rsh选项前用空格键选中,确定退出。然后执行：</span><br><span class="line">service xinetd restart即可。</span><br><span class="line"></span><br><span class="line">3. 到/etc/pam.d/目录下,把rsh文件中的auth required /lib/security/pam_securetty.so</span><br><span class="line"></span><br><span class="line">一行用“#”注释掉即可。（只有注释掉这一行，才能用root用户登录）</span><br><span class="line"></span><br><span class="line">命令使用:</span><br><span class="line"></span><br><span class="line">将文件复制到远程系统</span><br><span class="line">要将本地系统中的文件复制到远程系统，请使用以下命令：</span><br><span class="line">rcplocal_fileremote_hostname:remote_fileEnter</span><br><span class="line">注意，如果当前目录下没有 local_file，则除本地文件名外，还需要提供相对路径（自当前目录开始）或绝对路径名（自 / 开始）。</span><br><span class="line">仅当希望将 remote_hostname 上的 remote_file 放到其他目录（远程主目录除外）下时，才需要为其指定完整的（绝对）路径。</span><br></pre></td></tr></table></figure><p>实例1:将当前目录下的 test1 复制到名为 webserver1的远程系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp test1 webserver1:/home/root/test3</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">在这种情况下，test1被复制到远程子目录test3下，名称仍为test1。如果仅提供了远程主机名，rcp将把test1复制到远程主目录下，名称仍为test1 。</span><br><span class="line"></span><br><span class="line">还可以在目的目录中包含文件名。例如，将文件复制到名为webserver1的系统中：</span><br><span class="line"></span><br><span class="line">rcp test1 webserver1:/home/root/test3</span><br><span class="line"></span><br><span class="line">在这种情况下，将 test1 复制到远程目录root下并将其命名为test3。</span><br></pre></td></tr></table></figure><p>实例2：从远程系统复制文件：要将远程系统中的文件复制到本地目录下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp remote_hostname:remote_file local_file</span><br></pre></td></tr></table></figure><p>实例:3:将远程系统webserver1中的test2复制到当前目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp webserver1:/home/root/test2 .</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">点 (.) 是“当前目录”的简写形式。在这种情况下，远程目录中的test2被复制到当前目录下，名称仍为test2。</span><br><span class="line"></span><br><span class="line">如果希望用新名称复制文件，请提供目标文件名。</span><br><span class="line"></span><br><span class="line">如果希望将test2复制到本地系统中的其他目录下，请使用以下绝对或相对路径名：</span><br><span class="line"></span><br><span class="line">rcp webserver1:/home/root/test2 otherdir/</span><br><span class="line"></span><br><span class="line">或者，如果希望用其他文件名将文件复制到其他目录下：</span><br><span class="line"></span><br><span class="line">rcp webserver1:/home/root/test2 otherdir/otherfile</span><br></pre></td></tr></table></figure><p>实例4：将目录复制到远程系统：要将本地目录及其文件和子目录复制到远程系统，请同时使用 rcp 和 -r（递归）选项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp –r local_dir remote_hostname:remote_dir</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果当前目录下没有 local_dir，则除本地目录名外，还需要提供相对路径名（自当前目录开始）或绝对路径名（自 / 顶级目录开始）。另外，如果主目录下没有 remote_dir，则 remote_dir 将需要一个相对路径（自主目录开始）或绝对路径（自 / 开始）。</span><br></pre></td></tr></table></figure><p>实例5:要将名为 work 的子目录完整地复制到 webserver1远程计算机中的主目录下名为 products 的目录，请键入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp –r work webserver1:/home/root/products</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此命令在 webserver1:/home/root/products 下创建名为 work 的目录及其全部内容（假定 /home/root/products 已存在于 webserver1中）。</span><br><span class="line"></span><br><span class="line">本示例假定用户处于包含 work 的本地目录下。否则，必须提供该目录的相对或绝对路径，如 /home/root/work。</span><br></pre></td></tr></table></figure><p>实例6：从远程系统复制目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp –r remote_hostname:remote_dir local_dir</span><br></pre></td></tr></table></figure><p>要将名为 work 的远程目录复制到当前目录，请键入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rcp –r webserver1:/home/root/work .</span><br></pre></td></tr></table></figure><p>点 (.) 表示当前目录。将在此目录下创建 work 目录。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 网络命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-ping命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ping%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ping%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux系统的ping命令是常用的网络命令，它通常用来<strong>测试与目标主机的连通性</strong>，我们经常会说“ping一下某机器，看是不是开着”、不能打开网页时会说“你先ping网关地址192.168.1.1试试”。它通过发送<code>ICMP ECHO_REQUEST</code>数据包到网络主机（send ICMP ECHO_REQUEST to network hosts），并显示响应情况，这样我们就可以根据它输出的信息来确定目标主机是否可访问（但这不是绝对的）。有些服务器为了防止通过ping探测到，通过防火墙设置了禁止ping或者在内核参数中禁止ping，这样就不能通过ping确定该主机是否还处于开启状态。</p><p>&emsp;linux下的ping和windows下的ping稍有区别,linux下ping不会自动终止,需要按ctrl+c终止或者用参数-c指定要求完成的回应次数。</p><h3 id="1-命令格式："><a href="#1-命令格式：" class="headerlink" title="1.命令格式："></a>1.命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping [参数] [主机名或IP地址]</span><br></pre></td></tr></table></figure><h3 id="2-命令功能："><a href="#2-命令功能：" class="headerlink" title="2.命令功能："></a>2.命令功能：</h3><p>&emsp;ping命令用于：</p><p>&emsp;&emsp;确定网络和各外部主机的状态；</p><p>&emsp;&emsp;跟踪和隔离硬件和软件问题；</p><p>&emsp;&emsp;测试、评估和管理网络。</p><p>&emsp;如果主机正在运行并连在网上，它就对回送信号进行响应。每个回送信号请求包含一个网际协议（IP）和 ICMP 头，后面紧跟一个tim结构，以及来填写这个信息包的足够的字节。缺省情况是连续发送回送信号请求直到接收到中断信号（Ctrl-C）。</p><p>&emsp;ping命令每秒发送一个数据报并且为每个接收到的响应打印一行输出。ping命令计算信号往返时间和(信息)包丢失情况的统计信息，并且在完成之后显示一个简要总结。ping命令在程序超时或当接收到SIGINT信号时结束。Host参数或者是一个有效的主机名或者是因特网地址。</p><h3 id="3-命令参数："><a href="#3-命令参数：" class="headerlink" title="3.命令参数："></a>3.命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">-d, 使用Socket的SO_DEBUG功能。</span><br><span class="line">-f, 极限检测。大量且快速地送网络封包给一台机器，看它的回应。</span><br><span class="line">-n, 只输出数值。</span><br><span class="line">-q, 不显示任何传送封包的信息，只显示最后的结果。</span><br><span class="line">-r, 忽略普通的Routing Table，直接将数据包送到远端主机上。通常是查看本机的网络接口是否有问题。</span><br><span class="line">-R, 记录路由过程。</span><br><span class="line">-v, 详细显示指令的执行过程。</span><br><span class="line">&lt;p&gt;-c, 数目：在发送指定数目的包后停止。</span><br><span class="line">-i, 秒数：设定间隔几秒送一个网络封包给一台机器，预设值是一秒送一次。</span><br><span class="line">-I, 网络界面：使用指定的网络界面送出数据包。</span><br><span class="line">-l, 前置载入：设置在送出要求信息之前，先行发出的数据包。</span><br><span class="line">-p, 范本样式：设置填满数据包的范本样式。</span><br><span class="line">-s, 字节数：指定发送的数据字节数，预设值是56，加上8字节的ICMP头，一共是64ICMP数据字节。</span><br><span class="line">-t, 存活数值：设置存活数值TTL的大小。</span><br></pre></td></tr></table></figure><h3 id="4-使用实例："><a href="#4-使用实例：" class="headerlink" title="4.使用实例："></a>4.使用实例：</h3><p>实例1：ping的通的情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping 192.168.120.205</span><br></pre></td></tr></table></figure><p>实例2：ping网关</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -b 192.168.120.1</span><br></pre></td></tr></table></figure><p>实例3：ping指定次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 10 192.168.120.206</span><br></pre></td></tr></table></figure><p>实例4：时间间隔和次数限制的ping</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 10 -i 0.5 192.168.120.206</span><br></pre></td></tr></table></figure><p>实例5：通过域名ping公网上的站点</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ping -c 5 www.codingcode.cn</span><br></pre></td></tr></table></figure><p>实例6：多参数使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -i 3发送周期为3秒 -s设置发送包的大小为1024 -t设置TTL值为255</span></span><br><span class="line">ping -i 3 -s 1024 -t 255 192.168.120.206</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 网络命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-netstat命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-netstat%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-netstat%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;netstat命令用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。netstat是在内核中访问网络及相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。</p><p>&emsp;如果你的计算机有时候接收到的数据报导致出错数据或故障，你不必感到奇怪，TCP/IP可以容许这些类型的错误，并能够自动重发数据报。但如果累计的出错情况数目占到所接收的IP数据报相当大的百分比，或者它的数目正迅速增加，那么你就应该使用netstat查一查为什么会出现这些情况了。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat [-acCeFghilMnNoprstuvVwx][-A&lt;网络类型&gt;][--ip]</span><br></pre></td></tr></table></figure><blockquote><p>查看端口占用情况 : netstat -tln|grep 8080</p></blockquote><blockquote><p>查看端口占用情况 : netstat -an|grep 8080</p></blockquote><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">-a或–all, 显示所有连线中的Socket。</span><br><span class="line">-A&lt;网络类型&gt;或–&lt;网络类型&gt;, 列出该网络类型连线中的相关地址。</span><br><span class="line">-c或–continuous, 持续列出网络状态。</span><br><span class="line">-C或–cache, 显示路由器配置的快取信息。</span><br><span class="line">-e或–extend, 显示网络其他相关信息。</span><br><span class="line">-F或–fib, 显示FIB。</span><br><span class="line">-g或–groups, 显示多重广播功能群组组员名单。</span><br><span class="line">-i或–interfaces, 显示网络界面信息表单。</span><br><span class="line">-l或–listening, 显示监控中的服务器的Socket。</span><br><span class="line">-M或–masquerade, 显示伪装的网络连线。</span><br><span class="line">-n或–numeric, 直接使用IP地址，而不通过域名服务器。</span><br><span class="line">-N或–netlink或–symbolic, 显示网络硬件外围设备的符号连接名称。</span><br><span class="line">-o或–timers, 显示计时器。</span><br><span class="line">-p或–programs, 显示正在使用Socket的程序识别码和程序名称。</span><br><span class="line">-r或–route, 显示Routing Table。</span><br><span class="line">-s或–statistice, 显示网络工作信息统计表。</span><br><span class="line">-t或–tcp, 显示TCP传输协议的连线状况。</span><br><span class="line">-u或–udp, 显示UDP传输协议的连线状况。</span><br><span class="line">-v或–verbose, 显示指令执行过程。</span><br><span class="line">-V或–version, 显示版本信息。</span><br><span class="line">-w或–raw, 显示RAW传输协议的连线状况。</span><br><span class="line">-x或–unix, 此参数的效果和指定&quot;-A unix&quot;参数相同。</span><br><span class="line">–ip或–inet, 此参数的效果和指定&quot;-A inet&quot;参数相同。</span><br><span class="line">-h或–help, 在线帮助。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：无参数使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">从整体上看，netstat的输出结果可以分为两个部分：</span><br><span class="line"></span><br><span class="line">一个是Active Internet connections，称为有源TCP连接，其中&quot;Recv-Q&quot;和&quot;Send-Q&quot;指的是接收队列和发送队列。这些数字一般都应该是0。如果不是则表示软件包正在队列中堆积。这种情况只能在非常少的情况见到。</span><br><span class="line"></span><br><span class="line">另一个是Active UNIX domain sockets，称为有源Unix域套接口(和网络套接字一样，但是只能用于本机通信，性能可以提高一倍)。</span><br><span class="line"></span><br><span class="line">Proto显示连接使用的协议,RefCnt表示连接到本套接口上的进程号,Types显示套接口的类型,State显示套接口当前的状态,Path表示连接到套接口的其它进程使用的路径名。</span><br><span class="line"></span><br><span class="line">套接口类型：</span><br><span class="line">-t ：TCP</span><br><span class="line">-u ：UDP</span><br><span class="line">-raw ：RAW类型</span><br><span class="line">--unix ：UNIX域类型</span><br><span class="line">--ax25 ：AX25类型</span><br><span class="line">--ipx ：ipx类型</span><br><span class="line">--netrom ：netrom类型</span><br><span class="line"></span><br><span class="line">状态说明：</span><br><span class="line">LISTEN：侦听来自远方的TCP端口的连接请求</span><br><span class="line">SYN-SENT：再发送连接请求后等待匹配的连接请求（如果有大量这样的状态包，检查是否中招了）</span><br><span class="line">SYN-RECEIVED：再收到和发送一个连接请求后等待对方对连接请求的确认（如有大量此状态，估计被flood攻击了）</span><br><span class="line">ESTABLISHED：代表一个打开的连接</span><br><span class="line">FIN-WAIT-1：等待远程TCP连接中断请求，或先前的连接中断请求的确认</span><br><span class="line">FIN-WAIT-2：从远程TCP等待连接中断请求</span><br><span class="line">CLOSE-WAIT：等待从本地用户发来的连接中断请求</span><br><span class="line">CLOSING：等待远程TCP对连接中断的确认</span><br><span class="line">LAST-ACK：等待原来的发向远程TCP的连接中断请求的确认（不是什么好东西，此项出现，检查是否被攻击）</span><br><span class="line">TIME-WAIT：等待足够的时间以确保远程TCP接收到连接中断请求的确认</span><br><span class="line">CLOSED：没有任何连接状态</span><br></pre></td></tr></table></figure><p>实例2：列出所有端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示一个所有的有效连接信息列表，包括已建立的连接（ESTABLISHED），也包括监听连接请（LISTENING）的那些连接。</span></span><br><span class="line">netstat -a</span><br></pre></td></tr></table></figure><p>实例3：显示当前UDP连接状况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nu</span><br></pre></td></tr></table></figure><p>实例4：显示UDP端口号的使用情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -apu</span><br></pre></td></tr></table></figure><p>实例5：显示网卡列表</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -i</span><br></pre></td></tr></table></figure><p>实例6：显示组播组的关系</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -g</span><br></pre></td></tr></table></figure><p>实例7：显示网络统计信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -s</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">按照各个协议分别显示其统计数据。如果我们的应用程序（如Web浏览器）运行速度比较慢，或者不能显示Web页之类的数据，那么我们就可以用本选项来查看一下所显示的信息。我们需要仔细查看统计数据的各行，找到出错的关键字，进而确定问题所在。</span><br></pre></td></tr></table></figure><p>实例8：显示监听的套接口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -l</span><br></pre></td></tr></table></figure><p>实例9：显示所有已建立的有效连接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -n</span><br></pre></td></tr></table></figure><p>实例10：显示关于以太网的统计数据</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -e</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于显示关于以太网的统计数据。它列出的项目包括传送的数据报的总字节数、错误数、删除数、数据报的数量和广播的数量。这些统计数据既有发送的数据报数量，也有接收的数据报数量。这个选项可以用来统计一些基本的网络流量）</span><br></pre></td></tr></table></figure><p>实例11：显示关于路由表的信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -r</span><br></pre></td></tr></table></figure><p>实例12：列出所有 tcp 端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -at</span><br></pre></td></tr></table></figure><p>实例13：统计机器中网络连接各个状态个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -a | awk &#x27;/^tcp/ &#123;++S[$NF]&#125; END &#123;for(a in S) print a, S[a]&#125;&#x27;</span><br></pre></td></tr></table></figure><p>实例14：把状态全都取出来后使用uniq -c统计后再进行排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat |awk &#x27;&#123;print $6&#125;&#x27;|sort|uniq -c</span><br></pre></td></tr></table></figure><p>实例15：查看连接某服务端口最多的的IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -nat | grep &quot;192.168.120.20:16067&quot; |awk &#x27;&#123;print $5&#125;&#x27;|awk -F: &#x27;&#123;print $4&#125;&#x27;|sort|uniq -c|sort -nr|head -20</span><br></pre></td></tr></table></figure><p>实例16：找出程序运行的端口</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ap | grep ssh</span><br></pre></td></tr></table></figure><p>实例17：在 netstat 输出中显示 PID 和进程名称</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -pt</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -p 可以与其它开关一起使用，就可以添加 “PID/进程名称” 到 netstat 输出中，这样 debugging 的时候可以很方便的发现特定端口运行的程序。</span><br></pre></td></tr></table></figure><p>实例18：找出运行在指定端口的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -anpt | grep &#x27;:16064&#x27;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">运行在端口16064的进程id为24596，再通过ps命令就可以找到具体的应用程序了。</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 网络命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-ifconfig命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ifconfig%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ifconfig%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;许多windows非常熟悉<code>ipconfig</code>命令行工具，它被用来获取网络接口配置信息并对此进行修改。Linux系统拥有一个类似的工具，也就是ifconfig(interfaces config)。通常需要以<strong>root</strong>身份登录或使用sudo以便在Linux机器上使用ifconfig工具。依赖于ifconfig命令中使用一些选项属性，ifconfig工具不仅可以被用来简单地获取网络接口配置信息，还可以修改这些配置。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig [网络设备] [参数]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;ifconfig命令用来查看和配置网络设备。当网络环境发生改变时可通过此命令对网络进行相应的配置。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">up, 启动指定网络设备/网卡。</span><br><span class="line">down, 关闭指定网络设备/网卡。该参数可以有效地阻止通过指定接口的IP信息流，如果想永久地关闭一个接口，我们还需要从核心路由表中将该接口的路由信息全部删除。</span><br><span class="line">arp, 设置指定网卡是否支持ARP协议。</span><br><span class="line">-promisc, 设置是否支持网卡的promiscuous模式，如果选择此参数，网卡将接收网络中发给它所有的数据包</span><br><span class="line">-allmulti, 设置是否支持多播模式，如果选择此参数，网卡将接收网络中所有的多播数据包</span><br><span class="line">-a, 显示全部接口信息</span><br><span class="line">-s, 显示摘要信息（类似于 netstat -i）</span><br><span class="line">add, 给指定网卡配置IPv6地址</span><br><span class="line">del, 删除指定网卡的IPv6地址</span><br><span class="line">&lt;硬件地址&gt;, 配置网卡最大的传输单元</span><br><span class="line">mtu&lt;字节数&gt;, 设置网卡的最大传输单元 (bytes)</span><br><span class="line">netmask&lt;子网掩码&gt;, 设置网卡的子网掩码。掩码可以是有前缀0x的32位十六进制数，也可以是用点分开的4个十进制数。如果不打算将网络分成子网，可以不管这一选项；如果要使用子网，那么请记住，网络中每一个系统必须有相同子网掩码。</span><br><span class="line">tunel, 建立隧道</span><br><span class="line">dstaddr, 设定一个远端地址，建立点对点通信</span><br><span class="line">-broadcast&lt;地址&gt;, 为指定网卡设置广播协议</span><br><span class="line">-pointtopoint&lt;地址&gt;, 为网卡设置点对点通讯协议</span><br><span class="line">multicast, 为网卡设置组播标志</span><br><span class="line">address, 为网卡设置IPv4地址</span><br><span class="line">txqueuelen&lt;长度&gt;, 为网卡设置传输列队的长度</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示网络设备信息（激活状态的）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:50:56:BF:26:20  </span><br><span class="line">          inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:8700857 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:31533 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:596390239 (568.7 MiB)  TX bytes:2886956 (2.7 MiB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:16436  Metric:1</span><br><span class="line">          RX packets:68 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:68 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0 </span><br><span class="line">          RX bytes:2856 (2.7 KiB)  TX bytes:2856 (2.7 KiB)</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">eth0 表示第一块网卡，其中 HWaddr 表示网卡的物理地址，可以看到目前这个网卡的物理地址(MAC地址）是 00:50:56:BF:26:20</span><br><span class="line">inet addr 用来表示网卡的IP地址，此网卡的 IP地址是 192.168.120.204，广播地址， Bcast:192.168.120.255，掩码地址Mask:255.255.255.0 </span><br><span class="line">lo 是表示主机的回坏地址，这个一般是用来测试一个网络程序，但又不想让局域网或外网的用户能够查看，只能在此台主机上运行和查看所用的网络接口。比如把 HTTPD服务器的指定到回坏地址，在浏览器输入 127.0.0.1 就能看到你所架WEB网站了。但只是您能看得到，局域网的其它主机或用户无从知道。</span><br><span class="line">第一行：连接类型：Ethernet（以太网）HWaddr（硬件mac地址）</span><br><span class="line">第二行：网卡的IP地址、子网、掩码</span><br><span class="line">第三行：UP（代表网卡开启状态）RUNNING（代表网卡的网线被接上）MULTICAST（支持组播）MTU:1500（最大传输单元）：1500字节</span><br><span class="line">第四、五行：接收、发送数据包情况统计</span><br><span class="line">第七行：接收、发送数据字节数统计信息。</span><br></pre></td></tr></table></figure><p>实例2：启动关闭指定网卡</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开</span></span><br><span class="line">ifconfig eth0 up</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关</span></span><br><span class="line">ifconfig eth0 down</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。</span><br></pre></td></tr></table></figure><p>实例3：为网卡配置和删除IPv6地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置</span></span><br><span class="line">ifconfig eth0 add 33ffe:3240:800:1005::2/64</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除</span></span><br><span class="line">ifconfig eth0 del 33ffe:3240:800:1005::2/64</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh登陆linux服务器操作要小心，关闭了就不能开启了，除非你有多网卡。</span><br></pre></td></tr></table></figure><p>实例4：用ifconfig修改MAC地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 hw ether 00:AA:BB:CC:DD:EE</span><br></pre></td></tr></table></figure><p>实例5：配置IP地址</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig eth0 192.168.120.56 </span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 </span><br><span class="line">[root@localhost ~]# ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">ifconfig eth0 192.168.120.56 </span><br><span class="line"></span><br><span class="line">给eth0网卡配置IP地：192.168.120.56</span><br><span class="line"></span><br><span class="line">ifconfig eth0 192.168.120.56 netmask 255.255.255.0 </span><br><span class="line"></span><br><span class="line">给eth0网卡配置IP地址：192.168.120.56 ，并加上子掩码：255.255.255.0</span><br><span class="line"></span><br><span class="line">ifconfig eth0 192.168.120.56 netmask 255.255.255.0 broadcast 192.168.120.255</span><br><span class="line"></span><br><span class="line">给eth0网卡配置IP地址：192.168.120.56，加上子掩码：255.255.255.0，加上个广播地址： 192.168.120.255</span><br></pre></td></tr></table></figure><p>实例6：启用和关闭ARP协议</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 开启网卡eth0的arp协议</span></span><br><span class="line">ifconfig eth0 arp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭网卡eth0的arp协议</span></span><br><span class="line">ifconfig eth0 -arp</span><br></pre></td></tr></table></figure><p>实例7：设置最大传输单元</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置能通过的最大数据包大小为1500bytes</span></span><br><span class="line">ifconfig eth0 mtu 1500</span><br></pre></td></tr></table></figure><p>备注：用ifconfig命令配置的网卡信息，在网卡重启后机器重启后，配置就不存在。要想将上述的配置信息永远的存的电脑里，那就要修改网卡的配置文件了。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 网络命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-yum命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-yum%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-yum%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;yum(Yellow dog Updater, Modified)是一个在<code>Fedora</code>和<code>RedHat</code>以及<code>SUSE</code>中的<code>Shell</code>前端软件<strong>包管理器</strong>。</p><p>&emsp;基于<code>RPM</code>包管理，能够从指定的服务器自动下载<code>RPM</code>包并且安装，可以自动处理依赖性关系，并且<strong>一次安装所有依赖的软体包</strong>，无须繁琐地一次次下载、安装。</p><p>&emsp;yum提供了查找、安装、删除某一个、一组甚至全部软件包的命令，而且命令简洁而又好记。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yum [options] [command] [package ...]</span><br><span class="line">options:选项,可选。</span><br><span class="line">command:要进行的操作。</span><br><span class="line">package:操作的对象。</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;软件包管理器</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-h, 帮助</span><br><span class="line">-y, 当安装过程提示选择全部为&quot;yes&quot;</span><br><span class="line">-q, 不显示安装的过程</span><br></pre></td></tr></table></figure><h3 id="4-常用命令："><a href="#4-常用命令：" class="headerlink" title="4. 常用命令："></a>4. 常用命令：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1.列出所有可更新的软件清单命令：yum check-update</span><br><span class="line">2.更新所有软件命令：yum update</span><br><span class="line">3.仅安装指定的软件命令：yum install &lt;package_name&gt;</span><br><span class="line">4.仅更新指定的软件命令：yum update &lt;package_name&gt;</span><br><span class="line">5.列出所有可安裝的软件清单命令：yum list</span><br><span class="line">6.删除软件包命令：yum remove &lt;package_name&gt;</span><br><span class="line">7.查找软件包 命令yum search &lt;keyword&gt;</span><br><span class="line">8.查看系统中软件管理信息：yum history</span><br><span class="line">9.清除缓存命令:</span><br><span class="line">yum clean packages: 清除缓存目录下的软件包</span><br><span class="line">yum clean headers: 清除缓存目录下的 headers</span><br><span class="line">yum clean oldheaders: 清除缓存目录下旧的 headers</span><br><span class="line">yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</span><br></pre></td></tr></table></figure><h3 id="5．使用实例："><a href="#5．使用实例：" class="headerlink" title="5．使用实例："></a>5．使用实例：</h3><p>实例1：显示已经安装的软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list installed</span><br></pre></td></tr></table></figure><p>实例2：查找可以安装的软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum list tomcat</span><br></pre></td></tr></table></figure><p>实例3：安装软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install tomcat</span><br></pre></td></tr></table></figure><p>实例4：卸载软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum remove tomcat</span><br></pre></td></tr></table></figure><p>实例5：列出软件包的依赖</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum deplist tomcat</span><br></pre></td></tr></table></figure><p>实例6：info显示软件包的描述信息和概要信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum info tomcat</span><br></pre></td></tr></table></figure><p>实例7：升级软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 升级所有的软件包</span></span><br><span class="line">yum update</span><br><span class="line"><span class="meta">#</span><span class="bash"> 升级某一个软件包 ，以升级 tomcat 为例</span></span><br><span class="line">yum update tomcat</span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查可更新的程序</span></span><br><span class="line">yum check-update</span><br></pre></td></tr></table></figure><p>实例8：查看yum安装的软件路径</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查找redis的安装包</span></span><br><span class="line">rpm -qa|grep redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查找安装包的安装路径</span></span><br><span class="line">rpm -ql redis-3.2.10-2.el7.x86_64</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-wget命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-wget%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-wget%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux系统中的wget是一个<strong>下载文件的工具</strong>，它用在命令行下。wget的名字是<code>“World Wide Web”</code>与<code>“get”</code>的结合,对于Linux用户是必不可少的工具，我们经常要下载一些软件或从远程服务器恢复备份到本地服务器。wget支持<code>HTTP</code>，<code>HTTPS</code>和<code>FTP</code>协议，可以使用HTTP代理。所谓的<strong>自动下载</strong>是指wget可以在用户退出系统的之后在<strong>后台执行</strong>。这意味这你可以登录系统，启动一个wget下载任务，然后退出系统，wget将在后台执行直到任务完成，相对于其它大部分浏览器在下载大量数据时需要用户一直的参与，这省去了极大的麻烦。</p><p>wget可以跟踪HTML页面上的链接依次下载来创建远程服务器的本地版本，完全重建原始站点的目录结构。这又常被称作<code>&quot;递归下载&quot;</code>。在递归下载的时候，wget遵循Robot Exclusion标准(/robots.txt). <em>wget可以在下载的同时，将链接转换成指向本地文件，以方便离线浏览</em>。</p><p>wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性。<em>如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕</em>。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget [参数] [URL地址]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;<code>wget</code>类似于迅雷，是一种下载工具,用于从网络上下载资源，没有指定目录，下载资源会<strong>默认</strong>为<strong>当前目录</strong>。wget虽然功能强大，但是使用起来还是比较简单：</p><p>1）支持<strong>断点下传</strong>功能；这一点，也是网络蚂蚁和FlashGet当年最大的卖点，现在，Wget也可以使用此功能，那些网络不是太好的用户可以放心了；</p><p>2）同时<strong>支持FTP和HTTP下载</strong>方式；尽管现在大部分软件可以使用HTTP方式下载，但是，有些时候，仍然需要使用FTP方式下载软件；</p><p>3）<strong>支持代理服务器</strong>；对安全强度很高的系统而言，一般不会将自己的系统直接暴露在互联网上，所以，支持代理是下载软件必须有的功能；</p><p>4）<strong>设置方便简单</strong>；可能，习惯图形界面的用户已经不是太习惯命令行了，但是，命令行在设置上其实有更多的优点，最少，鼠标可以少点很多次，也不要担心是否错点鼠标；</p><p>5）<strong>程序小，完全免费</strong>；程序小可以考虑不计，因为现在的硬盘实在太大了；完全免费就不得不考虑了，即使网络上有很多所谓的免费软件，但是，这些软件的广告却不是我们喜欢的。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p>启动参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-V, –version 显示wget的版本后退出</span><br><span class="line">-h, –help 打印语法帮助</span><br><span class="line">-b, –background 启动后转入后台执行</span><br><span class="line">-e, –execute=COMMAND 执行`.wgetrc’格式的命令，wgetrc格式参见/etc/wgetrc或~/.wgetrc</span><br></pre></td></tr></table></figure><p>记录和输入文件参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-o, –output-file=FILE 把记录写到FILE文件中</span><br><span class="line">-a, –append-output=FILE 把记录追加到FILE文件中</span><br><span class="line">-d, –debug 打印调试输出</span><br><span class="line">-q, –quiet 安静模式(没有输出)</span><br><span class="line">-v, –verbose 冗长模式(这是缺省设置)</span><br><span class="line">-nv, –non-verbose 关掉冗长模式，但不是安静模式</span><br><span class="line">-i, –input-file=FILE 下载在FILE文件中出现的URLs</span><br><span class="line">-F, –force-html 把输入文件当作HTML格式文件对待</span><br><span class="line">-B, –base=URL 将URL作为在-F -i参数指定的文件中出现的相对链接的前缀</span><br><span class="line">–sslcertfile=FILE, 可选客户端证书</span><br><span class="line">–sslcertkey=KEYFILE, 可选客户端证书的KEYFILE</span><br><span class="line">–egd-file=FILE, 指定EGD socket的文件名</span><br></pre></td></tr></table></figure><p>下载参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">–bind-address=ADDRESS, 指定本地使用地址(主机名或IP，当本地有多个IP或名字时使用)</span><br><span class="line">-t, –tries=NUMBER 设定最大尝试链接次数(0 表示无限制).</span><br><span class="line">-O, –output-document=FILE 把文档写到FILE文件中</span><br><span class="line">-nc, –no-clobber 不要重复下载已存在的文件。</span><br><span class="line">-c, –continue 接着下载没下载完的文件</span><br><span class="line">–progress=TYPE 设定进程条标记</span><br><span class="line">-N, –timestamping 不要重新下载文件除非比本地文件新</span><br><span class="line">-S, –server-response 打印服务器的回应</span><br><span class="line">–spider 不下载任何东西</span><br><span class="line">-T, –timeout=SECONDS 设定响应超时的秒数</span><br><span class="line">-w, –wait=SECONDS 两次尝试之间间隔SECONDS秒</span><br><span class="line">–waitretry=SECONDS 在重新链接之间等待1…SECONDS秒</span><br><span class="line">–random-wait 在下载之间等待0…2*WAIT秒</span><br><span class="line">-Y, –proxy=on/off 打开或关闭代理</span><br><span class="line">-Q, –quota=NUMBER 设置下载的容量限制</span><br><span class="line">–limit-rate=RATE 限定下载输率</span><br></pre></td></tr></table></figure><p>目录参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-nd –no-directories 不创建目录</span><br><span class="line">-x, –force-directories 强制创建目录</span><br><span class="line">-nH, –no-host-directories 不创建主机目录</span><br><span class="line">-P, –directory-prefix=PREFIX 将文件保存到目录 PREFIX/…</span><br><span class="line">–cut-dirs=NUMBER 忽略 NUMBER层远程目录</span><br></pre></td></tr></table></figure><p>HTTP 选项参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">–http-user=USER 设定HTTP用户名为 USER.</span><br><span class="line">–http-passwd=PASS 设定http密码为 PASS</span><br><span class="line">-C, –cache=on/off 允许/不允许服务器端的数据缓存 (一般情况下允许)</span><br><span class="line">-E, –html-extension 将所有text/html文档以.html扩展名保存</span><br><span class="line">–ignore-length 忽略 `Content-Length`头域</span><br><span class="line">–header=STRING 在headers中插入字符串 STRING</span><br><span class="line">–proxy-user=USER 设定代理的用户名为 USER</span><br><span class="line">–proxy-passwd=PASS 设定代理的密码为 PASS</span><br><span class="line">–referer=URL 在HTTP请求中包含 `Referer: URL`头</span><br><span class="line">-s, –save-headers 保存HTTP头到文件</span><br><span class="line">-U, –user-agent=AGENT 设定代理的名称为 AGENT而不是 Wget/VERSION</span><br><span class="line">–no-http-keep-alive 关闭 HTTP活动链接 (永远链接)</span><br><span class="line">–cookies=off 不使用 cookies</span><br><span class="line">–load-cookies=FILE 在开始会话前从文件 FILE中加载cookie</span><br><span class="line">–save-cookies=FILE 在会话结束后将 cookies保存到 FILE文件中</span><br></pre></td></tr></table></figure><p>FTP 选项参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-nr, –dont-remove-listing 不移走 `.listing`文件</span><br><span class="line">-g, –glob=on/off 打开或关闭文件名的 globbing机制</span><br><span class="line">–passive-ftp 使用被动传输模式 (缺省值).</span><br><span class="line">–active-ftp 使用主动传输模式</span><br><span class="line">–retr-symlinks 在递归的时候，将链接指向文件(而不是目录)</span><br></pre></td></tr></table></figure><p>递归下载参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-r, –recursive 递归下载－－慎用!</span><br><span class="line">-l, –level=NUMBER 最大递归深度 (inf 或 0 代表无穷)</span><br><span class="line">–delete-after 在现在完毕后局部删除文件</span><br><span class="line">-k, –convert-links 转换非相对链接为相对链接</span><br><span class="line">-K, –backup-converted 在转换文件X之前，将之备份为 X.orig</span><br><span class="line">-m, –mirror 等价于 -r -N -l inf -nr</span><br><span class="line">-p, –page-requisites 下载显示HTML文件的所有图片</span><br></pre></td></tr></table></figure><p>递归下载中的包含和不包含(accept/reject)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-A, –accept=LIST 分号分隔的被接受扩展名的列表</span><br><span class="line">-R, –reject=LIST 分号分隔的不被接受的扩展名的列表</span><br><span class="line">-D, –domains=LIST 分号分隔的被接受域的列表</span><br><span class="line">–exclude-domains=LIST 分号分隔的不被接受的域的列表</span><br><span class="line">–follow-ftp 跟踪HTML文档中的FTP链接</span><br><span class="line">–follow-tags=LIST 分号分隔的被跟踪的HTML标签的列表</span><br><span class="line">-G, –ignore-tags=LIST 分号分隔的被忽略的HTML标签的列表</span><br><span class="line">-H, –span-hosts 当递归时转到外部主机</span><br><span class="line">-L, –relative 仅仅跟踪相对链接</span><br><span class="line">-I, –include-directories=LIST 允许目录的列表</span><br><span class="line">-X, –exclude-directories=LIST 不被包含目录的列表</span><br><span class="line">-np, –no-parent 不要追溯到父目录</span><br><span class="line">wget -S –spider url 不下载只显示过程</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：使用wget下载单个文件:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以下的例子是从网络下载一个文件并保存在当前目录，在下载的过程中会显示进度条，包含（下载完成百分比，已经下载的字节，当前下载速度，剩余下载时间）。</span></span><br><span class="line">wget http://www.minjieren.com/wordpress-3.1-zh_CN.zip</span><br></pre></td></tr></table></figure><p>实例2：使用wget -O下载并以不同的文件名保存</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">wget默认会以最后一个符合”/”的后面的字符来命令，对于动态链接的下载通常文件名会不正确。</span><br><span class="line">错误：下面的例子会下载一个文件并以名称download.aspx?id=1080保存</span><br><span class="line">wget http://www.minjieren.com/download?id=1</span><br><span class="line">即使下载的文件是zip格式，它仍然以download.php?id=1080命令。</span><br><span class="line">正确：为了解决这个问题，我们可以使用参数-O来指定一个文件名：</span><br><span class="line">wget -O wordpress.zip http://www.minjieren.com/download.aspx?id=1080</span><br></pre></td></tr></table></figure><p>实例3：使用wget –-limit-rate限速下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当你执行wget的时候，它默认会占用全部可能的宽带下载。但是当你准备下载一个大文件，而你还需要下载其它文件时就有必要限速了。</span></span><br><span class="line">wget --limit-rate=300k http://www.minjieren.com/wordpress-3.1-zh_CN.zip</span><br></pre></td></tr></table></figure><p>实例4：使用wget -c断点续传</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -c http://www.minjieren.com/wordpress-3.1-zh_CN.zip</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用wget -c重新启动下载中断的文件，对于我们下载大文件时突然由于网络等原因中断非常有帮助，我们可以继续接着下载而不是重新下载一个文件。需要继续中断的下载时可以使用-c参数。</span><br></pre></td></tr></table></figure><p>实例5：使用wget -b后台下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -b http://www.minjieren.com/wordpress-3.1-zh_CN.zip</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">对于下载非常大的文件的时候，我们可以使用参数-b进行后台下载。</span><br><span class="line">[root@localhost lxy]# wget -b http://www.minjieren.com/wordpress-3.1-zh_CN.zip</span><br><span class="line">Continuing in background, pid 1840.</span><br><span class="line">Output will be written to `wget-log&#x27;.</span><br><span class="line">你可以使用以下命令来察看下载进度：</span><br><span class="line">tail -f wget-log</span><br></pre></td></tr></table></figure><p>实例6：伪装代理名称下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --user-agent=&quot;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.204 Safari/534.16&quot; http://www.minjieren.com/wordpress-3.1-zh_CN.zip</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有些网站能通过根据判断代理名称不是浏览器而拒绝你的下载请求。不过你可以通过–user-agent参数伪装。</span><br></pre></td></tr></table></figure><p>实例7：使用wget –spider测试下载链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --spider URL</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">当你打算进行定时下载，你应该在预定时间测试下载链接是否有效。我们可以增加–spider参数进行检查。</span><br><span class="line"></span><br><span class="line">wget --spider URL</span><br><span class="line"></span><br><span class="line">如果下载链接正确，将会显示:</span><br><span class="line"></span><br><span class="line">[root@localhost lxy]# wget --spider URL</span><br><span class="line">Spider mode enabled. Check if remote file exists.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [text/html]</span><br><span class="line">Remote file exists and could contain further links,</span><br><span class="line">but recursion is disabled -- not retrieving.</span><br><span class="line">这保证了下载能在预定的时间进行.</span><br><span class="line"></span><br><span class="line">但当你给错了一个链接，将会显示如下错误:</span><br><span class="line"></span><br><span class="line">[root@localhost lxy]# wget --spider url</span><br><span class="line">Spider mode enabled. Check if remote file exists.</span><br><span class="line">HTTP request sent, awaiting response... 404 Not Found</span><br><span class="line">Remote file does not exist -- broken link!!!</span><br><span class="line"></span><br><span class="line">你可以在以下几种情况下使用spider参数：</span><br><span class="line">1.定时下载之前进行检查</span><br><span class="line">2.间隔检测网站是否可用</span><br><span class="line">3.检查网站页面的死链接</span><br></pre></td></tr></table></figure><p>实例8：使用wget –tries增加重试次数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --tries=40 URL</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果网络有问题或下载一个大文件也有可能失败。wget默认重试20次连接下载文件。如果需要，你可以使用–tries增加重试次数。</span><br></pre></td></tr></table></figure><p>实例9：使用wget -i下载多个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -i filelist.txt</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">首先，保存一份下载链接文件:</span><br><span class="line">cat &gt; filelist.txt</span><br><span class="line">url1</span><br><span class="line">url2</span><br><span class="line">url3</span><br><span class="line">url4</span><br><span class="line">接着使用这个文件和参数-i下载</span><br></pre></td></tr></table></figure><p>实例10：使用wget –mirror镜像网站</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget --mirror -p --convert-links -P ./LOCAL URL</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">下载整个网站到本地。</span><br><span class="line">–miror:开户镜像下载</span><br><span class="line">-p:下载所有为了html页面显示正常的文件</span><br><span class="line">–convert-links:下载后，转换成本地的链接</span><br><span class="line">-P ./LOCAL：保存所有文件和目录到本地指定目录</span><br></pre></td></tr></table></figure><p>实例11：使用wget –reject过滤指定格式下载</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 下载一个网站，但你不希望下载图片，可以使用以下命令。</span><br><span class="line">wget --reject=gif url</span><br></pre></td></tr></table></figure><p>实例12：使用wget -o把下载信息存入日志文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 不希望下载信息直接显示在终端而是在一个日志文件，可以使用-o选项</span></span><br><span class="line">wget -o download.log URL</span><br></pre></td></tr></table></figure><p>实例13：使用wget -Q限制总下载文件大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 当你想要下载的文件超过5M而退出下载，你可以使用。注意：这个参数对单个文件下载不起作用，只能递归下载时才有效。</span></span><br><span class="line">wget -Q5m -i filelist.txt</span><br></pre></td></tr></table></figure><p>实例14：使用wget -r -A下载指定格式文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget -r -A.pdf url</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">可以在以下情况使用该功能：</span><br><span class="line">下载一个网站的所有图片</span><br><span class="line">下载一个网站的所有视频</span><br><span class="line">下载一个网站的所有PDF文件</span><br></pre></td></tr></table></figure><p>实例15：使用wget FTP下载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用wget匿名ftp下载：</span></span><br><span class="line">wget ftp-url</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用wget用户名和密码认证的ftp下载:</span></span><br><span class="line">wget --ftp-user=USERNAME --ftp-password=PASSWORD url</span><br></pre></td></tr></table></figure><h3 id="5．编译安装"><a href="#5．编译安装" class="headerlink" title="5．编译安装"></a>5．编译安装</h3><p>使用如下命令编译安装： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># tar zxvf wget-1.9.1.tar.gz </span><br><span class="line"># cd wget-1.9.1 </span><br><span class="line"># ./configure </span><br><span class="line"># make </span><br><span class="line"># make install</span><br></pre></td></tr></table></figure><h3 id="yum安装wget"><a href="#yum安装wget" class="headerlink" title="yum安装wget"></a>yum安装wget</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install wget</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-wc命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-wc%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-wc%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux系统中的wc(Word Count)命令的功能为<strong>统计</strong>指定文件中的<strong>字节数</strong>、<strong>字数</strong>、<strong>行数</strong>，并将统计结果显示输出。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc [选项] 文件...</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;统计指定文件中的字节数、字数、行数，并将统计结果显示输出。该命令统计指定文件中的字节数、字数、行数。如果没有给出文件名，则从标准输入读取。wc同时也给出所指定文件的总统计数。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-c, 统计字节数。</span><br><span class="line">-l, 统计行数。</span><br><span class="line">-m, 统计字符数。这个标志不能与 -c 标志一起使用。</span><br><span class="line">-w, 统计字数。一个字被定义为由空白、跳格或换行字符分隔的字符串。</span><br><span class="line">-L, 打印最长行的长度。</span><br><span class="line">-help, 显示帮助信息</span><br><span class="line">--version, 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：查看文件的字节数、字数、行数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wc test.txt</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# wc test.txt</span><br><span class="line"> 7  8 70 test.txt</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7    8     70     test.txt</span><br><span class="line">行数 单词数 字节数 文件名</span><br></pre></td></tr></table></figure><p>实例2：用wc命令怎么做到只打印统计数字不打印文件名</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用管道线，这在编写shell脚本时特别有用。</span></span><br><span class="line">cat test.txt | wc -l</span><br></pre></td></tr></table></figure><p>实例3：用来统计当前目录下的文件数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 数量中包含当前目录</span></span><br><span class="line">ls -l | wc -l</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-watch命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-watch%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-watch%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;watch是一个非常实用的命令，基本所有的Linux发行版都带有这个小工具，如同名字一样，watch可以帮你<strong>监测一个命令的运行结果</strong>，省得你一遍遍的手动运行。在Linux下，watch是周期性的执行下个程序，并全屏显示执行结果。你可以拿他来监测你想要的一切命令的结果变化，比如tail一个log文件，ls监测某个文件的大小变化，看你的想象力了！</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch [参数] [命令]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;可以将命令的输出结果输出到标准输出设备，多用于周期性执行命令/定时执行命令</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-n或--interval, watch缺省每2秒运行一下程序，可以用-n或-interval来指定间隔的时间。</span><br><span class="line">-d或--differences, 用-d或--differences 选项watch 会高亮显示变化的区域。 而-d=cumulative选项会把变动过的地方(不管最近的那次有没有变动)都高亮显示出来。</span><br><span class="line">-t或-no-title, 会关闭watch命令在顶部的时间间隔,命令，当前时间的输出。</span><br><span class="line">-h或--help, 查看帮助文档</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：每隔一秒高亮显示网络链接数的变化情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 1 -d netstat -ant</span><br></pre></td></tr></table></figure><p>其它操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">切换终端：Ctrl+x</span><br><span class="line">退出watch：Ctrl+g</span><br></pre></td></tr></table></figure><p>实例2：每隔一秒高亮显示http链接数的变化情况</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 每隔一秒高亮显示http链接数的变化情况。后面接的命令若带有管道符，需要加<span class="string">&#x27;&#x27;</span>将命令区域归整。</span></span><br><span class="line">watch -n 1 -d &#x27;pstree|grep http&#x27;</span><br></pre></td></tr></table></figure><p>实例3：实时查看模拟攻击客户机建立起来的连接数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch &#x27;netstat -an | grep:21 | \ grep&lt;模拟攻击客户机的IP&gt;| wc -l&#x27; </span><br></pre></td></tr></table></figure><p>实例4：监测当前目录中 scf’ 的文件的变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -d &#x27;ls -l|grep scf&#x27; </span><br></pre></td></tr></table></figure><p>实例5：10秒一次输出系统的平均负载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">watch -n 10 &#x27;cat /proc/loadavg&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-w命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-w%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-w%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux w(who)命令用于显示<strong>目前登入系统的用户信息</strong>。执行这项指令可得知目前登入系统的用户有哪些人，以及他们<strong>正在执行的程序</strong>。单独执行<code>w</code>指令会显示所有的用户，您也可指定用户名称，仅显示某位用户的相关信息。</p><p>比如，我们在vi打开文件编辑的时候，经常会发现这个文件被别人打开了，这时就可以用w来看一下，如果在输出的列表中，那么就可以要对方先退出vi；如果不在列表中，那么就是以前在vi编辑该文件时没有正常退出（如网络断线）。该命令也可以用来查看是否有不明身份的用户登录了系统。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w [选项] [用户名称]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;显示已经登入系统的用户列表，并显示用户正在执行的指令。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-f, 开启或关闭显示用户从何处登入系统。</span><br><span class="line">-h, 不显示各栏位的标题信息列。</span><br><span class="line">-l, 使用详细格式列表，此为预设值。</span><br><span class="line">-s, 使用简洁格式列表，不显示用户登入时间，终端机阶段作业和程序所耗费的CPU时间。</span><br><span class="line">-u, 忽略执行程序的名称，以及该程序耗费CPU时间的信息。</span><br><span class="line">-V, 显示版本信息。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示已登入系统的用户信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost lxy]# w</span><br><span class="line"> 15:58:14 up 5 days,  6:11,  4 users,  load average: 2.83, 2.59, 2.28</span><br><span class="line">USER     TTY      FROM             LOGIN@   IDLE   JCPU   PCPU WHAT</span><br><span class="line">root     pts/0    :0               Fri09    5days  0.11s  0.11s bash</span><br><span class="line">root     pts/1    172.16.132.111   10:57    0.00s  2:41   0.01s w</span><br><span class="line">root     pts/2    192.168.240.4    14:14   54.00s  0.23s  0.03s vim replace.sh</span><br><span class="line">root     pts/3    172.16.132.111   14:27    5.00s  0.84s  0.84s -bash</span><br></pre></td></tr></table></figure><p>实例2：显示已登入系统的用户信息(不显示登录位置)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 返回信息中去掉了FROM这一列信息</span></span><br><span class="line">w -f</span><br></pre></td></tr></table></figure><p>实例3：显示已登入系统的用户信息(以精简模式显示):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w -s</span><br></pre></td></tr></table></figure><p>实例4：显示已登入系统的用户信息(不显示标题):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">w -h</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-type命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-type%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-type%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;type命令用来显示指定<strong>命令的类型</strong>。</p><p>&emsp;一个命令的类型可以是如下之一</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">alias:别名</span><br><span class="line">keyword:关键字，Shell保留字</span><br><span class="line">function:函数，Shell函数</span><br><span class="line">builtin:内建命令，Shell内建命令</span><br><span class="line">file:文件，磁盘文件，外部命令</span><br><span class="line">unfound:没有找到</span><br></pre></td></tr></table></figure><p>它是Linux系统的一种自省机制，知道了是那种类型，我们就可以针对性的获取帮助。比如内建命令可以用help命令来获取帮助，外部命令用man或者info来获取帮助。</p><h3 id="1-命令格式："><a href="#1-命令格式：" class="headerlink" title="1. 命令格式："></a>1. 命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type [选项][参数]</span><br></pre></td></tr></table></figure><h3 id="2-命令功能："><a href="#2-命令功能：" class="headerlink" title="2. 命令功能："></a>2. 命令功能：</h3><p>&emsp;用来显示指定<strong>命令的类型</strong>。</p><h3 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3. 常用参数"></a>3. 常用参数</h3><p>type命令的基本使用方式就是直接跟上命令名字。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-a, 可以显示所有可能的类型，比如有些命令如pwd是shell内建命令，也可以是外部命令。</span><br><span class="line">-p, 只返回外部命令的信息，相当于which命令。</span><br><span class="line">-f, 只返回shell函数的信息。</span><br><span class="line">-t, 只返回指定类型的信息。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：type自己是什么类型的命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# type -a type</span><br><span class="line">type is a shell builtin</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-rpm命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rpm%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-rpm%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<code>rpm</code>命令用于<strong>管理套件</strong>。</p><p>rpm(redhat package manager)原本是<code>RedHat Linux</code>发行版专门用来管理<code>Linux</code>各项套件的程序，由于它遵循GPL规则且功能强大方便，因而广受欢迎。逐渐受到其他发行版的采用。<code>RPM</code>套件管理方式的出现，让Linux易于安装，升级，间接提升了Linux的适用度。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm [选项...]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用于安装、卸载<code>.rpm</code>软件</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">-a, 查询所有套件；</span><br><span class="line">-b&lt;完成阶段&gt;&lt;套件档&gt;+或-t &lt;完成阶段&gt;&lt;套件档&gt;+, 设置包装套件的完成阶段，并指定套件档的文件名称；</span><br><span class="line">-c, 只列出组态配置文件，本参数需配合&quot;-l&quot;参数使用；</span><br><span class="line">-d, 只列出文本文件，本参数需配合&quot;-l&quot;参数使用；</span><br><span class="line">-e&lt;套件档&gt;或--erase&lt;套件档&gt;, 删除指定的套件；</span><br><span class="line">-f&lt;文件&gt;+, 查询拥有指定文件的套件；</span><br><span class="line">-h或--hash, 套件安装时显示安装进度；</span><br><span class="line">-i, 显示套件的相关信息；</span><br><span class="line">-i&lt;套件档&gt;或--install&lt;套件档&gt;, 安装指定的套件档；</span><br><span class="line">-l, 显示套件的文件列表；</span><br><span class="line">-p&lt;套件档&gt;+, 查询指定的RPM套件档；</span><br><span class="line">-q, 使用询问模式，当遇到任何问题时，rpm指令会先询问用户；</span><br><span class="line">-R, 显示套件的关联性信息；</span><br><span class="line">-s, 显示文件状态，本参数需配合&quot;-l&quot;参数使用；</span><br><span class="line">-U&lt;套件档&gt;或--upgrade&lt;套件档&gt;, 升级指定的套件档；</span><br><span class="line">-v, 显示指令执行过程；</span><br><span class="line">-vv, 详细显示指令执行过程，便于排错。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：安装软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 直接安装</span></span><br><span class="line">rpm -ivh your-package.rpm</span><br><span class="line"><span class="meta">#</span><span class="bash"> 忽略报错，强制安装</span></span><br><span class="line">rpm --force -ivh your-package.rpm </span><br></pre></td></tr></table></figure><p>实例2：如何卸载rpm软件包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查询(rpm包中的文件安装的位置)</span></span><br><span class="line">rpm -ql tree</span><br><span class="line"><span class="meta">#</span><span class="bash"> 卸载</span></span><br><span class="line">rpm -e tree</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询</span></span><br><span class="line">rpm -ql tree</span><br></pre></td></tr></table></figure><p>实例3：列出所有安装过的包</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa</span><br></pre></td></tr></table></figure><p>实例4：如何获得某个软件包的文件全名</p><pre><code class="shell">rpm -q tree</code></pre><h3 id="5．wget、rpm、yum、apt-get命令："><a href="#5．wget、rpm、yum、apt-get命令：" class="headerlink" title="5．wget、rpm、yum、apt-get命令："></a>5．wget、rpm、yum、apt-get命令：</h3><p>串联使用：使用<code>wget</code>下载一个<code>rpm包</code>, 然后用<code>rpm -ivh xxx.rpm</code>安装这个软件，嫌麻烦的话，就可以直接用<code>yum install xxx</code>来自动下载和安装依赖的rpm软件。</p><p><code>apt-get</code>是<code>ubuntu</code>下的一个软件安装方式，它是基于<code>debain</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-ln命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ln%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ln%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;ln(link)命令是linux中又一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个<strong>同步的链接</strong>.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln [参数] [源文件或目录]  [目标文件或目录]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的<strong>别名</strong>，而链接又可分为两种 : <strong>硬链接</strong>(hard link)与<strong>软链接</strong>(symbolic link)，<strong>硬链接</strong>的意思是<em>一个档案可以有多个名称</em>，而<strong>软链接</strong>的方式则是<em>产生一个特殊的档案</em>，该档案的内容是指向另一个档案的位置。硬链接是存在<em>同一个文件系统</em>中，而软链接却<em>可以跨越不同的文件系统</em>。</p><p>&emsp;软链接：</p><p>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式</p><p>2.软链接可以跨文件系统，硬链接不可以</p><p>3.软链接可以对一个不存在的文件名进行链接</p><p>4.软链接可以对目录进行链接</p><p>&emsp;硬链接:</p><p>1.硬链接，以文件<strong>副本</strong>的形式存在。但不占用实际空间。</p><p>2.不允许给目录创建硬链接</p><p>3.硬链接只有在同一个文件系统中才能创建</p><p>&emsp;这里有两点要注意：</p><p>第一，ln命令会保持每一处链接文件的<strong>同步性</strong>，也就是说，不论你改动了哪一处，其它的文件都会发生相同的变化；</p><p>第二，ln的链接又分软链接和硬链接两种，<strong>软链接</strong>就是<code>ln –s 源文件 目标文件</code>，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间，硬链接<code>ln 源文件 目标文件</code>，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，<strong>文件都保持同步变化</strong>。</p><p>ln指令用在链接文件或目录，如同时指定两个以上的文件或目录，且最后的目的地是一个已经存在的目录，则会把前面指定的所有文件或目录复制到该目录中。若同时指定多个文件或目录，且最后的目的地并非是一个已存在的目录，则会出现错误信息。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p>必要参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-b, 删除，覆盖以前建立的链接</span><br><span class="line">-d, 允许超级用户制作目录的硬链接</span><br><span class="line">-f, 强制执行</span><br><span class="line">-i, 交互模式，文件存在则提示用户是否覆盖</span><br><span class="line">-n, 把符号链接视为一般目录</span><br><span class="line">-s, 软链接(符号链接)</span><br><span class="line">-v, 显示详细的处理过程</span><br></pre></td></tr></table></figure><p>选择参数:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-S, &quot;-S&lt;字尾备份字符串&gt; &quot;或 “--suffix=&lt;字尾备份字符串&gt;&quot;</span><br><span class="line">-V, &quot;-V&lt;备份方式&gt;&quot;或&quot;--version-control=&lt;备份方式&gt;&quot;</span><br><span class="line">--help, 显示帮助信息</span><br><span class="line">--version, 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：给文件创建软链接(最后一个为目的文件或目录)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为log.log文件创建软链接link_log，如果log.log丢失，link_log将失效</span></span><br><span class="line">ln -s log.log link_log</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">lrwxrwxrwx 1 root root     11 12-07 16:01 link_log -&gt; log.log</span><br><span class="line">-rw-r--r-- 2 root bin      61 11-13 06:03 log.log</span><br></pre></td></tr></table></figure><p>实例2：给文件创建硬链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 为log.log创建硬链接ln_log，log.log与ln_log的各项属性相同</span></span><br><span class="line">ln log.log ln_log_</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ll</span><br><span class="line">-rw-r--r-- 2 root bin      61 11-13 06:03 ln_log</span><br><span class="line">-rw-r--r-- 2 root bin      61 11-13 06:03 log.log</span><br></pre></td></tr></table></figure><p>实例3：接上面两实例，链接完毕后，<em>删除</em>和<em>重建</em>链接原文件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.源文件被删除后，并没有影响硬链接文件；软链接文件在centos系统下不断的闪烁，提示源文件已经不存在</span><br><span class="line"></span><br><span class="line">2.重建源文件后，软链接不在闪烁提示，说明已经链接成功，找到了链接文件系统；重建后，硬链接文件并没有受到源文件影响，硬链接文件的内容还是保留了删除前源文件的内容，说明硬链接已经失效</span><br></pre></td></tr></table></figure><p>实例4：将文件链接为<strong>另一个目录中</strong>的相同名字</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 在test3目录中创建了log.log的硬链接，修改test3目录中的log2013.log文件，同时也会同步到源文件</span></span><br><span class="line">ln log.log test3</span><br></pre></td></tr></table></figure><p>实例5：给目录创建软链接</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ln -sv /opt/soft/test/test3 /opt/soft/test/test5</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.目录只能创建软链接</span><br><span class="line"></span><br><span class="line">2.目录创建链接必须用绝对路径，相对路径创建会不成功，会提示：符号连接的层数过多这样的错误</span><br><span class="line"></span><br><span class="line">3.在链接目标目录中修改文件都会在源文件目录中同步变化</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-ps命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ps%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-ps%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux中的ps(Process Status)命令用来列出<strong>系统中当前运行的哪些进程</strong>。ps命令列出的是当前那些进程的快照，就是执行ps命令的<strong>那个时刻</strong>的那些进程，如果想要动态的显示进程信息，就可以使用top命令。</p><p>&emsp;要对进程进行监测和控制，首先必须要了解当前进程的情况，也就是需要查看当前进程，而<code>ps</code>命令就是最基本同时也是<strong>非常强大的进程查看</strong>命令。使用该命令可以确定有哪些进程正在运行和运行的状态、进程是否结束、进程有没有僵死、哪些进程占用了过多的资源等等。总之大部分信息都是可以通过执行该命令得到的。</p><p>&emsp;<code>ps</code>为我们提供了进程的一次性的查看，它所提供的查看结果并不动态连续的；如果想对进程时间监控，应该用<code>top</code>工具。</p><p>&emsp;<code>kill</code>命令用于杀死进程。</p><p>&emsp;linux上进程有5种状态: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 运行(正在运行或在运行队列中等待) </span><br><span class="line">2. 中断(休眠中, 受阻, 在等待某个条件的形成或接受到信号) </span><br><span class="line">3. 不可中断(收到信号不唤醒和不可运行, 进程必须等待直到有中断发生) </span><br><span class="line">4. 僵死(进程已终止, 但进程描述符存在, 直到父进程调用wait4()系统调用后释放) </span><br><span class="line">5. 停止(进程收到SIGSTOP, SIGSTP, SIGTIN, SIGTOU信号后停止运行运行) </span><br></pre></td></tr></table></figure><p>&emsp;ps工具标识进程的5种状态码: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">D:不可中断 uninterruptible sleep (usually IO) </span><br><span class="line">R:运行 runnable (on run queue) </span><br><span class="line">S:中断 sleeping </span><br><span class="line">T:停止 traced or stopped </span><br><span class="line">Z:僵死 a defunct (”zombie”) process </span><br></pre></td></tr></table></figure><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps[参数]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用来显示当前进程的状态</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">a, 显示所有进程</span><br><span class="line">-a, 显示同一终端下的所有程序</span><br><span class="line">-A, 显示所有进程</span><br><span class="line">c, 显示进程的真实名称</span><br><span class="line">-N, 反向选择</span><br><span class="line">-e, 等于“-A”</span><br><span class="line">e, 显示环境变量</span><br><span class="line">f, 显示程序间的关系</span><br><span class="line">-H, 显示树状结构</span><br><span class="line">r, 显示当前终端的进程</span><br><span class="line">T, 显示当前终端的所有程序</span><br><span class="line">u, 指定用户的所有进程</span><br><span class="line">-au, 显示较详细的资讯</span><br><span class="line">-aux, 显示所有包含其他使用者的行程 </span><br><span class="line">-C&lt;命令&gt;, 列出指定命令的状况</span><br><span class="line">--lines&lt;行数&gt;, 每页显示的行数</span><br><span class="line">--width&lt;字符数&gt;, 每页显示的字符数</span><br><span class="line">--help, 显示帮助信息</span><br><span class="line">--version, 显示版本显示</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示所有进程信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -A</span><br></pre></td></tr></table></figure><p>实例2：显示指定用户信息</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -u root</span><br></pre></td></tr></table></figure><p>实例3：显示所有进程信息，连同命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef</span><br></pre></td></tr></table></figure><p>实例4： ps 与grep 常用组合用法，查找特定进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep ssh</span><br></pre></td></tr></table></figure><p>实例5：将目前属于您自己这次登入的PID与相关信息列示出来</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -l</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost lxy]# ps -l</span><br><span class="line">F S   UID    PID   PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD</span><br><span class="line">4 S     0  13373  13359  0  80   0 - 29201 wait   pts/1    00:00:00 bash</span><br><span class="line">0 R     0  21843  13373  0  80   0 - 38308 -      pts/1    00:00:00 ps</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">各相关信息的意义：</span><br><span class="line">F 代表这个程序的旗标 (flag)， 4 代表使用者为 super user</span><br><span class="line">S 代表这个程序的状态 (STAT)，关于各 STAT 的意义将在内文介绍</span><br><span class="line">UID 程序被该 UID 所拥有</span><br><span class="line">PID 就是这个程序的 ID ！</span><br><span class="line">PPID 则是其上级父程序的ID</span><br><span class="line">C CPU 使用的资源百分比</span><br><span class="line">PRI 这个是 Priority (优先执行序) 的缩写，详细后面介绍</span><br><span class="line">NI 这个是 Nice 值，在下一小节我们会持续介绍</span><br><span class="line">ADDR 这个是 kernel function，指出该程序在内存的那个部分。如果是个running的程序，一般就是 &quot;-&quot;</span><br><span class="line">SZ 使用掉的内存大小</span><br><span class="line">WCHAN 目前这个程序是否正在运作当中，若为-表示正在运作</span><br><span class="line">TTY 登入者的终端机位置</span><br><span class="line">TIME 使用掉的CPU时间。</span><br><span class="line">CMD 所下达的指令为何</span><br><span class="line"></span><br><span class="line">在预设的情况下，ps仅会列出与目前所在的bash shell有关的PID而已，所以，当我使用 ps -l的时候，只有三个PID。</span><br></pre></td></tr></table></figure><p>实例6：列出目前所有的正在内存当中的程序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps aux</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">USER：该 process 属于那个使用者账号的</span><br><span class="line">PID ：该 process 的ID</span><br><span class="line">%CPU：该 process 使用掉的CPU资源百分比</span><br><span class="line">%MEM：该 process 所占用的物理内存百分比</span><br><span class="line">VSZ ：该 process 使用掉的虚拟内存量 (Kbytes)</span><br><span class="line">RSS ：该 process 占用的固定的内存量 (Kbytes)</span><br><span class="line">TTY ：该 process 是在那个终端机上面运作，若与终端机无关，则显示 ?，另外， tty1-tty6 是本机上面的登入者程序，若为 pts/0 等等的，则表示为由网络连接进主机的程序。</span><br><span class="line">STAT：该程序目前的状态，主要的状态有</span><br><span class="line">    R ：该程序目前正在运作，或者是可被运作</span><br><span class="line">    S ：该程序目前正在睡眠当中(可说是idle状态)，但可被某些讯号(signal)唤醒。</span><br><span class="line">    T ：该程序目前正在侦测或者是停止了</span><br><span class="line">    Z ：该程序应该已经终止，但是其父程序却无法正常的终止他，造成 zombie (疆尸) 程序的状态</span><br><span class="line">START：该 process 被触发启动的时间</span><br><span class="line">TIME ：该 process 实际使用 CPU 运作的时间</span><br><span class="line">COMMAND：该程序的实际指令</span><br></pre></td></tr></table></figure><p>实例7：列出类似程序树的程序显示</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -axjf</span><br></pre></td></tr></table></figure><p>实例8：找出与 cron 与 syslog 这两个服务有关的 PID 号码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> egrep等价于grep -E</span></span><br><span class="line">ps aux | egrep &#x27;(cron|syslog)&#x27;</span><br></pre></td></tr></table></figure><p>实例9：可以用<code>|</code>管道和<code>more</code>连接起来分页查看</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux |more</span><br></pre></td></tr></table></figure><p>实例10：把所有进程显示出来，并输出到ps001.txt文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -aux &gt; ps001.txt</span><br></pre></td></tr></table></figure><p>实例10：输出指定的字段</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -o pid,ppid,pgrp,session,tpgid,comm</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-killall命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-killall%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-killall%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux系统中的killall命令用于<strong>杀死指定名字的进程</strong>(kill processes by name)。我们可以使用kill命令杀死指定进程PID的进程，如果要找到我们需要杀死的进程，我们还需要在之前使用ps等命令再配合grep来查找进程，而killall把这两个过程合二为一，是一个很好用的命令。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall [参数] [进程名]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用来结束同名的的所有进程</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-Z, 只杀死拥有scontext的进程</span><br><span class="line">-e, 要求匹配进程名称</span><br><span class="line">-I, 忽略小写</span><br><span class="line">-g, 杀死进程组而不是进程</span><br><span class="line">-i, 交互模式，杀死进程前先询问用户</span><br><span class="line">-l, 列出所有的已知信号名称</span><br><span class="line">-q, 不输出警告信息</span><br><span class="line">-s, 发送指定的信号</span><br><span class="line">-v, 报告信号是否成功发送</span><br><span class="line">-w, 等待进程死亡</span><br><span class="line">--help, 显示帮助信息</span><br><span class="line">--version, 显示版本显示</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：杀死所有同名进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall vi</span><br></pre></td></tr></table></figure><p>实例2：向进程发送指定信号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">后台运行程序：</span></span><br><span class="line">vi &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 杀死vi进程：</span></span><br><span class="line">killall -TERM vi</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或:</span></span><br><span class="line">killall -KILL vi</span><br></pre></td></tr></table></figure><p>实例3：把所有的登录后的shell给杀掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">killall -9 bash</span><br></pre></td></tr></table></figure><p>运行命令后，所有bash都会被卡掉了，所以当前所有连接丢失了。需要重新连接并登录。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-kill命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-kill%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-kill%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux中的kill命令用来<strong>终止指定的进程</strong>（terminate a process）的运行，是Linux下进程管理的常用命令。通常，终止一个前台进程可以使用Ctrl+C键，但是，对于一个后台进程就须用kill命令来终止，我们就需要先使用<code>ps</code>、<code>pidof</code>、<code>pstree</code>、<code>top</code>等工具获取进程<strong>PID</strong>，然后使用kill命令来杀掉该进程。</p><p>&emsp;kill命令是<em>通过向进程发送指定的信号</em>来结束相应进程的。在默认情况下，采用编号为<code>15</code>的<code>TERM</code>信号。TERM信号将终止所有不能捕获该信号的进程。对于那些可以捕获该信号的进程就要用编号为<code>9</code>的<code>kill</code>信号，<strong>强行“杀掉”该进程</strong>。 </p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill [参数] [进程号]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;发送指定的信号到相应进程。不指定型号将发送SIGTERM(15)终止指定进程。如果任无法终止该程序可用“-KILL” 参数，其发送的信号为SIGKILL(9) ，将强制结束进程，使用<code>ps</code>命令或者<code>jobs</code>命令可以查看进程号。root用户将影响用户的进程，非root用户只能影响自己的进程。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-l, 信号，若果不加信号的编号参数，则使用“-l”参数会列出全部的信号名称</span><br><span class="line">-a, 当处理当前进程时，不限制命令名和进程号的对应关系</span><br><span class="line">-p, 指定kill 命令只打印相关进程的进程号，而不发送任何信号</span><br><span class="line">-s, 指定发送信号</span><br><span class="line">-u, 指定用户 </span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">1、kill命令可以带信号号码选项，也可以不带。如果没有信号号码，kill命令就会发出终止信号(15)，这个信号可以被进程捕获，使得进程在退出之前可以清理并释放资源。也可以用kill向进程发送特定的信号。例如：</span><br><span class="line"></span><br><span class="line">kill -2 123</span><br><span class="line"></span><br><span class="line">它的效果等同于在前台运行PID为123的进程时按下Ctrl+C键。但是，普通用户只能使用不带signal参数的kill命令或最多使用-9信号。</span><br><span class="line"></span><br><span class="line">2、kill可以带有进程ID号作为参数。当用kill向这些进程发送信号时，必须是这些进程的主人。如果试图撤销一个没有权限撤销的进程或撤销一个不存在的进程，就会得到一个错误信息。</span><br><span class="line"></span><br><span class="line">3、可以向多个进程发信号或终止它们。</span><br><span class="line"></span><br><span class="line">4、当kill成功地发送了信号后，shell会在屏幕上显示出进程的终止信息。有时这个信息不会马上显示，只有当按下Enter键使shell的命令提示符再次出现时，才会显示出来。</span><br><span class="line"></span><br><span class="line">5、应注意，信号使进程强行终止，这常会带来一些副作用，如数据丢失或者终端无法恢复到正常状态。发送信号时必须小心，只有在万不得已时，才用kill信号(9)，因为进程不能首先捕获它。要撤销所有的后台作业，可以输入kill 0。因为有些在后台运行的命令会启动多个进程，跟踪并找到所有要杀掉的进程的PID是件很麻烦的事。这时，使用kill 0来终止所有由当前shell启动的进程，是个有效的方法。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：列出所有信号名称:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -l</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">只有第9种信号(SIGKILL)才可以无条件终止进程，其他信号进程都有权利忽略。</span><br><span class="line">下面是常用的信号：</span><br><span class="line">HUP     1    终端断线</span><br><span class="line">INT     2    中断（同 Ctrl + C）</span><br><span class="line">QUIT    3    退出（同 Ctrl + \）</span><br><span class="line">TERM   15    终止</span><br><span class="line">KILL    9    强制终止</span><br><span class="line">CONT   18    继续（与STOP相反， fg/bg命令）</span><br><span class="line">STOP   19    暂停（同 Ctrl + Z）</span><br></pre></td></tr></table></figure><p>实例2：得到指定信号的数值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost lxy]# kill -l KILL</span><br><span class="line">9</span><br><span class="line">[root@localhost lxy]# kill -l SIGKILL</span><br><span class="line">9</span><br><span class="line">[root@localhost lxy]# kill -l TERM</span><br><span class="line">15</span><br><span class="line">[root@localhost lxy]# kill -l SIGTERM</span><br><span class="line">15</span><br></pre></td></tr></table></figure><p>实例3：先用ps查找进程，然后用kill杀掉</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认使用TERM(15)的终止信号</span></span><br><span class="line">kill 3268</span><br></pre></td></tr></table></figure><p>实例4：彻底杀死进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill –9 3268</span><br></pre></td></tr></table></figure><p>实例5：杀死指定用户的所有进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 过滤出lxy用户进程并杀死</span></span><br><span class="line">kill -9 $(ps -ef | grep lxy)</span><br><span class="line"></span><br><span class="line">kill -u lxy</span><br></pre></td></tr></table></figure><p>实例6：init进程是不可杀的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kill -9 1</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">init是Linux系统操作中不可缺少的程序之一。所谓的init进程，它是一个由内核启动的用户级进程。内核自行启动（已经被载入内存，开始运行，并已初始化所有的设备驱动程序和数据结构等）之后，就通过启动一个用户级程序init的方式，完成引导进程。所以,init始终是第一个进程（其进程编号始终为1）。 其它所有进程都是init进程的子孙。init进程是不可杀的！</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-grep命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-grep%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-grep%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux系统中grep命令是一种强大的<strong>文本搜索工具</strong>，它能使用<strong>正则表达式</strong>搜索文本，并把匹配的行打印出来。grep全称是Global Regular Expression Print，表示全局正则表达式输出，它的使用权限是所有用户。</p><p>&emsp;grep的工作方式是这样的，它在一个或多个文件中搜索字符串模板。如果模板包括空格，则必须被引用，模板后的所有字符串被看作文件名。搜索的结果被送到标准输出，不影响原文件内容。</p><p>&emsp;grep可用于shell脚本，因为grep通过返回一个状态值来说明搜索的状态，如果模板搜索成功，则返回0，如果搜索不成功，则返回1，如果搜索的文件不存在，则返回2。我们利用这些返回值就可进行一些自动化的文本处理工作。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [option] pattern file</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用于过滤/搜索的特定字符。可使用正则表达式能多种命令配合使用，使用上十分灵活。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">-a --text, 不要忽略二进制的数据。   </span><br><span class="line">-A&lt;显示行数&gt; --after-context=&lt;显示行数&gt;, 除了显示符合范本样式的那一列之外，并显示该行之后的内容。   </span><br><span class="line">-b --byte-offset, 在显示符合样式的那一行之前，标示出该行第一个字符的编号。 </span><br><span class="line">-B&lt;显示行数&gt; --before-context=&lt;显示行数&gt;, 除了显示符合样式的那一行之外，并显示该行之前的内容。   </span><br><span class="line">-c --count, 计算符合样式的列数。   </span><br><span class="line">-C&lt;显示行数&gt; --context=&lt;显示行数&gt;或-&lt;显示行数&gt;, 除了显示符合样式的那一行之外，并显示该行之前后的内容。   </span><br><span class="line">-d &lt;动作&gt; --directories=&lt;动作&gt;, 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。   </span><br><span class="line">-e&lt;范本样式&gt; --regexp=&lt;范本样式&gt;, 指定字符串做为查找文件内容的样式。   </span><br><span class="line">-E --extended-regexp, 将样式为延伸的正则表达式来使用。   </span><br><span class="line">-f&lt;规则文件&gt; --file=&lt;规则文件&gt;, 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。   </span><br><span class="line">-F --fixed-regexp, 将样式视为固定字符串的列表。   </span><br><span class="line">-G --basic-regexp, 将样式视为普通的表示法来使用。   </span><br><span class="line">-h --no-filename, 在显示符合样式的那一行之前，不标示该行所属的文件名称。  </span><br><span class="line">-H --with-filename, 在显示符合样式的那一行之前，表示该行所属的文件名称。 </span><br><span class="line">-i --ignore-case, 忽略字符大小写的差别。   </span><br><span class="line">-l --file-with-matches, 列出文件内容符合指定的样式的文件名称。   </span><br><span class="line">-L --files-without-match, 列出文件内容不符合指定的样式的文件名称。   </span><br><span class="line">-n --line-number, 在显示符合样式的那一行之前，标示出该行的列数编号。   </span><br><span class="line">-q --quiet或--silent, 不显示任何信息。   </span><br><span class="line">-r --recursive, 此参数的效果和指定“-d recurse”参数相同。   </span><br><span class="line">-s --no-messages, 不显示错误信息。   </span><br><span class="line">-v --revert-match, 显示不包含匹配文本的所有行。   </span><br><span class="line">-w --word-regexp, 只显示全字符合的列。   </span><br><span class="line">-x --line-regexp, 只显示全列符合的列。</span><br><span class="line">-V --version, 显示版本信息。  </span><br><span class="line">-y, 此参数的效果和指定“-i”参数相同。</span><br></pre></td></tr></table></figure><h3 id="4．规则表达式："><a href="#4．规则表达式：" class="headerlink" title="4．规则表达式："></a>4．规则表达式：</h3><p>grep的规则表达式:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">^, 锚定行的开始 如：&#x27;^grep&#x27;匹配所有以grep开头的行。    </span><br><span class="line">$, 锚定行的结束 如：&#x27;grep$&#x27;匹配所有以grep结尾的行。    </span><br><span class="line">., 匹配一个非换行符的字符 如：&#x27;gr.p&#x27;匹配gr后接一个任意字符，然后是p。    </span><br><span class="line">*, 匹配零个或多个先前字符 如：&#x27;*grep&#x27;匹配所有一个或多个空格后紧跟grep的行。   </span><br><span class="line">.*, 一起用代表任意字符。   </span><br><span class="line">[], 匹配一个指定范围内的字符，如&#x27;[Gg]rep&#x27;匹配Grep和grep。    </span><br><span class="line">[^], 匹配一个不在指定范围内的字符，如：&#x27;[^A-FH-Z]rep&#x27;匹配不包含A-R和T-Z的一个字母开头，紧跟rep的行。    </span><br><span class="line">\(..\), 标记匹配字符，如&#x27;\(love\)&#x27;，love被标记为1。    </span><br><span class="line">\&lt;, 锚定单词的开始，如:&#x27;\&lt;grep&#x27;匹配包含以grep开头的单词的行。    </span><br><span class="line">\&gt;, 锚定单词的结束，如&#x27;grep\&gt;&#x27;匹配包含以grep结尾的单词的行。    </span><br><span class="line">x\&#123;m\&#125;, 重复字符x，m次，如：&#x27;o\&#123;5\&#125;&#x27;匹配包含5个o的行。    </span><br><span class="line">x\&#123;m,\&#125;, 重复字符x,至少m次，如：&#x27;o\&#123;5,\&#125;&#x27;匹配至少有5个o的行。    </span><br><span class="line">x\&#123;m,n\&#125;, 重复字符x，至少m次，不多于n次，如：&#x27;o\&#123;5,10\&#125;&#x27;匹配5--10个o的行。  </span><br><span class="line">\w, 匹配文字和数字字符，也就是[A-Za-z0-9]，如：&#x27;G\w*p&#x27;匹配以G后跟零个或多个文字或数字字符，然后是p。   </span><br><span class="line">\W, \w的反置形式，匹配一个或多个非单词字符，如点号句号等。   </span><br><span class="line">\b, 单词锁定符，如: &#x27;\bgrep\b&#x27;只匹配grep。  </span><br></pre></td></tr></table></figure><p>POSIX字符:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">为了在不同国家的字符编码中保持一至，POSIX(The Portable Operating System Interface)增加了特殊的字符类，如[:alnum:]是[A-Za-z0-9]的另一个写法。要把它们放到[]号内才能成为正则表达式，如[A- Za-z0-9]或[[:alnum:]]。在linux下的grep除fgrep外，都支持POSIX的字符类。</span><br><span class="line">[:alnum:]    #文字数字字符</span><br><span class="line">[:alpha:]    #文字字符</span><br><span class="line">[:digit:]    #数字字符</span><br><span class="line">[:graph:]    #非空字符（非空格、控制字符）</span><br><span class="line">[:upper:]    #大写字符</span><br><span class="line">[:lower:]    #小写字符</span><br><span class="line">[:cntrl:]    #控制字符</span><br><span class="line">[:print:]    #非空字符（包括空格）</span><br><span class="line">[:punct:]    #标点符号</span><br><span class="line">[:space:]    #所有空白字符（新行，空格，制表符）</span><br><span class="line">[:xdigit:]   #十六进制数字（0-9，a-f，A-F）  </span><br></pre></td></tr></table></figure><h3 id="5．使用实例："><a href="#5．使用实例：" class="headerlink" title="5．使用实例："></a>5．使用实例：</h3><p>实例1：查找指定进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep svn</span><br></pre></td></tr></table></figure><p>实例2：查找指定进程个数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef|grep svn -c</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或：</span></span><br><span class="line">ps -ef|grep -c svn</span><br></pre></td></tr></table></figure><p>实例3：从文件中读取关键词进行搜索</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 在test2.txt中写入要匹配的关键字</span></span><br><span class="line">cat test.txt | grep -f test2.txt</span><br></pre></td></tr></table></figure><p>实例4：从文件中读取关键词进行搜索且显示行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 输出test.txt文件中含有从test2.txt文件中读取出的关键词的内容行，并显示每一行的行号</span></span><br><span class="line">cat test.txt | grep -nf test2.txt</span><br></pre></td></tr></table></figure><p>实例5：从文件中查找关键词,并显示行号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep -n &#x27;linux&#x27; test.txt</span><br></pre></td></tr></table></figure><p>实例6：从多个文件中查找关键词</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 多文件时，输出查询到的信息内容行时，会把文件的命名在行最前面输出并且加上<span class="string">&quot;:&quot;</span>作为标示符</span></span><br><span class="line">grep &#x27;linux&#x27; test.txt test2.txt</span><br></pre></td></tr></table></figure><p>实例7：grep不显示本身进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps aux|grep \[s]sh</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或：</span></span><br><span class="line">ps aux | grep ssh | grep -v &quot;grep&quot;</span><br></pre></td></tr></table></figure><p>实例8：找出以u开头的行内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt |grep ^u</span><br></pre></td></tr></table></figure><p>实例9：输出非u开头的行内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt |grep ^[^u]</span><br></pre></td></tr></table></figure><p>实例10：输出以hat结尾的行内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat test.txt |grep hat$</span><br></pre></td></tr></table></figure><p>实例11：通过正则匹配内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]# ifconfig eth0|grep &quot;[0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;\.   [0-9]\&#123;1,3\&#125;\.[0-9]\&#123;1,3\&#125;&quot;</span><br><span class="line">    inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0</span><br><span class="line">[root@localhost test]# ifconfig eth0|grep -E &quot;([0-9]&#123;1,3&#125;\.)&#123;3&#125;[0-9]&quot;</span><br><span class="line">    inet addr:192.168.120.204  Bcast:192.168.120.255  Mask:255.255.255.0</span><br></pre></td></tr></table></figure><p>实例12：显示包含ed或者at字符的内容行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> grep -E 选项可以用来扩展选项为正则表达式。 如果使用了grep 命令的选项-E，则应该使用 | 来分割多个pattern，以此实现OR操作。</span></span><br><span class="line">cat test.txt |grep -E &quot;ed|at&quot;</span><br></pre></td></tr></table></figure><p>实例13：显示当前目录下面以.txt结尾的文件中的所有包含每个字符串至少有7个连续小写字符的字符串的行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep &#x27;[a-z]\&#123;7\&#125;&#x27; *.txt</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-echo命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-echo%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-echo%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;echo命令用来打印信息，是一个最常用的命令。在命令行中常用来打印环境变量的值，已确定当前环境中是否设置了指定的环境变量。在shell脚本中，常用来打印信息和帮助调试程序。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &lt;string&gt;</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用于字符串的输出</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-n, 打印信息之后不换行。</span><br><span class="line">-e, 对字符串转义。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：打印当前的PATH设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $PATH</span><br></pre></td></tr></table></figure><p>实例2：打印当前的LANG(系统语言)设置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $LANG</span><br></pre></td></tr></table></figure><p>实例3：打印之后不换行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 此处使用了-n参数，避免在输出信息之后自动换行。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">read</span>命令从标准输入中读取一行,并把输入行的每个字段的值指定给shell变量name</span></span><br><span class="line">[root@localhost ~]# echo -n &quot;Please input your name: &quot;; read name; echo &quot;Your name is $name&quot;</span><br><span class="line">Please input your name: lxy</span><br><span class="line">Your name is lxy</span><br></pre></td></tr></table></figure><p>实例4：对输出信息进行转义，比如输出换行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加-e选项将\n转义成换行</span></span><br><span class="line">echo -e &quot;hello\nworld&quot;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo hello; echo world</span><br></pre></td></tr></table></figure><p>可以使用如下转义字符:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">\a, 发出警告声；</span><br><span class="line">\b, 删除前一个字符；</span><br><span class="line">\c, 最后不加上换行符号；</span><br><span class="line">\f, 换行但光标仍旧停留在原来的位置；</span><br><span class="line">\n, 换行且光标移至行首；</span><br><span class="line">\r, 光标移至行首，但不换行；</span><br><span class="line">\t, 插入tab；</span><br><span class="line">\v, 与\f相同；</span><br><span class="line">\\, 插入\字符；</span><br><span class="line">\nnn, 插入nnn（八进制）所代表的ASCII字符；</span><br></pre></td></tr></table></figure><p>实例5：显示命令执行结果</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注意： 这里使用的是反引号 `, 而不是单引号 <span class="string">&#x27;。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="string"> 结果将显示当前日期</span></span></span><br><span class="line">echo `date`</span><br></pre></td></tr></table></figure><p>实例6：给文件追加内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 如果文件不存在会<span class="string">&quot;自动创建&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以<span class="string">&quot;覆盖写&quot;</span>的方式追加到文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件当中之前的内容不复存在了，实际上是修改了原文件的内容</span></span><br><span class="line">echo 内容 &gt; 文件</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以<span class="string">&quot;纯追加&quot;</span>的方式写入到文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对文件之前的内容不修改，只进行增添，也叫追加重定向</span></span><br><span class="line">echo 内容 &gt;&gt; 文件</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-expect命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-expect%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-expect%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<code>expect</code>可以实现shell实现不了的<strong>用户交互</strong>的需求。<code>expect</code>可以将交互写在一个脚本上，完成很多<em>自动化的动作</em>，比如<code>ssh</code>、<code>ftp</code>登陆等，都是需要交互需求的。</p><p>&emsp;<code>expect</code>是需要安装的，直接<code>yum -y install expect</code>安装即可。</p><p>&emsp;<code>expect</code>的四个关键命令为：<code>spawn</code>、<code>expect</code>、<code>send</code>、<code>set</code>,其中<code>spawn</code>是<strong>调用要执行的命令</strong>，<code>expect</code>是<strong>等待命令提示信息的出现</strong>也即<strong>捕捉用户提示信息</strong>，<code>send</code>是<strong>发送需要交互的信息来替代手工的输入</strong>，<code>set</code>则是<strong>输入变量值</strong>。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect [选项] [ -c cmds ] [ [ -[f|b] ] cmdfile] [ args]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;<code>expect</code>是一个免费的编程工具，用来<strong>实现自动的交互式任务</strong>，而无需人为干预。说白了，<code>expect</code>就是一套用来实现自动交互功能的软件。</p><p>&emsp;在实际工作中，我们运行命令、脚本或程序时，这些命令、脚本或程序都需要从终端输入某些继续运行的指令，而这些输入都需要人为的手工进行。而利用<code>expect</code>，则可以根据程序的提示，模拟标准输入提供给程序，从而实现自动化交互执行。这就是<code>expect</code>！！！</p><h3 id="3-工作流程："><a href="#3-工作流程：" class="headerlink" title="3.工作流程："></a>3.工作流程：</h3><p>&emsp;except的工作流程可以理解为： spawn启动进程 –&gt; expect期待关键字 –&gt; send向进程发送字符 –&gt; 退出结束</p><h3 id="4．命令参数："><a href="#4．命令参数：" class="headerlink" title="4．命令参数："></a>4．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-c, 从命令行执行expect脚本，默认expect是交互地执行的</span><br><span class="line">-d, 可以输出输出调试信息</span><br></pre></td></tr></table></figure><p>expect常用命令总结:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">spawn               交互程序开始,后面跟命令或者指定程序</span><br><span class="line">expect              获取匹配信息匹配成功则执行expect后面的程序动作</span><br><span class="line">send exp_send       用于发送指定的字符串信息</span><br><span class="line">exp_continue        在expect中多次匹配就需要用到</span><br><span class="line">send_user           用来打印输出 相当于shell中的echo</span><br><span class="line">exit                退出expect脚本</span><br><span class="line">eof                 expect执行结束 退出</span><br><span class="line">set                 定义变量</span><br><span class="line">puts                输出变量</span><br><span class="line">set timeout         设置超时时间</span><br></pre></td></tr></table></figure><h3 id="5-expect语法："><a href="#5-expect语法：" class="headerlink" title="5.expect语法："></a>5.expect语法：</h3><h4 id="5-1-spwan"><a href="#5-1-spwan" class="headerlink" title="5.1.spwan"></a>5.1.spwan</h4><p>spwan命令是expect的初始命令，它启动一个进程，之后所有expect操作都在这个进程中进行，其使用方法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spwan ssh root@192.168.1.26</span><br></pre></td></tr></table></figure><p>在spwan命令后面，直接加上要启动的进程、命令等信息，除此之外，还支持其他选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-open, 启动文件进程，具体说明请自行查阅</span><br><span class="line">-ignore, 忽略某些信号，具体说明请自行查阅</span><br></pre></td></tr></table></figure><h4 id="5-2-expect"><a href="#5-2-expect" class="headerlink" title="5.2.expect"></a>5.2.expect</h4><p>使用方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect 表达式 动作 表达式 动作 ... ...</span><br></pre></td></tr></table></figure><p>expect命令用于等候一个相匹配内容的输出，一旦匹配则执行expect后面的动作命令，这个命令接收几个特有参数，用的最多的就是-re，表示使用正则表达式进行匹配，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spwan ssh root@192.168.1.26</span><br><span class="line">expect -re &quot;.*password&quot; &#123;send &quot;root1234\r&quot;&#125;</span><br></pre></td></tr></table></figure><p>expect是依附与spwan命令的，当执行ssh命令后，expect就会匹配命令执行后的输出，然后执行expect后面包含在{}中的<code>send</code>或<code>exp_send</code>动作，匹配及动作可以放在下一行，就可以省略{}，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spwan ssh root@192.168.1.26</span><br><span class="line">expect -re &quot;.*password&quot; </span><br><span class="line">send &quot;root1234\r&quot;</span><br></pre></td></tr></table></figure><h4 id="5-3-exp-send和send"><a href="#5-3-exp-send和send" class="headerlink" title="5.3.exp_send和send"></a>5.3.exp_send和send</h4><p>exp_send是expect中的动作，send和其作用一样。exp_send命令可以发送一些特殊符号：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">\r, 回车</span><br><span class="line">\n, 换行</span><br><span class="line">\t, 制表符</span><br><span class="line">```    </span><br><span class="line">send命令还有几个可选的参数：</span><br><span class="line">```shell</span><br><span class="line">-i, 指定spwan_id, 这个参数用来向不同的spwan_id的进程发送命令，是进行多进程控制的关键参数。</span><br><span class="line">-s, s代表slowly，也就是控制发送的速度，这个参数使用的时候要与expect中的变量send_slow向关联</span><br></pre></td></tr></table></figure><h4 id="5-4-exp-continue"><a href="#5-4-exp-continue" class="headerlink" title="5.4.exp_continue"></a>5.4.exp_continue</h4><p>这个命令一般用在动作中，它被使用的条件比较苛刻，例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">spwan ssh -p22 root@192.168.1.26 /usr/sbin/ifconfig eth0</span><br><span class="line">set timeout 60</span><br><span class="line">expect &#123;</span><br><span class="line">    -timeout 1</span><br><span class="line">    &quot;yes/no&quot; &#123; exp_send &quot;yes\r&quot;; exp_continue &#125;</span><br><span class="line">    &quot;*password:&quot; &#123; exp_send &quot;root1234\r&quot; &#125;</span><br><span class="line">    timeout &#123; puts &quot;expect was timeout&quot;; return &#125;</span><br><span class="line">&#125;</span><br><span class="line">expect eof</span><br><span class="line">exit</span><br></pre></td></tr></table></figure><p>个人理解：spwan后面的命令的输出，从第一行开始进行expect遍历匹配，若匹配则执行动作，不匹配则进行下条匹配，而exp_continue的作用是，<em>若不匹配则跳过此行输出，并进行第二行输出进行expect的匹配</em></p><h4 id="5-5-send-user"><a href="#5-5-send-user" class="headerlink" title="5.5.send_user"></a>5.5.send_user</h4><p>send_user用于把后面的参数输出到<strong>标准输出</strong>中去，默认的<code>send</code>、<code>exp_send</code>都是将参数<strong>输出到程序</strong>中去，用法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">send_user &quot;please input password:&quot;</span><br></pre></td></tr></table></figure><p>这样就可以在标准输出中打印<code>please input password:</code>字符了。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">if &#123; $argc != 3 &#125; &#123;</span><br><span class="line">    send_user &quot;usage: expect scp-expect.exp file host dir\n&quot;</span><br><span class="line">    exit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-6-exit"><a href="#5-6-exit" class="headerlink" title="5.6.exit"></a>5.6.exit</h4><p>exit命令功能很简单，就是直接退出脚本，但可以利用这个命令做一些扫尾工作，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">exit -onexit &#123;</span><br><span class="line">    exec rm $tmpfile</span><br><span class="line">    send_user &quot;Good Bye\n&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-expect变量："><a href="#6-expect变量：" class="headerlink" title="6.expect变量："></a>6.expect变量：</h3><p>expect中有很多有用的变量，他们的使用方法与TCL中的变量相同，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">set 变量名 变量值  # 设置变量的方法</span><br><span class="line">puts $变量名       # 读取变量的方法</span><br><span class="line"></span><br><span class="line"># define var</span><br><span class="line">set file [lindex $argv 0] # 取命令行参数的</span><br><span class="line">set host [lindex $argv 1]</span><br><span class="line">set dir  [lindex $argv 2]</span><br><span class="line">set password &quot;root1234&quot;</span><br></pre></td></tr></table></figure><h3 id="7-expcct关键字："><a href="#7-expcct关键字：" class="headerlink" title="7.expcct关键字："></a>7.expcct关键字：</h3><p>expect中的关键字用于匹配过程，代表某些特殊含义或状态，一般用于expect命令中而不能在外面使用，也可以理解为事件，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect eof &#123;&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-eof"><a href="#7-1-eof" class="headerlink" title="7.1.eof"></a>7.1.eof</h4><p>eof(end-of-file)关键字用于匹配结束符，比如文件、ftp传输停止等，在这个关键字后跟上动作来做进一步的控制，特别是ftp交互操作方面，他的作用很大，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">spawn ftp root@192.168.1.26</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;password:&quot; &#123;exp_send &quot;root1234&quot;&#125;</span><br><span class="line">    eof &#123; ftp connect close &#125;</span><br><span class="line">&#125;</span><br><span class="line">interact &#123; &#125;</span><br></pre></td></tr></table></figure><p>interact也是关键字，可以是当前停留在服务端，交互模式使用</p><h4 id="7-2-timeout"><a href="#7-2-timeout" class="headerlink" title="7.2.timeout"></a>7.2.timeout</h4><p>timeout是expect中的一个重要变量，它是一个全局性的时间控制开关，你可以通过为这个变量赋值来规定整个expect操作的时间，注意这个变量是服务与expect全局的。例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">set timeout 60</span><br><span class="line">spawn ssh root@192.168.1.26</span><br><span class="line">expect &quot;*password:&quot; &#123; send &quot;root1234\n&quot; &#125;</span><br><span class="line">expect timeout &#123;puts &quot;timeout&quot;; return &#125;</span><br></pre></td></tr></table></figure><p>先将超时间设置为60秒，当程序阻塞到60秒，就会激活timeout动作。</p><p>另一种设置timeout的方法，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">spwan ssh root@192.168.1.26</span><br><span class="line">expect &#123;</span><br><span class="line">    -timeout 60</span><br><span class="line">    -re &quot;password:&quot; &#123;exp_send &quot;root1234\r&quot;&#125;</span><br><span class="line">    -re &quot;TopsecOS#&quot; &#123; &#125;</span><br><span class="line">    timeout &#123; puts &quot;timeout&quot;; return &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7．使用实例："><a href="#7．使用实例：" class="headerlink" title="7．使用实例："></a>7．使用实例：</h3><p>实例1：进行远程拷贝(#!/usr/bin/expect)</p><p>1.sh:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/usr/bin/expect</span></span><br><span class="line">spawn scp log.log root@&lt;ip&gt;:/home/lxy</span><br><span class="line"><span class="meta">#</span><span class="bash"> 匹配到信息password则发送信息</span></span><br><span class="line">expect &quot;*password*&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发送密码123456</span></span><br><span class="line">send &quot;123456\r&quot;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p>执行：<code>./1.sh</code>或者<code>expect 1.sh</code>，不能使用<code>sh 1.sh</code>或<code>bash 1.sh</code></p><p>实例2：进行远程拷贝(#!/bin/sh或者#!/bin/bash)</p><p>2.sh:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"></span><br><span class="line">passwd=&#x27;123456&#x27;</span><br><span class="line"></span><br><span class="line">spawn scp log.log root@&lt;ip&gt;:/home/lxy</span><br><span class="line"><span class="meta">#</span><span class="bash"> 匹配到信息password则发送信息</span></span><br><span class="line">expect &quot;*password*&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 发送密码123456</span></span><br><span class="line">send &quot;$passwd\r&quot;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p>执行：<code>expect 2.sh</code></p><p>实例3：进行远程拷贝—推荐使用此方法</p><p>3.sh:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">expect -c &quot;</span><br><span class="line">  spawn scp log.log root@&lt;ip&gt;:/home/lxy</span><br><span class="line">  expect &#123;</span><br><span class="line">     \&quot;*yes/no\&quot; &#123; send \&quot;yes\r\&quot;; exp_continue &#125;</span><br><span class="line">     \&quot;*password*\&quot; &#123;set timeout 300; send \&quot;123456\r\&quot;;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">expect eof&quot;</span><br></pre></td></tr></table></figure><p>执行：<code>./3.sh</code>、<code>sh 3.sh</code>或<code>bash 3.sh</code></p><p>实例4：进行远程拷贝(最终版本)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">username=&#x27;root&#x27;</span><br><span class="line">password=&#x27;eastcom&#x27;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 目录服务器IP</span></span><br><span class="line">ip=&#x27;127.0.0.1&#x27;</span><br><span class="line"></span><br><span class="line">expect -c &quot;</span><br><span class="line">  spawn scp log.log $username@$ip:/home/liuxy</span><br><span class="line">  expect &#123;</span><br><span class="line">     \&quot;*yes/no\&quot; &#123; send \&quot;yes\r\&quot;; exp_continue &#125;</span><br><span class="line">     \&quot;*password*\&quot; &#123;set timeout 300; send \&quot;$password\r\&quot;;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">expect eof&quot;</span><br></pre></td></tr></table></figure><p>实例5：expect执行多条命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">set timeout 10</span><br><span class="line"></span><br><span class="line">spawn sudo su - root</span><br><span class="line">expect &quot;*password*&quot;</span><br><span class="line">send &quot;123456\r&quot;</span><br><span class="line">expect &quot;]#*&quot;</span><br><span class="line">send &quot;ls\r&quot;</span><br><span class="line">expect &quot;]#*&quot;</span><br><span class="line">send &quot;df -Th\r&quot;</span><br><span class="line">send &quot;exit\r&quot;</span><br><span class="line">expect eof</span><br></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/saneri/p/10819348.html">参考</a></p><p><a href="https://www.jellythink.com/archives/373">参考</a></p><p><a href="http://www.fblinux.com/?p=526">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-dirname命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-dirname%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-dirname%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;dirname命令可以<strong>取给定路径的目录部分</strong>(strip non-directory suffix from file name)。这个命令很少直接在shell命令行中使用，我一般把它用在shell脚本中，用于取得脚本文件所在目录，然后将当前目录切换过去。Linux下还有一个命令是<a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-basename%E5%91%BD%E4%BB%A4.md">basename</a>，它与dirname相反，是取得文件名称部分。</p><p>&emsp;dirname命令去除文件名中的非目录部分，仅显示与目录有关的内容。dirname命令读取指定路径名保留最后一个<code>/</code>及其后面的字符，删除其他部分，并写结果到标准输出。如果最后一个<code>/</code>后<strong>无字符</strong>，dirname命令使用倒数第二个<code>/</code>，并忽略其后的所有字符。<code>dirname</code>和<code>basename</code>通常在shell内部命令替换使用，以指定一个与指定输入文件名略有差异的输出文件名。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname &lt;NAME&gt;</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;截取给定路径的目录部分。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：截取目录部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname /usr/bin/sort</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin</span><br></pre></td></tr></table></figure><p>实例2：截取目录部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname /usr/bin/</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr</span><br></pre></td></tr></table></figure><p>实例3：截取目录部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname //</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/</span><br></pre></td></tr></table></figure><p>实例4：截取目录部分</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dirname stdio.h</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-diff命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-diff%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-diff%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;diff(Difference)命令是linux上非常重要的工具，用于<strong>比较文件的内容</strong>，特别是比较两个版本不同的文件以找到改动的地方。diff在命令行中打印每一个行的改动。最新版本的diff还支持二进制文件。diff程序的输出被称为<strong>补丁</strong>(patch)，因为Linux系统中还有一个patch程序，可以根据diff的输出将a.c的文件内容更新为b.c。diff是svn、cvs、git等版本控制工具不可或缺的一部分。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff [参数] [文件1或目录1] [文件2或目录2]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;diff命令能比较<strong>单个文件</strong>或者<strong>目录内容</strong>。如果指定比较的是文件，则只有当输入为文本文件时才有效。以逐行的方式，比较文本文件的异同处。如果指定比较的是目录的的时候，diff命令会<strong>比较两个目录下名字相同的文本文件</strong>。列出不同的二进制文件、公共子目录和只在一个目录出现的文件。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">-, 指定要显示多少行的文本。此参数必须与-c或-u参数一并使用。</span><br><span class="line">-a或--text, diff预设只会逐行比较文本文件。</span><br><span class="line">-b或--ignore-space-change, 不检查空格字符的不同。</span><br><span class="line">-B或--ignore-blank-lines, 不检查空白行。</span><br><span class="line">-c, 显示全部内文，并标出不同之处。</span><br><span class="line">-C或--context, 与执行&quot;-c-&quot;指令相同。</span><br><span class="line">-d或--minimal, 使用不同的演算法，以较小的单位来做比较。</span><br><span class="line">-D或ifdef, 此参数的输出格式可用于前置处理器巨集。</span><br><span class="line">-e或--ed, 此参数的输出格式可用于ed的script文件。</span><br><span class="line">-f或-forward-ed, 输出的格式类似ed的script文件，但按照原来文件的顺序来显示不同处。</span><br><span class="line">-H或--speed-large-files, 比较大文件时，可加快速度。</span><br><span class="line">-l或--ignore-matching-lines, 若两个文件在某几行有所不同，而这几行同时都包含了选项中指定的字符或字符串，则不显示这两个文件的差异。</span><br><span class="line">-i或--ignore-case, 不检查大小写的不同。</span><br><span class="line">-l或--paginate, 将结果交由pr程序来分页。</span><br><span class="line">-n或--rcs, 将比较结果以RCS的格式来显示。</span><br><span class="line">-N或--new-file, 在比较目录时，若文件A仅出现在某个目录中，预设会显示：Only in目录：文件A若使用-N参数，则diff会将文件A与一个空白的文件比较。</span><br><span class="line">-p, 若比较的文件为C语言的程序码文件时，显示差异所在的函数名称。</span><br><span class="line">-P或--unidirectional-new-file, 与-N类似，但只有当第二个目录包含了一个第一个目录所没有的文件时，才会将这个文件与空白的文件做比较。</span><br><span class="line">-q或--brief, 仅显示有无差异，不显示详细的信息。</span><br><span class="line">-r或--recursive, 比较子目录中的文件。</span><br><span class="line">-s或--report-identical-files, 若没有发现任何差异，仍然显示信息。</span><br><span class="line">-S或--starting-file, 在比较目录时，从指定的文件开始比较。</span><br><span class="line">-t或--expand-tabs, 在输出时，将tab字符展开。</span><br><span class="line">-T或--initial-tab, 在每行前面加上tab字符以便对齐。</span><br><span class="line">-u,-U或--unified=, 以合并的方式来显示文件内容的不同。</span><br><span class="line">-w或--ignore-all-space, 忽略全部的空格字符。</span><br><span class="line">-W或--width, 在使用-y参数时，指定栏宽。</span><br><span class="line">-x或--exclude, 不比较选项中所指定的文件或目录。</span><br><span class="line">-X或--exclude-from, 您可以将文件或目录类型存成文本文件，然后在=中指定此文本文件。</span><br><span class="line">-y或--side-by-side, 以并列的方式显示文件的异同之处。</span><br><span class="line">-v或--version, 显示版本信息。</span><br><span class="line">--help, 显示帮助。</span><br><span class="line">--left-column, 在使用-y参数时，若两个文件某一行内容相同，则仅在左侧的栏位显示该行内容。</span><br><span class="line">--suppress-common-lines, 在使用-y参数时，仅显示不同之处。</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：比较两个文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> diff 的normal 显示格式有三种提示:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> a - add</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> c - change</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> d - delete</span> </span><br><span class="line">diff log1.log log2.log</span><br></pre></td></tr></table></figure><p>实例2：并排格式输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff log1.log log2.log -y -W 50</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;|&quot;表示前后2个文件内容有不同</span><br><span class="line">&quot;&lt;&quot;表示后面文件比前面文件少了1行内容</span><br><span class="line">&quot;&gt;&quot;表示后面文件比前面文件多了1行内容</span><br></pre></td></tr></table></figure><p>实例3：上下文输出格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff log1.log log2.log -c</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这种方式在开头两行作了比较文件的说明，这里有三中特殊字符：</span><br><span class="line">&quot;＋&quot; 比较的文件的后者比前着多一行</span><br><span class="line">&quot;－&quot; 比较的文件的后者比前着少一行</span><br><span class="line">&quot;！&quot; 比较的文件两者有差别的行</span><br></pre></td></tr></table></figure><p>实例4：统一格式输出</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff log1.log log2.log -u</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第一部分，也是文件的基本信息：</span><br><span class="line">--- log1.log 2021-04-28 18:01:54.000000000 +0800</span><br><span class="line">+++ log2.log 2021-04-28 16:36:26.000000000 +0800</span><br><span class="line">&quot;---&quot;表示变动前的文件</span><br><span class="line">&quot;+++&quot;表示变动后的文件</span><br><span class="line"></span><br><span class="line">第二部分，变动的位置用两个@作为起首和结束:</span><br><span class="line">@@ -1,12 +1,10 @@</span><br><span class="line">前面的&quot;-1,12&quot;分成三个部分：减号表示第一个文件（即log2014.log），&quot;1&quot;表示第1行，&quot;12&quot;表示连续12行。合在一起，就表示下面是第一个文件从第1行开始的连续12行。同样的，&quot;+1,10&quot;表示变动后，成为第二个文件从第1行开始的连续10行。</span><br></pre></td></tr></table></figure><p>实例5：比较<strong>文件夹</strong>不同</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff test3 test6</span><br></pre></td></tr></table></figure><p>实例6：比较两个文件不同，并生产补丁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff -ruN log1.log log2.log &gt; patch.log</span><br></pre></td></tr></table></figure><p>实例7：打补丁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">patch log1.log patch.log </span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-date命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-date%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-date%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;在linux环境中，不管是编程还是其他维护，时间是必不可少的，也经常会用到时间的运算，熟练运用date命令来表示自己想要表示的时间，肯定可以给自己的工作带来诸多方便。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date [参数]... [+格式]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;date可以用来显示或设定系统的日期与时间。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p>必要参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">%</span><span class="bash">H, 小时(以00-23来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">I, 小时(以01-12来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">K, 小时(以0-23来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">l, 小时(以0-12来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">M, 分钟(以00-59来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">P, AM或PM。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">r, 时间(含时分秒，小时以12小时AM/PM来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">s, 总秒数。起算时间为1970-01-01 00:00:00 UTC。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">S, 秒(以本地的惯用法来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">T, 时间(含时分秒，小时以24小时制来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">X, 时间(以本地的惯用法来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">Z, 市区。</span></span><br><span class="line"><span class="meta">%</span><span class="bash">a, 星期的缩写。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">A, 星期的完整名称。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">b, 月份英文名的缩写。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">B, 月份的完整英文名称。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">c, 日期与时间。只输入date指令也会显示同样的结果。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">d, 日期(以01-31来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">D, 日期(含年月日)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">j, 该年中的第几天。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">m, 月份(以01-12来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">U, 该年中的周数。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">w, 该周的天数，0代表周日，1代表周一，异词类推。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">x, 日期(以本地的惯用法来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">y, 年份(以00-99来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">Y, 年份(以四位数来表示)。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">n, 在显示时，插入新的一行。</span> </span><br><span class="line"><span class="meta">%</span><span class="bash">t, 在显示时，插入tab。</span> </span><br><span class="line">MM, 月份(必要) </span><br><span class="line">DD, 日期(必要) </span><br><span class="line">hh, 小时(必要) </span><br><span class="line">mm, 分钟(必要)</span><br><span class="line">ss, 秒(选择性) </span><br></pre></td></tr></table></figure><p>选择参数:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-d&lt;字符串&gt;, 显示字符串所指的日期与时间。字符串前后必须加上双引号。 </span><br><span class="line">-s&lt;字符串&gt;, 根据字符串来设置日期与时间。字符串前后必须加上双引号。 </span><br><span class="line">-u, 显示GMT。 </span><br><span class="line">--help, 在线帮助。 </span><br><span class="line">--version, 显示版本信息 </span><br></pre></td></tr></table></figure><h3 id="4．使用说明："><a href="#4．使用说明：" class="headerlink" title="4．使用说明："></a>4．使用说明：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">1.在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下: </span><br><span class="line">% : 打印出 %：</span><br><span class="line">%n : 下一行</span><br><span class="line">%t : 跳格</span><br><span class="line">%H : 小时(00..23)</span><br><span class="line">%I : 小时(01..12)</span><br><span class="line">%k : 小时(0..23)</span><br><span class="line">%l : 小时(1..12)</span><br><span class="line">%M : 分钟(00..59)</span><br><span class="line">%p : 显示本地 AM 或 PM</span><br><span class="line">%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)</span><br><span class="line">%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数</span><br><span class="line">%S : 秒(00..61)</span><br><span class="line">%T : 直接显示时间 (24 小时制)</span><br><span class="line">%X : 相当于 %H:%M:%S</span><br><span class="line">%Z : 显示时区 %a : 星期几 (Sun..Sat)</span><br><span class="line">%A : 星期几 (Sunday..Saturday)</span><br><span class="line">%b : 月份 (Jan..Dec)</span><br><span class="line">%B : 月份 (January..December)</span><br><span class="line">%c : 直接显示日期与时间</span><br><span class="line">%d : 日 (01..31)</span><br><span class="line">%D : 直接显示日期 (mm/dd/yy)</span><br><span class="line">%h : 同 %b</span><br><span class="line">%j : 一年中的第几天 (001..366)</span><br><span class="line">%m : 月份 (01..12)</span><br><span class="line">%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)</span><br><span class="line">%w : 一周中的第几天 (0..6)</span><br><span class="line">%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)</span><br><span class="line">%x : 直接显示日期 (mm/dd/yy)</span><br><span class="line">%y : 年份的最后两位数字 (00.99)</span><br><span class="line">%Y : 完整年份 (0000..9999)</span><br><span class="line"></span><br><span class="line">2.在设定时间方面：</span><br><span class="line">date -s //设置当前时间，只有root权限才能设置，其他只能查看。</span><br><span class="line">date -s 20210428 //设置成20210428，这样会把具体时间设置成空00:00:00</span><br><span class="line">date -s 01:01:01 //设置具体时间，不会对日期做更改</span><br><span class="line">date -s &quot;01:01:01 2021-04-28&quot; //这样可以设置全部时间</span><br><span class="line">date -s &quot;01:01:01 20210428&quot; //这样可以设置全部时间</span><br><span class="line">date -s &quot;2021-04-28 01:01:01&quot; //这样可以设置全部时间</span><br><span class="line">date -s &quot;20210428 01:01:01&quot; //这样可以设置全部时间</span><br><span class="line"></span><br><span class="line">3.加减：</span><br><span class="line">date +%Y%m%d         //显示当前天年月日</span><br><span class="line">date +%Y%m%d --date=&quot;+1 day&quot;  //显示前一天的日期</span><br><span class="line">date +%Y%m%d --date=&quot;-1 day&quot;  //显示后一天的日期</span><br><span class="line">date +%Y%m%d --date=&quot;-1 month&quot;  //显示上一月的日期</span><br><span class="line">date +%Y%m%d --date=&quot;+1 month&quot;  //显示下一月的日期</span><br><span class="line">date +%Y%m%d --date=&quot;-1 year&quot;  //显示前一年的日期</span><br><span class="line">date +%Y%m%d --date=&quot;+1 year&quot;  //显示下一年的日期</span><br></pre></td></tr></table></figure><h3 id="5．使用实例："><a href="#5．使用实例：" class="headerlink" title="5．使用实例："></a>5．使用实例：</h3><p>实例1：显示当前时间(可以不用加引号)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">date</span><br><span class="line">date &#x27;+%c&#x27;</span><br><span class="line">date &#x27;+%D&#x27;</span><br><span class="line">date &#x27;+%x&#x27;</span><br><span class="line">date &#x27;+%T&#x27;</span><br><span class="line">date &#x27;+%X&#x27;</span><br></pre></td></tr></table></figure><p>实例2：显示日期和设定时间(并没有真实的修改系统时间，执行控制台输出了设定的时间)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date --date 08:42:00</span><br></pre></td></tr></table></figure><p>实例3：date -d参数使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -d &quot;nov 22&quot;</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">date 命令的另一个扩展是-d选项，该选项非常有用。使用这个功能强大的选项，通过将日期作为引号括起来的参数提供，您可以快速地查明一个特定的日期。-d选项还可以告诉您，相对于当前日期若干天的究竟是哪一天，从现在开始的若干天或若干星期以后，或者以前（过去）。通过将这个相对偏移使用引号括起来，作为-d选项的参数，就可以完成这项任务。</span><br><span class="line"></span><br><span class="line">具体说明如下：</span><br><span class="line">date -d &quot;nov 22&quot; (今年的11月22日)</span><br><span class="line">date -d &#x27;2 weeks&#x27; (2周后的日期)</span><br><span class="line">date -d &#x27;50 days&#x27; (50天后的日期)</span><br><span class="line">date -d &#x27;next monday&#x27; (下周一的日期)</span><br><span class="line">date -d next-day +%Y%m%d（明天的日期）或者：date -d tomorrow +%Y%m%d</span><br><span class="line">date -d last-day +%Y%m%d(昨天的日期) 或者：date -d yesterday +%Y%m%d</span><br><span class="line">date -d last-month +%Y%m(上个月是几月)</span><br><span class="line">date -d next-month +%Y%m(下个月是几月)</span><br><span class="line"></span><br><span class="line">使用ago指令，您可以得到过去的日期：</span><br><span class="line">date -d &#x27;30 days ago&#x27; （30天前的日期）</span><br><span class="line"></span><br><span class="line">使用负数以得到相反的日期：</span><br><span class="line">date -d &#x27;dec 14 -2 weeks&#x27; （相对:dec 14这个日期的两周前的日期）</span><br><span class="line">date -d &#x27;-100 days&#x27; (100天以前的日期)</span><br></pre></td></tr></table></figure><p>实例4：显示月份和日数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date &#x27;+%B %d&#x27;</span><br></pre></td></tr></table></figure><p>实例5：显示时间后跳行，再显示目前日期 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date &#x27;+%T%n%D&#x27;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-crontab命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-crontab%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-crontab%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;<code>at</code>命令是针对<strong>仅运行一次</strong>的任务，循环运行的例行性计划任务，linux系统则是由cron(crond)这个系统服务来控制的。Linux系统上面原本就有非常多的计划性工作，因此这个系统服务是<strong>默认启动</strong>的。另外, 由于使用者自己也可以设置计划任务，所以，Linux系统也提供了使用者控制计划任务的命令即<code>crontab</code>(cron table)命令。</p><h2 id="1-crond简介"><a href="#1-crond简介" class="headerlink" title="1. crond简介"></a>1. crond简介</h2><p>&emsp;<code>crond</code>是linux下用来周期性的执行某种任务或等待处理某些事件的一个<strong>守护进程</strong>，与windows下的计划任务类似，当安装完成操作系统后，<strong>默认会安装此服务工具</strong>，并且会自动启动crond进程，crond进程<strong>每分钟</strong>会定期检查是否有要执行的任务，如果有要执行的任务，则自动执行该任务。</p><p>&emsp;Linux下的任务调度分为两类，<strong>系统任务</strong>调度和<strong>用户任务</strong>调度。</p><h3 id="系统任务调度："><a href="#系统任务调度：" class="headerlink" title="系统任务调度："></a><strong>系统任务调度</strong>：</h3><p>系统周期性所要执行的工作，比如写缓存数据到硬盘、日志清理等。在/etc目录下有一个crontab文件，这个就是系统任务调度的配置文件。</p><p>&emsp;<code>/etc/crontab</code>文件包括下面几行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost temp]# cat /etc/crontab</span><br><span class="line">SHELL=/bin/bash</span><br><span class="line">PATH=/sbin:/bin:/usr/sbin:/usr/bin</span><br><span class="line">MAILTO=root</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> For details see man 4 crontabs</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Example of job definition:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> .---------------- minute (0 - 59)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  .------------- hour (0 - 23)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  .---------- day of month (1 - 31)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  .------- month (1 - 12) OR jan,feb,mar,apr ...</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  |  .---- day of week (0 - 6) (Sunday=0 or 7) OR sun,mon,tue,wed,thu,fri,sat</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> |  |  |  |  |</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> *  *  *  *  * user-name  <span class="built_in">command</span> to be executed</span></span><br></pre></td></tr></table></figure><p>&emsp;前四行是用来配置crond任务运行的环境变量：</p><p>第一行SHELL变量指定了系统要使用哪个shell，这里是bash</p><p>第二行PATH变量指定了系统执行命令的路径</p><p>第三行MAILTO变量指定了crond的任务执行信息将通过电子邮件发送给root用户，如果MAILTO变量的值为空，则表示不发送任务执行信息给用户</p><p>第四行的HOME变量指定了在执行命令或者脚本时使用的主目录。第六至九行表示的含义将在下个小节详细讲述。这里不在多说。</p><p>用户任务调度：用户定期要执行的工作，比如用户数据备份、定时邮件提醒等。用户可以使用crontab工具来定制自己的计划任务。所有用户定义的crontab文件都被保存在<code>/var/spool/cron</code>目录中。其文件名与用户名一致。</p><h3 id="使用者权限文件："><a href="#使用者权限文件：" class="headerlink" title="使用者权限文件："></a><strong>使用者权限文件</strong>：</h3><p>文件:<code>/etc/cron.deny</code>,该文件中所列用户不允许使用crontab命令</p><p>文件:<code>/etc/cron.allow</code>,该文件中所列用户允许使用crontab命令</p><p>文件:<code>/var/spool/cron/</code>,所有用户crontab文件存放的目录,以用户名命名</p><h3 id="crontab文件的含义："><a href="#crontab文件的含义：" class="headerlink" title="crontab文件的含义："></a><strong>crontab文件的含义</strong>：</h3><p>用户所建立的crontab文件中，每一行都代表一项任务，每行的每个字段代表一项设置，它的格式共分为六个字段，前五段是时间设定段，第六段是要执行的命令段，格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minute   hour   day   month   week   command</span><br></pre></td></tr></table></figure><p>其中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">minute：表示分钟，可以是从0到59之间的任何整数。</span><br><span class="line">hour：表示小时，可以是从0到23之间的任何整数。</span><br><span class="line">day：表示日期，可以是从1到31之间的任何整数。</span><br><span class="line">month：表示月份，可以是从1到12之间的任何整数。</span><br><span class="line">week：表示星期几，可以是从0到7之间的任何整数，这里的0或7代表星期日。</span><br><span class="line">command：要执行的命令，可以是系统命令，也可以是自己编写的脚本文件。</span><br></pre></td></tr></table></figure><p>在以上各个字段中，还可以使用以下特殊字符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">星号（*）：代表所有可能的值，例如month字段如果是星号，则表示在满足其它字段的制约条件后每月都执行该命令操作。</span><br><span class="line">逗号（,）：可以用逗号隔开的值指定一个列表范围，例如:&quot;1,2,5,7,8,9&quot;</span><br><span class="line">中杠（-）：可以用整数之间的中杠表示一个整数范围，例如:&quot;2-6&quot;表示&quot;2,3,4,5,6&quot;</span><br><span class="line">正斜线（/）：可以用正斜线指定时间的间隔频率，例如:&quot;0-23/2&quot;表示每两小时执行一次。同时正斜线可以和星号一起使用，例如:&quot;*/10&quot;，如果用在minute字段，表示每十分钟执行一次。</span><br></pre></td></tr></table></figure><h2 id="2-crond服务"><a href="#2-crond服务" class="headerlink" title="2. crond服务"></a>2. crond服务</h2><p>安装crontab(安装完操作系统默认是已安装crontab的)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install crontabs</span><br></pre></td></tr></table></figure><p>服务操作说明：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动服务</span></span><br><span class="line">/sbin/service crond start</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭服务</span></span><br><span class="line">/sbin/service crond stop</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启服务</span></span><br><span class="line">/sbin/service crond restart</span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新载入配置</span></span><br><span class="line">/sbin/service crond reload</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看crontab服务状态：</span></span><br><span class="line">/sbin/service crond status</span><br></pre></td></tr></table></figure><p>查看crontab服务是否已设置为开机启动，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntsysv</span><br></pre></td></tr></table></figure><p>加入开机自动启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig –level 35 crond on</span><br></pre></td></tr></table></figure><h2 id="3-crontab命令详解"><a href="#3-crontab命令详解" class="headerlink" title="3. crontab命令详解"></a>3. crontab命令详解</h2><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">crontab [-u user] file</span><br><span class="line"></span><br><span class="line">crontab [-u user] [-e|-l|-r]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;通过crontab命令，我们可以在<strong>固定的间隔时间</strong>执行指定的系统指令或shell script脚本。时间间隔的单位可以是分钟、小时、日、月、周及以上的任意组合。这个命令非常设合周期性的<em>日志分析</em>或<em>数据备份</em>等工作。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-u user, 用来设定某个用户的crontab服务，例如:&quot;-u lxy&quot;表示设定lxy用户的crontab服务，此参数一般有root用户来运行。</span><br><span class="line">file, file是命令文件的名字,表示将file做为crontab的任务列表文件并载入crontab。如果在命令行中没有指定这个文件，crontab命令将接受标准输入（键盘）上键入的命令，并将它们载入crontab。</span><br><span class="line">-e, 编辑某个用户的crontab文件内容。如果不指定用户，则表示编辑当前用户的crontab文件。</span><br><span class="line">-l, 显示某个用户的crontab文件内容，如果不指定用户，则表示显示当前用户的crontab文件内容。</span><br><span class="line">-r, 从/var/spool/cron目录中删除某个用户的crontab文件，如果不指定用户，则默认删除当前用户的crontab文件。</span><br><span class="line">-i, 在删除用户的crontab文件时给确认提示。</span><br></pre></td></tr></table></figure><h3 id="4．常用方法："><a href="#4．常用方法：" class="headerlink" title="4．常用方法："></a>4．常用方法：</h3><h4 id="1-创建一个新的crontab文件"><a href="#1-创建一个新的crontab文件" class="headerlink" title="1). 创建一个新的crontab文件"></a>1). 创建一个新的crontab文件</h4><p>在考虑向cron进程提交一个crontab文件之前，首先要做的一件事情就是设置环境变量EDITOR。cron进程根据它来确定使用哪个编辑器编辑crontab文件。99%的UNIX和LINUX用户都使用vi，如果你也是这样，那么你就编辑<code>$HOME</code>目录下的<code>.profile</code>文件，在其中加入这样一行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EDITOR=vi; export EDITOR</span><br></pre></td></tr></table></figure><p>然后保存并退出。不妨创建一个名为<user> cron的文件，其中<user>是用户名，例如， davecron。在该文件中加入如下的内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> (put your own initials here)<span class="built_in">echo</span> the date to the console every</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 15minutes between 6pm and 6am</span></span><br><span class="line">0,15,30,45 18-06 * * * /bin/echo &#x27;date&#x27; &gt; /dev/console</span><br></pre></td></tr></table></figure><p>保存并退出。确信前面5个域用空格分隔。</p><p>在上面的例子中，系统将每隔15分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用tty1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。为了提交你刚刚创建的crontab文件，可以把这个新创建的文件作为cron命令的参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab davecron</span><br></pre></td></tr></table></figure><p>现在该文件已经提交给cron进程，它将每隔15分钟运行一次。</p><p>同时，新创建文件的一个副本已经被放在/var/spool/cron目录中，文件名就是用户名(即dave)</p><h4 id="2-列出crontab文件"><a href="#2-列出crontab文件" class="headerlink" title="2). 列出crontab文件"></a>2). 列出crontab文件</h4><p>为了列出crontab文件，可以用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l</span><br></pre></td></tr></table></figure><p>你将会看到和上面类似的内容。可以使用这种方法在$HOME目录中对crontab文件做一备份：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l &gt; $HOME/mycron</span><br></pre></td></tr></table></figure><p>这样，一旦不小心误删了crontab文件，可以用上一节所讲述的方法迅速恢复。</p><h4 id="3-编辑crontab文件"><a href="#3-编辑crontab文件" class="headerlink" title="3). 编辑crontab文件"></a>3). 编辑crontab文件</h4><p>如果希望添加、删除或编辑crontab文件中的条目，而EDITOR环境变量又设置为vi，那么就可以用vi来编辑crontab文件，相应的命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -e</span><br></pre></td></tr></table></figure><p>可以像使用vi编辑其他任何文件那样修改crontab文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时，cron会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。</p><p>我们在编辑crontab文件时，没准会加入新的条目。例如，加入下面的一条：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</span></span><br><span class="line">30 3 1,7,14,21,26 * * /bin/find -name &quot;core&#x27; -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><p>现在保存并退出。最好在crontab文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。</p><p>现在让我们使用前面讲过的crontab -l命令列出它的全部信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -l </span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> (crondave installed on Tue May 4 13:07:43 2019)</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> DT:ech the date to the console every 30 minites</span></span><br><span class="line">0,15,30,45 18-06 * * * /bin/echo `date` &gt; /dev/tty1</span><br><span class="line"><span class="meta">#</span><span class="bash"> DT:delete core files,at 3.30am on 1,7,14,21,26,26 days of each month</span></span><br><span class="line">30 3 1,7,14,21,26 * * /bin/find -name &quot;core&#x27; -exec rm &#123;&#125; \;</span><br></pre></td></tr></table></figure><h4 id="4-删除crontab文件"><a href="#4-删除crontab文件" class="headerlink" title="4). 删除crontab文件"></a>4). 删除crontab文件</h4><p>要删除crontab文件，可以用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">crontab -r</span><br></pre></td></tr></table></figure><h4 id="5-恢复丢失的crontab文件"><a href="#5-恢复丢失的crontab文件" class="headerlink" title="5). 恢复丢失的crontab文件"></a>5). 恢复丢失的crontab文件</h4><p>如果不小心误删了crontab文件，假设你在自己的$HOME目录下还有一个备份，那么可以将其拷贝到/var/spool/cron/<username>，其中<username>是用户名。如果由于权限问题无法完成拷贝，可以用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> &lt;filename&gt;是你在<span class="variable">$HOME</span>目录中副本的文件名</span></span><br><span class="line">crontab &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>我建议你在自己的$HOME目录中保存一个该文件的副本。我就有过类似的经历，有数次误删了crontab文件（因为r键紧挨在e键的右边）。这就是为什么有些系统文档建议不要直接编辑crontab文件，而是编辑该文件的一个副本，然后重新提交新的文件。</p><p>有些crontab的变体有些怪异，所以在使用crontab命令时要格外小心。如果遗漏了任何选项，crontab可能会打开一个空文件，或者看起来像是个空文件。这时敲delete键退出，不要按<Ctrl-D>，否则你将丢失crontab文件。</p><h3 id="5．使用实例"><a href="#5．使用实例" class="headerlink" title="5．使用实例"></a>5．使用实例</h3><p>实例1：每1分钟执行一次command</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* * * * * command</span><br></pre></td></tr></table></figure><p>实例2：每小时的第3和第15分钟执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 * * * * command</span><br></pre></td></tr></table></figure><p>实例3：在上午8点到11点的第3和第15分钟执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * * command</span><br></pre></td></tr></table></figure><p>实例4：每隔两天的上午8点到11点的第3和第15分钟执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 */2 * * command</span><br></pre></td></tr></table></figure><p>实例5：每个星期一的上午8点到11点的第3和第15分钟执行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3,15 8-11 * * 1 command</span><br></pre></td></tr></table></figure><p>实例6：每晚的21:30重启smb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">30 21 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><p>实例7：每月1、10、22日的4:45重启smb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">45 4 1,10,22 * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><p>实例8：每周六、周日的1:10重启smb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 * * 6,0 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><p>实例9：每天18:00至23:00之间每隔30分钟重启smb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0,30 18-23 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><p>实例10：每星期六的晚上11:00pm重启smb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 23 * * 6 /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><p>实例11：每一小时重启smb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* */1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><p>实例12：晚上11点到早上7点之间，每隔一小时重启smb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">* 23-7/1 * * * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><p>实例13：每月的4号与每周一到周三的11点重启smb</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 11 4 * mon-wed /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><p>实例14：一月一号的4点重启smb </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 4 1 jan * /etc/init.d/smb restart</span><br></pre></td></tr></table></figure><p>实例15：每小时执行/etc/cron.hourly目录内的脚本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> run-parts这个参数了，如果去掉这个参数的话，后面就可以写要运行的某个脚本名，而不是目录名了</span></span><br><span class="line">01 * * * * root run-parts /etc/cron.hourly</span><br></pre></td></tr></table></figure><h2 id="4-使用注意事项"><a href="#4-使用注意事项" class="headerlink" title="4. 使用注意事项"></a>4. 使用注意事项</h2><h3 id="1-注意环境变量问题"><a href="#1-注意环境变量问题" class="headerlink" title="1. 注意环境变量问题"></a>1. 注意环境变量问题</h3><p>有时我们创建了一个crontab，但是这个任务却无法自动执行，而手动执行这个任务却没有问题，这种情况一般是由于在crontab文件中<strong>没有配置环境变量引起</strong>的。</p><p>在crontab文件中定义多个调度任务时，需要特别注意的一个问题就是环境变量的设置，因为我们手动执行某个任务时，是在当前shell环境下进行的，程序当然能找到环境变量，而系统自动执行任务调度时，是不会加载任何环境变量的，因此，就需要在crontab文件中指定任务运行所需的所有环境变量，这样，系统执行任务调度时就没有问题了。</p><p>不要假定cron知道所需要的特殊环境，它其实并不知道。所以你要保证在shell脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。所以注意如下3点：</p><ul><li>1）脚本中涉及文件路径时写全局路径；</li><li>2）脚本执行要用到java或其他环境变量时，通过source命令引入环境变量，如：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# cat start_cbp.sh</span><br><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">source /etc/profile</span><br><span class="line">export RUN_CONF=/home/d139/conf/platform/cbp/cbp_jboss.conf</span><br><span class="line">/usr/local/jboss-4.0.5/bin/run.sh -c mev &amp;</span><br></pre></td></tr></table></figure></li><li>3）当手动执行脚本OK，但是crontab死活不执行时。这时必须大胆怀疑是环境变量惹的祸，并可以尝试在crontab中直接引入环境变量解决问题。如：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 * * * * . /etc/profile;/bin/sh /var/www/java/audit_no_count/bin/restart_audit.sh</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-注意清理系统用户的邮件日志"><a href="#2-注意清理系统用户的邮件日志" class="headerlink" title="2. 注意清理系统用户的邮件日志"></a>2. 注意清理系统用户的邮件日志</h3><p>&emsp;每条任务调度执行完毕，系统都会将任务输出信息通过电子邮件的形式发送给当前系统用户，这样日积月累，日志信息会非常大，可能会影响系统的正常运行，因此，将每条任务进行重定向处理非常重要。</p><p>例如，可以在crontab文件中设置如下形式，忽略日志输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 */3 * * * /usr/local/apache2/apachectl restart &gt;/dev/null 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p><code>/dev/null 2&gt;&amp;1</code>表示先将标准输出重定向到<code>/dev/null</code>，然后将标准错误重定向到标准输出，由于标准输出已经重定向到了<code>/dev/null</code>，因此标准错误也会重定向到<code>/dev/null</code>，这样日志输出问题就解决了。</p><h3 id="3-系统级任务调度与用户级任务调度"><a href="#3-系统级任务调度与用户级任务调度" class="headerlink" title="3. 系统级任务调度与用户级任务调度"></a>3. 系统级任务调度与用户级任务调度</h3><p>系统级任务调度主要完成系统的一些<strong>维护</strong>操作，<strong>用户级任务调度</strong>主要完成用户自定义的一些任务，可以将用户级任务调度放到<strong>系统级任务调度</strong>来完成(不建议这么做)，但是反过来却不行，root用户的任务调度操作可以通过”crontab –uroot –e”来设置，也可以将调度任务直接写入<code>/etc/crontab</code>文件，需要注意的是，如果要定义一个定时重启系统的任务，就必须将任务放到<code>/etc/crontab</code>文件，即使在root用户下创建一个定时重启系统的任务也是无效的。</p><h3 id="4-其他注意事项"><a href="#4-其他注意事项" class="headerlink" title="4. 其他注意事项"></a>4. 其他注意事项</h3><p>新创建的cron job，不会马上执行，至少要过<strong>2分钟</strong>才执行。如果<strong>重启cron</strong>则马上执行。</p><p>当crontab突然失效时，可以尝试<code>/etc/init.d/crond restart</code>解决问题。或者查看日志看某个job有没有执行/报错<code>tail -f /var/log/cron</code>。</p><p>千万别乱运行<code>crontab -r</code>。它从Crontab目录（/var/spool/cron）中删除用户的Crontab文件。删除了该用户的所有crontab都没了。</p><p>在crontab中<code>%</code>是有特殊含义的，表示<strong>换行</strong>的意思。如果要用的话必须进行转义<code>\%</code>，如经常用的<code>date &#39;+%Y%m%d&#39;</code>在crontab里是不会执行的，应该换成<code>date &#39;+\%Y\%m\%d&#39;</code>。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-cal命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cal%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-cal%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;cal(Calendar)命令可以用来显示公历（阳历）日历。公历是现在国际通用的历法，又称格列历，通称阳历。“阳历”又名“太阳历”，系以地球绕行太阳一周为一年，为西方各国所通用，故又名“西历”。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal [参数] [月份] [年份]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;用于查看日历等时间信息，如只有一个参数，则表示年份(1-9999)，如有两个参数，则表示月份和年份</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-1, 显示一个月的月历</span><br><span class="line">-3, 显示系统前一个月，当前月，下一个月的月历</span><br><span class="line">-s, 显示星期天为一个星期的第一天，默认的格式</span><br><span class="line">-m, 显示星期一为一个星期的第一天</span><br><span class="line">-j, 显示在当年中的第几天（一年日期按天算，从1月1号算起，默认显示当前月在一年中的天数）</span><br><span class="line">-y, 显示当前年份的日历</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示当前月份日历</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal</span><br></pre></td></tr></table></figure><p>实例2：显示指定月份的日历</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal 1 2020</span><br></pre></td></tr></table></figure><p>实例3：显示2020年日历</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cal -y 2020 </span><br><span class="line"><span class="meta">#</span><span class="bash"> 或：</span></span><br><span class="line">cal 2020</span><br></pre></td></tr></table></figure><p>实例4：显示自1月1日的天数</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal -j</span><br></pre></td></tr></table></figure><p>实例5：星期一显示在第一列</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal -m</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-basename命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-basename%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-basename%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;basename命令用于去掉文件名的目录和后缀(strip directory and suffix from filenames),对应的<a href="../%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-dirname%E5%91%BD%E4%BB%A4.md">dirname</a>命令用于截取目录</p><h3 id="1-命令格式："><a href="#1-命令格式：" class="headerlink" title="1. 命令格式："></a>1. 命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 去掉NAME中的目录部分</span></span><br><span class="line">basename &lt;NAME&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定SUFFIX(后缀)，如果不指定SUFFIX则在结果保留SUFFIX</span></span><br><span class="line">basename &lt;NAME&gt; &lt;SUFFIX&gt;</span><br></pre></td></tr></table></figure><h3 id="2-命令功能："><a href="#2-命令功能：" class="headerlink" title="2. 命令功能："></a>2. 命令功能：</h3><p>&emsp;去掉文件名的目录和后缀。</p><h3 id="3-常用参数"><a href="#3-常用参数" class="headerlink" title="3. 常用参数"></a>3. 常用参数</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-a, --multiple, 支持多个名称，并将每个参数作为一个单独的名字</span><br><span class="line">-s, --suffix=SUFFIX, 删除尾随的后缀</span><br><span class="line">-z, --zero，用nul结尾，然不是换行</span><br><span class="line">--help, 帮助信息</span><br><span class="line">--version, 版本信息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：去掉目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename /usr/bin/sort.h</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort.h</span><br></pre></td></tr></table></figure><p>实例2：去掉目录和后缀</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 指定了SUFFIX为‘.h’</span></span><br><span class="line">basename /usr/include/sort.h .h</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用-s选项</span></span><br><span class="line">basename -s .h /usr/include/sort.h</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sort</span><br></pre></td></tr></table></figure><p>实例3：NAME为‘/’</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename /</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/</span><br></pre></td></tr></table></figure><p>实例4：NAME为‘.’</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename .</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.</span><br></pre></td></tr></table></figure><p>实例5：支持多个名称(每个名称换行输出)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">basename -a /data/hadoop/1901.gz /data/hadoop/1902.gz</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1901.gz</span><br><span class="line">1902.gz</span><br></pre></td></tr></table></figure><p>实例6：支持多个名称(每个名称不换行输出)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> -z选项不换行</span></span><br><span class="line">basename -az /data/hadoop/1901.gz /data/hadoop/1902.gz</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1901.gz1902.gz</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-at命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-at%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E5%85%B6%E4%BB%96%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-at%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;在windows系统中，windows提供了计划任务这一功能，在控制面板-&gt;性能与维护-&gt;任务计划，它的功能就是<strong>安排自动运行的任务</strong>。通过’添加任务计划’的一步步引导，则可建立一个<strong>定时执行的任务</strong>。</p><p>&emsp;在linux系统中你可能已经发现了为什么系统常常会自动的进行一些任务？这些任务到底是谁在支配他们工作的？在linux系统如果你想要让自己设计的备份程序可以自动在某个时间点开始在系统底下运行，而不需要手动来启动它，又该如何处置呢？ 这些例行的工作可能又分为<em>一次性定时工作</em>与<em>循环定时工作</em>，在系统内又是哪些服务在负责？ 还有，如果你想要每年在老婆的生日前一天就发出一封信件提醒自己不要忘记，linux系统下该怎么做呢？ </p><p>&emsp;今天我们主要学习一下一次性定时计划任务的at命令的用法！</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at [参数] [时间]</span><br></pre></td></tr></table></figure><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;在一个指定的时间执行一个指定任务，只能执行一次，且需要开启atd进程(<code>ps -ef | grep atd</code>查看， 开启用<code>/etc/init.d/atd start or restart</code>； 开机即启动则需要运行<code>chkconfig --level 2345 atd on</code>)。</p><p>&emsp;at一般是临时任务，crontab一般是周期性任务，但都是计划任务的一种。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-m, 当指定的任务被完成之后，将给用户发送邮件，即使没有标准输出</span><br><span class="line">-I, atq的别名</span><br><span class="line">-d, atrm的别名</span><br><span class="line">-v, 显示任务将被执行的时间</span><br><span class="line">-c, 打印任务的内容到标准输出</span><br><span class="line">-V, 显示版本信息</span><br><span class="line">-q&lt;列队&gt;, 使用指定的列队</span><br><span class="line">-f&lt;文件&gt;, 从指定文件读入任务而不是从标准输入读入</span><br><span class="line">-t&lt;时间参数&gt;, 以时间参数的形式提交要运行的任务</span><br></pre></td></tr></table></figure><p>at允许使用一套<em>相当复杂</em>的<strong>指定时间</strong>的方法:</p><p>他能够接受在当天的<code>hh:mm</code>(小时:分钟)式的时间指定。假如该时间已过去，那么就放在第二天执行。</p><p>当然也能够使用<code>midnight</code>(深夜)，<code>noon</code>(中午)，<code>teatime</code>(饮茶时间，一般是下午4点)等比较模糊的词语来指定时间。</p><p>用户还能够采用<code>12小时计时制</code>，即在时间后面加上<code>AM</code>(上午)或<code>PM</code>(下午)来说明是上午还是下午。 </p><p>也能够指定命令执行的<code>具体日期</code>，指定格式为<code>month day</code>(月 日)或<code>mm/dd/yy</code>(月/日/年)或<code>dd.mm.yy</code>(日.月.年)。指定的日期必须跟在指定时间的后面。 </p><p>上面介绍的都是<strong>绝对计时法</strong>，其实还能够使用<strong>相对计时法</strong>，这对于安排不久就要执行的命令是很有好处的。</p><p>指定格式为：<code>now + count time-units</code>,<code>now</code>就是当前时间，<code>time-units</code>是时间单位，这里能够是<code>minutes</code>(分钟)、<code>hours</code>(小时)、<code>days</code>(天)、<code>weeks</code>(星期)。<code>count</code>是时间的<strong>数量</strong>，究竟是几天，还是几小时，等等。 </p><p>更有一种计时方法就是直接使用<code>today</code>(今天)、<code>tomorrow</code>(明天)来指定完成命令的时间。</p><p>TIME：时间格式，这里可以定义出什么时候要进行at这项任务的时间，格式有：</p><p><code>HH:MM</code></p><p>ex&gt; 04:00</p><p>在今日的HH:MM时刻进行，若该时刻已超过，则明天的HH:MM进行此任务。</p><p><code>HH:MM YYYY-MM-DD</code></p><p>ex&gt; 04:00 2009-03-17</p><p>强制规定在某年某月的某一天的特殊时刻进行该项任务</p><p><code>HH:MM[am|pm] [Month] [Date]</code></p><p>ex&gt; 04pm March 17</p><p>也是一样，强制在某年某月某日的某时刻进行该项任务</p><p><code>HH:MM[am|pm] + number [minutes|hours|days|weeks]</code></p><p>ex&gt; now + 5 minutes</p><p>ex&gt; 04pm + 3 days</p><p>就是说，在某个时间点再加几个时间后才进行该项任务。</p><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：三天后的下午5点钟执行/bin/ls</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">at 5pm+3 days</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# at 5pm+3 days</span><br><span class="line"><span class="meta">at&gt;</span><span class="bash"> /bin/ls</span></span><br><span class="line"><span class="meta">at&gt;</span><span class="bash"> &lt;EOT&gt;  //Ctrl+d会直接打出&lt;EOT&gt;</span></span><br><span class="line">job 7 at 2021-04-28 17:00</span><br></pre></td></tr></table></figure><p>实例2：明天17点钟，输出时间到指定文件内</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# at 17:20 tomorrow</span><br><span class="line"><span class="meta">at&gt;</span><span class="bash"> date &gt; time.log</span>         </span><br><span class="line"><span class="meta">at&gt;</span><span class="bash"> &lt;EOT&gt;</span></span><br><span class="line">job 8 at 2021-04-29 17:20</span><br></pre></td></tr></table></figure><p>实例3：计划任务设定后，在没有执行之前我们可以用atq命令来查看系统没有执行工作任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atq</span><br></pre></td></tr></table></figure><p>实例4：删除已经设置的任务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">atrm 7</span><br></pre></td></tr></table></figure><p>实例5：显示已经设置的任务内容</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> at命令尚未执行的任务都存在/var/spool/at/目录下，也可以直接查看该文件</span></span><br><span class="line">at -c 8</span><br></pre></td></tr></table></figure><h3 id="5．atd的启动与at运行的方式："><a href="#5．atd的启动与at运行的方式：" class="headerlink" title="5．atd的启动与at运行的方式："></a>5．atd的启动与at运行的方式：</h3><h4 id="5-1-atd的启动"><a href="#5-1-atd的启动" class="headerlink" title="5.1 atd的启动"></a>5.1 atd的启动</h4><p>&emsp;要使用一次性计划任务时，我们的Linux系统上面必须要有负责这个计划任务的服务，那就是<code>atd</code>服务。不过并非所有的Linux distributions都默认会把他打开的，所以，某些时刻我们需要手动将atd服务激活才行。</p><p>激活的方法很简单，就是这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">/etc/init.d/atd start </span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启</span></span><br><span class="line">/etc/init.d/atd restart </span><br></pre></td></tr></table></figure><p>备注：配置一下启动时就启动这个服务，免得每次重新启动都得再来一次</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chkconfig atd on</span><br></pre></td></tr></table></figure><h4 id="5-2-at-的运行方式"><a href="#5-2-at-的运行方式" class="headerlink" title="5.2 at 的运行方式"></a>5.2 at 的运行方式</h4><p>&emsp;既然是计划任务，那么应该会有任务执行的方式，并且将这些任务排进行程表中。那么产生计划任务的方式是怎么进行的? 事实上，我们使用<code>at</code>这个命令来产生所要运行的计划任务，并将这个计划任务以文字档的方式写入<code>/var/spool/at/</code>目录内，该工作便能等待<code>atd</code>这个服务的取用与运行了。就这么简单。</p><p>&emsp;不过，并不是所有的人都可以进行<code>at</code>计划任务。为什么? 因为<em>系统安全</em>的原因。很多主机被所谓的攻击破解后，最常发现的就是他们的系统当中多了很多的黑客程序， 这些程序非常可能运用一些<strong>计划任务</strong>来运行或搜集你的系统运行信息,并定时的发送给黑客。所以，除非是你认可的帐号，否则先不要让他们使用<code>at</code>命令。那怎么达到使用<code>at</code>的可控呢?</p><p>&emsp;我们可以利用<code>/etc/at.allow</code>与<code>/etc/at.deny</code>这两个文件来进行<code>at</code>的使用限制。加上这两个文件后，<code>at</code>的工作情况是这样的：</p><p>&emsp;先找寻<code>/etc/at.allow</code>这个文件，写在这个文件中的使用者才能使用<code>at</code>，没有在这个文件中的使用者则不能使用<code>at</code>(即使没有写在<code>at.deny</code>当中);</p><p>&emsp;如果<code>/etc/at.allow</code>不存在，就寻找<code>/etc/at.deny</code>这个文件，若写在这个<code>at.deny</code>的使用者则不能使用<code>at</code>，而没有在这个<code>at.deny</code>文件中的使用者，就可以使用<code>at</code>命令了。</p><p>&emsp;如果两个文件都不存在，那么只有<code>root</code>可以使用<code>at</code>这个命令。</p><p>&emsp;透过这个说明，我们知道<code>/etc/at.allow</code>是管理较为严格的方式，而<code>/etc/at.deny</code>则较为松散 (因为帐号没有在该文件中，就能够运行<code>at</code>了)。在一般的<code>distributions</code>当中，由于假设系统上的所有用户都是可信任的，因此系统通常会保留一个空的<code>/etc/at.deny</code>文件，意思是允许所有人使用<code>at</code>命令的意思 (您可以自行检查一下该文件)。不过，万一你不希望有某些使用者使用<code>at</code>的话，将那个使用者的帐号写入<code>/etc/at.deny</code>即可！一个帐号写一行。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 其他命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-du命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-du%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-du%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;Linux du(Disk Usage)命令也是查看使用空间的，但是与df命令不同的是Linux du命令是对<strong>文件和目录</strong>磁盘使用的空间的查看，还是和df命令有一些区别的.</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du [选项] [文件]...</span><br></pre></td></tr></table></figure><blockquote><p>显示filePath的使用空间总大小 : du -sh <filePath></p></blockquote><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;显示每个文件和目录的磁盘使用空间。</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">-a或-all, 显示目录中个别文件的大小。   </span><br><span class="line">-b或-bytes, 显示目录或文件大小时，以byte为单位。   </span><br><span class="line">-c或--total, 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。 </span><br><span class="line">-k或--kilobytes, 以KB(1024bytes)为单位输出。</span><br><span class="line">-m或--megabytes, 以MB为单位输出。   </span><br><span class="line">-s或--summarize, 仅显示总计，只列出最后加总的值。</span><br><span class="line">-h或--human-readable, 以K，M，G为单位，提高信息的可读性。</span><br><span class="line">-x或--one-file-xystem, 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。 </span><br><span class="line">-L&lt;符号链接&gt;或--dereference&lt;符号链接&gt;, 显示选项中所指定符号链接的源文件大小。  </span><br><span class="line">-S或--separate-dirs, 显示个别目录的大小时，并不含其子目录的大小。 </span><br><span class="line">-X&lt;文件&gt;或--exclude-from=&lt;文件&gt;, 在&lt;文件&gt;指定目录或文件。   </span><br><span class="line">--exclude=&lt;目录或文件&gt;, 略过指定的目录或文件。    </span><br><span class="line">-D或--dereference-args, 显示指定符号链接的源文件大小。   </span><br><span class="line">-H或--si, 与-h参数相同，但是K，M，G是以1000为换算单位。   </span><br><span class="line">-l或--count-links, 重复计算硬件链接的文件。  </span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示目录或者文件所占空间(只显示当前目录下面的子目录的目录大小和当前目录的总的大小) </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du</span><br></pre></td></tr></table></figure><p>实例2：显示指定文件所占空间:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du log.log</span><br></pre></td></tr></table></figure><p>实例3：查看指定目录的所占空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du lxy</span><br></pre></td></tr></table></figure><p>实例4：显示多个文件所占空间</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du log30.tar.gz log31.tar.gz</span><br></pre></td></tr></table></figure><p>实例5：只显示总和的大小</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -s</span><br></pre></td></tr></table></figure><p>实例6：文件和目录都显示,并以方便阅读的格式显示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -ah</span><br></pre></td></tr></table></figure><p>实例7：显示几个文件或目录各自占用磁盘空间的大小，还统计它们的总和</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加上-c选项后，du不仅显示两个目录各自占用磁盘空间的大小，还在最后一行统计它们的总和。</span></span><br><span class="line">du -c log30.tar.gz log31.tar.gz</span><br></pre></td></tr></table></figure><p>实例8：按照空间大小排序</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du|sort -nr|more</span><br></pre></td></tr></table></figure><p>实例9：输出当前目录下各个子目录所使用的空间:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 磁盘命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux命令-df命令</title>
      <link href="/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-df%E5%91%BD%E4%BB%A4/"/>
      <url>/2021/04/28/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/%E7%A3%81%E7%9B%98%E5%91%BD%E4%BB%A4/Linux%E5%91%BD%E4%BB%A4-df%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;linux中df(Disk Free)命令的功能是用来检查linux服务器的文件系统的<strong>磁盘空间占用情况</strong>。可以利用该命令来获取<strong>硬盘</strong>被<strong>占用了多少空间</strong>，目前还<strong>剩下多少空间</strong>等信息。</p><h3 id="1．命令格式："><a href="#1．命令格式：" class="headerlink" title="1．命令格式："></a>1．命令格式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df [选项] [文件]</span><br></pre></td></tr></table></figure><blockquote><p>df -h</p></blockquote><h3 id="2．命令功能："><a href="#2．命令功能：" class="headerlink" title="2．命令功能："></a>2．命令功能：</h3><p>&emsp;显示指定<strong>磁盘</strong>文件的可用空间。如果没有文件名被指定，则所有当前被挂载的文件系统的可用空间将被显示。默认情况下，磁盘空间将以<strong>KB</strong>为单位进行显示，除非环境变量POSIXLY_CORRECT被指定，那样将以512字节为单位进行显示</p><h3 id="3．命令参数："><a href="#3．命令参数：" class="headerlink" title="3．命令参数："></a>3．命令参数：</h3><p>必要参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">-a, 全部文件系统列表</span><br><span class="line">-h, 方便阅读方式显示</span><br><span class="line">-H, 等于“-h”，但是计算式，1K=1000，而不是1K=1024</span><br><span class="line">-i, 显示inode信息</span><br><span class="line">-k, 区块为1024字节</span><br><span class="line">-l, 只显示本地文件系统</span><br><span class="line">-m, 区块为1048576字节</span><br><span class="line">--no-sync, 忽略 sync 命令</span><br><span class="line">-P, 输出格式为POSIX</span><br><span class="line">--sync, 在取得磁盘信息前，先执行sync命令</span><br><span class="line">-T, 文件系统类型</span><br></pre></td></tr></table></figure><p>选择参数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--block-size=&lt;区块大小&gt;, 指定区块大小</span><br><span class="line">-t&lt;文件系统类型&gt;, 只显示选定文件系统的磁盘信息</span><br><span class="line">-x&lt;文件系统类型&gt;, 不显示选定文件系统的磁盘信息</span><br><span class="line">--help, 显示帮助信息</span><br><span class="line">--version, 显示版本信息</span><br></pre></td></tr></table></figure><h3 id="4．使用实例："><a href="#4．使用实例：" class="headerlink" title="4．使用实例："></a>4．使用实例：</h3><p>实例1：显示磁盘使用情况:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@CT1190 log]# df</span><br><span class="line">Filesystem        1K-blocks      Used  Available Use%  Mounted on</span><br><span class="line">/dev/sda7          19840892    890896   17925856   5%  /</span><br><span class="line">/dev/sda9         203727156 112797500   80413912  59%  /opt</span><br><span class="line">/dev/sda8           4956284    570080    4130372  13%  /var</span><br><span class="line">/dev/sda6          19840892   1977568   16839184  11%  /usr</span><br><span class="line">/dev/sda3            988116     23880     913232   3%  /boot</span><br><span class="line">tmpfs              16473212         0   16473212   0%  /dev/shm</span><br></pre></td></tr></table></figure><p>输出清单说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">第1列(Filesystem):是代表文件系统对应的设备文件的**路径名**（一般是硬盘上的分区）</span><br><span class="line"></span><br><span class="line">第2列(1K-blocks):给出分区包含的数据块（1024字节）的数目</span><br><span class="line"></span><br><span class="line">第3，4列分别表示**已用**的和**可用**的数据块数目。用户也许会感到奇怪的是，第3，4列块数之和不等于第2列中的块数。这是因为缺省的每个分区都留了少量空间供系统管理员使用。即使遇到普通用户空间已满的情况，管理员仍能登录和留有解决问题所需的工作空间。</span><br><span class="line"></span><br><span class="line">第5列(Use%):表示普通用户空间使用的百分比，即使这一数字达到100％，分区仍然留有系统管理员使用的空间。</span><br><span class="line"></span><br><span class="line">第6列(Mounted on):表示文件系统的挂载点。</span><br></pre></td></tr></table></figure><p>实例2：显示指定类型磁盘:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -t ext3</span><br></pre></td></tr></table></figure><p>实例3：列出文件系统的类型:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">df -T</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux命令大全 </category>
          
          <category> 磁盘命令 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杭州历年独角兽名单 2021年最新</title>
      <link href="/2021/04/28/%E6%9D%AD%E5%B7%9E%E5%8E%86%E5%B9%B4%E7%8B%AC%E8%A7%92%E5%85%BD%E5%85%AC%E5%8F%B8/"/>
      <url>/2021/04/28/%E6%9D%AD%E5%B7%9E%E5%8E%86%E5%B9%B4%E7%8B%AC%E8%A7%92%E5%85%BD%E5%85%AC%E5%8F%B8/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是独角兽"><a href="#什么是独角兽" class="headerlink" title="什么是独角兽"></a>什么是独角兽</h3><p>独角兽公司:公司成立的时间比较短，一般在十年之内，在短时间内公司的市值超过10亿美元，且还未在金融市场上市募资的公司。</p><h3 id="2019杭州独角兽"><a href="#2019杭州独角兽" class="headerlink" title="2019杭州独角兽"></a>2019杭州独角兽</h3><p><img src="https://i.loli.net/2021/04/28/uomQnS5BxZvJdch.jpg" alt="2019杭州独角兽.png"></p><h3 id="2020杭州独角兽"><a href="#2020杭州独角兽" class="headerlink" title="2020杭州独角兽"></a>2020杭州独角兽</h3><p><img src="https://i.loli.net/2021/04/28/shHkNpimRYaF4M8.jpg" alt="2020杭州独角兽.png"></p><h3 id="2021杭州独角兽"><a href="#2021杭州独角兽" class="headerlink" title="2021杭州独角兽"></a>2021杭州独角兽</h3><p><img src="https://i.loli.net/2021/04/28/8GJEjUZkMrczL6D.png" alt="2021杭州独角兽.png"></p>]]></content>
      
      
      <categories>
          
          <category> 独角兽 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 独角兽 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown最全教程</title>
      <link href="/2021/04/28/Markdown%E6%9C%80%E5%85%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2021/04/28/Markdown%E6%9C%80%E5%85%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="jump">1.基本操作</h2><h3 id="1-1-内容目录"><a href="#1-1-内容目录" class="headerlink" title="1.1 内容目录"></a>1.1 内容目录</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[TOC]</span><br></pre></td></tr></table></figure><h3 id="1-2-标题"><a href="#1-2-标题" class="headerlink" title="1.2 标题"></a>1.2 标题</h3><p>语法1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><p>语法2:(使用 = 和 - 标记一级和二级标题)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一级标题</span><br><span class="line">=================</span><br><span class="line">二级标题</span><br><span class="line">-----------------</span><br></pre></td></tr></table></figure><h3 id="1-3-引用-区块"><a href="#1-3-引用-区块" class="headerlink" title="1.3 引用/区块"></a>1.3 引用/区块</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用内容1</span><br><span class="line">&gt;&gt; 引用内容2</span><br><span class="line">&gt;&gt;&gt; 引用内容3</span><br></pre></td></tr></table></figure><p>效果:</p><blockquote><p>引用内容1</p><blockquote><p>引用内容2</p><blockquote><p>引用内容3</p></blockquote></blockquote></blockquote><h3 id="1-4-段落"><a href="#1-4-段落" class="headerlink" title="1.4 段落"></a>1.4 段落</h3><p>语法:(段落的换行是使用两个以上空格+回车)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">段落1&lt;space&gt;&lt;space&gt;&lt;enter&gt;</span><br><span class="line">段落2</span><br></pre></td></tr></table></figure><h2 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2.代码块"></a>2.代码块</h2><h3 id="2-1-单行代码"><a href="#2-1-单行代码" class="headerlink" title="2.1 单行代码"></a>2.1 单行代码</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">`String str1 = &quot;hello&quot;;`</span><br><span class="line">``String str1 = &quot;hello&quot;;``</span><br><span class="line">```String str1 = &quot;hello&quot;;```</span><br></pre></td></tr></table></figure><p>效果:<br><code>String str1 = &quot;hello&quot;;</code></p><h3 id="2-2-多行代码-代码块"><a href="#2-2-多行代码-代码块" class="headerlink" title="2.2 多行代码(代码块)"></a>2.2 多行代码(代码块)</h3><p>语法1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">``` &lt;type&gt;</span><br><span class="line">代码块</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>语法2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">~~~&lt;type&gt;</span><br><span class="line">代码块</span><br><span class="line">~~~</span><br></pre></td></tr></table></figure><p>语法3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;TAB&gt;int main()</span><br><span class="line">&lt;TAB&gt;&#123;</span><br><span class="line">&lt;TAB&gt;    printf(&quot;我是个段落代码块&quot;);</span><br><span class="line">&lt;TAB&gt;    return 0;</span><br><span class="line">&lt;TAB&gt;&#125;</span><br></pre></td></tr></table></figure><p>指定type代码可支持对应语法的高亮(type可省略)</p><p>代码段的语法高亮支持:</p><table><thead><tr><th align="center">关键字[以下任何一个都可以]</th><th align="center">语言</th></tr></thead><tbody><tr><td align="center">c#, c-sharp, csharp</td><td align="center">C#</td></tr><tr><td align="center">java</td><td align="center">Java</td></tr><tr><td align="center">php</td><td align="center">PHP</td></tr><tr><td align="center">js, jscript, javascript</td><td align="center">JavaScript</td></tr><tr><td align="center">css</td><td align="center">CSS</td></tr><tr><td align="center">text, plain</td><td align="center">text</td></tr><tr><td align="center">sql</td><td align="center">SQL</td></tr><tr><td align="center">py, python</td><td align="center">Python</td></tr><tr><td align="center">bash, shell</td><td align="center">Shell</td></tr><tr><td align="center">sass, scss</td><td align="center">SASS&amp;SCSS</td></tr><tr><td align="center">perl, pl, Perl</td><td align="center">Perl</td></tr><tr><td align="center">swift</td><td align="center">swift</td></tr><tr><td align="center">go, golang</td><td align="center">GO</td></tr><tr><td align="center">cpp, c</td><td align="center">C</td></tr><tr><td align="center">applescript</td><td align="center">AppleScript</td></tr><tr><td align="center">actionscript3, as3</td><td align="center">ActionScript 3.0</td></tr><tr><td align="center">coldfusion, cf</td><td align="center">ColdFusion</td></tr><tr><td align="center">delphi, pascal, pas</td><td align="center">Delphi</td></tr><tr><td align="center">diff,patch</td><td align="center">diff&amp;patch</td></tr><tr><td align="center">erl, erlang</td><td align="center">Erlang</td></tr><tr><td align="center">groovy</td><td align="center">Groovy</td></tr><tr><td align="center">jfx, javafx</td><td align="center">JavaFX</td></tr><tr><td align="center">ruby, rails, ror, rb</td><td align="center">Ruby</td></tr><tr><td align="center">scala</td><td align="center">Scala</td></tr><tr><td align="center">vb, vbnet</td><td align="center">Visual Basic</td></tr><tr><td align="center">xml, xhtml, xslt, html</td><td align="center">XML</td></tr><tr><td align="center">objc, obj-c</td><td align="center">Objective C</td></tr><tr><td align="center">f#, f-sharp, fsharp</td><td align="center">F#</td></tr><tr><td align="center">r, s, splus</td><td align="center">R</td></tr><tr><td align="center">matlab</td><td align="center">matlab</td></tr><tr><td align="center">yml</td><td align="center">yml</td></tr></tbody></table><p>效果:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br></pre></td></tr></table></figure><p>特别提示：<br>如何在代码块中打出 ```<br>实际上是使用 4个`包含 3个`就可以了，想表示更多，最外层+1就好了</p><h2 id="3-列表"><a href="#3-列表" class="headerlink" title="3.列表"></a>3.列表</h2><h3 id="3-1-无序列表"><a href="#3-1-无序列表" class="headerlink" title="3.1 无序列表"></a>3.1 无序列表</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 无序列表1</span><br><span class="line">+ 无序列表2</span><br><span class="line">- 无序列表3</span><br></pre></td></tr></table></figure><p>效果:</p><ul><li>无序列表1</li></ul><ul><li>无序列表2</li></ul><ul><li>无序列表3</li></ul><h3 id="3-2-多行无序列表"><a href="#3-2-多行无序列表" class="headerlink" title="3.2 多行无序列表"></a>3.2 多行无序列表</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* 多行无序列表1</span><br><span class="line">TAB* 多行无序列表2</span><br><span class="line">TABTAB* 多行无序列表3</span><br></pre></td></tr></table></figure><p>效果:</p><ul><li>多行无序列表1<ul><li>多行无序列表2<ul><li>多行无序列表3</li></ul></li></ul></li></ul><h3 id="3-3-有序列表"><a href="#3-3-有序列表" class="headerlink" title="3.3 有序列表"></a>3.3 有序列表</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 有序列表1</span><br><span class="line">2. 有序列表2</span><br><span class="line">3. 有序列表3</span><br></pre></td></tr></table></figure><p>效果:</p><ol><li>有序列表1</li><li>有序列表2</li><li>有序列表3</li></ol><h3 id="3-4-多行有序列表"><a href="#3-4-多行有序列表" class="headerlink" title="3.4 多行有序列表"></a>3.4 多行有序列表</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 多行有序列表1</span><br><span class="line">2. 多行有序列表2</span><br><span class="line">    1. 多行有序列表2-1</span><br><span class="line">    2. 多行有序列表2-2</span><br><span class="line">3. 多行有序列表3</span><br><span class="line">    1. 多行有序列表3-1</span><br><span class="line">    2. 多行有序列表3-2</span><br></pre></td></tr></table></figure><p>效果:</p><ol><li>多行有序列表1</li><li>多行有序列表2<ol><li>多行有序列表2-1</li><li>多行有序列表2-2</li></ol></li><li>多行有序列表3<ol><li>多行有序列表3-1</li><li>多行有序列表3-2</li></ol></li></ol><h3 id="3-5-区块中使用列表"><a href="#3-5-区块中使用列表" class="headerlink" title="3.5 区块中使用列表"></a>3.5 区块中使用列表</h3><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; 区块中使用列表</span><br><span class="line">&gt; 1. 第一项</span><br><span class="line">&gt; 2. 第二项</span><br><span class="line">&gt; + 第一项</span><br><span class="line">&gt; + 第二项</span><br><span class="line">&gt; * 第三项</span><br></pre></td></tr></table></figure><p>效果:</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li></ul><ul><li>第三项</li></ul></blockquote><h3 id="3-6-列表中使用区块"><a href="#3-6-列表中使用区块" class="headerlink" title="3.6 列表中使用区块"></a>3.6 列表中使用区块</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">    &gt; 菜鸟教程</span><br><span class="line">    &gt; 学的不仅是技术更是梦想</span><br><span class="line">- 第二项</span><br></pre></td></tr></table></figure><p>效果:</p><ul><li>第一项<blockquote><p>菜鸟教程<br>学的不仅是技术更是梦想</p></blockquote></li></ul><ul><li>第二项</li></ul><h3 id="3-7-任务列表"><a href="#3-7-任务列表" class="headerlink" title="3.7 任务列表"></a>3.7 任务列表</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [ ] 抽烟</span><br><span class="line">- [x] 喝酒</span><br><span class="line">* [ ] 烫头</span><br></pre></td></tr></table></figure><p>效果:</p><ul><li><input disabled="" type="checkbox"> 抽烟</li><li><input checked="" disabled="" type="checkbox"> 喝酒</li></ul><ul><li><input disabled="" type="checkbox"> 烫头</li></ul><h3 id="3-8-表格"><a href="#3-8-表格" class="headerlink" title="3.8 表格"></a>3.8 表格</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|姓名|性别|年龄|城市|</span><br><span class="line">|:---|:--:|:--:|---:|</span><br><span class="line">|张三|男|21|浙江&lt;br&gt;杭州|</span><br><span class="line">|李四|女|23|浙江&lt;br&gt;绍兴|</span><br><span class="line">|王五|男|25|浙江&lt;br&gt;温州|</span><br></pre></td></tr></table></figure><p>说明:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|:---|:左对齐</span><br><span class="line">|:--:|:居中</span><br><span class="line">|---:|:右对齐</span><br><span class="line">表格中换行使用:&lt;br&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><table><thead><tr><th align="left">姓名</th><th align="center">性别</th><th align="center">年龄</th><th align="right">城市</th></tr></thead><tbody><tr><td align="left">张三</td><td align="center">男</td><td align="center">21</td><td align="right">浙江<br>杭州</td></tr><tr><td align="left">李四</td><td align="center">女</td><td align="center">23</td><td align="right">浙江<br>绍兴</td></tr><tr><td align="left">王五</td><td align="center">男</td><td align="center">25</td><td align="right">浙江<br>温州</td></tr></tbody></table><h2 id="4-链接"><a href="#4-链接" class="headerlink" title="4. 链接"></a>4. 链接<span id="link"/></h2><h3 id="4-1-图片"><a href="#4-1-图片" class="headerlink" title="4.1 图片"></a>4.1 图片</h3><p>语法1:(本地图片)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![avatar](/home/picture/1.png)</span><br></pre></td></tr></table></figure><p>语法2:(网络图片)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![avatar](https://static01.imgkr.com/temp/0004529ccbfd47c48ee9e543943a9a4a.png)</span><br><span class="line">或者(添加图片标题)</span><br><span class="line">![avatar](https://static01.imgkr.com/temp/0004529ccbfd47c48ee9e543943a9a4a.png &quot;LXY&#x27;s blog&quot;)</span><br></pre></td></tr></table></figure><p>效果2:<br><img src="https://static01.imgkr.com/temp/0004529ccbfd47c48ee9e543943a9a4a.png" alt="avatar" title="LXY&#39;s blog"></p><p>语法3：(Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的<code>&lt;img&gt;</code>标签)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src=&quot;https://static01.imgkr.com/temp/0004529ccbfd47c48ee9e543943a9a4a.png&quot; width=&quot;50%&quot;&gt;</span><br></pre></td></tr></table></figure><p>效果3：<br><img src="https://static01.imgkr.com/temp/0004529ccbfd47c48ee9e543943a9a4a.png" width="50%"></p><h3 id="4-2-超链接"><a href="#4-2-超链接" class="headerlink" title="4.2 超链接"></a>4.2 超链接</h3><p>语法1:(行内式链接)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[LXY&#x27;s blog](http://www.codingcode.cn/)</span><br></pre></td></tr></table></figure><p>效果1:<br><a href="http://www.codingcode.cn/">LXY’s blog</a></p><p>语法2:(自动链接)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;http://www.codingcode.cn/&gt;</span><br></pre></td></tr></table></figure><p>效果2:<br><a href="http://www.codingcode.cn/">http://www.codingcode.cn/</a></p><h3 id="4-5-高级链接"><a href="#4-5-高级链接" class="headerlink" title="4.5 高级链接"></a>4.5 高级链接</h3><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：<br>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[LXY&#x27;s blog][anyword]</span><br><span class="line"></span><br><span class="line">[anyword]:http://www.codingcode.cn/</span><br></pre></td></tr></table></figure><p>效果：<br><a href="http://www.codingcode.cn/">LXY’s blog</a></p><h2 id="5-其他"><a href="#5-其他" class="headerlink" title="5. 其他"></a>5. 其他</h2><h3 id="5-1-斜体"><a href="#5-1-斜体" class="headerlink" title="5.1 斜体"></a>5.1 斜体</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">_斜体_</span><br></pre></td></tr></table></figure><p>效果:<br><em>斜体</em><br><em>斜体</em></p><h3 id="5-2-加粗"><a href="#5-2-加粗" class="headerlink" title="5.2 加粗"></a>5.2 加粗</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">**加粗**</span><br><span class="line">__加粗__</span><br></pre></td></tr></table></figure><p>效果:<br><strong>加粗</strong><br><strong>加粗</strong></p><h3 id="5-3-下划线"><a href="#5-3-下划线" class="headerlink" title="5.3 下划线"></a>5.3 下划线</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;u&gt;下划线&lt;/u&gt;</span><br></pre></td></tr></table></figure><p>效果:<br><u>下划线</u></p><h3 id="5-4-删除线"><a href="#5-4-删除线" class="headerlink" title="5.4 删除线"></a>5.4 删除线</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure><p>效果:<br><del>删除线</del></p><h3 id="5-5-分隔线"><a href="#5-5-分隔线" class="headerlink" title="5.5 分隔线"></a>5.5 分隔线</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">***</span><br><span class="line">---</span><br><span class="line">___</span><br></pre></td></tr></table></figure><p>效果:</p><hr><hr><hr><h3 id="5-6-公式"><a href="#5-6-公式" class="headerlink" title="5.6 公式"></a>5.6 公式</h3><p>使用两个美元符<code>$$</code>包裹<strong>TeX</strong>或<strong>LaTeX</strong>格式的数学公式来实现</p><h4 id="5-6-1-表示行内公式："><a href="#5-6-1-表示行内公式：" class="headerlink" title="5.6.1 $ 表示行内公式："></a>5.6.1 $ 表示行内公式：</h4><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$3^2=9$</span><br><span class="line">$3^&#123;(3-1)&#125;=9$</span><br><span class="line">$H_2SO_4$</span><br><span class="line">$H_&#123;2SO_4&#125;$</span><br></pre></td></tr></table></figure><p>效果:(有些可能不支持)<br>$3^2=9$<br>$3^{(3-1)}=9$<br>$H_2SO_4$<br>$H_{2SO_4}$</p><h4 id="5-6-2-表示整行公式："><a href="#5-6-2-表示整行公式：" class="headerlink" title="5.6.2 $$ 表示整行公式："></a>5.6.2 $$ 表示整行公式：</h4><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\sum_&#123;i=1&#125;^n a_i=0$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\sum_{i=1}^n a_i=0$$</p><h4 id="5-6-3-字体"><a href="#5-6-3-字体" class="headerlink" title="5.6.3 字体"></a>5.6.3 字体</h4><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ \mathsf&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $</span><br><span class="line">$ \mathcal&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $</span><br><span class="line">$ \mathscr&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $</span><br><span class="line">$ \mathfrak&#123;ABCDEFGHIJKLMNOPQRSTUVWXYZ&#125; $</span><br></pre></td></tr></table></figure><p>效果:<br>$ \mathsf{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $<br>$ \mathcal{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $<br>$ \mathscr{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $<br>$ \mathfrak{ABCDEFGHIJKLMNOPQRSTUVWXYZ} $</p><h4 id="5-6-4-常用公式"><a href="#5-6-4-常用公式" class="headerlink" title="5.6.4 常用公式"></a>5.6.4 常用公式</h4><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$x_i^2$，$x_i^2+x_&#123;i^2&#125;$，$10^&#123;10&#125;$</span><br><span class="line">$\log_2 x$</span><br><span class="line">$&#123;x^y&#125;^z+x^&#123;y^z&#125;$</span><br><span class="line">$\sum^&#123;j-1&#125;_&#123;k=0&#125;&#123;\widehat&#123;\gamma&#125;_&#123;kj&#125; z_k&#125;$</span><br><span class="line">$\sum_&#123;i=0&#125;^n i^2 = \frac&#123;(n^2+n)(2n+1)&#125;&#123;6&#125;$</span><br><span class="line">$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $</span><br><span class="line">$\displaystyle \lim_&#123;t \to 0&#125; \int_t^1 f(t)\, dt$</span><br><span class="line">$\lim_&#123;t \to 0&#125; \int_t^1 f(t)\, dt$.</span><br></pre></td></tr></table></figure><p>效果:<br>$x_i^2$，$x_i^2+x_{i^2}$，$10^{10}$<br>$\log_2 x$<br>${x^y}^z+x^{y^z}$<br>$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$<br>$\sum_{i=0}^n i^2 = \frac{(n^2+n)(2n+1)}{6}$<br>$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $<br>$\displaystyle \lim_{t \to 0} \int_t^1 f(t), dt$<br>$\lim_{t \to 0} \int_t^1 f(t), dt$.</p><h4 id="5-6-5-如果需要大小调整，大小写切换写"><a href="#5-6-5-如果需要大小调整，大小写切换写" class="headerlink" title="5.6.5 如果需要大小调整，大小写切换写"></a>5.6.5 如果需要大小调整，大小写切换写</h4><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$$\Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) gives (((((x)))))$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$\Biggl(\biggl(\Bigl(\bigl((x)\bigr)\Bigr)\biggr)\Biggr) gives (((((x)))))$$</p><h4 id="5-6-6-括号自适应大小"><a href="#5-6-6-括号自适应大小" class="headerlink" title="5.6.6 括号自适应大小"></a>5.6.6 括号自适应大小</h4><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$$(\frac&#123;\sqrt x&#125;&#123;y^3&#125;)$$</span><br><span class="line">$$ \left(\frac&#123;\sqrt x&#125;&#123;y^3&#125;\right)$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$(\frac{\sqrt x}{y^3})$$<br>$$ \left(\frac{\sqrt x}{y^3}\right)$$</p><h4 id="5-6-7-等式"><a href="#5-6-7-等式" class="headerlink" title="5.6.7 等式"></a>5.6.7 等式</h4><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">    \begin&#123;aligned&#125;</span><br><span class="line">        a &amp;= b + c \\</span><br><span class="line">        &amp;= d + e + f + g \\</span><br><span class="line">        &amp;= h + i</span><br><span class="line">    \end&#123;aligned&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><p>效果:<br>$$<br>    \begin{aligned}<br>        a &amp;= b + c \<br>        &amp;= d + e + f + g \<br>        &amp;= h + i<br>    \end{aligned}<br>$$</p><h3 id="5-7-符号的输入"><a href="#5-7-符号的输入" class="headerlink" title="5.7 符号的输入"></a>5.7 符号的输入</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">\\   反斜线</span><br><span class="line">\`   反引号</span><br><span class="line">\*   星号</span><br><span class="line">\_   底线</span><br><span class="line">\&#123; \&#125;  花括号</span><br><span class="line">\[ \]  方括号</span><br><span class="line">\( \)  括弧</span><br><span class="line">\#   井字号</span><br><span class="line">\+   加号</span><br><span class="line">\-   减号</span><br><span class="line">\.   英文句点</span><br><span class="line">\!   惊叹号</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\ ` * _ &#123; &#125; [ ] ( ) # + - . !</span><br></pre></td></tr></table></figure><h3 id="5-8-特殊字符"><a href="#5-8-特殊字符" class="headerlink" title="5.8 特殊字符"></a>5.8 特殊字符</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&amp;copy;      版权</span><br><span class="line">&amp;reg;       注册商标</span><br><span class="line">&amp;trade;     商标</span><br><span class="line">&amp;nbsp;      空格</span><br><span class="line">&amp;emsp;      空格</span><br><span class="line">&amp;amp;       和号</span><br><span class="line">&amp;quot;      引号</span><br><span class="line">&amp;apos;      撇号</span><br><span class="line">&amp;lt;        小于号</span><br><span class="line">&amp;gt;        大于号</span><br><span class="line">&amp;ne;        不等号</span><br><span class="line">&amp;le;        小于等于</span><br><span class="line">&amp;ge;        大于等于</span><br><span class="line">&amp;cent;      分</span><br><span class="line">&amp;pound;     磅</span><br><span class="line">&amp;euro;      欧元</span><br><span class="line">&amp;yen;       元</span><br><span class="line">&amp;sect;      节</span><br><span class="line">&amp;times;     乘号</span><br><span class="line">&amp;divide;    除号</span><br><span class="line">&amp;plusmn;    正负号</span><br></pre></td></tr></table></figure><p>效果:<br>&copy;  &reg;  &trade;  &nbsp;  &amp;  &emsp;  &quot;  &apos;  &lt;   &gt;  &ne;  &le;  &ge;  &cent;  &pound;  &euro;  &yen;  &sect; &times;  &divide;  &plusmn;</p><h3 id="5-9-使用HTML标签"><a href="#5-9-使用HTML标签" class="headerlink" title="5.9 使用HTML标签"></a>5.9 使用HTML标签</h3><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：<code>&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;</code>等<br>如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</span><br></pre></td></tr></table></figure><p>效果:<br>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑<br>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;span style=&quot;color:red&quot;&gt;分析、设计、实现、改进&lt;/span&gt;</span><br></pre></td></tr></table></figure><p>效果:<br><span style="color:red">分析、设计、实现、改进</span></p><h2 id="5-10-脚注-VSCode支持"><a href="#5-10-脚注-VSCode支持" class="headerlink" title="5.10 脚注(VSCode支持)"></a>5.10 脚注(VSCode支持)</h2><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">脚注：Content [^1]</span><br><span class="line">[^1]:Hi 这里是一个注脚，会自动拉到最后面排版</span><br></pre></td></tr></table></figure><p>效果:<br>脚注：Content [^1]<br>[^1]:Hi 这里是一个注脚，会自动拉到最后面排版</p><h2 id="5-11-缩略-VSCode支持"><a href="#5-11-缩略-VSCode支持" class="headerlink" title="5.11 缩略(VSCode支持)"></a>5.11 缩略(VSCode支持)</h2><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*[HTML]: 超文本标记语言</span><br><span class="line">The HTML specification</span><br></pre></td></tr></table></figure><p>效果:<br>*[HTML]: 超文本标记语言<br>The HTML specification</p><h2 id="6-折叠"><a href="#6-折叠" class="headerlink" title="6.折叠"></a>6.折叠</h2><h3 id="6-1-折叠文本"><a href="#6-1-折叠文本" class="headerlink" title="6.1 折叠文本"></a>6.1 折叠文本</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;折叠文本&lt;/summary&gt;</span><br><span class="line">  此处可书写文本</span><br><span class="line">  嗯，是可以书写文本的</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><details>  <summary>折叠文本</summary>  此处可书写文本  嗯，是可以书写文本的</details><h3 id="6-2-折叠代码块-高亮"><a href="#6-2-折叠代码块-高亮" class="headerlink" title="6.2 折叠代码块(高亮)"></a>6.2 折叠代码块(高亮)</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;折叠代码块&lt;/summary&gt;</span><br><span class="line">  &lt;pre&gt;&lt;code&gt; </span><br><span class="line">     System.out.println(&quot;折叠代码块&quot;);</span><br><span class="line">     System.out.println(&quot;并且代码高亮了&quot;);</span><br><span class="line">  &lt;/code&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><details>  <summary>折叠代码块</summary>  <pre><code>      System.out.println("折叠代码块");     System.out.println("并且代码高亮了");  </code></pre></details><h3 id="6-3-折叠代码块-无法高亮"><a href="#6-3-折叠代码块-无法高亮" class="headerlink" title="6.3 折叠代码块(无法高亮)"></a>6.3 折叠代码块(无法高亮)</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;details&gt;</span><br><span class="line">  &lt;summary&gt;折叠代码块&lt;/summary&gt;</span><br><span class="line">  &lt;pre&gt;&lt;blockcode&gt; </span><br><span class="line">     System.out.println(&quot;虽然可以折叠代码块&quot;);</span><br><span class="line">     System.out.println(&quot;但是代码无法高亮&quot;);</span><br><span class="line">  &lt;/blockcode&gt;&lt;/pre&gt;</span><br><span class="line">&lt;/details&gt;</span><br></pre></td></tr></table></figure><p>效果:</p><details>  <summary>折叠代码块</summary>  <pre><blockcode>      System.out.println("虽然可以折叠代码块");     System.out.println("但是代码无法高亮");  </blockcode></pre></details><h3 id="6-4-折叠功能的解读"><a href="#6-4-折叠功能的解读" class="headerlink" title="6.4 折叠功能的解读"></a>6.4 折叠功能的解读</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">details:折叠语法标签</span><br><span class="line">summary:折叠语法展示的摘要</span><br><span class="line">pre:以原有格式显示元素内的文字是已经格式化的文本</span><br><span class="line">code:指定代码块</span><br></pre></td></tr></table></figure><h2 id="7-页内跳转"><a href="#7-页内跳转" class="headerlink" title="7.页内跳转"></a>7.页内跳转</h2><p>语法1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;h2 id=&quot;jump&quot;&gt;1.基本操作&lt;/h2&gt;</span><br></pre></td></tr></table></figure><p>效果1:<br><a href="#jump">点我跳转</a></p><p>语法2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;span id=&quot;link&quot;&gt;&lt;/span&gt;</span><br><span class="line">或者</span><br><span class="line">&lt;span id=&quot;link&quot;/&gt;</span><br></pre></td></tr></table></figure><p>效果2:<br><a href="#link">点我跳转</a></p><h2 id="8-注释"><a href="#8-注释" class="headerlink" title="8.注释"></a>8.注释</h2><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[^_^]:我是注释</span><br><span class="line">[&gt;_&lt;]:我是注释</span><br><span class="line">[&gt;_&gt;]:我是注释</span><br><span class="line">[T-T]:我是注释</span><br></pre></td></tr></table></figure><p>效果:</p><h2 id="9-流程图、时序图-顺序图-、甘特图"><a href="#9-流程图、时序图-顺序图-、甘特图" class="headerlink" title="9.流程图、时序图(顺序图)、甘特图"></a>9.流程图、时序图(顺序图)、甘特图</h2><p>注：hexo中无法显示，vscode中可以正常显示</p><h3 id="9-1-横向流程图"><a href="#9-1-横向流程图" class="headerlink" title="9.1 横向流程图"></a>9.1 横向流程图</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt;|a=1| D[结果1]</span><br><span class="line">    C --&gt;|a=2| E[结果2]</span><br><span class="line">    F[横向流程图]</span><br></pre></td></tr></table></figure><h3 id="9-2-竖向流程图"><a href="#9-2-竖向流程图" class="headerlink" title="9.2 竖向流程图"></a>9.2 竖向流程图</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line">    B --&gt; C&#123;条件a&#125;</span><br><span class="line">    C --&gt; |a=1| D[结果1]</span><br><span class="line">    C --&gt; |a=2| E[结果2]</span><br><span class="line">    F[竖向流程图]</span><br></pre></td></tr></table></figure><h3 id="9-3-标准流程图-竖向"><a href="#9-3-标准流程图-竖向" class="headerlink" title="9.3 标准流程图(竖向)"></a>9.3 标准流程图(竖向)</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="9-4-标准流程图（横向）"><a href="#9-4-标准流程图（横向）" class="headerlink" title="9.4 标准流程图（横向）"></a>9.4 标准流程图（横向）</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">```flow</span><br><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><h3 id="9-5-UML时序图"><a href="#9-5-UML时序图" class="headerlink" title="9.5 UML时序图"></a>9.5 UML时序图</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">```sequence</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure><h3 id="9-6-UML时序图-复杂样例"><a href="#9-6-UML时序图-复杂样例" class="headerlink" title="9.6 UML时序图(复杂样例)"></a>9.6 UML时序图(复杂样例)</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">```sequence</span><br><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure><h3 id="9-7-UML标准时序图"><a href="#9-7-UML标准时序图" class="headerlink" title="9.7 UML标准时序图"></a>9.7 UML标准时序图</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line">    participant 张三</span><br><span class="line">    participant 李四</span><br><span class="line">    张三-&gt;王五: 王五你好吗？</span><br><span class="line">    loop 健康检查</span><br><span class="line">        王五-&gt;王五: 与疾病战斗</span><br><span class="line">    end</span><br><span class="line">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span><br><span class="line">    李四--&gt;&gt;张三: 很好!</span><br><span class="line">    王五-&gt;李四: 你怎么样?</span><br><span class="line">    李四--&gt;王五: 很好!</span><br></pre></td></tr></table></figure><h3 id="9-8-甘特图"><a href="#9-8-甘特图" class="headerlink" title="9.8 甘特图"></a>9.8 甘特图</h3><p>语法:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">```mermaid</span><br><span class="line">    gantt</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    title 软件开发甘特图</span><br><span class="line">    section 设计</span><br><span class="line">    需求                     :done, des1, 2014-01-06,2014-01-08</span><br><span class="line">    原型                     :active, des2, 2014-01-09, 3d</span><br><span class="line">    UI设计                   :des3, after des2, 5d</span><br><span class="line">未来任务                     :des4, after des3, 5d</span><br><span class="line">    section 开发</span><br><span class="line">    学习准备理解需求          :crit, done, 2014-01-06,24h</span><br><span class="line">    设计框架                 :crit, done, after des2, 2d</span><br><span class="line">    开发                     :crit, active, 3d</span><br><span class="line">    未来任务                  :crit, 5d</span><br><span class="line">    耍                       :2d</span><br><span class="line">    section 测试</span><br><span class="line">    功能测试                  :active, a1, after des3, 3d</span><br><span class="line">    压力测试                  :after a1, 20h</span><br><span class="line">    测试报告                  : 48h</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>效果:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    gantt</span><br><span class="line">    dateFormat  YYYY-MM-DD</span><br><span class="line">    title 软件开发甘特图</span><br><span class="line">    section 设计</span><br><span class="line">    需求                     :done, des1, 2014-01-06,2014-01-08</span><br><span class="line">    原型                     :active, des2, 2014-01-09, 3d</span><br><span class="line">    UI设计                   :des3, after des2, 5d</span><br><span class="line">未来任务                     :des4, after des3, 5d</span><br><span class="line">    section 开发</span><br><span class="line">    学习准备理解需求          :crit, done, 2014-01-06,24h</span><br><span class="line">    设计框架                 :crit, done, after des2, 2d</span><br><span class="line">    开发                     :crit, active, 3d</span><br><span class="line">    未来任务                  :crit, 5d</span><br><span class="line">    耍                       :2d</span><br><span class="line">    section 测试</span><br><span class="line">    功能测试                  :active, a1, after des3, 3d</span><br><span class="line">    压力测试                  :after a1, 20h</span><br><span class="line">    测试报告                  : 48h</span><br></pre></td></tr></table></figure><hr><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><h3 id="1-常用转义字符表"><a href="#1-常用转义字符表" class="headerlink" title="1.常用转义字符表"></a>1.常用转义字符表</h3><table><thead><tr><th>结果</th><th>描述</th><th>实体编号</th></tr></thead><tbody><tr><td></td><td>空格</td><td><code>&amp;#32;</code></td></tr><tr><td>!</td><td>感叹号</td><td><code>&amp;#33;</code></td></tr><tr><td>“</td><td>双引号</td><td><code>&amp;#34;</code></td></tr><tr><td>#</td><td>#号</td><td><code>&amp;#35;</code></td></tr><tr><td>$</td><td>美元符号</td><td><code>&amp;#36;</code></td></tr><tr><td>%</td><td>百分号</td><td><code>&amp;#37;</code></td></tr><tr><td>&amp;</td><td>&amp;符号</td><td><code>&amp;#38;</code></td></tr><tr><td>‘</td><td>单引号</td><td><code>&amp;#39;</code></td></tr><tr><td>(</td><td>左括号</td><td><code>&amp;#40;</code></td></tr><tr><td>)</td><td>右括号</td><td><code>&amp;#41;</code></td></tr><tr><td>*</td><td>星号</td><td><code>&amp;#42;</code></td></tr><tr><td>+</td><td>加号</td><td><code>&amp;#43;</code></td></tr><tr><td>,</td><td>逗号</td><td><code>&amp;#44;</code></td></tr><tr><td>-</td><td>减号</td><td><code>&amp;#45;</code></td></tr><tr><td>.</td><td>点</td><td><code>&amp;#46;</code></td></tr><tr><td>/</td><td>左斜杠</td><td><code>&amp;#47;</code></td></tr><tr><td>0</td><td>数字0</td><td><code>&amp;#48;</code></td></tr><tr><td>1</td><td>数字 1</td><td><code>&amp;#49;</code></td></tr><tr><td>2</td><td>数字 2</td><td><code>&amp;#50;</code></td></tr><tr><td>3</td><td>数字 3</td><td><code>&amp;#51;</code></td></tr><tr><td>4</td><td>数字 4</td><td><code>&amp;#52;</code></td></tr><tr><td>5</td><td>数字 5</td><td><code>&amp;#53;</code></td></tr><tr><td>6</td><td>数字 6</td><td><code>&amp;#54;</code></td></tr><tr><td>7</td><td>数字 7</td><td><code>&amp;#55;</code></td></tr><tr><td>8</td><td>数字 8</td><td><code>&amp;#56;</code></td></tr><tr><td>9</td><td>数字 9</td><td><code>&amp;#57;</code></td></tr><tr><td>:</td><td>冒号</td><td><code>&amp;#58;</code></td></tr><tr><td>;</td><td>分号</td><td><code>&amp;#59;</code></td></tr><tr><td>&lt;</td><td>小于</td><td><code>&amp;#60;</code></td></tr><tr><td>=</td><td>等于</td><td><code>&amp;#61;</code></td></tr><tr><td>&gt;</td><td>大于</td><td><code>&amp;#62;</code></td></tr><tr><td>?</td><td>问号</td><td><code>&amp;#63;</code></td></tr><tr><td>@</td><td>at符号</td><td><code>&amp;#64;</code></td></tr><tr><td>A</td><td>大写 A</td><td><code>&amp;#65;</code></td></tr><tr><td>B</td><td>大写 B</td><td><code>&amp;#66;</code></td></tr><tr><td>C</td><td>大写 C</td><td><code>&amp;#67;</code></td></tr><tr><td>D</td><td>大写 D</td><td><code>&amp;#68;</code></td></tr><tr><td>E</td><td>大写 E</td><td><code>&amp;#69;</code></td></tr><tr><td>F</td><td>大写 F</td><td><code>&amp;#70;</code></td></tr><tr><td>G</td><td>大写 G</td><td><code>&amp;#71;</code></td></tr><tr><td>H</td><td>大写 H</td><td><code>&amp;#72;</code></td></tr><tr><td>I</td><td>大写 I</td><td><code>&amp;#73;</code></td></tr><tr><td>J</td><td>大写 J</td><td><code>&amp;#74;</code></td></tr><tr><td>K</td><td>大写 K</td><td><code>&amp;#75;</code></td></tr><tr><td>L</td><td>大写 L</td><td><code>&amp;#76;</code></td></tr><tr><td>M</td><td>大写 M</td><td><code>&amp;#77;</code></td></tr><tr><td>N</td><td>大写 N</td><td><code>&amp;#78;</code></td></tr><tr><td>O</td><td>大写 O</td><td><code>&amp;#79;</code></td></tr><tr><td>P</td><td>大写 P</td><td><code>&amp;#80;</code></td></tr><tr><td>Q</td><td>大写 Q</td><td><code>&amp;#81;</code></td></tr><tr><td>R</td><td>大写 R</td><td><code>&amp;#82;</code></td></tr><tr><td>S</td><td>大写 S</td><td><code>&amp;#83;</code></td></tr><tr><td>T</td><td>大写 T</td><td><code>&amp;#84;</code></td></tr><tr><td>U</td><td>大写 U</td><td><code>&amp;#85;</code></td></tr><tr><td>V</td><td>大写 V</td><td><code>&amp;#86;</code></td></tr><tr><td>W</td><td>大写 W</td><td><code>&amp;#87;</code></td></tr><tr><td>X</td><td>大写 X</td><td><code>&amp;#88;</code></td></tr><tr><td>Y</td><td>大写 Y</td><td><code>&amp;#89;</code></td></tr><tr><td>Z</td><td>大写 Z</td><td><code>&amp;#90;</code></td></tr><tr><td>[</td><td>左方括号</td><td><code>&amp;#91;</code></td></tr><tr><td>\</td><td>右斜杠</td><td><code>&amp;#92;</code></td></tr><tr><td>]</td><td>右方括号</td><td><code>&amp;#93;</code></td></tr><tr><td>^</td><td>非符号</td><td><code>&amp;#94;</code></td></tr><tr><td>_</td><td>下滑线</td><td><code>&amp;#95;</code></td></tr><tr><td>`</td><td>grave accent</td><td><code>&amp;#96;</code></td></tr><tr><td>a</td><td>小写 a</td><td><code>&amp;#97;</code></td></tr><tr><td>b</td><td>小写 b</td><td><code>&amp;#98;</code></td></tr><tr><td>c</td><td>小写 c</td><td><code>&amp;#99;</code></td></tr><tr><td>d</td><td>小写 d</td><td><code>&amp;#100;</code></td></tr><tr><td>e</td><td>小写 e</td><td><code>&amp;#101;</code></td></tr><tr><td>f</td><td>小写 f</td><td><code>&amp;#102;</code></td></tr><tr><td>g</td><td>小写 g</td><td><code>&amp;#103;</code></td></tr><tr><td>h</td><td>小写 h</td><td><code>&amp;#104;</code></td></tr><tr><td>i</td><td>小写 i</td><td><code>&amp;#105;</code></td></tr><tr><td>j</td><td>小写 j</td><td><code>&amp;#106;</code></td></tr><tr><td>k</td><td>小写 k</td><td><code>&amp;#107;</code></td></tr><tr><td>l</td><td>小写 l</td><td><code>&amp;#108;</code></td></tr><tr><td>m</td><td>小写 m</td><td><code>&amp;#109;</code></td></tr><tr><td>n</td><td>小写 n</td><td><code>&amp;#110;</code></td></tr><tr><td>o</td><td>小写 o</td><td><code>&amp;#111;</code></td></tr><tr><td>p</td><td>小写 p</td><td><code>&amp;#112;</code></td></tr><tr><td>q</td><td>小写 q</td><td><code>&amp;#113;</code></td></tr><tr><td>r</td><td>小写 r</td><td><code>&amp;#114;</code></td></tr><tr><td>s</td><td>小写 s</td><td><code>&amp;#115;</code></td></tr><tr><td>t</td><td>小写 t</td><td><code>&amp;#116;</code></td></tr><tr><td>u</td><td>小写 u</td><td><code>&amp;#117;</code></td></tr><tr><td>v</td><td>小写 v</td><td><code>&amp;#118;</code></td></tr><tr><td>w</td><td>小写 w</td><td><code>&amp;#119;</code></td></tr><tr><td>x</td><td>小写 x</td><td><code>&amp;#120;</code></td></tr><tr><td>y</td><td>小写 y</td><td><code>&amp;#121;</code></td></tr><tr><td>z</td><td>小写 z</td><td><code>&amp;#122;</code></td></tr><tr><td>{</td><td>左花括号</td><td><code>&amp;#123;</code></td></tr><tr><td>|</td><td>垂直符号</td><td><code>&amp;#124;</code></td></tr><tr><td>}</td><td>左花括号</td><td><code>&amp;#125;</code></td></tr><tr><td>~</td><td>波浪线</td><td><code>&amp;#126;</code></td></tr></tbody></table><h3 id="2-常用-Emoji-amp-Font-Awesome-VSCode支持"><a href="#2-常用-Emoji-amp-Font-Awesome-VSCode支持" class="headerlink" title="2. 常用 Emoji &amp; Font-Awesome(VSCode支持)"></a>2. 常用 Emoji &amp; Font-Awesome(VSCode支持)</h3><table><thead><tr><th align="center"></th><th align="right">a</th><th align="right">b</th><th align="right">c</th><th align="right">d</th><th align="right">e</th><th align="right">f</th></tr></thead><tbody><tr><td align="center">1</td><td align="right"><code>:punch:</code></td><td align="right"><code>:notebook:</code></td><td align="right"><code>:e-mail:</code></td><td align="right"><code>:smile:</code></td><td align="right"><code>:movie_camera:</code></td><td align="right"><code>:camera:</code></td></tr><tr><td align="center">2</td><td align="right"><code>:fa-car:</code></td><td align="right"><code>:telephone_receiver:</code></td><td align="right"><code>:phone:</code></td><td align="right"><code>:heart:</code></td><td align="right"><code>:alarm_clock:</code></td><td align="right"><code>:loop:</code></td></tr><tr><td align="center">3</td><td align="right"><code>:+1:</code></td><td align="right"><code>:books:</code></td><td align="right"><code>:email:</code></td><td align="right"><code>:-1:</code></td><td align="right"><code>:bulb:</code></td><td align="right"><code>:hammer:</code></td></tr><tr><td align="center">4</td><td align="right"><code>:rocket:</code></td><td align="right"><code>:book:</code></td><td align="right"><code>:envelope:</code></td><td align="right"><code>:sunny:</code></td><td align="right"><code>:mag_right:</code></td><td align="right"><code>:chart_with_upwards_trend:</code></td></tr><tr><td align="center">5</td><td align="right"><code>:cloud:</code></td><td align="right"><code>:bar_chart:</code></td><td align="right"><code>:wind_chime:</code></td><td align="right"><code>:hibiscus:</code></td><td align="right"><code>:paperclip:</code></td><td align="right"><code>:ghost:</code></td></tr><tr><td align="center">6</td><td align="right"><code>:bug:</code></td><td align="right"><code>:date:</code></td><td align="right"><code>:balloon:</code></td><td align="right"><code>:beers:</code></td><td align="right"><code>:guitar:</code></td><td align="right"><code>:headphones:</code></td></tr><tr><td align="center">7</td><td align="right"><code>:rice:</code></td><td align="right"><code>:guitar:</code></td><td align="right"><code>:mortar_board:</code></td><td align="right"><code>:house:</code></td><td align="right"><code>:mount_fuji:</code></td><td align="right"><code>:office:</code></td></tr><tr><td align="center">8</td><td align="right"><code>:rocket:</code></td><td align="right"><code>:school:</code></td><td align="right"><code>:cupid:</code></td><td align="right"><code>:notes:</code></td><td align="right"><code>:shit:</code></td><td align="right"><code>:feet:</code></td></tr><tr><td align="center">9</td><td align="right"><code>:speech_balloon:</code></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td></tr></tbody></table><p>效果:</p><table><thead><tr><th align="center"></th><th align="right">a</th><th align="right">b</th><th align="right">c</th><th align="right">d</th><th align="right">e</th><th align="right">f</th></tr></thead><tbody><tr><td align="center">1</td><td align="right">:punch:</td><td align="right">:notebook:</td><td align="right">:e-mail:</td><td align="right">:smile:</td><td align="right">:movie_camera:</td><td align="right">:camera:</td></tr><tr><td align="center">2</td><td align="right">:fa-car:</td><td align="right">:telephone_receiver:</td><td align="right">:phone:</td><td align="right">:heart:</td><td align="right">:alarm_clock:</td><td align="right">:loop:</td></tr><tr><td align="center">3</td><td align="right">:+1:</td><td align="right">:books:</td><td align="right">:email:</td><td align="right">:-1:</td><td align="right">:bulb:</td><td align="right">:hammer:</td></tr><tr><td align="center">4</td><td align="right">:rocket:</td><td align="right">:book:</td><td align="right">:envelope:</td><td align="right">:sunny:</td><td align="right">:mag_right:</td><td align="right">:chart_with_upwards_trend:</td></tr><tr><td align="center">5</td><td align="right">:cloud:</td><td align="right">:bar_chart:</td><td align="right">:wind_chime:</td><td align="right">:hibiscus:</td><td align="right">:paperclip:</td><td align="right">:ghost:</td></tr><tr><td align="center">6</td><td align="right">:bug:</td><td align="right">:date:</td><td align="right">:balloon:</td><td align="right">:beers:</td><td align="right">:guitar:</td><td align="right">:headphones:</td></tr><tr><td align="center">7</td><td align="right">:rice:</td><td align="right">:guitar:</td><td align="right">:mortar_board:</td><td align="right">:house:</td><td align="right">:mount_fuji:</td><td align="right">:office:</td></tr><tr><td align="center">8</td><td align="right">:rocket:</td><td align="right">:school:</td><td align="right">:cupid:</td><td align="right">:notes:</td><td align="right">:shit:</td><td align="right">:feet:</td></tr><tr><td align="center">9</td><td align="right">:speech_balloon:</td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td><td align="right"></td></tr></tbody></table><p><a href="https://www.webfx.com/tools/emoji-cheat-sheet/">更多emoji</a></p><h3 id="3-符号大全"><a href="#3-符号大全" class="headerlink" title="3.符号大全"></a>3.符号大全</h3><h4 id="3-1-带圈符号"><a href="#3-1-带圈符号" class="headerlink" title="3.1 带圈符号"></a>3.1 带圈符号</h4><ul><li>白底数字<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">0：⓪</span><br><span class="line">1-10：①②③④⑤ ⑥⑦⑧⑨⑩</span><br><span class="line">11-20：⑪⑪⑫⑬⑭⑮ ⑯⑰⑱⑲⑳</span><br><span class="line">21-30：㉑㉒㉓㉔㉕㉖㉗㉘㉙㉚</span><br><span class="line">31-40：㉛㉜㉝㉞㉟㊱㊲㊳㊴㊵</span><br><span class="line">41-50：㊶㊷㊸㊹㊺㊻㊼㊽㊾㊿</span><br></pre></td></tr></table></figure></li><li>黑底数字<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1-10：❶❷❸❹❺ ❻❼❽❾❿</span><br><span class="line">11-20：⓫⓬⓭⓮⓯ ⓰⓱⓲⓳⓴</span><br></pre></td></tr></table></figure><h4 id="3-2-中文数字"><a href="#3-2-中文数字" class="headerlink" title="3.2 中文数字"></a>3.2 中文数字</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一-十：㊀㊁㊂㊃㊄㊅㊆㊇㊈㊉</span><br></pre></td></tr></table></figure><h4 id="3-3-带圈字母"><a href="#3-3-带圈字母" class="headerlink" title="3.3 带圈字母"></a>3.3 带圈字母</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ⒶⒷⒸⒹⒺⒻⒼⒽⒾⒿⓀⓁⓂⓃⓄⓅⓆⓇⓈⓉⓊⓋⓌⓍⓎⓏ</span><br><span class="line">ⓐⓑⓒⓓⓔⓕⓖⓗⓘⓙⓚⓛⓜⓝⓞⓟⓠⓡⓢⓣⓤⓥⓦⓧⓨⓩ</span><br></pre></td></tr></table></figure><h4 id="3-4-其他带圈符号"><a href="#3-4-其他带圈符号" class="headerlink" title="3.4 其他带圈符号"></a>3.4 其他带圈符号</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">®㊎㊍㊌㊋㊏㊚㊛㊐㊊㊣㊤㊥㊦㊧㊨㊒㊫㊑㊓㊔㊕㊖㊗㊘㊜㊝㊞㊟㊠㊡㊢㊩㊪㊬㊭㊮㊯㊰㊙㉿</span><br></pre></td></tr></table></figure></li></ul><p><a href="http://www.fhdq.net/">更多符号</a></p>]]></content>
      
      
      <categories>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装RocketMQ</title>
      <link href="/2021/04/27/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85RocketMQ/"/>
      <url>/2021/04/27/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85RocketMQ/</url>
      
        <content type="html"><![CDATA[<h1 id="一、Linux安装RocketMQ"><a href="#一、Linux安装RocketMQ" class="headerlink" title="一、Linux安装RocketMQ"></a>一、Linux安装RocketMQ</h1><p><a href="http://rocketmq.apache.org/docs/quick-start/">官方安装教程</a></p><h2 id="1-下载安装包"><a href="#1-下载安装包" class="headerlink" title="1.下载安装包"></a>1.下载安装包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载<span class="built_in">source</span>版本（未编译版）</span></span><br><span class="line">wget https://ftp.jaist.ac.jp/pub/apache/rocketmq/4.8.0/rocketmq-all-4.8.0-source-release.zip</span><br></pre></td></tr></table></figure><h2 id="2-解压"><a href="#2-解压" class="headerlink" title="2.解压"></a>2.解压</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unzip rocketmq-all-4.8.0-source-release.zip</span><br></pre></td></tr></table></figure><h2 id="3-使用mvn进行编译"><a href="#3-使用mvn进行编译" class="headerlink" title="3.使用mvn进行编译"></a>3.使用mvn进行编译</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd rocketmq-all-4.8.0-source-release/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译打包(时间比较久，耐心等待)</span></span><br><span class="line">mvn -Prelease-all -DskipTests clean install -U</span><br></pre></td></tr></table></figure><h2 id="4-启动"><a href="#4-启动" class="headerlink" title="4.启动"></a>4.启动</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入项目目录文件</span></span><br><span class="line">cd distribution/target/rocketmq-4.8.0/rocketmq-4.8.0</span><br></pre></td></tr></table></figure><h3 id="4-1-启动NameServer"><a href="#4-1-启动NameServer" class="headerlink" title="4.1 启动NameServer"></a>4.1 启动NameServer</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqnamesrv &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志(可以看到The Name Server boot success...)</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/namesrv.log</span><br></pre></td></tr></table></figure><h3 id="4-2-启动Broker"><a href="#4-2-启动Broker" class="headerlink" title="4.2 启动Broker"></a>4.2 启动Broker</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nohup sh bin/mqbroker -n localhost:9876 &amp;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看日志(可以看到The broker[localhost.localdomain, 172.17.0.1:10911] boot success)</span></span><br><span class="line">tail -f ~/logs/rocketmqlogs/broker.log </span><br></pre></td></tr></table></figure><h2 id="5-验证端口9876"><a href="#5-验证端口9876" class="headerlink" title="5.验证端口9876"></a>5.验证端口9876</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof -i:9876</span><br></pre></td></tr></table></figure><p>看见端口在监听中说明安装成功了</p><h2 id="6-附上关闭服务的命令"><a href="#6-附上关闭服务的命令" class="headerlink" title="6.附上关闭服务的命令"></a>6.附上关闭服务的命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 关闭Broker</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sh bin/mqshutdown broker</span></span><br><span class="line">The mqbroker(36695) is running...</span><br><span class="line">Send shutdown request to mqbroker(36695) OK</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭NameServer</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> sh bin/mqshutdown namesrv</span></span><br><span class="line">The mqnamesrv(36664) is running...</span><br><span class="line">Send shutdown request to mqnamesrv(36664) OK</span><br></pre></td></tr></table></figure><h1 id="二、安装-RocketMQ-官方管理页面"><a href="#二、安装-RocketMQ-官方管理页面" class="headerlink" title="二、安装 RocketMQ 官方管理页面"></a>二、安装 RocketMQ 官方管理页面</h1><h2 id="1-下载源码包"><a href="#1-下载源码包" class="headerlink" title="1.下载源码包"></a>1.下载源码包</h2><p><a href="https://github.com/apache/rocketmq-externals">下载地址</a><br><img src="https://i.loli.net/2021/04/27/5O7iQAkprjbSzeJ.png" alt="image.png"></p><h2 id="2-上次并解压"><a href="#2-上次并解压" class="headerlink" title="2.上次并解压"></a>2.上次并解压</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">unzip rocketmq-externals-master.zip</span><br></pre></td></tr></table></figure><h2 id="3-修改配置文件"><a href="#3-修改配置文件" class="headerlink" title="3.修改配置文件"></a>3.修改配置文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd rocketmq-externals-master\rocketmq-console\src\main\resources</span><br><span class="line">vim application.properties</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/27/ZN3UzYa7Ggncfxo.png" alt="image.png"></p><h2 id="4-maven打包"><a href="#4-maven打包" class="headerlink" title="4.maven打包"></a>4.maven打包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 进入目录</span></span><br><span class="line">cd rocketmq-externals-master\rocketmq-console</span><br><span class="line"><span class="meta">#</span><span class="bash"> 打包生成rocketmq-console-ng-2.0.0.jar</span></span><br><span class="line">mvn clean package -Dmaven.test.skip=true</span><br></pre></td></tr></table></figure><p>在路径<code>rocketmq-externals-master/rocketmq-console/target</code>下得到<code>rocketmq-console-ng-2.0.0.jar</code>jar包</p><h2 id="5-将jar包复制出来"><a href="#5-将jar包复制出来" class="headerlink" title="5.将jar包复制出来"></a>5.将jar包复制出来</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">cp rocketmq-externals-master/rocketmq-console/target/rocketmq-console-ng-2.0.0.jar .</span><br></pre></td></tr></table></figure><h2 id="6-启动rocketmq-console-ng-2-0-0-jar"><a href="#6-启动rocketmq-console-ng-2-0-0-jar" class="headerlink" title="6.启动rocketmq-console-ng-2.0.0.jar"></a>6.启动rocketmq-console-ng-2.0.0.jar</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -jar rocketmq-console-ng-2.0.0.jar &amp;</span><br></pre></td></tr></table></figure><h2 id="7-验证安装"><a href="#7-验证安装" class="headerlink" title="7.验证安装"></a>7.验证安装</h2><p>浏览器访问<code>http://&lt;IP&gt;:9877</code></p><p>看到如下页面安装成功：<br><img src="https://i.loli.net/2021/04/27/eS6NdzQ7Jkpljny.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux软件安装 </tag>
            
            <tag> RocketMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Maven</title>
      <link href="/2021/04/27/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Maven/"/>
      <url>/2021/04/27/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Maven/</url>
      
        <content type="html"><![CDATA[<h1 id="Linux安装Maven"><a href="#Linux安装Maven" class="headerlink" title="Linux安装Maven"></a>Linux安装Maven</h1><p>maven依赖于jdk，请先安装jdk</p><h2 id="1-下载压缩包"><a href="#1-下载压缩包" class="headerlink" title="1.下载压缩包:"></a>1.下载压缩包:</h2><p><img src="https://i.loli.net/2021/04/27/w3qIjsdWE1hYiLe.png" alt="image.png"></p><h2 id="2-上传到linux的-usr-local目录"><a href="#2-上传到linux的-usr-local目录" class="headerlink" title="2.上传到linux的/usr/local目录"></a>2.上传到linux的/usr/local目录</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br></pre></td></tr></table></figure><h2 id="3-解压文件"><a href="#3-解压文件" class="headerlink" title="3.解压文件"></a>3.解压文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf apache-maven-3.8.1-bin.tar.gz</span><br></pre></td></tr></table></figure><h2 id="4-配置环境变量"><a href="#4-配置环境变量" class="headerlink" title="4.配置环境变量"></a>4.配置环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/profile</span><br></pre></td></tr></table></figure><p>加入一下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export MAVEN_HOME=/usr/local/apache-maven-3.8.1</span><br><span class="line">export PATH=$MAVEN_HOME/bin:$PATH </span><br></pre></td></tr></table></figure><h2 id="5-刷新环境变量"><a href="#5-刷新环境变量" class="headerlink" title="5.刷新环境变量"></a>5.刷新环境变量</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h2 id="6-检查版本"><a href="#6-检查版本" class="headerlink" title="6.检查版本"></a>6.检查版本</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mvn -v </span><br></pre></td></tr></table></figure><p>看到如下内容安装成功</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Apache Maven 3.8.1 (05c21c65bdfed0f71a2f2ada8b84da59348c4c5d)</span><br><span class="line">Maven home: /home/maven/apache-maven-3.8.1</span><br><span class="line">Java version: 1.8.0_212, vendor: Oracle Corporation, runtime: /usr/java/jdk1.8.0_212-amd64/jre</span><br><span class="line">Default locale: en_US, platform encoding: UTF-8</span><br><span class="line">OS name: &quot;linux&quot;, version: &quot;4.14.35-1902.7.3.1.el7uek.x86_64&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux软件安装 </tag>
            
            <tag> Maven </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java八股文</title>
      <link href="/2021/04/26/Java/java%E5%85%AB%E8%82%A1%E6%96%87/"/>
      <url>/2021/04/26/Java/java%E5%85%AB%E8%82%A1%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-八股文"><a href="#Java-八股文" class="headerlink" title="Java 八股文"></a>Java 八股文</h1><h3 id="一、Java-基础知识"><a href="#一、Java-基础知识" class="headerlink" title="一、Java 基础知识"></a>一、Java 基础知识</h3><h4 id="1、Object-类相关方法"><a href="#1、Object-类相关方法" class="headerlink" title="1、Object 类相关方法"></a>1、Object 类相关方法</h4><ul><li>  getClass 获取当前运行时对象的 Class 对象。</li><li>  hashCode 返回对象的 hash 码。</li><li>  clone 拷贝当前对象， 必须实现 Cloneable 接口。<strong>浅拷贝</strong>对基本类型进行值拷贝，对引用类型拷贝引用；<strong>深拷贝</strong>对基本类型进行值拷贝，对引用类型对象不但拷贝对象的引用还拷贝对象的相关属性和方法。两者不同在于深拷贝创建了一个新的对象。</li><li>  equals 通过内存地址比较两个对象是否相等，String 类重写了这个方法使用值来比较是否相等。</li><li>  toString 返回类名@哈希码的 16 进制。</li><li>  notify 唤醒当前对象监视器的任一个线程。</li><li>  notifyAll 唤醒当前对象监视器上的所有线程。</li><li>  wait 1、暂停线程的执行；2、三个不同参数方法（等待多少毫秒；额外等待多少毫秒；一直等待）3、与 <code>Thread.sleep(long time)</code> 相比，sleep 使当前线程休眠一段时间，并没有释放该对象的锁，wait 释放了锁。</li><li>  finalize 对象被垃圾回收器回收时执行的方法。</li></ul><h4 id="2、基本数据类型"><a href="#2、基本数据类型" class="headerlink" title="2、基本数据类型"></a>2、基本数据类型</h4><ul><li>  整型：byte(8)、short(16)、int(32)、long(64)</li><li>  浮点型：float(32)、double(64)</li><li>  布尔型：boolean(8)</li><li>  字符型：char(16)</li></ul><h4 id="3、序列化"><a href="#3、序列化" class="headerlink" title="3、序列化"></a>3、序列化</h4><p>Java 对象实现序列化要实现 Serializable 接口。</p><ul><li>  反序列化并不会调用构造方法。反序列的对象是由 JVM 自己生成的对象，不通过构造方法生成。</li><li>  序列化对象的引用类型成员变量，也必须是可序列化的，否则，会报错。</li><li>  如果想让某个变量不被序列化，使用 transient 修饰。</li><li>  单例类序列化，需要重写 readResolve() 方法。</li></ul><h4 id="4、String、StringBuffer、StringBuilder"><a href="#4、String、StringBuffer、StringBuilder" class="headerlink" title="4、String、StringBuffer、StringBuilder"></a>4、String、StringBuffer、StringBuilder</h4><ul><li>  String 由 char[] 数组构成，使用了 final 修饰，是不可变对象，可以理解为常量，线程安全；对 String 进行改变时每次都会新生成一个 String 对象，然后把指针指向新的引用对象。</li><li>  StringBuffer 线程安全；StringBuiler 线程不安全。</li><li>  操作少量字符数据用 String；单线程操作大量数据用 StringBuilder；多线程操作大量数据用 StringBuffer。</li></ul><h4 id="5、重载与重写"><a href="#5、重载与重写" class="headerlink" title="5、重载与重写"></a>5、重载与重写</h4><ul><li>  重载 发生在同一个类中，方法名相同，参数的类型、个数、顺序不同，方法的返回值和修饰符可以不同。</li><li>  重写 发生在父子类中，方法名和参数相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 或者 final 则子类就不能重写该方法。</li></ul><h4 id="6、final"><a href="#6、final" class="headerlink" title="6、final"></a>6、final</h4><ul><li>  修饰基本类型变量，一经出初始化后就不能够对其进行修改。</li><li>  修饰引用类型变量，不能够指向另一个引用。</li><li>  修饰类或方法，不能被继承或重写。</li></ul><h4 id="7、反射"><a href="#7、反射" class="headerlink" title="7、反射"></a>7、反射</h4><ul><li>  在运行时动态的获取类的完整信息</li><li>  增加程序的灵活性</li><li>  JDK 动态代理使用了反射</li></ul><h4 id="8、JDK-动态代理"><a href="#8、JDK-动态代理" class="headerlink" title="8、JDK 动态代理"></a>8、JDK 动态代理</h4><ul><li>使用步骤<ul><li>  创建接口及实现类</li><li>  实现代理处理器：实现 InvokationHandler ，实现 invoke（Proxy proxy，Method method，Object[] args） 方法</li><li>  通过 Proxy.newProxyInstance(ClassLoaderloader, Class[] interfaces, InvocationHandler h) 获得代理类</li><li>  通过代理类调用方法。</li></ul></li></ul><h4 id="9、Java-IO"><a href="#9、Java-IO" class="headerlink" title="9、Java IO"></a>9、Java IO</h4><ul><li>  普通 IO ，面向流，同步阻塞线程。</li><li>  NIO，面向缓冲区，同步非阻塞。</li></ul><h3 id="二、Java-集合框架"><a href="#二、Java-集合框架" class="headerlink" title="二、Java 集合框架"></a>二、Java 集合框架</h3><h4 id="1、List（线性结构）"><a href="#1、List（线性结构）" class="headerlink" title="1、List（线性结构）"></a>1、List（线性结构）</h4><ul><li>  ArrayList Object[] 数组实现，默认大小为 10 ，支持随机访问，连续内存空间，插入末尾时间复杂度 o(1)，插入第 i 个位置时间复杂度 o(n - i)。扩容，大小变为 <strong>1.5</strong> 倍，Arrays.copyOf（底层 System.ArrayCopy），复制到新数组，指针指向新数组。</li><li>  Vector 类似 ArrayList，线程安全，扩容默认增长为原来的 <strong>2</strong> 倍，还可以指定增长空间长度。</li><li>  LinkedList 基于链表实现，1.7 为双向链表，1.6 为双向循环链表，取消循环更能分清头尾。</li></ul><h4 id="2、Map（K，V-对）"><a href="#2、Map（K，V-对）" class="headerlink" title="2、Map（K，V 对）"></a>2、Map（K，V 对）</h4><ul><li>HashMap<ul><li>  底层数据结构，JDK 1.8 是<strong>数组 + 链表 + 红黑树</strong>，JDK 1.7 无红黑树。链表长度大于 8 时，转化为红黑树，优化查询效率。</li><li>  初始容量为 <strong>16</strong>，通过 tableSizeFor 保证容量为 2 的幂次方。寻址方式，高位异或，**(n-1)&amp;h** 取模，优化速度。</li><li>  扩容机制，当元素数量大于容量 x 负载因子 0.75 时，容量扩大为原来的 2 倍，新建一个数组，然后转移到新数组。</li><li>  基于 Map 实现。</li><li>  线程不安全。</li></ul></li><li>HashMap (1.7) 多线程循环链表问题<ul><li>  在多线程环境下，进行扩容时，1.7 下的 HashMap 会形成循环链表。</li><li>  怎么形成循环链表： 假设有一 HashMap 容量为 2 ， 在数组下标 1 位置以 A -&gt; B 链表形式存储。有一线程对该 map 做 put 操作，由于触发扩容条件，需要进行扩容。这时另一个线程也 put 操作，同样需要扩容，并完成了扩容操作，由于复制到新数组是头部插入，所以 1 位置变为 B -&gt; A 。这时第一个线程继续做扩容操作，首先复制 A ，然后复制 B ，再判断 B.next 是否为空时，由于第二个线程做了扩容操作，导致 B.next = A，所以在将 A 放到 B 前，A.next 又等于 B ，导致循环链表出现。</li></ul></li><li>HashTable<ul><li>  线程安全，方法基本全用 Synchronized 修饰。</li><li>  初始容量为 11 ，扩容为 2n + 1 。</li><li>  继承 <strong>Dictionary</strong> 类。</li></ul></li><li>ConcurrentHashMap<ul><li>  线程安全的 HashMap。</li><li>  1.7 采用分段锁的形式加锁；1.8 使用 Synchronized 和 CAS 实现同步，若数组的 Node 为空，则通过 CAS 的方式设置值，不为空则加在链表的第一个节点。获取第一个元素是否为空使用 Unsafe 类提供的 getObjectVolatile 保证可见性。</li><li>  对于读操作，数组由 volatile 修饰，同时数组的元素为 Node，Node 的 K 使用 final 修饰，V 使用 volatile 修饰，下一个节点也用 volatile 修饰，保证多线程的可见性。</li></ul></li><li>  LinkedHashMap LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。</li><li>  TreeMap 有序的 Map，红黑树结构，可以自定义比较器来进行排序。</li><li>  Collections.synchronizedMap 如何实现 Map 线程安全？ 基于 Synchronized ，实际上就是锁住了当前传入的 Map 对象。</li></ul><h4 id="3、Set（唯一值）"><a href="#3、Set（唯一值）" class="headerlink" title="3、Set（唯一值）"></a>3、Set（唯一值）</h4><ul><li>  HashSet 基于 HashMap 实现，使用了 HashMap 的 K 作为元素存储，V 为 new Object() ，在 add() 方法中如果两个元素的 Hash 值相同，则通过 equals 方法比较是否相等。</li><li>  LinkedHashSet LinkedHashSet 继承于 HashSet，并且其内部是通过 LinkedHashMap 来实现的。</li><li>  TreeSet 红黑树实现有序唯一。</li></ul><h3 id="三、Java-多线程"><a href="#三、Java-多线程" class="headerlink" title="三、Java 多线程"></a>三、Java 多线程</h3><h4 id="1、synchronized"><a href="#1、synchronized" class="headerlink" title="1、synchronized"></a>1、synchronized</h4><ul><li>  修饰代码块 底层实现，通过 monitorenter &amp; monitorexit 标志代码块为同步代码块。</li><li>  修饰方法 底层实现，通过 ACC_SYNCHRONIZED 标志方法是同步方法。</li><li>  修饰类 class 对象时，实际锁在类的实例上面。</li><li>  单例模式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123;</span><br><span class="line">                instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>偏向锁，自旋锁，轻量级锁，重量级锁<ul><li>  通过 synchronized 加锁，第一个线程获取的锁为偏向锁，这时有其他线程参与锁竞争，升级为轻量级锁，其他线程通过循环的方式尝试获得锁，称自旋锁。若果自旋的次数达到一定的阈值，则升级为重量级锁。</li><li>  需要注意的是，在第二个线程获取锁时，会先判断第一个线程是否仍然存活，如果不存活，不会升级为轻量级锁。</li></ul></li></ul><h4 id="2、Lock"><a href="#2、Lock" class="headerlink" title="2、Lock"></a>2、Lock</h4><ul><li>ReentrantLock<ul><li>  基于 AQS （AbstractQueuedSynchronizer）实现，主要有 state (资源) + FIFO (线程等待队列) 组成。</li><li>  公平锁与非公平锁：区别在于在获取锁时，公平锁会判断当前队列是否有正在等待的线程，如果有则进行排队。</li><li>  使用 lock() 和 unLock() 方法来加锁解锁。</li></ul></li><li>ReentrantReadWriteLock<ul><li>  同样基于 AQS 实现，内部采用内部类的形式实现了读锁（共享锁）和写锁 （排它锁）。</li></ul></li><li>  非公平锁吞吐量高 在获取锁的阶段来分析，当某一线程要获取锁时，非公平锁可以直接尝试获取锁，而不是判断当前队列中是否有线程在等待。一定情况下可以避免线程频繁的上下文切换，这样，活跃的线程有可能获得锁，而在队列中的锁还要进行唤醒才能继续尝试获取锁，而且线程的执行顺序一般来说不影响程序的运行。</li></ul><h4 id="3、volatile"><a href="#3、volatile" class="headerlink" title="3、volatile"></a>3、volatile</h4><ul><li>  Java 内存模型</li></ul><p><img src="https://img-blog.csdnimg.cn/2020090416055754.png" alt="image.png"></p><ul><li>  在多线程环境下，保证变量的可见性。使用了 volatile 修饰变量后，<strong>在变量修改后会立即同步到主存中，每次用这个变量前会从主存刷新。</strong></li><li>  禁止 JVM 指令重排序。</li><li>  单例模式双重校验锁变量为什么使用 volatile 修饰？ 禁止 JVM 指令重排序，new Object()分为三个步骤：申请内存空间，将内存空间引用赋值给变量，变量初始化。如果不禁止重排序，有可能得到一个未经初始化的变量。</li></ul><h4 id="4、线程的五种状态"><a href="#4、线程的五种状态" class="headerlink" title="4、线程的五种状态"></a>4、线程的五种状态</h4><h5 id="1-New"><a href="#1-New" class="headerlink" title="1). New"></a>1). New</h5><p>一个新的线程被创建，还没开始运行。</p><h5 id="2-Runnable"><a href="#2-Runnable" class="headerlink" title="2). Runnable"></a>2). Runnable</h5><p>一个线程准备就绪，随时可以运行的时候就进入了 Runnable 状态。</p><p>Runnable 状态可以是实际正在运行的线程，也可以是随时可以运行的线程。</p><p>多线程环境下，每个线程都会被分配一个固定长度的 CPU 计算时间，每个线程运行一会儿就会停止让其他线程运行，这样才能让每个线程公平的运行。这些等待 CPU 和正在运行的线程就处于 Runnable 状态。</p><h5 id="3-Blocked"><a href="#3-Blocked" class="headerlink" title="3). Blocked"></a>3). Blocked</h5><p>例如一个线程在等待 I/O 资源，或者它要访问的被保护代码已经被其他线程锁住了，那么它就在阻塞 Blocked 状态，这个线程所需的资源到位后就转入 Runnable 状态。</p><h5 id="4-Waiting（无限期等待）"><a href="#4-Waiting（无限期等待）" class="headerlink" title="4). Waiting（无限期等待）"></a>4). Waiting（无限期等待）</h5><p>如果一个线程在等待其他线程的唤醒，那么它就处于 Waiting 状态。以下方法会让线程进入等待状态：</p><ul><li>  Object.wait()</li><li>  Thread.join()</li><li>  LockSupport.park()</li></ul><h5 id="5-Timed-Waiting（有期限等待）"><a href="#5-Timed-Waiting（有期限等待）" class="headerlink" title="5). Timed Waiting（有期限等待）"></a>5). Timed Waiting（有期限等待）</h5><p>无需等待被其他线程显示唤醒，在一定时间后有系统自动唤醒。</p><p>以下方法会让线程进入有限等待状态：</p><ul><li>  Thread.sleep(sleeptime)</li><li>  Object.wait(timeout)</li><li>  Thread.join(timeout)</li><li>  LockSupport.parkNanos(timeout)</li><li>  LockSupport.parkUntil(timeout)</li></ul><h5 id="6-Terminated"><a href="#6-Terminated" class="headerlink" title="6). Terminated"></a>6). Terminated</h5><p>一个线程正常执行完毕，或者意外失败，那么就结束了。</p><h4 id="5、-wait-与-sleep"><a href="#5、-wait-与-sleep" class="headerlink" title="5、 wait() 与 sleep()"></a>5、 wait() 与 sleep()</h4><ul><li>  调用后线程进入 waiting 状态。</li><li>  wait() 释放锁，sleep() 没有释放锁。</li><li>  调用 wait() 后需要调用 notify() 或 notifyAll() 方法唤醒线程。</li><li>  wait() 方法声明在 Object 中，sleep() 方法声明在 Thread 中。</li></ul><h4 id="6、-yield"><a href="#6、-yield" class="headerlink" title="6、 yield()"></a>6、 yield()</h4><ul><li>  调用后线程进入 runnable 状态。</li><li>  让出 CPU 时间片，之后有可能其他线程获得执行权，也有可能这个线程继续执行。</li></ul><h4 id="7、-join"><a href="#7、-join" class="headerlink" title="7、 join()"></a>7、 join()</h4><ul><li>  在线程 B 中调用了线程 A 的 Join()方法，直到线程 A 执行完毕后，才会继续执行线程 B。</li><li>  可以保证线程的顺序执行。</li><li>  join() 方法必须在 线程启动后调用才有意义。</li><li>  使用 wait() 方法实现。</li></ul><h4 id="9、线程使用方式"><a href="#9、线程使用方式" class="headerlink" title="9、线程使用方式"></a>9、线程使用方式</h4><ul><li>  继承 Tread 类</li><li>  实现 Runnable 接口</li><li>  实现 Callable 接口：带有返回值</li></ul><h4 id="10、Runnable-和-Callable-比较"><a href="#10、Runnable-和-Callable-比较" class="headerlink" title="10、Runnable 和 Callable 比较"></a>10、Runnable 和 Callable 比较</h4><ol><li> 方法签名不同， <code>void Runnable.run()</code> , <code>V Callable.call() throws Exception</code></li><li> 是否允许有返回值， <code>Callable</code> 允许有返回值</li><li> 是否允许抛出异常， <code>Callable</code> 允许抛出异常。</li><li> 提交任务方式， <code>Callable</code> 使用 <code>Future&lt;T&gt; submit(Callable&lt;T&gt; task)</code> 返回 Future 对象，调用其 get() 方法可以获得返回值， <code>Runnable</code> 使用 <code>void execute(Runnable command)</code> 。</li></ol><h4 id="11、hapens-before"><a href="#11、hapens-before" class="headerlink" title="11、hapens-before"></a>11、hapens-before</h4><p>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</p><h4 id="12、ThreadLocal"><a href="#12、ThreadLocal" class="headerlink" title="12、ThreadLocal"></a>12、ThreadLocal</h4><ul><li>  场景 主要用途是为了保持线程自身对象和避免参数传递，主要适用场景是按线程多实例（每个线程对应一个实例）的对象的访问，并且这个对象很多地方都要用到。</li><li>  原理 为每个线程创建变量副本，不同线程之间不可见，保证线程安全。使用 ThreadLocalMap 存储变量副本，以 ThreadLocal 为 K，这样一个线程可以拥有多个 ThreadLocal 对象。</li><li>  实际 使用多数据源时，需要根据数据源的名字切换数据源，假设一个线程设置了一个数据源，这个时候就有可能有另一个线程去修改数据源，可以使用 ThreadLocal 维护这个数据源名字，使每个线程持有数据源名字的副本，避免线程安全问题。</li></ul><h4 id="8、线程池"><a href="#8、线程池" class="headerlink" title="8、线程池"></a>8、线程池</h4><h5 id="1-、分类"><a href="#1-、分类" class="headerlink" title="1)、分类"></a>1)、分类</h5><ul><li>  FixThreadPool 固定数量的线程池，适用于对线程管理，高负载的系统</li><li>  SingleThreadPool 只有一个线程的线程池，适用于保证任务顺序执行</li><li>  CacheThreadPool 创建一个不限制线程数量的线程池，适用于执行短期异步任务的小程序，低负载系统</li><li>  ScheduledThreadPool 定时任务使用的线程池，适用于定时任务</li></ul><h5 id="2-、线程池的几个重要参数"><a href="#2-、线程池的几个重要参数" class="headerlink" title="2)、线程池的几个重要参数"></a>2)、线程池的几个重要参数</h5><ul><li>  int corePoolSize, 核心线程数</li><li>  int maximumPoolSize, 最大线程数</li><li>  long keepAliveTime, TimeUnit unit, 超过 corePoolSize 的线程的存活时长，超过这个时间，多余的线程会被回收。</li><li>  BlockingQueue workQueue, 任务的排队队列</li><li>  ThreadFactory threadFactory, 新线程的产生方式</li><li>  RejectedExecutionHandler handler) 拒绝策略</li></ul><h5 id="3-、线程池线程工作过程"><a href="#3-、线程池线程工作过程" class="headerlink" title="3)、线程池线程工作过程"></a>3)、线程池线程工作过程</h5><p>corePoolSize -&gt; 任务队列 -&gt; maximumPoolSize -&gt; 拒绝策略</p><blockquote><p>核心线程在线程池中一直存活，当有任务需要执行时，直接使用核心线程执行任务。当任务数量大于核心线程数时，加入等待队列。当任务队列数量达到队列最大长度时，继续创建线程，最多达到最大线程数。当设置回收时间时，核心线程以外的空闲线程会被回收。如果达到了最大线程数还不能够满足任务执行需求，则根据拒绝策略做拒绝处理。</p></blockquote><h5 id="4-、线程池拒绝策略（默认抛出异常）"><a href="#4-、线程池拒绝策略（默认抛出异常）" class="headerlink" title="4)、线程池拒绝策略（默认抛出异常）"></a>4)、线程池拒绝策略（默认抛出异常）</h5><table><thead><tr><th align="left">策略</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">AbortPolicy</td><td align="left">抛出 RejectedExecutionException</td></tr><tr><td align="left">DiscardPolicy</td><td align="left">什么也不做，直接忽略</td></tr><tr><td align="left">DiscardOldestPolicy</td><td align="left">丢弃执行队列中最老的任务，尝试为当前提交的任务腾出位置</td></tr><tr><td align="left">CallerRunsPolicy</td><td align="left">直接由提交任务者执行这个任务</td></tr></tbody></table><h5 id="5-、如何根据-CPU-核心数设计线程池线程数量"><a href="#5-、如何根据-CPU-核心数设计线程池线程数量" class="headerlink" title="5)、如何根据 CPU 核心数设计线程池线程数量"></a>5)、如何根据 CPU 核心数设计线程池线程数量</h5><ul><li>  IO 密集型 2nCPU</li><li>计算密集型 nCPU+1<ul><li>  其中 n 为 CPU 核心数量，可通过 <code>Runtime.getRuntime().availableProcessors()</code> 获得核心数：。</li><li>  为什么加 1：即使当计算密集型的线程偶尔由于缺失故障或者其他原因而暂停时，这个额外的线程也能确保 CPU 的时钟周期不会被浪费。</li></ul></li></ul><h3 id="四、Java-虚拟机"><a href="#四、Java-虚拟机" class="headerlink" title="四、Java 虚拟机"></a>四、Java 虚拟机</h3><h4 id="1、Java-内存结构"><a href="#1、Java-内存结构" class="headerlink" title="1、Java 内存结构"></a>1、Java 内存结构</h4><p><img src="https://img-blog.csdnimg.cn/20200904160557208.png" alt="image.png"></p><ul><li>  堆 由线程共享，存放 new 出来的对象，是垃圾回收器的主要工作区域。</li><li>  栈 线程私有，分为 Java 虚拟机栈和本地方法栈，存放局部变量表、操作栈、动态链接、方法出口等信息，方法的执行对应着入栈到出栈的过程。</li><li>  方法区 线程共享，存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等信息，JDK 1.8 中方法区被元空间取代，使用直接内存。</li></ul><h4 id="2、Java-类加载机制"><a href="#2、Java-类加载机制" class="headerlink" title="2、Java 类加载机制"></a>2、Java 类加载机制</h4><p><img src="https://img-blog.csdnimg.cn/20200904160557387.png" alt="image.png"></p><ul><li>  加载 加载字节码文件。</li><li>链接<ul><li>  验证 验证字节码文件的正确性。</li><li>  准备 为静态变量分配内存。</li><li>  解析 将符号引用（如类的全限定名）解析为直接引用（类在实际内存中的地址）。</li></ul></li><li>  初始化 为静态变量赋初值。</li></ul><blockquote><p>双亲委派模式</p></blockquote><blockquote><p>当一个类需要加载时，判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的 <code>loadClass()</code> 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。当父类加载器无法处理时，才由自己来处理。当父类加载器为 null 时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</p></blockquote><h4 id="3、垃圾回收算法"><a href="#3、垃圾回收算法" class="headerlink" title="3、垃圾回收算法"></a>3、垃圾回收算法</h4><ul><li>  Mark-Sweep（标记-清除）算法 标记需要回收的对象，然后清除，会造成许多内存碎片。</li><li>  Copying（复制）算法 将内存分为两块，只使用一块，进行垃圾回收时，先将存活的对象复制到另一块区域，然后清空之前的区域。</li><li>  Mark-Compact（标记-整理）算法（压缩法） 与标记清除算法类似，但是在标记之后，将存活对象向一端移动，然后清除边界外的垃圾对象。</li><li>  Generational Collection（分代收集）算法 分为年轻代和老年代，年轻代时比较活跃的对象，使用复制算法做垃圾回收。老年代每次回收只回收少量对象，使用标记整理法。</li></ul><h4 id="4、典型垃圾回收器"><a href="#4、典型垃圾回收器" class="headerlink" title="4、典型垃圾回收器"></a>4、典型垃圾回收器</h4><ul><li>CMS<ul><li>  简介 以获取最短回收停顿时间为目标的收集器，它是一种并发收集器，采用的是 Mark-Sweep 算法。</li><li>  场景 如果你的应用需要更快的响应，不希望有长时间的停顿，同时你的 CPU 资源也比较丰富，就适合适用 CMS 收集器。</li><li>垃圾回收步骤</li></ul><ol><li> 初始标记 (Stop the World 事件 CPU 停顿， 很短) 初始标记仅标记一下 GC Roots 能直接关联到的对象，速度很快；</li><li> 并发标记 (收集垃圾跟用户线程一起执行) 并发标记过程就是进行 GC Roots 查找的过程；</li><li> 重新标记 (Stop the World 事件 CPU 停顿，比初始标记稍微长，远比并发标记短) 修正由于并发标记时应用运行产生变化的标记。</li><li>并发清理，标记清除算法；</li></ol><ul><li>缺点<ul><li>  并发标记时和应用程序同时进行，占用一部分线程，所以吞吐量有所下降。</li><li>  并发清除时和应用程序同时进行，这段时间产生的垃圾就要等下一次 GC 再清除。</li><li>  采用的标记清除算法，产生内存碎片，如果要新建大对象，会提前触发 Full GC 。</li></ul></li></ul></li><li>G1<ul><li>  简介 是一款面向服务端应用的收集器，它能充分利用多 CPU、多核环境。因此它是一款并行与并发收集器，并且它能建立可预测的停顿时间模型，即可以设置 STW 的时间。</li><li>  垃圾回收步骤 1、初始标记(stop the world 事件 CPU 停顿只处理垃圾)； 2、并发标记(与用户线程并发执行)； 3、最终标记(stop the world 事件 ,CPU 停顿处理垃圾)； 4、筛选回收(stop the world 事件 根据用户期望的 GC 停顿时间回收)</li><li>特点<ul><li>  并发与并行 充分利用多核 CPU ，使用多核来缩短 STW 时间，部分需要停顿应用线程的操作，仍然可以通过并发保证应用程序的执行。</li><li>  分代回收 新生代，幸存带，老年代</li><li>  空间整合 总体看是采用标记整理算法回收，每个 Region 大小相等，通过复制来回收。</li><li>  可预测的停顿时间 使用 -XX:MaxGCPauseMillis=200 设置最长目标暂停值。</li></ul></li></ul></li></ul><blockquote><p>在 Java 语言中，可作为 GC Roots 的对象包括 4 种情况：</p></blockquote><blockquote><p>a) 虚拟机栈中引用的对象（栈帧中的本地变量表）； b) 方法区中类静态属性引用的对象； c) 方法区中常量引用的对象； d) 本地方法栈中 Native 方法引用的对象。</p></blockquote><h3 id="五、MySQL-（Inno-DB）"><a href="#五、MySQL-（Inno-DB）" class="headerlink" title="五、MySQL （Inno DB）"></a>五、MySQL （Inno DB）</h3><h4 id="1、聚簇索引与非聚簇索引"><a href="#1、聚簇索引与非聚簇索引" class="headerlink" title="1、聚簇索引与非聚簇索引"></a>1、聚簇索引与非聚簇索引</h4><p><img src="https://img-blog.csdnimg.cn/20200904160557515.png" alt="image.png"></p><ul><li>  都使用 B+ 树作为数据结构</li><li>  聚簇索引中数据存在主键索引的叶子结点中，得到 key 即得到 data ；非聚簇索引的数据存在单独的空间。</li><li>  聚簇索引中辅助索引的叶子结点存的是主键；非聚簇索引中叶子结点存的是数据的地址；</li><li>  聚簇索引的优势是找到主键就找到数据，只需一次磁盘 IO ；当 B+ 树的结点发生变化时，地址也会发生变化，这时非聚簇索引需要更新所有的地址，增加开销。</li></ul><h4 id="2、为何使用-B-树做索引而不是红黑树？"><a href="#2、为何使用-B-树做索引而不是红黑树？" class="headerlink" title="2、为何使用 B 树做索引而不是红黑树？"></a>2、为何使用 B 树做索引而不是红黑树？</h4><p>索引很大，通常作为文件存储在磁盘上面，每次检索索引都需要把索引文件加载进内存，所以磁盘 IO 的次数是衡量索引数据结构好坏的重要指标。应用程序在从磁盘读取数据时，不只是读取需要的数据，还会连同其他数据以页的形式做预读来减少磁盘 IO 的次数。数据库的设计者将每个节点的大小设置为一页的大小，同时每次新建节点时都重新申请一个页，这样检索一个节点只需要一次 IO，根据索引定位到数据只需要 h- 1（h 为 B 树高度，根节点常驻内存） 次 IO，而 d (度，可以理解为宽度)与 h 称反比，即 d 越大，高度就越小，所以树越扁，磁盘 IO 次数越少，即渐进复杂度为 logdN ，这也是为什么不选择红黑树做索引的原因。前面可以得出结论，d 越大，索引的性能越好。节点由 key 和 data 组成，页的大小一定，key 和 data 越小，d 越大。B + 树去掉了节点内的 data 域，所以有更大的 d , 性能更好。</p><h4 id="3、最左前缀原则"><a href="#3、最左前缀原则" class="headerlink" title="3、最左前缀原则"></a>3、最左前缀原则</h4><p>在 MySQL 中，可以指定多个列为索引，即联合索引。比如 index(name，age) ，最左前缀原则是指查询时精确匹配到从最左边开始的一列或几列（name；name&amp;age），就可以命中索引。如果所有列都用到了，顺序不同，查询引擎会自动优化为匹配联合索引的顺序，这样是能够命中索引的。</p><h4 id="4、什么情况下可以用到-B-树索引"><a href="#4、什么情况下可以用到-B-树索引" class="headerlink" title="4、什么情况下可以用到 B 树索引"></a>4、什么情况下可以用到 B 树索引</h4><p>(1) 定义有主键的列一定要建立索引。因为主键可以加速定位到表中的某行</p><p>(2) 定义有外键的列一定要建立索引。外键列通常用于表与表之间的连接，在其上创建索引可以加快表间的连接</p><p>(3) 对于经常查询的数据列最好建立索引。</p><p>① 对于需要在指定范围内快速或频繁查询的数据列，因为索引已经排序，其指定的范围是连续的，查询可以利用索引的排序，加快查询的时间</p><p>② 经常用在 <code>where</code> 子句中的数据列，将索引建立在 <code>where</code> 子句的集合过程中，对于需要加速或频繁检索的数据列，可以让这些经常参与查询的数据列按照索引的排序进行查询，加快查询的时间。</p><h4 id="5、事务隔离级别"><a href="#5、事务隔离级别" class="headerlink" title="5、事务隔离级别"></a>5、事务隔离级别</h4><ul><li>  <strong>Read uncommitted</strong> 读未提交，可能出现脏读，不可重复读，幻读。</li><li>  <strong>Read committed</strong> 读提交，可能出现不可重复读，幻读。</li><li>  <strong>Repeatable read</strong> 可重复读，可能出现脏读。</li><li>  <strong>Serializable</strong> 可串行化，同一数据读写都加锁，避免脏读，性能不忍直视。</li></ul><blockquote><p>Inno DB 默认隔离级别为可重复读级别，分为快照度和当前读，并且通过行锁和间隙锁解决了幻读问题。</p></blockquote><h4 id="6、MVCC-（多版本并发控制）"><a href="#6、MVCC-（多版本并发控制）" class="headerlink" title="6、MVCC （多版本并发控制）"></a>6、MVCC （多版本并发控制）</h4><ul><li>实现细节<ul><li>  每行数据都存在一个版本，每次数据更新时都更新该版本。</li><li>  修改时 Copy 出当前版本随意修改，各个事务之间互不干扰。</li><li>  保存时比较版本号，如果成功（commit），则覆盖原记录；失败则放弃 copy（rollback）。</li></ul></li><li>  Inno DB 实现</li></ul><blockquote><p>在 InnoDB 中为每行增加两个隐藏的字段，分别是该行数据<strong>创建时的版本号</strong>和<strong>删除时的版本号</strong>，这里的版本号是系统版本号（可以简单理解为事务的 ID），每开始一个新的事务，系统版本号就自动递增，作为事务的 ID 。通常这两个版本号分别叫做创建时间和删除时间。</p></blockquote><p>详细参考：<a href="https://aysaml.com/articles/2020/01/04/1578137608006.html">《 脏读、幻读和不可重复读》</a></p><h3 id="六、Spring-相关"><a href="#六、Spring-相关" class="headerlink" title="六、Spring 相关"></a>六、Spring 相关</h3><h4 id="1、Bean-的作用域"><a href="#1、Bean-的作用域" class="headerlink" title="1、Bean 的作用域"></a>1、Bean 的作用域</h4><table><thead><tr><th align="left">类别</th><th align="left">说明</th></tr></thead><tbody><tr><td align="left">singleton</td><td align="left">默认在 Spring 容器中仅存在一个实例</td></tr><tr><td align="left">prototype</td><td align="left">每次调用 getBean() 都重新生成一个实例</td></tr><tr><td align="left">request</td><td align="left">为每个 HTTP 请求生成一个实例</td></tr><tr><td align="left">session</td><td align="left">同一个 HTTP session 使用一个实例，不同 session 使用不同实例</td></tr></tbody></table><h4 id="2、Bean-生命周期"><a href="#2、Bean-生命周期" class="headerlink" title="2、Bean 生命周期"></a>2、Bean 生命周期</h4><p>简单来说四步：</p><ul><li><ol><li> 实例化 Instantiation</li></ol></li><li><ol start="2"><li> 属性赋值 Populate</li></ol></li><li><ol start="3"><li> 初始化 Initialization</li></ol></li><li><ol start="4"><li> 销毁 Destruction</li></ol></li></ul><p>在这四步的基础上面，Spring 提供了一些拓展点：</p><ul><li>  <strong>Bean 自身的方法</strong>: 这个包括了 Bean 本身调用的方法和通过配置文件中 %3Cbean %3E 的 init-method 和 destroy-method 指定的方法</li><li>  <strong>Bean 级生命周期接口方法</strong>: 这个包括了 BeanNameAware、BeanFactoryAware、InitializingBean 和 DiposableBean 这些接口的方法</li><li>  <strong>容器级生命周期接口方法</strong>：这个包括了 InstantiationAwareBeanPostProcessor 和 BeanPostProcessor 这两个接口实现，一般称它们的实现类为“后处理器”。</li><li>  <strong>工厂后处理器接口方法</strong>: 这个包括了 AspectJWeavingEnabler, ConfigurationClassPostProcessor, CustomAutowireConfigurer 等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的。在应用上下文装配配置文件之后立即调用。</li></ul><h4 id="3、Spring-AOP"><a href="#3、Spring-AOP" class="headerlink" title="3、Spring AOP"></a>3、Spring AOP</h4><p>实现方式两种：</p><ul><li>  JDK 动态代理：带有接口的对象，在运行期实现</li><li>  CGlib 静态代理：在编译期实现。</li></ul><h4 id="4、Spring-事务传播行为"><a href="#4、Spring-事务传播行为" class="headerlink" title="4、Spring 事务传播行为"></a>4、Spring 事务传播行为</h4><p>默认 <strong>PROPAGATION_REQUIRED</strong> ，如果存在一个事务，则支持当前事务。如果没有事务则开启一个新的事务。</p><p><img src="https://img-blog.csdnimg.cn/20200904160557690.png" alt="image.png"></p><h4 id="5、Spring-IoC"><a href="#5、Spring-IoC" class="headerlink" title="5、Spring IoC"></a>5、Spring IoC</h4><p><img src="https://img-blog.csdnimg.cn/20200904160557786.png" alt="image.png"></p><h4 id="6、Spring-MVC-工作流程"><a href="#6、Spring-MVC-工作流程" class="headerlink" title="6、Spring MVC 工作流程"></a>6、Spring MVC 工作流程</h4><p><img src="https://img-blog.csdnimg.cn/20200904160557996.png"></p><h3 id="七、计算机网络"><a href="#七、计算机网络" class="headerlink" title="七、计算机网络"></a>七、计算机网络</h3><h4 id="1、TCP-IP-五层模型"><a href="#1、TCP-IP-五层模型" class="headerlink" title="1、TCP/IP 五层模型"></a>1、TCP/IP 五层模型</h4><p><img src="https://img-blog.csdnimg.cn/20200904160558176.png" alt="image.png"></p><h4 id="2、浏览器输入地址后做了什么？"><a href="#2、浏览器输入地址后做了什么？" class="headerlink" title="2、浏览器输入地址后做了什么？"></a>2、浏览器输入地址后做了什么？</h4><p><img src="https://img-blog.csdnimg.cn/20200904160558322.png" alt="image.png"></p><h4 id="3、三次握手与四次挥手"><a href="#3、三次握手与四次挥手" class="headerlink" title="3、三次握手与四次挥手"></a>3、三次握手与四次挥手</h4><ul><li>  三次握手 <img src="https://img-blog.csdnimg.cn/20200904160558436.png" alt="image.png"></li><li>  四次挥手 <img src="https://img-blog.csdnimg.cn/20200904160558571.png" alt="image.png"></li></ul><h4 id="4、TIME-WAIT-与-CLOSE-WAIT"><a href="#4、TIME-WAIT-与-CLOSE-WAIT" class="headerlink" title="4、TIME_WAIT 与 CLOSE_WAIT"></a>4、TIME_WAIT 与 CLOSE_WAIT</h4><p><img src="https://img-blog.csdnimg.cn/20200904160558691.png" alt="image.png"></p><h4 id="5、TCP-滑动窗口"><a href="#5、TCP-滑动窗口" class="headerlink" title="5、TCP 滑动窗口"></a>5、TCP 滑动窗口</h4><p>TCP 流量控制，主要使用<strong>滑动窗口协议</strong>，滑动窗口是接受数据端使用的窗口大小，用来告诉发送端接收端的缓存大小，以此可以控制发送端发送数据的大小，从而达到流量控制的目的。这个窗口大小就是我们一次传输几个数据。对所有数据帧按顺序赋予编号，发送方在发送过程中始终保持着一个发送窗口，只有落在发送窗口内的帧才允许被发送；同时接收方也维持着一个接收窗口，只有落在接收窗口内的帧才允许接收。</p><h4 id="6、TCP-粘包和拆包"><a href="#6、TCP-粘包和拆包" class="headerlink" title="6、TCP 粘包和拆包"></a>6、TCP 粘包和拆包</h4><ul><li>  现象 <img src="https://img-blog.csdnimg.cn/20200904160558786.png" alt="image.png"></li><li>  产生原因 1、要发送的数据大于 TCP 发送缓冲区剩余空间大小，将会发生拆包。 2、待发送数据大于 MSS（最大报文长度），TCP 在传输前将进行拆包。 3、要发送的数据小于 TCP 发送缓冲区的大小，TCP 将多次写入缓冲区的数据一次发送出去，将会发生粘包。 4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。</li><li>  解决方式 1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。 2、发送端将每个数据包封装为固定长度（不够的可以通过补 0 填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。 3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。</li></ul><h3 id="八、MQ-消息队列"><a href="#八、MQ-消息队列" class="headerlink" title="八、MQ 消息队列"></a>八、MQ 消息队列</h3><h4 id="1、场景作用"><a href="#1、场景作用" class="headerlink" title="1、场景作用"></a>1、场景作用</h4><p><strong>削峰填谷，异步解耦</strong>。</p><h4 id="2、如何保证消息不被重复消费呢？"><a href="#2、如何保证消息不被重复消费呢？" class="headerlink" title="2、如何保证消息不被重复消费呢？"></a>2、如何保证消息不被重复消费呢？</h4><p>这个问题可以换个思路，保证消息重复消费，其实是保证程序的幂等性。无论消息如何重复，程序运行的结果是一致的。比如消费消息后做数据库插入操作，为了防止消息重复消费，可以在插入前先查询一下有没有对应的数据。</p><h4 id="3、怎么保证从消息队列里拿到的数据按顺序执行？"><a href="#3、怎么保证从消息队列里拿到的数据按顺序执行？" class="headerlink" title="3、怎么保证从消息队列里拿到的数据按顺序执行？"></a>3、怎么保证从消息队列里拿到的数据按顺序执行？</h4><p>消费端在接收到消息后放入内存队列，然后对队列中的消息进行有序消费。</p><h4 id="4、如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"><a href="#4、如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？" class="headerlink" title="4、如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？"></a>4、如何解决消息队列的延时以及过期失效问题？消息队列满了以后该怎么处理？有几百万消息持续积压几小时，说说怎么解决？</h4><p>消息过期失效问题，如果消息一段时间不消费，导致过期失效了，消息就丢失了，只能重新查出丢失的消息，重新发送。 再来说消息积压的问题：（思路是快速消费掉积压的消息）</p><ul><li>  首先排查消费端问题，恢复消费端正常消费速度。</li><li>然后着手处理队列中的积压消息。<ul><li>  停掉现有的 consumer。</li><li>  新建一个 topic ，设置之前 10 倍的 partation，之前 10 倍的队列。</li><li>  写一个分发程序，将积压的消息均匀的轮询写入这些队列。</li><li>  然后临时用 10 倍的机器部署 consumer，每一批 consumer 消费 1 个临时的队列。</li><li>  消费完毕后，恢复原有架构。</li></ul></li></ul><p>消息队列满了：只能边接收边丢弃，然后重新补回丢失的消息，再做消费。</p><h4 id="4、如何保证消息的可靠性传输（如何处理消息丢失的问题）？"><a href="#4、如何保证消息的可靠性传输（如何处理消息丢失的问题）？" class="headerlink" title="4、如何保证消息的可靠性传输（如何处理消息丢失的问题）？"></a>4、如何保证消息的可靠性传输（如何处理消息丢失的问题）？</h4><p>kafka 为例：</p><ul><li>  消费者丢了数据： 每次消息消费后，由自动提交 offset 改为手动提交 offset 。</li><li>kafka 丢了消息： 比较常见的一个场景，就是 kafka 某个 broker 宕机，然后重新选举 partition 的 leader 时。要是此时其他的 follower 刚好还有些数据没有同步，结果此时 leader 挂了，然后大家选举某个 follower 成为 leader 之后，不就少了一些数据。<ul><li>  给 topic 设置<strong>replication.factor</strong>参数：这个值必须大于 1，要求每个 partition 必须有至少两个副本。</li><li>  在 kafka 服务端设置<strong>min.insync.replicas</strong>参数：这个值必须大于 1，这个是要求一个 leader 至少感知到有至少一个 follower 还跟自己保持联系，没掉队，这样才能确保 leader 挂了还有一个 follower。</li><li>  在 producer 端设置<strong>acks=all</strong>：这个是要求每条数据，必须是写入所有 replica 之后，才能认为是写成功了。</li><li>  在 producer 端设置<strong>retries=MAX</strong>（很大很大很大的一个值，无限次重试的意思）：这个是要求一旦写入失败，就无限重试，卡在这里。</li></ul></li><li>  生产者丢了消息： 如果按照上述的思路设置了 ack=all，一定不会丢，要求是，你的 leader 接收到消息，所有的 follower 都同步到了消息之后，才认为本次写成功了。如果没满足这个条件，生产者会自动不断的重试，重试无限次。</li></ul><h3 id="九、Redis"><a href="#九、Redis" class="headerlink" title="九、Redis"></a>九、Redis</h3><h4 id="1、数据类型"><a href="#1、数据类型" class="headerlink" title="1、数据类型"></a>1、数据类型</h4><ul><li>  String</li></ul><blockquote><p>常用命令： set,get,decr,incr,mget 等。</p></blockquote><ul><li>  Hash</li></ul><blockquote><p>常用命令： hget,hset,hgetall 等</p></blockquote><ul><li>  List</li></ul><blockquote><p>常用命令： lpush,rpush,lpop,rpop,lrange 等</p></blockquote><p>可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询。</p><ul><li>  Set</li></ul><blockquote><p>常用命令： sadd,spop,smembers,sunion 等</p></blockquote><ul><li>  Sort Set</li></ul><blockquote><p>常用命令： zadd,zrange,zrem,zcard 等</p></blockquote><h4 id="2、Redis-如何实现-key-的过期删除？"><a href="#2、Redis-如何实现-key-的过期删除？" class="headerlink" title="2、Redis 如何实现 key 的过期删除？"></a>2、Redis 如何实现 key 的过期删除？</h4><blockquote><p>定期删除和惰性删除的形式。</p></blockquote><ul><li>  定期删除 Redis 每隔一段时间从设置过期时间的 key 集合中，随机抽取一些 key ，检查是否过期，如果已经过期做删除处理。</li><li>  惰性删除 Redis 在 key 被访问的时候检查 key 是否过期，如果过期则删除。</li></ul><h4 id="3、Redis-的持久化机制"><a href="#3、Redis-的持久化机制" class="headerlink" title="3、Redis 的持久化机制"></a>3、Redis 的持久化机制</h4><blockquote><p>数据快照（RDB）+ 修改数据语句文件（AOF）</p></blockquote><h4 id="4、如何解决-Redis-缓存雪崩和缓存穿透？"><a href="#4、如何解决-Redis-缓存雪崩和缓存穿透？" class="headerlink" title="4、如何解决 Redis 缓存雪崩和缓存穿透？"></a>4、如何解决 Redis 缓存雪崩和缓存穿透？</h4><ul><li>缓存雪崩 缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。<ul><li>解决方式<ul><li>  事前：保证 Redis 集群的稳定性，发现机器宕机尽快补上，设置合适的内存淘汰策略。</li><li>  事中：本地缓存 + 限流降级，避免大量请求落在数据库上。</li><li>  事后：利用 Redis 持久化机制尽快恢复缓存。</li></ul></li></ul></li><li>缓存穿透 一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。<ul><li>  解决方式 将不存在的数据列举到一个足够大的 map 上，这样遭到攻击时，直接拦截 map 中的请求，请求到数据库上面。或是把不存在的也做缓存，值为 null ，设置过期时间。</li></ul></li></ul><h4 id="5、如何使用-Redis-实现消息队列？"><a href="#5、如何使用-Redis-实现消息队列？" class="headerlink" title="5、如何使用 Redis 实现消息队列？"></a>5、如何使用 Redis 实现消息队列？</h4><p>Redis 实现消息队列依赖于 Redis 集群的稳定性，通常不建议使用。</p><ul><li>  Redis 自带发布订阅功能，基于 publish 和 subscribe 命令。</li><li>  使用 List 存储消息，lpush，rpop 分别发送接收消息。</li></ul><h3 id="十、Nginx"><a href="#十、Nginx" class="headerlink" title="十、Nginx"></a>十、Nginx</h3><blockquote><p>Nginx 是一款轻量级的 Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器。 Nginx 主要提供反向代 理、负载均衡、动静分离(静态资源服务)等服务。</p></blockquote><h4 id="1、正向代理和反向代理"><a href="#1、正向代理和反向代理" class="headerlink" title="1、正向代理和反向代理"></a>1、正向代理和反向代理</h4><ul><li>  正向代理 代理客户端访问服务器。典型：VPN</li><li>  反向代理 代替服务器接收客户端请求，然后转发给服务器，服务器接收请求并将处理的结果通过代理服务器转发给客户端。</li></ul><h4 id="2、负载均衡"><a href="#2、负载均衡" class="headerlink" title="2、负载均衡"></a>2、负载均衡</h4><blockquote><p>将请求分摊到多台机器上去，高并发，增加吞吐量。</p></blockquote><ul><li>负载均衡算法<ul><li>  轮询</li><li>  随机</li><li>  源地址hash法</li><li>  加权轮询</li><li>  加权随机</li><li>  最小链接法</li></ul></li></ul><h4 id="3、动静分离"><a href="#3、动静分离" class="headerlink" title="3、动静分离"></a>3、动静分离</h4><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><h4 id="4、Nginx-四个组成部分"><a href="#4、Nginx-四个组成部分" class="headerlink" title="4、Nginx 四个组成部分"></a>4、Nginx 四个组成部分</h4><ul><li>  Nginx 二进制可执行文件：由各模块源码编译出一个文件</li><li>  Nginx.conf 配置文件：控制 Nginx 行为</li><li>  acess.log 访问日志： 记录每一条 HTTP 请求信息</li><li>  error.log 错误日志：定位问题</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 命令大全</title>
      <link href="/2021/04/26/git/Git_%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2021/04/26/git/Git_%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="git-config"><a href="#git-config" class="headerlink" title="git config"></a>git config</h2><p>配置 Git 的相关参数。</p><p>Git 一共有3个配置文件：</p><ul><li>1.<strong>仓库级</strong>的配置文件：在仓库的<code>.git/.gitconfig</code>,该配置文件只对所在的仓库有效。</li><li>2.<strong>全局级</strong>的配置文件：Mac系统在<code>~/.gitconfig</code>,Windows系统在<code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。</li><li>3.<strong>系统级</strong>的配置文件：在Git的安装目录下（Mac 系统下安装目录在<code>/usr/local/git</code>）的etc文件夹中的<code>gitconfig</code>。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看配置信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --<span class="built_in">local</span>：仓库级,--global：全局级,--system：系统级</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -l</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看当前生效的配置信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config -l</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 编辑配置文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --<span class="built_in">local</span>：仓库级,--global：全局级,--system：系统级</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -e</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加配置项</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> --<span class="built_in">local</span>：仓库级,--global：全局级,--system：系统级</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取配置项</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --get &lt;name&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除配置项</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --<span class="built_in">unset</span> &lt;name&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置提交记录中的用户信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.name <span class="string">&quot;&lt;用户名&gt;&quot;</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global user.email <span class="string">&quot;&lt;邮箱地址&gt;&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 更改Git缓存区的大小</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果提交的内容较大,默认缓存较小,提交会失败</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缓存大小单位：B,例如：524288000（500MB）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global http.postBuffer &lt;缓存大小&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global color.ui <span class="literal">true</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置可以缓存密码,默认缓存时间15分钟</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global credential.helper cache</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置密码的缓存时间</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 缓存时间单位：秒</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global credential.helper <span class="string">&#x27;cache --timeout=&lt;缓存时间&gt;&#x27;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置长期存储密码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git config --global credential.helper store</span></span><br></pre></td></tr></table></figure></li></ul><h2 id="git-clone"><a href="#git-clone" class="headerlink" title="git clone"></a>git clone</h2><p>从远程仓库克隆一个版本库到本地。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定本地仓库的目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -b 指定要克隆的分支,默认是master分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h2><p>初始化项目所在目录,初始化后会在当前目录下出现一个名为 .git 的目录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 初始化本地仓库,在当前目录下生成 .git 文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git init</span></span><br></pre></td></tr></table></figure><h2 id="git-status"><a href="#git-status" class="headerlink" title="git status"></a>git status</h2><p>查看本地仓库的状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看本地仓库的状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以简短模式查看本地仓库的状态</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输出中有两栏，左栏指明了暂存区的状态，右栏指明了工作区的状态。</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 文件状态：A 新增,M 修改,D 删除,?? 未添加到Git中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git status -s</span></span><br></pre></td></tr></table></figure><h2 id="git-remote"><a href="#git-remote" class="headerlink" title="git remote"></a>git remote</h2><p>操作远程库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出已经存在的远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出远程仓库的详细信息,在别名后面列出URL地址</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote -v</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote --verbose</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改远程仓库的别名</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定名称的远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote remove &lt;远程仓库的别名&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改远程仓库的 URL 地址</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示某个远程仓库的信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git remote show [remote]</span></span><br></pre></td></tr></table></figure><h2 id="git-branch"><a href="#git-branch" class="headerlink" title="git branch"></a>git branch</h2><p>操作 Git 的分支命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出本地的所有分支,当前所在分支以 <span class="string">&quot;*&quot;</span> 标出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出本地的所有分支并显示最后一次提交,当前所在分支以 <span class="string">&quot;*&quot;</span> 标出</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -v</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出所有本地分支和远程分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建新分支,新的分支基于上一次提交建立(新建一个分支，但依然停留在当前分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;分支名&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 新建一个分支，并切换到该分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;分支名&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建远程分支到本地</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git brabch -b &lt;分支名&gt; origin/&lt;分支名&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将当前分支绑定到远程origin/&lt;分支名&gt;分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -u origin/&lt;分支名&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改分支名称</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制修改分支名称(即使新分支已经存在)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;分支名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强制删除指定的本地分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D &lt;分支名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除远程仓库分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch origin :&lt;分支名&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin –delete &lt;branch-name&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看哪些分支已经合并到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --merged</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看哪些分支未合并到当前分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --no-merged</span></span><br></pre></td></tr></table></figure><h2 id="git-checkout"><a href="#git-checkout" class="headerlink" title="git checkout"></a>git checkout</h2><p>检出命令,用于创建、切换分支等。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 切换到已存在的指定分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;分支名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建并切换到指定的分支,保留所有的提交记录</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 等同于 <span class="string">&quot;git branch&quot;</span> 和 <span class="string">&quot;git checkout&quot;</span> 两个命令合并</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;分支名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建并切换到指定的分支,删除所有的提交记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout --orphan &lt;分支名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 替换掉本地的改动,新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;文件路径&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 抛弃所有的修改内容</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 请务必记得 git checkout -- &lt;file&gt; 是一个危险的命令。</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 你对那个文件在本地的任何修改都会消失——Git 会用最近提交的版本覆盖掉它。</span> </span><br><span class="line"><span class="meta">#</span><span class="bash"> 除非你确实清楚不想要对那个文件的本地修改了，否则请不要使用这个命令。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -- &lt;file&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-cherry-pick"><a href="#git-cherry-pick" class="headerlink" title="git cherry-pick"></a>git cherry-pick</h2><p>把已经提交的记录合并到当前分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把已经提交的记录合并到当前分支(选择一个commit，合并进当前分支)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git cherry-pick &lt;commit ID&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h2><p>把要提交的文件的信息添加到暂存区中。当使用<code>git commit</code>时,将依据暂存区中的内容来进行文件的提交。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把指定的文件添加到暂存区中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;文件路径&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定目录到暂存区，包括子目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;dir&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加指定文件到暂存区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add &lt;file1&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -u [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --update [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加所有修改、已删除、新增的文件到暂存区中,省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -A [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --all [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有修改、已删除但没有提交的文件,进入一个子命令系统</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add -i [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git add --interactive [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git add . 和 git add * 区别</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git add . 会把本地所有untrack的文件都加入暂存区，并且会根据.gitignore做过滤</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 但是git add * 会忽略.gitignore把任何文件都加入(实测并没有把.gitignore忽略的文件也加进去)</span></span><br></pre></td></tr></table></figure><h2 id="git-commit"><a href="#git-commit" class="headerlink" title="git commit"></a>git commit</h2><p>将暂存区中的文件提交到本地仓库中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 把暂存区中的文件提交到本地仓库,调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交暂存区的指定文件到本地仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit &lt;file1&gt; -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不包括未被版本库跟踪的文件,等同于先调用了<span class="string">&quot;git add -u&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过<span class="string">&quot;git add&quot;</span>步骤</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 提交工作区自上次commit之后的变化，直接到仓库区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit -a -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改最近一次提交。有时候如果提交注释书写有误或者漏提文件，可以使用此命令。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改上次提交的描述信息(使用一次新的commit，替代上一次提交)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git commit --amend -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span></span><br></pre></td></tr></table></figure><h2 id="git-fetch"><a href="#git-fetch" class="headerlink" title="git fetch"></a>git fetch</h2><p>从远程仓库获取最新的版本到本地的tmp分支上。<br>必须注意git fetch命令只会将数据下载到你的本地仓库——它并不会自动合并或修改你当前的工作。 当准备好时你必须手动将其合并入你的工作。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将远程仓库所有分支的最新版本全部取回到本地</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程仓库的别名&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将远程仓库指定分支的最新版本取回到本地</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-merge"><a href="#git-merge" class="headerlink" title="git merge"></a>git merge</h2><p>合并分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> merge之前先拉一下远程仓库最新代码</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch origin</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把指定的分支合并到当前所在的分支下</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge &lt;分支名&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> git一般使用<span class="string">&quot;Fast forward&quot;</span>模式，在这种模式下，删除分支后，会丢掉分支信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不使用Fast forward方式合并，采用这种方式合并可以看到合并记录(保留分支信息)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&#x27;&lt;合并描述&gt;&#x27;</span> &lt;分支名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-diff"><a href="#git-diff" class="headerlink" title="git diff"></a>git diff</h2><p>比较版本之间的差异。<br><img src="https://i.loli.net/2021/05/25/OzTHoBDVuQ8R5pY.png" alt="image.png"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 比较当前文件和暂存区中文件的差异,显示没有暂存起来的更改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff [fileName]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看与版本库区别</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD -- filename</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比较暂存区中的文件和上次提交时的差异(--staged和 --cached是同义词)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --cached</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff --staged</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比较当前文件和上次提交时的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff HEAD</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看从指定的版本之后改动的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 展示本地仓库中任意两个 commit 之间的文件变动</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff &lt;commit ID&gt; &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比较两个分支之间的差异</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff &lt;分支名称&gt; &lt;分支名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看两个分支分开后各自的改动内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-pull"><a href="#git-pull" class="headerlink" title="git pull"></a>git pull</h2><p>从远程仓库获取最新版本并合并到本地。<br>首先会执行 git fetch,然后执行 git merge,把获取的分支的 HEAD 合并到当前分支。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从远程仓库获取最新版本。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br></pre></td></tr></table></figure><h2 id="git-push"><a href="#git-push" class="headerlink" title="git push"></a>git push</h2><p>把本地仓库的提交推送到远程仓库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将本地分支的更新，推送到远程主机。强制推送 -f</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 上传本地指定分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin &lt;branch&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 强行推送当前分支到远程仓库，即使有冲突</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote&gt; –force</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 推送所有分支到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;remote&gt; –all</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 把本地仓库的分支推送到远程仓库的指定分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的远程仓库的分支</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-log"><a href="#git-log" class="headerlink" title="git log"></a>git log</h2><p>显示提交的记录。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 打印所有的提交记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看提交日志，单行显示</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=oneline</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单行显示，并缩短commit id</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --oneline</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示commit历史，以及每次commit发生变更的文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --<span class="built_in">stat</span></span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印从第一次提交到指定的提交的记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 打印指定数量的最新提交的记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -&lt;指定的数量&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示每一次diff</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> -p</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支合并图</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式化输出历史记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --pretty=format:<span class="string">&quot;%h %s&quot;</span></span> </span><br></pre></td></tr></table></figure><p>Git 用各种 placeholder 来决定各种显示内容，挑几个常用的显示如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%H: commit hash</span><br><span class="line">%h: 缩短的commit hash</span><br><span class="line">%T: tree hash</span><br><span class="line">%t: 缩短的 tree hash</span><br><span class="line">%P: parent hashes</span><br><span class="line">%p: 缩短的 parent hashes</span><br><span class="line">%an: 作者名字</span><br><span class="line">%aN: mailmap的作者名</span><br><span class="line">%ae: 作者邮箱</span><br><span class="line">%ad: 日期 (--date= 制定的格式)</span><br><span class="line">%ar: 日期, 相对格式(1 day ago)</span><br><span class="line">%cn: 提交者名字</span><br><span class="line">%ce: 提交者 email</span><br><span class="line">%cd: 提交日期 (--date= 制定的格式)</span><br><span class="line">%cr: 提交日期, 相对格式(1 day ago)</span><br><span class="line">%d: ref名称</span><br><span class="line">%s: commit信息标题</span><br><span class="line">%b: commit信息内容</span><br><span class="line">%n: 换行</span><br></pre></td></tr></table></figure><h3 id="统计代码"><a href="#统计代码" class="headerlink" title="统计代码"></a>统计代码</h3><h4 id="1、统计个人代码量-修改提交者姓名-："><a href="#1、统计个人代码量-修改提交者姓名-：" class="headerlink" title="1、统计个人代码量(修改提交者姓名)："></a>1、统计个人代码量(修改提交者姓名)：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author=&quot;lxy&quot; --pretty=tformat: --numstat | awk &#x27;&#123; add += $1; subs += $2; loc += $1 - $2 &#125; END &#123; printf &quot;added lines: %s, removed lines: %s, total lines: %s\n&quot;, add, subs, loc &#125;&#x27; -</span><br></pre></td></tr></table></figure><h4 id="2、贡献者数量统计："><a href="#2、贡献者数量统计：" class="headerlink" title="2、贡献者数量统计："></a>2、贡献者数量统计：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&#x27;%aN&#x27; | sort -u | wc -l</span><br></pre></td></tr></table></figure><h4 id="3、查看排名前-5-的贡献者："><a href="#3、查看排名前-5-的贡献者：" class="headerlink" title="3、查看排名前 5 的贡献者："></a>3、查看排名前 5 的贡献者：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --pretty=&#x27;%aN&#x27; | sort | uniq -c | sort -k1 -n -r | head -n 5</span><br></pre></td></tr></table></figure><h2 id="git-reflog"><a href="#git-reflog" class="headerlink" title="git reflog"></a>git reflog</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 获取执行过的命令</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reflog</span></span><br></pre></td></tr></table></figure><h2 id="git-reset"><a href="#git-reset" class="headerlink" title="git reset"></a>git reset</h2><p>reset命令把当前分支指向另一个位置，并且相应的变动工作区和暂存区。(还原提交记录)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将 HEAD 的指向改变,撤销到指定的提交记录,文件未修改</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相当于调用 <span class="string">&quot;git reset --mixed&quot;</span> 命令后又做了一次 <span class="string">&quot;git add&quot;</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 只改变提交点，暂存区和工作目录的内容都不改变</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --soft &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 改变提交点，同时改变暂存区的内容</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --mixed &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重置暂存区,但文件不受影响</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 相当于将用 <span class="string">&quot;git add&quot;</span> 命令更新到暂存区的内容撤出暂存区,可以指定文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有指定 commit ID 则默认为当前 HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -mixed 是不带参数时的默认参数</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --mixed [&lt;文件路径&gt;]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 HEAD 的指向改变,撤销到指定的提交记录,文件未修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --mixed &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回退到某个commit ID版本</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将 HEAD 的指向改变,撤销到指定的提交记录,文件也修改了</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 暂存区、工作区的内容都会被修改到与提交点完全一致的状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard &lt;commit ID&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 让工作区回到上次提交时的状态</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset –hard HEAD</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 回退到上一个版本（一个^退一个版本，多个可用 --hard HEAD~100）</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset --hard HEAD^</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 撤回暂存区的文件修改到工作区</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git reset HEAD file</span></span><br></pre></td></tr></table></figure><h2 id="git-revert"><a href="#git-revert" class="headerlink" title="git revert"></a>git revert</h2><p>生成一个新的提交来撤销某次提交,此次提交之前的所有提交都会被保留。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成一个新的提交来撤销某次提交</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git revert &lt;commit ID&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-tag"><a href="#git-tag" class="headerlink" title="git tag"></a>git tag</h2><p>操作标签的命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 列出所有标签列表</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加标签(默认对当前版本)</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;标签名称&gt;</span> </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 对某一提交记录打标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag &lt;标签名&gt; &lt;commit_id&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加带有描述信息的附注标签,可以指定之前的提交记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -a &lt;标签名称&gt; -m <span class="string">&quot;&lt;标签描述信息&gt;&quot;</span> [&lt;commit ID&gt;]</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到指定的标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;标签名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看标签的信息,输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git show &lt;标签名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除指定的本地标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git tag -d &lt;标签名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将指定的标签提交到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地所有的标签全部提交到远程仓库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push &lt;远程仓库的别名&gt; –-tags</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 从远程仓库中删除标签</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin :refs/tags/&lt;标签名&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-mv"><a href="#git-mv" class="headerlink" title="git mv"></a>git mv</h2><p>重命名文件或者文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 重命名指定的文件或者文件夹</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</span></span><br></pre></td></tr></table></figure><h2 id="git-rm"><a href="#git-rm" class="headerlink" title="git rm"></a>git rm</h2><p>删除文件或者文件夹。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 移除跟踪指定的文件,并从本地仓库的文件夹中删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm &lt;文件路径&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除跟踪指定的文件夹,并从本地仓库的文件夹中删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm -r &lt;文件夹路径&gt;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除跟踪指定的文件,在本地仓库的文件夹中保留该文件</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git rm --cached</span></span><br></pre></td></tr></table></figure><h2 id="git-stash"><a href="#git-stash" class="headerlink" title="git stash"></a>git stash</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 暂存当前修改</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复最近的一次暂存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash apply</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 恢复暂存并删除暂存记录</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash pop</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看暂存列表</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash list</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 移除某次暂存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash drop &lt;暂存名&gt;(例：stash@&#123;0&#125;)</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 清除暂存</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git stash clear</span></span><br></pre></td></tr></table></figure><h2 id="git-rebase"><a href="#git-rebase" class="headerlink" title="git rebase"></a>git rebase</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 分支开发规范</title>
      <link href="/2021/04/26/git/Git_%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
      <url>/2021/04/26/git/Git_%E5%88%86%E6%94%AF%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<h2 id="分支命名"><a href="#分支命名" class="headerlink" title="分支命名"></a>分支命名</h2><h3 id="1、master-分支"><a href="#1、master-分支" class="headerlink" title="1、master 分支"></a>1、master 分支</h3><p>master 为主分支，也是用于<strong>部署生产环境</strong>的分支，确保master分支稳定性， master 分支一般由develop以及hotfix分支合并，任何时间都不能直接修改代码。</p><h3 id="2、develop-分支"><a href="#2、develop-分支" class="headerlink" title="2、develop 分支"></a>2、develop 分支</h3><p>develop 为开发分支，始终保持<strong>最新完成</strong>以及<strong>bug修复后</strong>的代码，一般开发的新功能时，feature分支都是基于develop分支下创建的。</p><h4 id="feature-分支"><a href="#feature-分支" class="headerlink" title="feature 分支"></a>feature 分支</h4><p>开发新功能时，以develop为基础创建feature分支。</p><p>分支命名: <code>feature/</code>开头的为特性分支， 命名规则: <code>feature/user_module</code>、 <code>feature/cart_module</code></p><h4 id="release分支"><a href="#release分支" class="headerlink" title="release分支"></a>release分支</h4><p>release 为预上线分支，<strong>发布提测</strong>阶段，会release分支代码为基准提测。当有一组feature开发完成，首先会合并到develop分支，进入提测时会创建release分支。</p><p>如果测试过程中若存在bug需要修复，则直接由开发者在release分支修复并提交。当测试完成之后，合并release分支到master和develop分支，此时master为最新代码，用作上线。</p><h4 id="hotfix-bugfix-分支"><a href="#hotfix-bugfix-分支" class="headerlink" title="hotfix/bugfix 分支"></a>hotfix/bugfix 分支</h4><p>分支命名: <code>hotfix/</code>开头的为<strong>修复</strong>分支，它的命名规则与feature分支类似。线上出现紧急问题时，需要及时修复，以master分支为基线，创建hotfix分支，修复完成后，需要合并到master分支和develop分支</p><h2 id="常见任务"><a href="#常见任务" class="headerlink" title="常见任务"></a>常见任务</h2><h3 id="增加新功能–feature分支"><a href="#增加新功能–feature分支" class="headerlink" title="增加新功能–feature分支"></a>增加新功能–feature分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(dev)$: git checkout -b feature/xxx # 从dev建立特性分支</span><br><span class="line">(feature/xxx)$: blabla # 开发</span><br><span class="line">(feature/xxx)$: git add xxx</span><br><span class="line">(feature/xxx)$: git commit -m &#x27;commit comment&#x27;</span><br><span class="line">(dev)$: git merge feature/xxx --no-ff # 把特性分支合并到dev</span><br></pre></td></tr></table></figure><h3 id="修复紧急bug–hotfix分支"><a href="#修复紧急bug–hotfix分支" class="headerlink" title="修复紧急bug–hotfix分支"></a>修复紧急bug–hotfix分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(master)$: git checkout -b hotfix/xxx # 从master建立hotfix分支</span><br><span class="line">(hotfix/xxx)$: blabla # 开发</span><br><span class="line">(hotfix/xxx)$: git add xxx</span><br><span class="line">(hotfix/xxx)$: git commit -m &#x27;commit comment&#x27;</span><br><span class="line">(master)$: git merge hotfix/xxx --no-ff # 把hotfix分支合并到master，并上线到生产环境</span><br><span class="line">(dev)$: git merge hotfix/xxx --no-ff # 把hotfix分支合并到dev，同步代码</span><br></pre></td></tr></table></figure><h3 id="测试环境代码–release分支"><a href="#测试环境代码–release分支" class="headerlink" title="测试环境代码–release分支"></a>测试环境代码–release分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(release)$: git merge dev --no-ff # 把dev分支合并到release，然后在测试环境拉取并测试</span><br></pre></td></tr></table></figure><h3 id="生产环境上线–master分支"><a href="#生产环境上线–master分支" class="headerlink" title="生产环境上线–master分支"></a>生产环境上线–master分支</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(master)$: git merge release --no-ff # 把release测试好的代码合并到master，运维人员操作</span><br><span class="line">(master)$: git tag -a v0.1 -m &#x27;部署包版本名&#x27;  #给版本命名，打Tag</span><br></pre></td></tr></table></figure><p><img src="https://i.loli.net/2021/04/26/x2GzJjrFdD3AogN.png" alt="image.png"></p><h2 id="提交的日志规范"><a href="#提交的日志规范" class="headerlink" title="提交的日志规范"></a>提交的日志规范</h2><p>当前业界应用的比较广泛的是<code>Angular Git Commit Guidelines</code></p><h3 id="Commit-message-的具体格式"><a href="#Commit-message-的具体格式" class="headerlink" title="Commit message 的具体格式"></a>Commit message 的具体格式</h3><p>每次提交，Commit message 都包括三个部分：<code>header</code>，<code>body</code>和<code>footer</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;body&gt;</span><br><span class="line">// 空一行</span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中，<strong>header 是必需的</strong>，body 和 footer 可以省略。</p><p>不管是哪一个部分，任何一行都不得超过72个字符（或100个字符）。这是为了避免自动换行影响美观。</p><ul><li>type: 本次 commit 的类型，诸如 bugfix docs style 等</li><li>scope: 本次 commit 波及的范围</li><li>subject: 简明扼要的阐述下本次 commit 的主旨，在原文中特意强调了几点：<ul><li>使用祈使句，是不是很熟悉又陌生的一个词</li><li>首字母不要大写</li><li>结尾无需添加标点</li></ul></li><li>body: 同样使用祈使句，在主体内容中我们需要把本次 commit 详细的描述一下，比如此次变更的动机，如需换行，则使用 |</li><li>footer: 描述下与之关联的 issue 或 break change</li></ul><h3 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h3><p>Header部分只有一行，包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和<code>subject</code>（必需）。</p><h4 id="type的类别说明："><a href="#type的类别说明：" class="headerlink" title="type的类别说明："></a>type的类别说明：</h4><p><code>type</code>用于说明 commit 的类别，只允许使用下面7个标识。</p><ul><li>feat: 新功能（feature）</li><li>fix: 修复bug</li><li>docs: 仅仅修改了文档（documentation）</li><li>style: 仅仅修改了空格、格式缩进、逗号等等，不改变代码逻辑（不影响代码运行的变动）</li><li>refactor: 代码重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test: 增加测试用例</li><li>chore: 改变构建流程、或者增加依赖库、工具等<br>如果<code>type</code>为<code>feat</code>和<code>fix</code>，则该 commit 将肯定出现在 Change log 之中。其他情况（<code>docs</code>、<code>chore</code>、<code>style</code>、<code>refactor</code>、<code>test</code>）由你决定，要不要放入 Change log，建议是不要。</li></ul><h4 id="scope"><a href="#scope" class="headerlink" title="scope"></a>scope</h4><p><code>scope</code>用于说明 commit <strong>影响的范围</strong>，比如数据层、控制层、视图层等等，视项目不同而不同。</p><p>例如在Angular，可以是$location, $browser, $compile, $rootScope, ngHref, ngClick, ngView等。</p><p>如果你的修改影响了不止一个scope，你可以使用*代替。</p><h4 id="subject"><a href="#subject" class="headerlink" title="subject"></a>subject</h4><p>subject是 commit 目的的<strong>简短描述</strong>，不超过50个字符。</p><p>其他注意事项：</p><ul><li>以动词开头，使用第一人称现在时，比如<code>change</code>，而不是<code>changed</code>或<code>changes</code></li><li>第一个字母小写</li><li>结尾不加句号（<code>.</code>）</li></ul><h3 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h3><p>Body 部分是对本次 commit 的<strong>详细描述</strong>，可以分成多行。下面是一个范例。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">More detailed explanatory text, if necessary.  Wrap it to </span><br><span class="line">about 72 characters or so. </span><br><span class="line"></span><br><span class="line">Further paragraphs come after blank lines.</span><br><span class="line"></span><br><span class="line">- Bullet points are okay, too</span><br><span class="line">- Use a hanging indent</span><br></pre></td></tr></table></figure><p>有两个注意点:</p><ul><li>使用第一人称现在时，比如使用<code>change</code>而不是<code>changed</code>或<code>changes</code>。</li><li>永远别忘了第2行是空行</li><li>应该说明代码变动的动机，以及与以前行为的对比。</li></ul><h3 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h3><p>当前Project，Footer 部分只用于<strong>关闭issue</strong>或者<strong>关联issue</strong>。</p><p>如果当前 commit 针对某个issue，关闭或者关联这个 issue 。<br><code>Close/Relate #234</code><br>也可以一次关闭或者关联多个 issue 。<br><code>Close/Relate #123, #245, #992</code></p><h3 id="Revert"><a href="#Revert" class="headerlink" title="Revert"></a>Revert</h3><p>还有一种特殊情况，如果当前 commit 用于撤销以前的 commit，则必须以<code>revert:</code>开头，后面跟着被撤销 Commit 的 Header。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">revert: feat(pencil): add &#x27;graphiteWidth&#x27; option</span><br><span class="line"></span><br><span class="line">This reverts commit 667ecc1654a317a13331b17617d973392f415f02.</span><br></pre></td></tr></table></figure><p>Body部分的格式是固定的，必须写成<code>This reverts commit &lt;hash&gt;.</code>，其中的<code>hash</code>是被撤销 commit 的 SHA 标识符。</p><p>如果当前 commit 与被撤销的 commit，在同一个发布（release）里面，那么它们都不会出现在 Change log 里面。如果两者在不同的发布，那么当前 commit，会出现在 Change log 的Reverts小标题下面。</p><h3 id="Commit-message-的作用"><a href="#Commit-message-的作用" class="headerlink" title="Commit message 的作用"></a>Commit message 的作用</h3><p>格式化的Commit message，有几个好处。</p><h4 id="（1）提供更多的历史信息，方便快速浏览。"><a href="#（1）提供更多的历史信息，方便快速浏览。" class="headerlink" title="（1）提供更多的历史信息，方便快速浏览。"></a>（1）提供更多的历史信息，方便快速浏览。</h4><p>比如，下面的命令显示上次发布后的变动，每个commit占据一行。你只看行首，就知道某次 commit 的目的。<br><code>$ git log &lt;last tag&gt; HEAD --pretty=format:%s</code></p><h4 id="（2）可以过滤某些commit（比如文档改动），便于快速查找信息。"><a href="#（2）可以过滤某些commit（比如文档改动），便于快速查找信息。" class="headerlink" title="（2）可以过滤某些commit（比如文档改动），便于快速查找信息。"></a>（2）可以过滤某些commit（比如文档改动），便于快速查找信息。</h4><p>比如，下面的命令仅仅显示本次发布新增加的功能。<br><code>$ git log &lt;last release&gt; HEAD --grep feature</code></p><h4 id="（3）可以直接从commit生成Change-log。"><a href="#（3）可以直接从commit生成Change-log。" class="headerlink" title="（3）可以直接从commit生成Change log。"></a>（3）可以直接从commit生成Change log。</h4><p>Change Log 是发布新版本时，用来说明与上一个版本差异的文档。<br><img src="https://i.loli.net/2021/05/13/VDsdeOFY6xGa9PW.png" alt="image.png"></p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL基础教程</title>
      <link href="/2021/04/25/database/mysql%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2021/04/25/database/mysql%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><ul><li>什么是数据库？<ul><li>数据库(Database)是按照数据结构来组织、存储和管理数据的仓库。</li></ul></li><li>数据存储的几种方式：<ul><li>内存：效率高，但是数据会丢失。</li><li>硬盘：数据可以永久保存，但是读取效率非常低。</li><li>数据库：数据最终还是保存在硬盘，会通过SQL语句来读取或者操作数据。</li></ul></li><li>mysql(关系型数据库)<ul><li>什么是关系型数据库？<ul><li>建立在关系模型上的数据库系统。</li></ul></li><li>常用的关系型数据库<ul><li><strong>Oracle</strong>：甲骨文公司—专门的数据库厂商，oracle是收费，大型数据库，几乎可以用于任何系统任何平台。</li><li><strong>MySQL</strong>：早期开源免费数据库产品，被oralce收购，从6.0开始出现收费版本。LAMP组合Linux+Apache+MySQL+PHP完全开源免费，自从mysql被oracle收购后，从6.0开始出现收费版本。</li><li><strong>DB2</strong>：IBM数据库产品，大型收费数据库。 </li><li><strong>SYBASE</strong>：中等规模数据库，收费(很少用了)。SYBASE公司的另外一款产品，<strong>PowerDesigner</strong>—数据库建模工具。</li><li>*<em>SQL Server</em>：微软公司数据库产品(收费)中等规模数据库，操作系统要求是windows结合.net一起使用。</li><li>Java开发者主要使用MySQL、Oracle、DB2三种数据库。</li></ul></li></ul></li><li>Mysql安装</li></ul><ul><li><p>mysql的存储结构：</p><ul><li>当一台电脑安装了mysql数据库服务，就可以把这台电脑称之为<strong>数据库服务器</strong>。</li></ul></li><li><p>一个数据库服务器可以有多个数据库，一个数据库中可以有多个表(就是一个二维表)，一个表中可以有多条数据记录。</p><h2 id="SQL语言"><a href="#SQL语言" class="headerlink" title="SQL语言"></a>SQL语言</h2></li><li><p>概述：</p><ul><li>SQL是Structured Query Language(结构化查询语言)的缩写。</li><li>SQL是专为数据库而建立的操作命令集。</li><li>SQL功能强大、简单易学、使用方便，已经成为了数据库操作的基础，并且现在几乎所有的关系型数据库均支持SQL。</li></ul></li><li><p>特点：</p><ul><li>非过程性语言。一条语句一个结果。多条语句之间没有影响。(过程性语言：例如java)</li></ul></li><li><p>SQL是用来操作关系数据库的语言，具有查询、操纵、定义和控制关系型数据库的四方面功能：</p><ul><li><strong>DDL</strong>(数据定义语言-Data Definition Language)<ul><li>用来<strong>定义数据库的对象</strong>，如数据表、视图、索引等，数据库。</li><li>如：create drop alter truncate</li></ul></li><li><strong>DML</strong> (数据操作语言-Data Manipulation Language) <ul><li>操作在数据库表中的记录：修改，更新，删除。</li><li>如：update，insert，delete(不包含查询)</li></ul></li><li><strong>DCL</strong> (数据控制语言-Data Control Language) <ul><li>指用于<strong>设置用户权限</strong>和<strong>控制事务</strong>语句。</li><li>如：grant，revoke，begin transaction等</li></ul></li><li><strong>DQL</strong> (数据查询语言-Data Query Language)——不是标准 <ul><li>数据表记录的查询。</li><li>select</li></ul></li></ul></li><li><p>SQL能做些什么？</p><ul><li>操作数据<strong>库</strong></li><li>操作数据库中的<strong>表</strong></li><li>操作数据库中的表<strong>记录</strong><h2 id="数据库操作语句"><a href="#数据库操作语句" class="headerlink" title="数据库操作语句"></a>数据库操作语句</h2></li></ul></li><li><p>创建数据库：<code>create database 数据库名</code> (PS:数据库名称不要用中文)</p></li><li><p>查看数据库：<code>show databases;</code></p><ul><li><strong>information_schema</strong>数据库：其中保存着关于MySQL服务器所维护的所有其他数据库的信息。如数据库名，数据库的表，表栏的数据类型与访问权限等。</li><li><strong>performance_schema</strong>数据库：存储引擎,主要用于收集数据库服务器性能参数。</li><li><strong>mysql</strong>数据库：mysql库是系统库,里面保存有账户信息,权限信息,存储过程,event,时区等信息。</li><li><strong>test</strong>数据库：这个是安装时候创建的一个测试数据库，和它的名字一样，是一个完全的空数据库，没有任何表，可以删除。</li></ul></li><li><p>设置数据库编码表(了解即可)</p><ul><li>此时的db1数据库的编码格式 mysql的默认编码格式。(安装数据库时候指定的,UTF8)</li><li>设置数据库编码格式：<code>create database 数据库名 character  set ‘字符集’</code><br>创建数据库的同时指定字符集。</li><li>指定字符集是utf8,utf-8是错误的(mysql不认识UTF-8)。</li><li>查看数据库信息：<code>show create database  数据库名</code> </li></ul></li><li><p>设置数据库校对规则(了解即可)</p><ul><li><code>create database 数据库名 character set ‘字符集‘ collate ‘校对规则’</code></li><li>校对规则：数据内的比较方式。某一个字符的比较规则是有mysql已经设定好了。可以查看mysql的文档。确定某个字符集有那些比较规则。</li></ul></li><li><p>数据库的修改操作(了解即可)</p><ul><li>修改数据库，实际上是修改数据库的字符集。</li><li><code>alter database 数据库名 character  set  ‘字符集’</code></li><li>没有修改数据库名称的命令。</li></ul></li><li><p>删除数据库：<code>drop database 数据库名</code></p></li><li><p>切换到某一个数据库：<code>use 数据库名</code></p><ul><li>在操作某个数据库或者数据库中的表或者表中的数据库时，首先要切换到这个数据库。</li></ul></li><li><p>查看当前数据名：<code>select database()</code></p><ul><li>有时如果切换数据库多了，忘了在使用哪个数据库，可以使用查看语句(如果是’NULL’表示没选中数据库)。<h2 id="数据表结构的SQL语句"><a href="#数据表结构的SQL语句" class="headerlink" title="数据表结构的SQL语句"></a>数据表结构的SQL语句</h2></li></ul></li><li><p>建表语句：</p>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    列名 数据类型， <span class="comment">----某一列，存放的数据是什么类型</span></span><br><span class="line">    列名 数据类型，</span><br><span class="line">    ......</span><br><span class="line">    列名 数据类型 <span class="comment">---最后一个列不需要逗号。</span></span><br><span class="line">)；</span><br></pre></td></tr></table></figure><ul><li><p>数据类型：</p><ul><li><p>字符类型：</p><ul><li>varchar:长度可变   <ul><li>name varchar(20):设置name字段的长度为20,name的储存长度在20以内都可以，并且会自动适应长短。</li></ul></li><li>char:长度固定<ul><li>name char(20):设置name字段的长度为20，name的存储长度在20以内，如果不满20，用空格补足。</li></ul></li><li>char的性能好，varchar可以节省空间。通常时候，如果长度不固定，我们使用varchar。</li><li>使用char的情况：当某个字段的长度固定的时候，可以采用char。例如身份证号或者手机号。</li></ul></li><li><p>数值型：</p><ul><li><p>整形：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT</p><table><thead><tr><th>类型</th><th>字节</th><th>带符号(最小值~最大值)</th><th>不带符号(最小值~最大值)</th></tr></thead><tbody><tr><td>TINYINT</td><td>1</td><td>-128~127</td><td>0~255</td></tr><tr><td>SMALLINT</td><td>2</td><td>-32768~32767</td><td>0~65535</td></tr><tr><td>MEDIUMINT</td><td>3</td><td>-8388608~8388607</td><td>0~16777215</td></tr><tr><td>INT</td><td>4</td><td>-2147483648~2147483647</td><td>0~4294967295</td></tr><tr><td>BIGINT</td><td>8</td><td>-9223372036854775808~9223372036854775807</td><td>0~18446744073709551615</td></tr></tbody></table></li><li><p>小数：FLOAT(单精度)、DOUBLE(双精度)</p><ul><li>在定义类型的时候可以设置两个参数，如sal float(5,2)：sal字段总共5位长度，可以有两位小数,如果 插入12345或者1234，默认为999.99，因为要保证小数点前三位和小数点后两位的格式。</li></ul></li></ul></li><li><p>位数据类型 –了解</p><ul><li>BIT： 1或者0组成的数据<ul><li>其数据有两种取值：0和1，长度为1位。在输入0以外的其他值时，系统均把它们当1看待。这种数据类型常作为逻辑变量使用，用来表示真、假或是、否等。</li></ul></li></ul></li><li><p>日期型</p><ul><li>date ：日期—-只有日期，年月日“yyyy-MM-dd”</li><li>time：时间—–时分秒,”HH:mm:ss”</li><li>dateTime：日期和时间都包含,“yyyy-MM-dd HH:mm:ss”</li><li>timestamp：日期和时间都包含,“yyyy-MM-dd HH:mm:ss” <ul><li>当其他数据发生改变的时候，这个字段会自己修改为当前时间。</li></ul></li></ul></li><li><p>大数据类型–了解</p><ul><li>BLOB-字节：存放二进制内容，一般可以存放视频、音频、图片等。<ul><li>tinyblob：255字节</li><li>blob：64KB</li><li>mediumblob：16MB</li><li>longblob：4GB</li></ul></li><li>TEXT-字符：存放大文本，存放txt。<ul><li>tinytext：255字节 </li><li>text：64KB </li><li>mediumtext：16MB  </li><li>longtext：4GB</li></ul></li><li>通常我们不会把文件存储到数据库。(占用资源，操作速度慢)</li><li>我们会把文件的路径(通常存放在本地磁盘)存到数据库中。</li></ul></li></ul></li></ul></li><li><p>查看表</p><ul><li><code>show tables</code>: 查看该数据库的所有的表</li><li><code>show create table 表名</code>：查看<strong>建表语句</strong>以及字符集</li><li><code>desc 表名</code>：查看表的列的信息(<strong>查看表结构</strong>)</li></ul></li><li><p>约束</p><ul><li>概述：<ul><li><strong>约束</strong>：规定，限制。</li><li>限制表中列的内容。需要满足一定的规则。</li><li>数据库中的约束：限制列的内容。</li><li>作用(目的)：保证数据的有效性和<strong>完整性</strong>。</li></ul></li><li>**主键约束(PK primary key)**：<ul><li>作用：设置某一个字段为主键，主键的特性是<strong>唯一</strong>(不能重复)，并且不能为空。</li><li>一般使用一个没有任何意义的字段，比如id作为一个主键(没有意义就不需要修改)。</li><li>如果主键是一个int类型，还可以设置主键自增长。(即在插入记录的时候可以不用设置主键，让其自动以递增的形式添加)</li><li>一张表中<strong>只能有一个</strong>主键。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li><li><strong>唯一约束(unique)</strong><ul><li>内容不允许重复，可以为null(null不算重复)。 </li><li>一个表里可以添加**多个((唯一约束。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名 (</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span>,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li>唯一约束和主键约束的区别:<ul><li>唯一约束可以是空(null)。 但是主键约束不能为空</li><li>一张表中只能有一个主键，但是唯一约束可以有多个</li></ul></li></ul></li><li><strong>非空约束(not null)</strong><ul><li>不允许为空。 表示该列的内容不允许为空。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 表名(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>) <span class="keyword">unique</span>,</span><br><span class="line">    age <span class="type">int</span> <span class="keyword">not</span> <span class="keyword">null</span>,</span><br><span class="line">    ...</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>数据表结构的修改</p><ul><li>增加列：<code>alter table 表名 add 列名 类型(长度) 约束;</code></li><li>添加主键：<code>alter table 表名 add primary key (列名);</code>–几乎不用,主键一般都是在建表的时候直接设置。</li><li>修改现有列的类型或者长度：<code>alter table 表名 modify 列名 类型(长度);</code>–注意：通常我们不会修改列的类型。</li><li>修改现有列的名称：<code>alter table 表名 change 旧列名 新列名 类型(长度);</code>–注意：通常我们不会修改列的名称。</li><li>删除一个现有列：<code>alter table 表名 drop 列名;</code>–注意：通常我们不会删除列。</li><li>修改表名：<code>rename table 旧表名 to 新表名;</code>–注意：通常我们不会重命名数据库表名。</li><li>修改表的字符集–表的字符集：在创建数据库时默认和数据库一致。通常不会去修改，使其与数据库的编码集相同。<ul><li>查看表的字符集：<code>show create table 表名;</code></li><li>修改表的字符集：<code>alter table 表名 character set 字符集</code></li></ul></li></ul></li><li><p>数据表的删除：<code>drop table 表名;</code> </p><h2 id="数据记录的增删查改-重点"><a href="#数据记录的增删查改-重点" class="headerlink" title="数据记录的增删查改(重点)"></a>数据记录的增删查改(重点)</h2></li><li><p>概述：</p><ul><li>在java代码中对数据库操作最频繁的就是对表中数据的<strong>CRUD</strong>操作：create read update delete</li><li>数据记录存储位置：表。</li></ul></li><li><p><strong>增</strong>–增加数据记录:insert语句</p><ul><li>方式一：<strong>全写</strong><ul><li><code>insert into 表名(列名1,列名2,列名3...)values(值1,值2,值3...);</code></li><li>注意事项：<ul><li>值与列一一对应。有多少个列，就需要写多少个值。如果某一个列没有值。可以使用null。表示插入空。</li><li>值的数据类型，与列被定义的数据类型要相匹配。并且值的长度不能够超过定义的列长度。</li><li>字符串：插入字符类型的数据，必须写单引号。在mysql中，使用单引号表示字符串。</li><li>date:时间类型的数据可以直接使用单引号表示：’yyyyMMdd’,’yyyy-MM-dd’,’yyyy/MM/dd’。</li></ul></li></ul></li><li>方式二：<strong>省略部分列</strong><ul><li><code>insert into 表名(列名1,列名3,列名5...)values(值1,值3,值5...);</code></li><li>注意事项：<ul><li>可以省略部分列名。某一列有默认值，或者允许为空，才可以省略。</li><li>主键是自增长的认为是有默认值的。也可以省略</li></ul></li></ul></li><li>方式三：<strong>省略所有的列</strong><ul><li><code>insert into 表名 values(值,值,值,值);</code></li><li>注意事项：<ul><li>表中有多少列，就有多个值。</li><li>按照表的结构，列和值去对应。通过<code>desc 表名</code>得到列的顺序。从上到下，对应的值，从左到右</li></ul></li></ul></li></ul></li><li><p><strong>改</strong>–修改数据记录：update语句</p><ul><li><code>update 表名 set 列名=值,列名=值...where 条件;</code></li><li>条件：将满足指定条件的某一行进行修改。</li><li>注意事项：<ul><li>如果没有where条件，则会把表中的所有行的对应的列全部修改。</li><li>如果有条件，则只有满足条件的数据才会被修改。</li></ul></li></ul></li><li><p><strong>删</strong>–删除数据：delete&amp;truncate语句</p><ul><li>delete语句：<ul><li><code>delete from 表名 where 条件;</code></li><li>删除满足条件的行的数据。delete是<strong>删除行的数据</strong>。</li><li>注意：如果没有where条件，则删除表中的所有记录。</li></ul></li><li>truncate语句：<ul><li><code>truncate table 表名;</code>—删除表的所有记录</li><li>先删除表,再创建表，就等于将数据全部删除了。</li><li>性能问题：truncate table的性能更好</li></ul></li><li>如果使用delete删除表中所有记录和使用truncate table删除表中所有记录有何不同 ？<ul><li>删除过程不同:<ul><li>truncate删除数据，过程先将整个表删除，再重新创建 </li><li>delete删除数据，逐行删除记录 </li><li>truncate效率要好于delete </li></ul></li><li>语言定义不同:truncate属于DDL，delete属于DML。</li></ul></li><li><strong>事务管理</strong>只能对**DML(数据操作语言)**有效，被事务管理的SQL语句可以回滚到SQL执行前状态。<ul><li><strong>事务</strong>：逻辑上的一组(一条或者多条sql语句)操作。这组sql语句，要么都成功，要么都失败。</li><li><code>start transaction;</code>–开启事务</li><li>失败：<code>rollback;</code> 事务的回滚–事务的结束，把修改的内容恢复到之前的状态。</li><li>成功：<code>commit;</code> 提交–事务的结束。把修改的内容进行永久保存。</li></ul></li></ul></li></ul><ul><li><strong>查</strong>(重点)–查询数据：select语句<ul><li>查询所有信息：<code>select * from 表名;</code>–会把表的所有的列，所有的行都列出来。</li><li>查询指定列的信息：<code>select 列名,列名,列名 from 表名;</code>–显示指定列数据,列出所有行信息。</li><li>查询符合条件的信息：<code>select * from 表名 where 条件;</code>–只有符合条件的，才去列出相应的信息。</li><li>运算符:<ul><li>比较运算符:<ul><li>&gt;  &lt;  &lt;=  &gt;=  =  &lt;&gt;:大于、小于、小于/大于等于、不等于。</li><li>between 1 and 10:显示某一区间的值–[1,10]。</li><li>in(1,2,3):显示在in列表中的值–1、2、3任意一个。</li><li>Like ‘张_’:模糊查询–’_’表示一个字符。</li><li>Like ‘张%’:模糊查询–’%’表示零或任意多个字符。</li><li>is null、is not null:是否为空</li></ul></li><li>逻辑运算符:<ul><li>and:多个条件同时成立</li><li>or:多个条件任意一个成立</li><li>not:不成立，例如：where not(age&gt;18)</li></ul></li></ul></li><li>去重(滤重)<ul><li><code>select distinct 列名,列名,列名 from 表名;</code>–显示distinct后面列的内容，并且去重。</li></ul></li><li>别名<ul><li><code>select 列名 as 别名 from 表名;</code></li><li><code>select 列名 别名 from 表名;</code>–as也可以省略</li></ul></li><li>列运算<ul><li>可以为列或者列进行运算后的结果起一个别名。</li><li>在select语句中可使用表达式对查询的列进行运算</li><li><code>select 列名+-*/列名,列名+-*/ 列名 from 表名;</code>–如果是多个运算使用逗号隔开。</li><li>注意：<ul><li>数据库表中的原始数据不会改变。</li><li>(需要重点注意的)：如果使用null来进行表达式运算，那么计算的结果也会是null。如：a=null,b=10那么a+b=null。</li></ul></li><li>mysql提供了一个函数：<code>ifnull(列名,默认值)</code> –判断该列是否为null,如果为null，返回默认值，如果不为null，返回实际的值</li></ul></li><li>排序：<code>order by</code><ul><li>统计的时候使用。</li><li><code>select * from 表名 order by 列名1(desc|asc),列名2(desc|asc),列名3(desc|asc)...</code>–按照列名1，列名2，列名3进行排序输出。</li><li>注意：<ul><li>select语句关键字的顺序:select..from..where..order by..</li><li>按照第一列进行排序，如果第一列相同，按照第二列再进行排序。</li><li>desc：表示的降序</li><li>asc：表示的升序</li><li>默认是asc升序。</li></ul></li></ul></li><li>聚合函数<ul><li>多个数据进行运算，运算出一个结果。例如，求和，平均值，最大值，最小值。</li><li>作用(目的)：用于统计使用。</li><li>count(数目)–统计记录数(统计行数)<ul><li><code>select count(列名) from 表名 where 条件;</code>:统计该列有多少行。如果该列中有值为null的行，该行不做统计。</li><li><code>select count(*) from 表名 where 条件;</code>: 统计表中的行数。</li></ul></li><li>sum(和)–求和<ul><li><code>select sum(列名) from 表名 where 条件;</code>–统计该列的所有的值的和。sum 也可排除null</li><li>sum仅对数值类型的列起作用，否则会报错。</li></ul></li><li>avg(均值)–平均值<ul><li><code>select avg(列名) from 表名 where 条件;</code>–求该列的平均值,avg里面的null不作为统计</li><li>注意：如果有null值则会导致求平均值不正确，建议添加<code>ifnull(列名,默认值);</code>函数，即<code>select avg(ifnull(列名,默认值)) from 表名 where 条件;</code>。</li><li>不能和sum一起使用,并且要对每一列先进行ifnull的判断</li></ul></li><li>max(最大值)/min(最小值)–统计该列的最大值或者最小值<ul><li><code>select max(列名),min(列名) from 表名;</code></li><li>null 排除在外。</li><li>不能和sum一起使用</li></ul></li></ul></li><li>分组查询：group by<ul><li>按照某一列或者某几列。把相同的数据，进行合并输出。</li><li><code>select ... from ... group by 列名,列名;</code></li><li>目的：仍然是统计使用。</li><li>其实就是按列进行分类，然后可以对分类完的数据使用聚集函数进行运算。</li><li>注意：聚集函数在分组之后进行计算。</li><li>通常select的内容，被分组的列，以及聚集函数。</li><li>如果分组之后，需要一些条件。则使用<strong>having</strong>条件，表示分组之后的条件。可以书写聚合函数。<ul><li><code>group by 列名 having 条件;</code>–分组之后加过滤条件。</li><li>where和having的区别：<ul><li>having通常与group by分组结合使用；where和分组无关。</li><li>where后面的条件可以写在having中，但是having中的条件不一定能写在where中。</li><li>having可以书写聚合函数 (聚合函数出现的位置： select之后，having之后)，例如having中的聚合函数(count，sum，avg，max，min)，是不可以出现where条件中的。</li><li>where是在分组<strong>之前</strong>进行过滤的。having是在分组<strong>之后</strong>进行过滤的。</li><li><code>select ... from ... where 条件1 ... gropu by ... having 条件2;</code>–条件1 会先执行过滤,然后进行分组，然后条件2再进行过滤。</li></ul></li></ul></li></ul></li><li>总结：<ul><li>查询关键字的出现的顺序是固定的：<ul><li><code>select 要显示的内容 from 表名 where 条件 group by 分组的列 having 分组后的条件 order by 排序</code></li></ul></li><li>查询的执行顺序：<ul><li><code>select 5 from 1 where 2 group by 3 having 4 order by 6</code><h2 id="数据库的备份和恢复"><a href="#数据库的备份和恢复" class="headerlink" title="数据库的备份和恢复"></a>数据库的备份和恢复</h2></li></ul></li></ul></li></ul></li><li>备份：把数据库里面的内容进行备份放到硬盘或者其他位置。如果数据库出现问题之后，可以进行数据的恢复。</li><li>数据库备份<ul><li>将某个数据库备份到指定的路径进行保存:<code>mysqldump -u 用户名 -p 数据库名 &gt; 备份文件的路径和名称</code></li></ul></li><li>数据库恢复<ul><li>方式一:<ul><li>步骤一：创建数据库<ul><li>注意：备份的时候，没有备份创建数据库的语句。当需要恢复某个具体的数据库时候，需要手动的创建数据库。</li><li>手动创建数据库<code>create database 数据库名;</code>,并切换到该数据库<code>use 数据库名;</code></li></ul></li><li>步骤二：导入数据<ul><li><code>source 备份文件的路径和名称;</code></li></ul></li></ul></li><li>方式二：<ul><li>步骤一：创建数据库<ul><li>注意：备份的时候，没有备份创建数据库的语句。当需要恢复某个具体的数据库时候，需要手动的创建数据库。</li><li>手动创建数据库<code>create database 数据库名;</code>。</li></ul></li><li>步骤二：导入数据<ul><li><code>mysql –u 用户名 -p 数据库名 &lt; 备份文件的路径和名称</code> </li><li>注意：在命令行下使用，不是登录mysql后使用，和备份比较类似，只不过mysql后面不带dump，并且箭头是&lt;,指向需要导入数据的新的数据库。</li><li>这种恢复的方式，也需要数据库提前存在。<h2 id="多表设计"><a href="#多表设计" class="headerlink" title="多表设计"></a>多表设计</h2></li></ul></li></ul></li></ul></li><li>表与表之间可以总结出如下关系：<ul><li>1：1(一对一)<ul><li>单表，一方设置外键即可。</li></ul></li><li>1：N(一对多)<ul><li>主从表，从表设置外键。</li></ul></li><li>M：N(多对多)<ul><li>一般添加第三张关系表。</li></ul></li></ul></li><li>外键约束(FK Foreign Key)<ul><li>主表： 被引用字段的那个表—（一方）</li><li>从表： 引入字段的表 — (多方)</li><li>建表之后添加外键约束:<ul><li><code>alter table 从表名称 add foreign key (外键列的名称) references 主表名称(主键)</code></li></ul></li><li>建表的时候添加外键约束:  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> 从表(</span><br><span class="line">    id <span class="type">int</span> <span class="keyword">primary</span> key auto_increment,</span><br><span class="line">    name <span class="type">varchar</span>(<span class="number">20</span>),</span><br><span class="line">    age <span class="type">int</span>,</span><br><span class="line">    salary <span class="keyword">double</span>,</span><br><span class="line">    dept_id <span class="type">int</span>,</span><br><span class="line">    <span class="keyword">foreign</span> key (dept_id) <span class="keyword">references</span> 主表(id)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>注意：在建表时，必须先创建主表，再创建从表，因为在从表中设置外键约束时引用了主表中的主键，如果主表都还没创建的话，结果肯定是外键约束添加失败。</li></ul></li></ul></li></ul><h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><ul><li>在实际的工作中，我们所需要的数据，通常会来自多张表。那么就涉及到多表关联查询的问题。也就是指，如何使用sql语句一次性查询多张表的数据。</li><li><strong>笛卡尔积</strong><ul><li>需求：查询两张表中关于水果的信息，要显示水果名称和水果价格。</li><li>多表查询语法：<code>select * from a,b;</code></li><li>问题分析：<ul><li>这样查询得到的结果存在冗余，变成了排列组合，即a表中的每一条记录，都和b表中的每一条进行匹配连接。所得到的最终结果是，a表中的条目数乘以b表中的数据的条目数。</li><li>解决方案：在查询两张表的同时添加条件进行过滤，比如a表的id和必须和b表的id相同：<code>select * from a,b where a.id=b.id;</code></li></ul></li></ul></li><li><strong>内连接</strong>查询：<ul><li><strong>隐式内连接</strong>查询：<code>select * from a,b where a.列名 = b.列名;</code>–在产生两张表的笛卡尔积的数据后，通过条件筛选出正确的结果。</li><li><strong>显式内连接</strong>查询：<code>select * from a inner join b on a.id = b.id where 其他条件;</code>–查询到的数据为两个表经过ON条件过滤后的笛卡尔积然后在通过where条件进行筛选,<strong>inner可以省略</strong></li></ul></li><li><strong>外连接</strong>查询：<ul><li><strong>左外连接</strong>查询：<code>select * from a left outer join b on a.id = b.id;</code><ul><li>查询的内容，以关键字左侧数据为主。不管右侧的数据是否有对应，都把左侧的数据显示出来</li><li>把left关键字之前的表，是定义为左侧。left关键字之后的表，定义右侧。</li><li><strong>outer可以省略</strong></li></ul></li><li><strong>右外连接</strong>查询：<code>select * from a right outer join b on a.id = b.id;</code><ul><li>查询的内容，以关键字右侧数据为主，不管左侧有没有数据对应。都把右侧的数据进行显示。</li><li>right之前的是左侧，right之后的是右侧。</li><li><strong>outer可以省略</strong></li></ul></li><li><strong>全外连接</strong>查询：<code>select * from a full outer join b on a.id = b.id;</code> <ul><li>查询的内容，就是左外连接和右外连接之和，将左右两表中的数据全部显示出来</li><li><strong>mysql不支持全外连接。</strong><ul><li>可以使用<strong>union</strong>来达到全外连接的查询效果。</li><li><strong>union</strong> ：可以将左外连接查询和右外连接查询两条sql语句使用union合并起来进行查询，去掉重复的数据。</li><li><code>select * from a left outer join b on a.id = b.id union select * from a right outer join b on a.id = b.id;</code></li><li><strong>union all</strong>:不去掉重复进行合并,相当于查询一次左外连接，然后再查询一次右外连接，然后将两次的查询结果合并。</li></ul></li></ul></li></ul></li><li>多表查询总结：<br>  <img src="https://i.loli.net/2021/04/25/lQnyRO96tFPXI3c.png" alt="多表查询总结图.png"><ul><li>内连接：<ul><li>隐式内连接<ul><li><code>select * from a,b where a.id = b.id;</code></li><li>结果：C</li></ul></li><li>显式内连接：<ul><li><code>select * from a inner join b on a.id = b.id;</code></li><li>结果：C</li></ul></li></ul></li><li>外连接：<ul><li>左外连接<ul><li><code>select * from a left outer join b on a.id = b.id</code></li><li>结果：A+C</li></ul></li><li>右外连接<ul><li><code>select * from a right outer join b on a.id = b.id</code></li><li>结果：B+C</li></ul></li><li>union:相当于全外连接  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id <span class="operator">=</span> b.id</span><br><span class="line"><span class="keyword">union</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure><ul><li>结果：A+B+C,会自动虑重<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">left</span> <span class="keyword">outer</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id <span class="operator">=</span> b.id</span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> a <span class="keyword">right</span> <span class="keyword">outer</span> <span class="keyword">join</span> b <span class="keyword">on</span> a.id <span class="operator">=</span> b.id</span><br></pre></td></tr></table></figure></li><li>结果：A+B+C,有重复数据 </li></ul></li></ul></li></ul></li><li>关联子查询：将一个查询作为另一个查询的一部分。<ul><li>子查询：<code>select * from student where age=(select max(age) from student);</code></li><li>in的用法：in (20,30)：表示条件是20或者30，类似于添加条件<code>select * from student where age = 20 or age = 30;</code><ul><li><code>select * from student where id in (select student_id from student_course where score&lt;60);</code></li></ul></li><li>exists的用法：(了解)<ul><li>exists的意思是表示存在,如果子查询有返回数据行，就认为是true，否则就认为是false，关注的是子查询<strong>是否有数据</strong>。只要有数据就认为匹配成功</li><li><code>select * from 表名 where exists (select ... from 表名 where 条件);</code> –将外表中的查询结果拿到内表中去逐行判断条件是否成立，如果成立，取出该行结果,如果不成立，则丢弃改行数据。</li></ul></li><li>in在外表大而内表小的情况下效率高,exist在外表小而内表大的情况下效率高</li><li>all的用法-了解<ul><li>all：表示所有，和union一起使用。</li><li>左连接和右连接查询结果的合集。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> iphone_memory <span class="keyword">left</span> <span class="keyword">join</span> iphone_color <span class="keyword">on</span> iphone_memory.id <span class="operator">=</span> iphone_color.id </span><br><span class="line"><span class="keyword">union</span> <span class="keyword">all</span></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> iphone_memory <span class="keyword">right</span> <span class="keyword">join</span> iphone_color <span class="keyword">on</span> iphone_memory.memory <span class="operator">=</span> iphone_color.color;</span><br></pre></td></tr></table></figure></li><li>a&gt;all(1,2,3,4) 相当于a&gt;1 and a&gt;2 and a&gt;3 and a&gt;4 或者相当于 a&gt;max(1,2,3,4);</li></ul></li><li>any和some以及as的用法:<ul><li>any:表示任何一个</li><li>a&gt;any(1,3,5,6) 相当于a&gt;1相当于a&gt;min(1,3,5,6);</li><li>a=any(1,3,5,6) 相当于 a in(1,3,5,6) 或者 a=1 or a=3 or a=5 or a=6。</li><li>注意：any的后面需要跟语句，不能直接放值。</li><li>some：表示任何一个和any的作用相同。</li><li>as:不仅可以用来做表的别名，还可以将查询结果通过as作为一张表来使用。<h2 id="mysql自带函数"><a href="#mysql自带函数" class="headerlink" title="mysql自带函数"></a>mysql自带函数</h2>字符串相关函数:<br><img src="https://i.loli.net/2021/04/25/z3Z8qSd9vtfUGMQ.png" alt="mysql自带函数-字符串相关函数.png"><br>数学相关函数:<br><img src="https://i.loli.net/2021/04/25/OFzUN3pW1dQrP9Y.png" alt="mysql自带函数-数学相关函数.png"><br>日期相关函数:<br><img src="https://i.loli.net/2021/04/25/nRTrtUXgFVYjxS9.png" alt="mysql自带函数-日期相关函数.png"><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2></li></ul></li></ul></li><li>创建用户<ul><li>语法：<code>create user &#39;用户名&#39;@&#39;host&#39; identified by &#39;密码&#39;;</code></li><li>上述sql语句中的’host’可以有如下三种设置方式：<ul><li>1、localhost:本机连接，并且主机地址只能填写localhost</li><li>2、ip地址：指定一个ip来连接数据库</li><li>3、%：本机和远程ip都可以连接数据库</li></ul></li></ul></li><li>修改用户的密码<ul><li>1、切换数据库:<code>use lxy;</code></li><li>2、修改密码:<code>update user set password=password(&#39;123&#39;) where user=&#39;zhangsan&#39;;</code></li><li>3、使操作生效:<code>flush privileges;</code></li><li>注意：设置密码时必须加密，更改密码后需用flush privileges刷新MySQL的系统权限相关表</li></ul></li><li>删除用户<ul><li>语法：<code>drop user &#39;用户名&#39;@&#39;host&#39;;</code></li></ul></li><li>用户授权<ul><li>语法：<code>grant privileges on 数据库名.表名 to &#39;用户名&#39;@&#39;hoost&#39;;</code><ul><li>priveleges(权限列表):可以是all priveleges, 表示所有权限，也可以是select、update等权限，多个权限的名词,相互之间用逗号分开。</li><li>on:用来指定权限针对哪些库和表。</li><li><em>.</em>:前面的*号用来指定数据库名，后面的*号用来指定表名,*可表示全部。</li></ul></li></ul></li><li>查看用户权限<ul><li>查看当前用户（自己）权限：<code>show grants;</code></li><li>查看其他MySQL用户权限：<code>show grants for &#39;zhangsan&#39;@&#39;%&#39;;</code></li></ul></li><li>撤销用户的权限<ul><li>语法：<code>revoke privileges on 数据库.表 from &#39;用户名&#39;@&#39;host&#39;;</code><ul><li>priveleges(权限列表):可以是all priveleges, 表示所有权限，也可以是select、update等权限，多个权限的名词,相互之间用逗号分开。</li></ul></li></ul></li><li>grant和revoke用户权限的注意事项:<ul><li><ol><li>grant, revoke用户权限后，该用户只有重新连接MySQL数据库，权限才能生效。</li></ol></li><li><ol start="2"><li>如果想让授权的用户，也可以将这些权限grant给其他用户，需要选项 “grant option“</li></ol><ul><li><code>grant select on testdb.* to dba@localhost with grant option;</code></li><li>这个特性一般用不到。实际中，数据库权限最好由DBA来统一管理。</li></ul></li><li>注意：用户本身有多少权限就能赋予别人多少权限，如果一个用户a只有查询权限，那么就只能赋予其他人查询权限，不能赋予删除等权限。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JDBC基础教程</title>
      <link href="/2021/04/25/Java/Jdbc%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/"/>
      <url>/2021/04/25/Java/Jdbc%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><h3 id="JDBC介绍"><a href="#JDBC介绍" class="headerlink" title="JDBC介绍"></a>JDBC介绍</h3><ul><li>JDBC全称为：Java DataBase Connectivity（java数据库连接）。 </li><li>SUN公司为了简化、统一对数据库的操作，定义了一套Java操作数据库的规范，称之为JDBC。</li><li>没有jdbc之前：<br><img src="https://i.loli.net/2021/04/25/iugV6ZypDmcro31.png" alt="没有JDBC之前.png"></li><li>有了jdbc之后:<br><img src="https://i.loli.net/2021/04/25/9QhsPSTWUz4X1I6.png" alt="有了jdbc之后.png"><h3 id="JDBC-API常用类与接口"><a href="#JDBC-API常用类与接口" class="headerlink" title="JDBC API常用类与接口"></a>JDBC API常用类与接口</h3></li><li>Jdbc操作的相关api如下：<ul><li><strong>DriverManger</strong>:数据区驱动类,不同的数据库有不同的数据库驱动,是各数据库厂商对sun公司接口规范的实现。</li><li><strong>Connection</strong>:数据库连接，建立一个操作数据库的连接。</li><li><strong>Statement</strong>:数据库操作，向数据库发送sql语句.</li><li><strong>ResultSet</strong>:结果集，Statement执行完sql返回的结果。</li></ul></li><li>图中是几个核心类的关系。<br><img src="https://i.loli.net/2021/04/25/vnxJ4zLMjUeis1p.png" alt="JDBC核心API类关系.png"><h3 id="入门代码："><a href="#入门代码：" class="headerlink" title="入门代码："></a>入门代码：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">query</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 1.加载数据库驱动</span></span><br><span class="line">        Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">        <span class="comment">// 2.建立数据库连接</span></span><br><span class="line">        <span class="comment">// jdbc:mysql:连接mysql数据库的固定写法，localhost：ip地址，3306：端口号，jdbcDemo：数据库名称</span></span><br><span class="line">        String url = <span class="string">&quot;jdbc:mysql://localhost:3306/lxy?characterEncoding=utf-8&amp;useSSL=false&quot;</span>;</span><br><span class="line">        <span class="comment">// 第一个参数：连接mysql数据库,第二和第三个参数分别是数据库的用户名和密码</span></span><br><span class="line">        Connection con = DriverManager.getConnection(url, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;***&quot;</span>);</span><br><span class="line">        <span class="comment">// 3.获取statement对象</span></span><br><span class="line">        Statement st = con.createStatement();</span><br><span class="line">        <span class="comment">// 4.执行sql语句，并且获取结果</span></span><br><span class="line">        String sql = <span class="string">&quot;select * from user&quot;</span>;</span><br><span class="line">        ResultSet res = st.executeQuery(sql);</span><br><span class="line">        <span class="comment">// 5.处理结果</span></span><br><span class="line">        <span class="keyword">while</span> (res.next()) &#123;</span><br><span class="line">            System.out.println(res.getString(<span class="string">&quot;name&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 6.释放资源</span></span><br><span class="line">        res.close();</span><br><span class="line">        st.close();</span><br><span class="line">        con.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>jdbc编程步骤:<br><img src="https://i.loli.net/2021/04/25/MvsPGJICByzA4XH.png" alt="jdbc编程步骤.png"><h3 id="Connection详解"><a href="#Connection详解" class="headerlink" title="Connection详解"></a>Connection详解</h3></li><li>url介绍：指定一个具体的数据库<br>  <img src="https://i.loli.net/2021/04/25/6I74Ee9GsxCgzft.png" alt="url详解.png"><ul><li>Oracle的URL：jdbc:oracle:thin:@localhost:3306:jdbcDemo</li><li>MySql的URL：jdbc:mysql://localhost:3306/jdbcDemo</li><li>MySql的URL简写方式：jdbc:mysql:///jdbcDemo（注意：简写方式必须是本地连接-localhost，并且需要端口是3306的）<ul><li>jdbc:mysql:///jdbcDemo ===== jdbc:mysql://localhost:3306/jdbcDemo</li><li>要求是localhost，并且端口是3306； 才可以进行简写</li><li>前面是后面的简写。</li></ul></li></ul></li><li>Connection<ul><li>获取数据库连接Connction的方法：<ul><li><code>DriverManager.getConnection(url, user, password);</code><ul><li>url：连接到某一个具体的数据库</li><li>user：数据库的用户名</li><li>password：数据库用户名对应的密码。</li><li>注意：获取连接时导入的包是java.sql.Connection;</li><li>虽然导入com.mysql.jdbc.Driver;然后进行强转也可以使用，但是这样就与代码耦合了，不方便更换数据库。</li></ul></li></ul></li><li>Jdbc程序中的Connection，它用于<strong>代表数据库的链接</strong>，Connection是数据库编程中最重要的一个对象，客户端与数据库所有交互都是通过connection对象完成的，这个对象的常用方法.<ul><li><code>Statement createStatement();</code>:创建一个Statement对象来将SQL语句发送到数据库。<h3 id="Statement-详解"><a href="#Statement-详解" class="headerlink" title="Statement 详解"></a>Statement 详解</h3></li></ul></li></ul></li><li>需要掌握的方法：<ul><li><code>stmt.executeUpdate(sql)</code>：执行增删改</li><li><code>stmt.executeQuery(sql)</code>：执行查询</li></ul></li><li><strong>Statement</strong>：向数据库发送sql的对象，并且得到执行sql之后的结果。是接口</li><li>Jdbc程序中的Statement对象用于向数据库发送SQL语句，Statement对象常用方法：<ul><li>1、<code>ResultSet executeQuery(String sql)</code>：执行给定的SQL语句，该语句返回单个ResultSet对象<ul><li>相当于执行select查询语句，当然查询语句就是executeQuery(String sql)中的参数，查询语句可以自定义。</li><li>将查询到的数据封装到ResultSet中并进行返回。</li></ul></li><li>2、<code>int executeUpdate(String sql)</code>：执行给定SQL语句，该语句可能为INSTERT，UPDATE，或DELETE语句，或者不返回任何内容的SQL语句(如SQL DDL语句)<ul><li>相当于执行update,delete,insert等语句，当然具体的语句就是executeQuery(String sql)中的参数，语句可以自定义。</li><li>返回值int:代表执行增删改的时候总共影响到了几条记录。</li></ul></li><li>3、<code>boolean execute(String sql)</code>:执行给定的SQL语句，该语句可能返回多个结果。<ul><li>如果第一个结果为ResultSet对象，则返回true；如果其为更新计数或者不存在任何结果，则返回 false </li><li>可以通过<code>Result getResultSet()</code>; 获取当前sql执行之后得到的结果集。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span> <span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="comment">//注册驱动</span></span><br><span class="line">    Class.forName(<span class="string">&quot;com.mysql.jdbc.Driver&quot;</span>);</span><br><span class="line">    <span class="comment">//后去连接</span></span><br><span class="line">    Connection con = DriverManager.getConnection(<span class="string">&quot;jdbc:mysql://localhost:3306/jdbcdemo&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;root&quot;</span>);</span><br><span class="line">    <span class="comment">//定义sql</span></span><br><span class="line">    <span class="comment">//String sql = &quot;select * from employee&quot;;</span></span><br><span class="line">    <span class="comment">//更新貂蝉的年龄为18岁</span></span><br><span class="line">    String sql = <span class="string">&quot;update employee set age= 18 where name = &#x27;貂蝉&#x27;&quot;</span>;</span><br><span class="line">    <span class="comment">//创建sql操作对象</span></span><br><span class="line">    Statement st = con.createStatement();</span><br><span class="line">    <span class="comment">//执行查询,并且返回boolean</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = st.execute(sql);</span><br><span class="line">    <span class="comment">//判断flag是否为true来判断到底是不是查询语句</span></span><br><span class="line">    <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">        <span class="comment">//如果是true，就证明是一个查询语句，需要获取结果集</span></span><br><span class="line">        ResultSet res = st.getResultSet();</span><br><span class="line">        <span class="keyword">while</span>(res.next())&#123;</span><br><span class="line">            System.out.println(res.getInt(<span class="string">&quot;id&quot;</span>)+<span class="string">&quot;...&quot;</span>+res.getString(<span class="string">&quot;name&quot;</span>)+<span class="string">&quot;...&quot;</span>+res.getInt(<span class="string">&quot;age&quot;</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        res.close();</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="comment">//如果是false，就证明不是查询语句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sql语句执行成功！一共操作了&quot;</span>+st.getUpdateCount()+<span class="string">&quot;条sql语句&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">    st.close();</span><br><span class="line">    con.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ResultSet-详解"><a href="#ResultSet-详解" class="headerlink" title="ResultSet 详解"></a>ResultSet 详解</h3></li></ul></li></ul></li><li>结果集：我们查询所有数据的时候，得到结果集</li><li>如何去遍历ResultSet:<ul><li><code> boolean    next()</code>:将光标从当前位置向前移一行。</li><li><code>boolean absolute(int row)</code>:将光标移动到此ResultSet对象的给定行编号。</li><li><code>void afterLast()</code>:将光标移动到此ResultSet对象的末尾，正好位于最后一行之后。</li><li><code>void beforeFirst()</code>:将光标移动到此ResultSet对象的开头，正好位于第一行之前。</li><li><code>boolean previous()</code>:将光标移动到此ResultSet对象的上一行。<br><img src="https://i.loli.net/2021/04/25/21VOfiSAGWU3CMm.png" alt="遍历ResultSet.png"></li></ul></li><li>如何取出数据:<ul><li><code>Resulset getXxx(String columnLabel)</code>:xxx表示的是具体的数据类型。<ul><li>数据库表中的每个列（字段），有自己的数据类型。</li><li>从结果集中取出数据是从列中取出数据。</li><li>获取数据库中数据的类型需要和getXxx(XXX)方法的类型需要一一对应。</li></ul></li><li><code>getXxx（String 列的名字）</code>；—常用<ul><li>如果从列的名字是name的取出数据。</li><li>getString(“name”);</li></ul></li><li><code>getXxx(int 列的顺序)</code>—-注意：列的顺序从1开始。<ul><li>如果想要获取name</li><li>getString(2);</li></ul></li><li>建议使用按照列名去获取数据。如果有别名，也可以按照别名去获取。<br><img src="https://i.loli.net/2021/04/25/yDKCpOkG6USjRx5.png" alt="如何取出数据.png"><h3 id="资源释放"><a href="#资源释放" class="headerlink" title="资源释放"></a>资源释放</h3></li></ul></li><li>连接资源是珍贵的，是有数目限制的。如果只有打开没有关闭，那么当达到一个限定之后，其他人将无法继续连接数据库。所以需要关闭连接。因此，在使用完资源以后，就必须将资源释放掉，节省资源。<h3 id="JDBC-工具（JdbcUtil）类抽取（★★★★★）"><a href="#JDBC-工具（JdbcUtil）类抽取（★★★★★）" class="headerlink" title="JDBC 工具（JdbcUtil）类抽取（★★★★★）"></a>JDBC 工具（JdbcUtil）类抽取（★★★★★）</h3></li><li>配置文件：<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># jdbc.properties放置在src目录下</span></span><br><span class="line"><span class="attr">driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="attr">url</span>=<span class="string">jdbc:mysql://47.101.175.143:3306/lxy?characterEncoding=utf-8&amp;useSSL=false</span></span><br><span class="line"><span class="attr">user</span>=<span class="string">root</span></span><br><span class="line"><span class="attr">password</span>=<span class="string">naraka47</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> String url;</span><br><span class="line">    <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">static</span> String driverClass;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库驱动只需要加载一次</span></span><br><span class="line">    <span class="comment">// static静态代码块在类加载的时候会执行，并且只执行一次</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">            InputStream inputStream = <span class="keyword">new</span> FileInputStream(<span class="string">&quot;src/jdbc.properties&quot;</span>);</span><br><span class="line">            <span class="comment">//加载properties文件</span></span><br><span class="line">            pro.load(inputStream);</span><br><span class="line">            <span class="comment">//读取properties文件中的数据</span></span><br><span class="line">            driverClass = pro.getProperty(<span class="string">&quot;driverClass&quot;</span>);</span><br><span class="line">            url = pro.getProperty(<span class="string">&quot;url&quot;</span>);</span><br><span class="line">            user = pro.getProperty(<span class="string">&quot;user&quot;</span>);</span><br><span class="line">            password = pro.getProperty(<span class="string">&quot;password&quot;</span>);</span><br><span class="line">            Class.forName(driverClass);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对外提供获取连接的方法</span></span><br><span class="line">    <span class="comment">// 异常可以直接抛出，因为在调用该方法处还会执行try-catch.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Connection con = DriverManager.getConnection(url, user, password);</span><br><span class="line">        <span class="keyword">return</span> con;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源方法2</span></span><br><span class="line">    <span class="comment">//其他增删改释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection con, Statement st)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">                st.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//释放资源方法1</span></span><br><span class="line">    <span class="comment">//查询的时候释放资源</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(Connection con, Statement st, ResultSet res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (res != <span class="keyword">null</span>) &#123;</span><br><span class="line">                res.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (st != <span class="keyword">null</span>) &#123;</span><br><span class="line">                st.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">                con.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="SQL注入问题"><a href="#SQL注入问题" class="headerlink" title="SQL注入问题"></a>SQL注入问题</h2><ul><li>什么是sql注入问题？<ul><li>用户在页面提交数据的时候人为的添加一些特殊字符，使得sql语句的结构发生了变化，最终可以在没有用户名或者密码的情况下进行登录。</li></ul></li><li>sql注入分析与解决方案<ul><li>Sql注入的原因分析：<ul><li>之所以有sql注入的问题，无非是在参数中设置了一些特殊字符，使sql语句在拼接这些参数的时候因为特殊字符的原因改变了sql语句原来的规则。</li></ul></li><li>解决方案：<ul><li>使用PreparedStatement解决SQL注入问题，运行在SQL中参数以’?’占位符的方式表示</li><li>举例：<ul><li>String sql = “select * from user where username = ‘admin’ and password = ‘admin’ “;<br>使用？进行站位后的语句<br>String sql = “select * from user where username = ? and password = ? “;<br>PreparedStatement将带有?的SQL发送给数据库完成预编译，预编译的sql语句由于缺少两个参数，因此无法执行，需要通过PreparedStatement将预编译中被？占位的参数传递进来。</li></ul></li><li>而且由于SQL已经编译过，参数中特殊字符不再当做特殊字符编译，因此无法达到SQL注入的目的。</li></ul></li></ul></li><li>PreparedStatement API介绍<ul><li>PreparedStatment —sql只被编译一次，可以防止sql的注入。sql语句格式良好方便阅读。</li><li>statement —-调用几次编译几次。</li><li>使用方式基本和statement的使用方式相同。</li><li>获取PreparedStatement对象：通过connection获取</li><li><code>PreparedStatement prepareStatement(String sql)</code>:创建一个PreparedStatement对象来将参数化的SQL语句发送到数据库。</li><li>注意：上述方法在创建PreparedStatement对象的时候需要先将sql语句传递进去并进行预编译，因此sql需要提前创建好。sql语句中需要参数。使用？进行占位。</li><li>然后获取到PreparedStatement对象后，在执行sql语句之前需要先用参数把？替换掉。<ul><li>可以使用<code>setXxx(int parameterIndex, Xxx x)</code>进行传递：Xxx为参数类型，如String、int、double等，传递什么类型的参数就需要使用什么类型的setXxx(int parameterIndex, Xxx x)方法。</li></ul></li></ul></li><li>PreparedStatement案例（★★★★★）  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    Connection con = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement ps = <span class="keyword">null</span>;</span><br><span class="line">    ResultSet res = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//获取连接</span></span><br><span class="line">        con = JdbcUtils.getConnection();</span><br><span class="line">        <span class="comment">//创建数据库操作对象</span></span><br><span class="line">        String sql = <span class="string">&quot;select * from User where username = ? and password = ?&quot;</span>;</span><br><span class="line">        <span class="comment">//执行预编译</span></span><br><span class="line">        ps = con.prepareStatement(sql);</span><br><span class="line">        <span class="comment">//传递参数</span></span><br><span class="line">        ps.setString(<span class="number">1</span>, user.getUsername());</span><br><span class="line">        ps.setString(<span class="number">2</span>, user.getPassword());</span><br><span class="line">        <span class="comment">//执行查询</span></span><br><span class="line">        res = ps.executeQuery();</span><br><span class="line">        <span class="comment">//获取数据并封装</span></span><br><span class="line">        <span class="keyword">if</span> (res.next()) &#123;</span><br><span class="line">            User queryUser = <span class="keyword">new</span> User();</span><br><span class="line">            queryUser.setId(res.getInt(<span class="string">&quot;id&quot;</span>));</span><br><span class="line">            queryUser.setUsername(res.getString(<span class="string">&quot;username&quot;</span>));</span><br><span class="line">            queryUser.setPassword(res.getString(<span class="string">&quot;password&quot;</span>));</span><br><span class="line">            <span class="keyword">return</span> queryUser;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        JdbcUtils.release(con, ps, res);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>PreparedStatement优点:<ul><li>PreparedStatement是Statement的子接口，它的实例对象可以通过调用Connection.preparedStatement(sql)方法获得，相对于Statement对象而言：<ul><li>PreperedStatement可以避免SQL注入的问题。</li><li>Statement会使数据库频繁编译SQL，可能造成数据库缓冲区溢出。PreparedStatement可对SQL进行预编译，从而提高数据库的执行效率。</li><li>并且PreperedStatement对于sql中的参数，允许使用占位符的形式进行替换，简化sql语句的编写。方便阅读，使代码的可读性更高。<h2 id="JDBC批处理"><a href="#JDBC批处理" class="headerlink" title="JDBC批处理"></a>JDBC批处理</h2></li></ul></li></ul></li><li>批处理介绍和优点<ul><li>在实际开发中，经常需要向数据库发送多条SQL语句，这时，如果逐条执行这些SQL语句，效率会很低。为此，JDBC提供了批处理提供了批处理机制，即同时执行多条SQL语句。</li><li>在jdbc中提供两种批处理的方式：<ul><li>1、 Statement批处理</li><li>2、 PrepareStatement批处理</li><li>两种批处理的方式都可以批量的执行sql语句，以达到提升效率的目的。</li></ul></li></ul></li><li>statement批处理<ul><li>常用方法：<ul><li><code>Statement.addBatch(sql)</code> ：添加批处理的sql语句</li><li><code>Statement.executeBatch()</code>：执行批处理命令</li><li><code>Statement.clearBatch()</code>：清除批处理命令</li></ul></li><li>总结:<ul><li>采用Statement.addBatch(sql)方式实现批处理：<ul><li>优点：可以向数据库发送多条不同类型的sql语句。</li><li>缺点：SQL语句没有预编译，有注入风险。当向数据库发送多条语句相同，但参数不同的SQL语句时，需重复写上很多条SQL语句并且编译多次.</li></ul></li></ul></li></ul></li><li>preparestatement批处理<ul><li>常用方法:<ul><li><code>Connection.prepareStatement(sql)</code>: 预编译sql语句</li><li><code>PreparedStatement.addBatch()</code> : 增加批处理</li><li><code>PreparedStatement.executeBatch()</code> : 执行批处理命令</li><li><code>PreparedStatement.clearBatch()</code>; 清除批处理的命令</li></ul></li><li>总结:<ul><li>PrepareStatement批处理的优缺点：<ul><li>优点：发送的是预编译后的SQL语句，执行效率高。</li><li>缺点：只能在SQL语句相同，当参数不同的批处理中使用,因此这种批处理的方式经常适用于在同一个表中批量插入或者更新数据。<h2 id="事务（★★★★★）"><a href="#事务（★★★★★）" class="headerlink" title="事务（★★★★★）"></a>事务（★★★★★）</h2></li></ul></li></ul></li></ul></li><li>什么是事务？<ul><li>一组sql语句(insert、update、delete)，要么全部执行成功，要么全部执行失败，不能成功或者失败其中一部分。</li></ul></li><li>事务的使用步骤：<ul><li>1、开启事务</li><li>2、执行一组sql语句</li><li>3、提交事务/回滚事务</li></ul></li><li>Mysql中的事务管理<ul><li>mysql的事务默认自动打开，自动提交。 </li><li>每一条sql就是一个单独的事务，所以不需要事务开启、事务回滚、事务提交。</li><li>Mysql中事务的使用：<ul><li><code>start transaction;</code>  —开启事务。以后的sql都在一个事务中。更改的内容不会自动提交。</li><li><code>rollback;</code>  —回滚事务(都失败的情况)。事务结束，全部失败，数据恢复到事务未开启之前的状态。</li><li><code>commit;</code> —提交事务(都成功的情况)。事务结束，全部成功。</li></ul></li></ul></li><li>JDBC中的事务管理（★★★★★） <ul><li>Jdbc的事务介绍：<ul><li>JDBC的事务管理，是通过Connection对象来完成的。</li><li>当JDBC程序向数据库获得一个Connection对象时，默认情况下这个Connection对象会自动向数据库提交在它上面的发送的sql语句。</li><li>若想关闭这种默认的提交方式，需要使用以下三个方法：<ul><li><code>void setAutoCommit(boolean autoCommit)</code>:将此连接的自动提交模式设置为给定状态。<ul><li>参数为<strong>false</strong>，表示禁用自动提交模式，相当于<code>strart transaction</code>–开启事务。</li><li>参数为<strong>true</strong>，表示自动提交。默认就是true。–一条sql语句就是一个事务.</li><li>开启事务：<code>con.setAutoCommit(false);</code></li></ul></li><li><code>void rollback()</code>:取消在当前事务中进行的所有更改，并释放此Connection对象当前持有的所有数据库锁。<ul><li>相当于<code>rollback()</code>, 回滚事务。表示事务结束，取消当前事务的所有更改。</li><li>注意：<code>con.rollback()</code>应该只在开启事务时使用，即con.setAutoCommit(false); 时才有效。</li></ul></li><li><code>void commit()</code>:使所有上次提交/回滚后进行的更改成为持久更改，并释放此Connection对象当前持有的所有数据库锁。<ul><li>相当于<code>commit()</code>,提交事务。表示事务结束，更改有效。</li><li>注意：<code>con.commit()</code>应该只在开启事务时使用，即conn.setAutoCommit(false); 时才有效。</li></ul></li></ul></li></ul></li><li>Jdbc中事务的使用:<ul><li>1、开启事务：<code>connection.setAutoCommit(false)</code>;</li><li>2、执行一组sql语句;</li><li>3、提交事务：<code>connection.commit()</code>/回滚事务：<code>connection.rollback()</code>;</li></ul></li></ul></li><li>事务的回滚点 <ul><li>事务的回滚点有什么作用？类似于单机游戏的存档和读档：<ul><li>1、如果没有游戏的存档功能，每次玩单机游戏都会从第一关重新开始。</li><li>2、如果使用了游戏的存档功能，下次在玩游戏时，就会从存档处满血复活。</li></ul></li></ul></li><li>事务的回滚点介绍：<ul><li>接口 Savepoint:<ul><li><code>public interface Savepoint</code></li><li>保存点的表示形式，保存点是可以从Connection.rollback方法引用的当前事务中的点。将事务回滚到保存点时，在该保存点之后所作的全部更改都将被撤消。 </li><li>作用：JDBC使用接口Savapoint表示事务回滚点，当出现异常事务回滚时，使用savapoint更新回滚点之前的数据。</li><li>如何设置事务的回滚点？<code>connection.setSavepoint()</code><ul><li><code>Savepoint setSavepoint()</code>:在当前事务中创建一个未命名的保存点(savepoint)，并返回表示它的新Savepoint对象。</li></ul></li><li>如何使用事务的回滚点把数据回滚到指定的位置？<ul><li><code>void rollback(Savepoint savepoint)</code>:取消所有设置给定Savepoint对象之后进行的更改。</li><li>把数据会滚到给定回滚点的位置。</li></ul></li></ul></li><li>注意点：<ul><li>1、设置回滚点，必须事务开启之后。</li><li>2、事务回滚，需要设置一个回滚点。</li><li>3、事务回滚到回滚点之后，还需要提交事务，才能将回滚点之前的数据持久化到数据库。</li></ul></li></ul></li></ul><h2 id="事务的特性–ACID"><a href="#事务的特性–ACID" class="headerlink" title="事务的特性–ACID"></a>事务的特性–<strong>ACID</strong></h2><ul><li>在执行一组sql语句的操作过程中，这些操作要么都执行，要么都不执行，他是一个不可分割的工作单元。</li><li>数据库的事务必须具备<strong>ACID</strong>特性，ACID是指:<ul><li><strong>Atomicity（原子性）</strong><ul><li>一个事务中所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中如果发生错误，会被回滚到事务开始前的状态，就像这个事务从来没有执行一样。</li></ul></li><li><strong>Consistensy（一致性）</strong><ul><li>一个事务在执行之前和执行之后，数据库都必须处于一致性状态。如果事务成功的完成，那么执行成功的sql语句会将数据库中所有涉及到的数据进行更新。如果事务执行出现错误，那么数据库的所有变化将会被回滚（撤销），返回到原始状态。</li></ul></li><li><strong>Isolation（隔离性）</strong><ul><li>多个用户并发的访问数据库时，一个用户的事务不能被其他用户的事务干扰，多个并发的事务之间要相互隔离。</li><li>多个事务之间是相互独立的，事务和事务之间不能相互干扰。</li><li>所谓事务的隔离性是指两个操作的两个事务不能同时去修改数据库中的数据。必须等待一个事务执行完毕之后，另外一个事务再去执行。</li></ul></li><li><strong>Durability（持久性）</strong><ul><li>持久性是指当数据库系统出现故障了，要确保已经提交的事务的更新是不会丢失的。即数据库中的数据的修改是永久性的。就算系统出现了故障，我们也可以使用数据库的备份和恢复来保证数据的修改。<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2></li></ul></li></ul></li><li><strong>如果不考虑事务的隔离性</strong>，由于事务的并发，将会出现以下问题：<ul><li>1、<strong>脏读</strong><ul><li>指一个事务读取了另外一个事务 未提交的数据。</li><li>一个事务读取了另一个事务没有提交的数据，非常严重。应当尽量避免脏读。</li></ul></li><li>2、<strong>不可重复读</strong><ul><li>在<strong>一个事务内</strong>多次读取表中的数据，多次读取的结果不同。</li><li>不可重复读强调数据内容的更新，一个事务内的多次查询结果不同。</li><li>在一个事务内的两次查询得到了不同的结果，这叫做不可重复读。</li><li>常用的sql语句的类型为update</li></ul></li><li>3、<strong>幻读（虚读）</strong><ul><li>一个事务中多次读取的记录数不一致.</li><li>指在一个事务中读取另一个事务<strong>插入或删除</strong>数据记录，导致当前事务读取的数据的记录数前后不一致。</li><li>注意：mysql数据库本身，已经对虚读(幻读)做了优化处理。</li></ul></li><li>虚读和不可重复读的区别：<ul><li><strong>虚读</strong>强调的是数据表<strong>记录数</strong>的变化，主要是insert和delete语句。</li><li><strong>不可重复读</strong>强调的是数据表<strong>内容</strong>的变化，主要是update语句。</li></ul></li></ul></li><li>数据库的隔离级别的设置<ul><li>数据库共定义了<strong>4种隔离级别</strong>（限制由高到低, 性能从低到高）：<ul><li><strong>serializable</strong>（串行化）：可避免脏读、不可重复读、虚读情况的发生。</li><li><strong>repeatable read</strong>（可重复读）：可避免脏读、不可重复读，不可避免虚读。Mysql默认采用可重复读。</li><li><strong>read committed</strong>（读已提交）：可避免脏读，不可避免不可重复读、虚读。Oracle默认采用读已提交。</li><li><strong>read uncommitted</strong>（读未提交）：不可避免脏读、不可重复读、虚读。</li></ul></li><li>查询当前数据库的隔离级别：<code>select @@tx_isolation;</code></li><li>设置事务的隔离级别：<code>set session transaction isolation level 事务隔离级别;</code></li><li>为什么串行可以解决所有的问题？ <ul><li>所有的问题其实都是由不同的事务并行执行引起的，所以改成所有事务依次执行（串行），当一个事务执行完毕之后再去执行另外一个事务，这样就能解决所有问题。</li></ul></li></ul></li><li>隔离级别的性能问题<ul><li>性能比较：<ul><li>serializable 性能最差，多个事务排队执行。</li><li>serializable&lt;repeatable read&lt;read committed&lt;read uncommitted;</li></ul></li><li>安全性比较：<ul><li>serializable 安全性能最好，所有问题都可以避免。</li><li>serializable&gt;repeatable read&gt;read committed&gt;read uncommitted;</li></ul></li><li>分析：<ul><li>serializable 性能太差</li><li>read uncommitted 无法避免脏读，问题严重</li></ul></li><li>总结：不同的数据库厂商默认的隔离级别不同<ul><li>mysql 的默认隔离级别 – repeatable read</li><li>oracle 的默认隔离级别 – read committed<h2 id="连接池"><a href="#连接池" class="headerlink" title="连接池"></a>连接池</h2></li></ul></li></ul></li><li>建立连接产生的问题：Jdbc的每次操作都要和数据库建立连接。</li><li>创建连接是<strong>非常耗费资源</strong>的，每次建立连接的时间都比执行CRUD的时间要长很多，频繁的创建和释放连接会引起大量的性能开销。</li><li>什么是连接池？<ul><li>创建一个连接的池子，然后在池子中先存放多个连接，比如5个，每次使用的时候去池子中获取，使用完毕之后再放回池子中，这样就避免了多次建立连接和释放连接造成的资源浪费。</li></ul></li><li>这样做的好处是：可能有10000个人需要使用到连接，但是只需要在连接池中放置10个连接来回利用就可以了。<h2 id="传播行为"><a href="#传播行为" class="headerlink" title="传播行为"></a>传播行为</h2></li><li>传播行为是方法之间调用事务采取的策略问题。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础教程</title>
      <link href="/2021/04/25/Java/JAVA%E9%BB%91%E9%A9%AC%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"/>
      <url>/2021/04/25/Java/JAVA%E9%BB%91%E9%A9%AC%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="JAVA基础知识"><a href="#JAVA基础知识" class="headerlink" title="JAVA基础知识"></a>JAVA基础知识</h1><h2 id="JAVA语言平台"><a href="#JAVA语言平台" class="headerlink" title="JAVA语言平台"></a>JAVA语言平台</h2><ul><li><strong>J2SE</strong>：(Java 2 Platform Standard Edition)标准版,为开发普通桌面和商务应用程序,可以完成一些桌面型应用程序的开发。</li><li><strong>J2ME</strong>：(Java 2 Platform Micro Edition)小型版,为开发电子消费产品和嵌入式设备。</li><li><strong>J2EE</strong>：(Java 2 Platform Enterprise Edition)企业版,为开发企业环境下的应用程序,该体系中包含的技术入Servlet、Jsp等,主要针对Web应用程序开发。</li><li>JavaEE和JavaSE的区别：<ul><li>JavaEE：Java Enterprise Edition，Java企业版，多用于企业级开发，包括web开发等等。企业版本帮助开发和部署可移植、健壮、可伸缩切安全的服务端Java应用。Java EE是在JavaSE的基础上构建的他提供Web 服务、组建模型、管理和通信API.可以用来实现企业级的面向服务体系结构(service-oriented architecture,SOA)和web2.0应用程序。</li><li>JavaSE：通常是指Java Standard Edition，Java标准版，就是一般Java程序的开发就可以(如桌面程序)，可以看作是JavaEE的子集。它允许开发和部署在桌面、服务器、嵌入式环境和实施环境中使用的Java应用程序。JavaSE 包括支持Java　Ｗeb服务开发的类，并为Java Platform,Enterprise Edition(Java EE)提供基础。<h2 id="JAVA属于跨平台语言"><a href="#JAVA属于跨平台语言" class="headerlink" title="JAVA属于跨平台语言"></a>JAVA属于跨平台语言</h2></li></ul></li><li>什么是跨平台？<ul><li>平台：指的是操作系统(Windows,Linux,Mac)。</li><li>跨平台：Java程序可以在任意操作系统上运行,一次编写到处运行。</li><li>原理：实现跨平台需要依赖Java的虚拟机JVM（Java Virtual Machine）<h2 id="JVM、JRE、JDK说明"><a href="#JVM、JRE、JDK说明" class="headerlink" title="JVM、JRE、JDK说明"></a>JVM、JRE、JDK说明</h2></li></ul></li><li>JVM：JVM是java虚拟机(Java Virtual Machine),java程序需要运行在虚拟机上,不同平台有自己的虚拟机,因此java语言可以跨平台。</li><li>JRE：包括Java虚拟机(Java Virtual Machine)和Java程序所需的核心类库等。如果想要运行一个开发好的Java程序,计算机中只需要安装JRE即可。<br>&emsp;&emsp;JRE=JVM+核心类库。 </li><li>JDK：JDK是提供给Java开发人员使用的,其中包含了java的开发工具,也包括了JRE。所以安装了JDK,就不用在单独安装JRE了。<br>&emsp;&emsp;其中的开发工具：编译工具(javac.exe)、打包工具(jar.exe)等。<br>&emsp;&emsp;JDK=JRE+JAVA的开发工具。<h2 id="运行代码"><a href="#运行代码" class="headerlink" title="运行代码"></a>运行代码</h2></li><li>运行代码步骤：<ul><li>在命令行模式中，输入javac命令对源代码进行编译，生成字节码文件<br>  – javac 源文件名.java</li><li>编译完成后，如果没有报错信息，输入java命令对class字节码文件进行解释运行,执行时不需要添加.class扩展名<ul><li>java HelloWorld<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2></li></ul></li></ul></li><li>Java语言是强类型语言,对于每一种数据都定义了明确的具体数据类型,在内存中分配了不同大小的内存空间。</li><li>Java中数据类型的分类：<ul><li>基本数据类型(8种)：byte,short,int,long,float,double,char,boolean</li><li>引用数据类型(3种)：类(class),接口(interface),数组([])  </li></ul></li></ul><p><img src="https://i.loli.net/2021/04/25/wjusHikbGVna73q.jpg" alt="JAVA基本数据类型.jpg"><br><img src="https://i.loli.net/2021/04/25/hTZCVmQJezEvYrA.jpg" alt="JAVA数据类型.jpg"></p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><ul><li>作用：给包,类,方法,变量等起名字</li><li>组成规则:<ul><li>由字符,下划线_,美元符$组成(这里的字符采用的是unicode字符集,所以包括英文大小写字母,中文字符,数字字符等)</li></ul></li><li>注意事项:<ul><li>不能以数字开头</li><li>不能是Java中的关键字</li></ul></li><li>命名原则：见名知意<ul><li>包：<ul><li>其实就是文件夹,用于对类进行管理</li><li>最好是域名倒过来,要求所有的字母小写</li><li>多级包用’.’隔开</li></ul></li><li>类或者接口：<ul><li>如果是一个单词,首字母大写</li><li>如果是多个单词,每个单词首字母大写(驼峰标识) </li></ul></li><li>方法或者变量：<ul><li>如果是一个单词,全部小写</li><li>如果是多个单词,从第二个单词首字母大写 </li></ul></li><li>常量：<ul><li>如果是一个单词,所有字母大写</li><li>如果是多个单词,所有的单词大写,用下划线区分每个单词 <h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2></li></ul></li></ul></li><li>隐式数据类型转换：<ul><li>取值范围小的数据类型与取值范围大的数据类型进行运算,会先将小的数据类型提升为大的,再进行运算。</li></ul></li><li>强制类型数据转换<ul><li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目标类型 变量名 = (目标类型) (被转换的数据);</span></span><br><span class="line">b = (<span class="keyword">byte</span>)(a);</span><br></pre></td></tr></table></figure></li><li>注意事项：如果超出了被赋值的数据类型的取值范围得到的结果会与你期望的结果不同。</li></ul></li></ul><h2 id="集成开发环境-IDE"><a href="#集成开发环境-IDE" class="headerlink" title="集成开发环境(IDE)"></a>集成开发环境(IDE)</h2><ul><li>集成开发环境IDE(Integrated Development Environment)<h2 id="运算符与表达式"><a href="#运算符与表达式" class="headerlink" title="运算符与表达式"></a>运算符与表达式</h2></li><li>运算符：对常量和变量进行操作的符号。</li><li>表达式：用运算符把常量或者变量连接起来的符合Java语法的式子。<br>&emsp;&emsp;&emsp;&emsp;不同运算符连接的式子体现的是不同类型的表达式。</li><li>常用运算符<ul><li>算术运算符：+,-,*,/(取整),%(取余),++,–</li><li>赋值运算符：<ul><li>基本的赋值运算符：=</li><li>扩展的赋值运算符：+=,-=,*=,/=,%=</li></ul></li><li>关系运算符：<ul><li>==,!=,&gt;,&gt;=,&lt;,&lt;=</li><li>关系运算符的结果都是boolean型,也就是要么是true,要么是false。</li></ul></li><li>逻辑运算符：<ul><li>&amp;,|,^,!,&amp;&amp;,||</li><li>&amp;逻辑与:有false则false。</li><li>|逻辑或:有true则true。</li><li>^逻辑异或:相同为false,不同为true。</li><li>!逻辑非:非false则true,非true则false。</li><li>逻辑运算符&amp;&amp;与&amp;的区别?<ul><li>最终结果一样。</li><li>&amp;&amp;具有短路效果。左边是false,右边不执行。</li><li>&amp;是无论左边是false还是true,右边都会执行。</li></ul></li><li>逻辑运算符||与|的区别?<ul><li>最终结果一样</li><li>||具有短路效果。左边是true,右边不执行。</li><li>|是无论左边是false还是true,右边都会执行。</li></ul></li></ul></li><li>三元运算符：<ul><li>格式：<code>(关系表达式)?表达式1：表达式2</code></li><li>如果条件为true,运算后的结果是表达式1。</li><li>如果条件为false,运算后的结果是表达式2。<h2 id="键盘录入"><a href="#键盘录入" class="headerlink" title="键盘录入"></a>键盘录入</h2></li></ul></li></ul></li><li>概述：把数据改进为键盘录入,提高程序的灵活性。</li><li>步骤：<ul><li>导包：import java.util.Scanner;</li><li>创建对象：Scanner sc = new Scanner(System.in);</li><li>接收数据：int x = sc.nextInt();</li></ul></li></ul><h2 id="选择流程控制语句"><a href="#选择流程控制语句" class="headerlink" title="选择流程控制语句"></a>选择流程控制语句</h2><ul><li>顺序结构：按照代码的先后顺序,依次执行。</li><li>if语句：</li><li>switch语句：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(表达式) &#123;</span><br><span class="line">   <span class="keyword">case</span> 值<span class="number">1</span>:</span><br><span class="line">语句体<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> 值<span class="number">2</span>:</span><br><span class="line">语句体<span class="number">2</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">语句体n+<span class="number">1</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="循环流程控制语句"><a href="#循环流程控制语句" class="headerlink" title="循环流程控制语句"></a>循环流程控制语句</h2></li><li>for循环：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(初始化语句;判断条件语句;控制条件语句) &#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>while循环：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(判断条件语句) &#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>do…while循环:(while为true时继续执行)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">    循环体语句;</span><br><span class="line">&#125;<span class="keyword">while</span>(判断条件语句);</span><br></pre></td></tr></table></figure><h2 id="控制循环语句"><a href="#控制循环语句" class="headerlink" title="控制循环语句"></a>控制循环语句</h2></li><li>break：退出当前的循环。</li><li>continue：退出本次循环。</li></ul><h2 id="产生随机数-Random"><a href="#产生随机数-Random" class="headerlink" title="产生随机数(Random)"></a>产生随机数(Random)</h2><ul><li>使用步骤：<ul><li>导包：import java.util.Random;</li><li>创建对象：Random r = new Random();</li><li>接收数据：int number = r.nextInt(10);//随机数范围[0,10)<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></li></ul></li><li>数组是存储同一种数据类型多个元素的容器。</li><li>数组既可以存储基本数据类型,也可以存储引用数据类型。</li><li>定义格式：<ul><li>格式1：数据类型[] 数组名;</li><li>格式2：数据类型 数组名[];</li></ul></li><li>数组初始化：Java中的数组必须先初始化,然后才能使用。所谓初始化：就是为数组中的数组元素分配内存空间,并为每个数组元素赋值。<ul><li>初始化方式：<ul><li>动态初始化:初始化时只指定数组长度,由系统为数组分配初始值<ul><li>格式：<code>数据类型[] 数组名 = new 数据类型[数组长度];</code>(数组长度其实就是数组中元素的个数)</li></ul></li><li>静态初始化:初始化时指定每个数组元素的初始值,由系统决定数组长度<ul><li>初始化的格式：<code>数据类型[] 数组名 = new 数据类型[]&#123;元素1,元素2,...&#125;;</code></li><li>简化格式：<code>数据类型[] 数组名 = &#123;元素1,元素2,...&#125;;</code><h2 id="数组内存划分"><a href="#数组内存划分" class="headerlink" title="数组内存划分"></a>数组内存划分</h2></li></ul></li></ul></li></ul></li><li>JVM内存划分<ul><li>栈(存储局部变量)</li><li>堆(存储new出来的东西)</li><li>方法区(面向对象进阶讲)</li><li>本地方法区(和系统相关)</li><li>寄存器(给CPU使用)<h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2></li></ul></li><li>定义格式：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据类型[][] 数组名;</span><br><span class="line">数据类型 数组名[][]; 不推荐</span><br><span class="line">数据类型[] 数组名[]; 不推荐</span><br></pre></td></tr></table></figure></li><li>初始化方式:  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">数据类型[][] 变量名 = new 数据类型[m][n];</span><br><span class="line">数据类型[][] 变量名 = new 数据类型[][]&#123;&#123;元素…&#125;,&#123;元素…&#125;,&#123;元素…&#125;&#125;;</span><br><span class="line">简化版格式：</span><br><span class="line">数据类型[][] 变量名 = &#123;&#123;元素…&#125;,&#123;元素…&#125;,&#123;元素…&#125;&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul><li>方法就是完成特定功能的代码块。</li><li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">修饰符 返回值类型 方法名(参数类型 参数名<span class="number">1</span>,参数类型 参数名<span class="number">2</span>…) &#123;</span><br><span class="line">函数体;</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="方法的重载及参数传递"><a href="#方法的重载及参数传递" class="headerlink" title="方法的重载及参数传递"></a>方法的重载及参数传递</h2></li><li>方法的重载：<ul><li>概述：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或者参数类型不同即可。</li><li>特点：与返回值类型无关，只看方法名和参数列表。在调用时，虚拟机通过参数列表的不同来区分同名方法。</li></ul></li><li>参数传递：<ul><li>方法的形式参数为基本数据类型：<ul><li>形式参数的改变<strong>不影响</strong>实际参数。</li><li>形式参数：用于接收实际数据的变量</li><li>实际参数：实际参与运算的变量</li></ul></li><li>方法的形式参数为引用数据类型：<ul><li>形式参数的改变<strong>直接影响</strong>实际参数。</li></ul></li></ul></li></ul><h2 id="面向过程和面向对象"><a href="#面向过程和面向对象" class="headerlink" title="面向过程和面向对象"></a>面向过程和面向对象</h2><ul><li>面向过程：<ul><li>概述：其实就是面向着具体的每一个步骤和过程，把每一个步骤和过程完成，然后由这些功能方法相互调用，完成需求。</li><li>特点：强调的是过程，所有事情都需要自己完成。</li></ul></li><li>面向对象：<ul><li>概述：思想就是不断的创建对象，使用对象，指挥对象做事情。（如果有对象，直接用对象，对我们直接提供服务）</li><li>特点：<ul><li>是一种更符合我们思想习惯的思想(懒人思想，我把事情自己不做，交给别人去做)。</li><li>可以将复杂的事情简单化(对使用者来说简单了，对象里面还是很复杂的)。</li><li>将我们从执行者变成了指挥者角色发生了转换。<h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2></li></ul></li></ul></li><li>概述：<ul><li>我们学习编程是为了什么?<ul><li>是为了把我们日常生活中实物用学习语言描述出来。</li></ul></li><li>我们如何描述现实世界事物?<ul><li>属性：就是该事物的描述信息(事物身上的名词)</li><li>行为：就是该事物能够做什么(事物身上的动词)</li></ul></li><li>Java中最基本的单位是类,Java中用class描述事物也是如此<ul><li>成员变量:就是事物的属性</li><li>成员方法:就是事物的行为</li></ul></li><li>定义类其实就是定义类的成员(成员变量和成员方法)<ul><li>成员变量:和以前定义变量是一样的，只不过位置发生了改变。在类中，方法外。</li><li>成员方法:和以前定义方法是一样的，只不过把static去掉，后面在详细讲解static的作用。</li></ul></li><li>类和对象的概念<ul><li>类：是一组相关的属性和行为的集合（我们班所有的同学都具备相同的属性和行为，比如：姓名，年龄，学习，这样就把所有的学生成为学生类）</li><li>对象：是该类事物的具体体现（说某个同学时，他都具备自己特有的属性和行为）</li><li>举例：<ul><li>类:学生</li><li>对象:具体的某个学生就是一个对象</li><li>比如：车是一个类，具体的开的奔驰、宝马，就是对象<h2 id="成员变量和局部变量的区别："><a href="#成员变量和局部变量的区别：" class="headerlink" title="成员变量和局部变量的区别："></a>成员变量和局部变量的区别：</h2></li></ul></li></ul></li></ul></li><li>在类中的位置不同<ul><li>成员变量：类中，方法外。</li><li>局部变量：方法中或者方法声明上(形式参数)。</li></ul></li><li>在内存中的位置不同<ul><li>成员变量：堆内存。</li><li>局部变量：栈内存。</li></ul></li><li>生命周期不同<ul><li>成员变量：随着对象的创建而存在，随着对象的消失而消失。</li><li>局部变量：随着方法的调用而存在，随着方法的调用完毕而消失。</li></ul></li><li>初始化值的问题<ul><li>成员变量：有默认值。</li><li>局部变量：没有默认值。必须先定义，赋值，最后使用。<h2 id="封装-面向对象三大特性之一"><a href="#封装-面向对象三大特性之一" class="headerlink" title="封装(面向对象三大特性之一)"></a>封装(面向对象三大特性之一)</h2></li></ul></li><li>private关键字:<ul><li>是一个权限修饰符。</li><li>可以修饰成员(成员变量和成员方法)</li><li>被private修饰的成员只在本类中才能访问。</li></ul></li><li>封装的概述：<ul><li>是<a href="https://www.cnblogs.com/fzz9/p/8973315.html">面向对象三大特征</a>之一(三大特征为：封装、继承、多态)。</li><li>是面向对象编程语言对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。</li></ul></li><li>封装的原则：<ul><li>将不需要对外提供的内容都隐藏起来。</li><li>把属性隐藏，提供公共方法对其访问。</li><li>将成员变量设置为private，提供对应的getXxx()/setXxx()方法。</li></ul></li><li>封装的好处：<ul><li>通过方法来控制成员变量的操作，提高了代码的安全性。</li><li>把代码用方法进行封装，提高了代码的复用性。</li></ul></li><li>this关键字：<ul><li>this代表所在类的对象引用，方法被哪个对象调用，this就代表那个对象。</li><li>什么时候使用this呢：当局部变量和成员变量重名时。<h2 id="面向对象之构造方法"><a href="#面向对象之构造方法" class="headerlink" title="面向对象之构造方法"></a>面向对象之<strong>构造方法</strong></h2></li></ul></li><li>主要用来给对象的数据进行初始化。</li><li>构造方法格式：<ul><li>方法名与类名相同。</li><li>没有返回值类型，连void都没有。</li><li>没有具体的返回值。</li></ul></li><li>构造方法注意事项与重载<ul><li>如果我们没有给出构造方法，系统将会提供一个默认的无参构造方法供我们使用。</li><li>如果我们给出了构造方法，系统将不在提供默认的无参构造方法供我们使用。<br>这个时候，如果我们想使用无参构造方法，就必须自己提供。<br>推荐：自己给无参构造方法。</li><li>构造方法也是可以重载的,重载条件和普通方法相同。</li></ul></li></ul><h1 id="JAVA常用API"><a href="#JAVA常用API" class="headerlink" title="JAVA常用API"></a>JAVA常用API</h1><h2 id="API概述"><a href="#API概述" class="headerlink" title="API概述"></a>API概述</h2><ul><li>API(Application Programming Interface):应用程序编程接口。</li><li>String类：<ul><li>通过构造方法创建的字符串对象和直接赋值方式创建的字符串对象有什么区别呢?<ul><li>通过构造方法创建字符串对象是在堆内存。</li><li>直接赋值方式创建对象是在方法区的常量池。</li></ul></li></ul></li><li>“==”比较符：<ul><li>比较基本数据类型：比较的是基本数据类型的值是否相同。</li><li>比较引用数据类型：比较的是引用数据类型的地址值是否相同。</li></ul></li><li>StringBuilder类<ul><li>StringBuilder:是一个可变的字符串。字符串缓冲区类。  </li><li>String和StringBuilder的区别：<ul><li>String的内容是固定的，String拼接的时候<strong>会开辟</strong>一个新的内存空间。</li><li>StringBuilder的内容是可变的，拼接的时候<strong>不会开辟</strong>新的内存空间。</li></ul></li></ul></li></ul><h2 id="对象数组"><a href="#对象数组" class="headerlink" title="对象数组"></a>对象数组</h2><ul><li>概述<ul><li>基本类型的数组:存储的元素为基本类型：<code>int[] arr=&#123;1,2,3,4&#125;</code></li><li>对象数组:存储的元素为引用类：<code>Student[] stus=new Student[3]</code><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2></li></ul></li><li>特点：长度可变。</li><li>ArrayList<E>集合:<ul><li>取长度：size();</li></ul></li></ul><h2 id="IO流及FileWriter类、FileReader类-基本流-使用"><a href="#IO流及FileWriter类、FileReader类-基本流-使用" class="headerlink" title="IO流及FileWriter类、FileReader类(基本流)使用"></a>IO流及FileWriter类、FileReader类(基本流)使用</h2><ul><li>IO概述及分类：<ul><li>IO流用来处理设备之间的数据传输。</li><li>Java对数据的操作是通过流的方式。</li><li>Java用于操作流的类都在IO包中。</li><li>流按流向分为两种：输入流、输出流。</li></ul></li><li>FileWriter类使用：<ul><li>FileWriter向文件中写数据<ul><li>步骤:<ul><li>使用FileWriter流关联文件</li><li>利用FileWriter的写方法写数据</li><li>利用FileWriter的刷新方法将数据从内存刷到硬盘上</li><li>利用FileWriter的关流方法将释放占用的系统底层资源</li></ul></li><li>FileWriter方法:<ul><li>构造方法<ul><li>FileWriter(String fileName)//传入一个文件的路径</li></ul></li><li>成员方法<ul><li>void write(String str)//向文件中写str</li><li>void flush()//将内存中的数据刷新到文件中(刷新缓冲区。流对象还可以继续使用)</li><li>void close()//关流释放系统底层资源(先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileWriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;e:\\a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//FileWriter fw = new FileWriter(new File(&quot;e:\\a.txt&quot;), true); //设置成true就是追加</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 创建输出流对象做了哪些事情:</span></span><br><span class="line"><span class="comment">        * A:调用系统资源创建了一个文件</span></span><br><span class="line"><span class="comment">        * B:创建输出流对象</span></span><br><span class="line"><span class="comment">        * C:把输出流对象指向文件</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用输出流对象的写数据的方法</span></span><br><span class="line">        <span class="comment">//写一个字符串数据</span></span><br><span class="line">        fw.write(<span class="string">&quot;第一行&quot;</span>);</span><br><span class="line">        <span class="comment">/*如何实现数据的换行?</span></span><br><span class="line"><span class="comment">        &#x27;\n&#x27;可以实现换行，但是windows系统自带的记事本打开并没有换行，这是为什么呢?</span></span><br><span class="line"><span class="comment">        因为windows识别的换行不是\n，而是\r\n</span></span><br><span class="line"><span class="comment">            windows:\r\n</span></span><br><span class="line"><span class="comment">            linux:\n</span></span><br><span class="line"><span class="comment">            mac:\r</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        fw.write(<span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">        fw.write(<span class="string">&quot;第二行&quot;</span>);</span><br><span class="line">        <span class="comment">//数据没有直接写到文件，其实是写到了内存缓冲区</span></span><br><span class="line">        fw.flush();<span class="comment">//刷新缓冲区。流对象还可以继续使用。</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="comment">//通知系统释放和该文件相关的资源</span></span><br><span class="line">        fw.close();<span class="comment">//先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul></li><li>FileReader类使用：<ul><li>FileReader读数据一次读取一个字符<ul><li>输入流读文件的步骤：<ul><li>创建输入流对象。</li><li>调用输入流对象的读数据方法。</li><li>释放资源。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//调用输入流对象的读数据方法</span></span><br><span class="line">        <span class="comment">//int read():一次读取一个字符</span></span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span> ((ch = fr.read()) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.print((<span class="keyword">char</span>) ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li>利用FileReader和FileWriter完成文件复制<ul><li>读一次写一次:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFileDemo</span> </span>&#123;<span class="comment">//a.txt-&gt;b.txt</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;f://b.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//读写数据</span></span><br><span class="line">        <span class="keyword">int</span> ch;</span><br><span class="line">        <span class="keyword">while</span>((ch=fr.read())!=-<span class="number">1</span>) &#123;</span><br><span class="line">            fw.write(ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>利用字符数组拷贝文件:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CopyFileDemo2</span> </span>&#123;<span class="comment">//a.txt-&gt;b.txt</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;f://b.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//读写数据</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span>((len=fr.read(chs))!=-<span class="number">1</span>) &#123;</span><br><span class="line">            fw.write(chs, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">        fr.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="缓冲流介绍和使用"><a href="#缓冲流介绍和使用" class="headerlink" title="缓冲流介绍和使用"></a>缓冲流介绍和使用</h2></li></ul></li><li>BufferedWriter:将文本写入字符输出流，缓冲各个字符，从而提供单个字符、数组和字符串的高效写入。   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedWriterDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输出缓冲流对象</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;f://a.txt&quot;</span>));</span><br><span class="line">        bw.write(<span class="string">&quot;hello&quot;</span>);</span><br><span class="line">        bw.newLine();<span class="comment">//写入一个换行符，这个换行符由系统而定</span></span><br><span class="line">        <span class="comment">//bw.flush();</span></span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>BufferedReader:从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedReaderDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入缓冲流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//一次读写一个字符数组</span></span><br><span class="line">        <span class="comment">/*char[] chs = new char[1024];</span></span><br><span class="line"><span class="comment">        int len;</span></span><br><span class="line"><span class="comment">        while((len=br.read(chs))!=-1) &#123;</span></span><br><span class="line"><span class="comment">            System.out.print(new String(chs,0,len));</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        <span class="comment">//一次读取一行，但不会读取换行符</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(line);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>缓冲流复制文本文件:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedCopyFileDemo</span> </span>&#123;<span class="comment">//a.txt-&gt;b.txt</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入缓冲流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//创建输出缓冲流对象</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;f://b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读写数据</span></span><br><span class="line">        <span class="comment">//一次读写一个字符数组</span></span><br><span class="line">        <span class="keyword">char</span>[] chs = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = br.read(chs)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bw.write(chs, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>缓冲流的特有方法使用:<ul><li>BufferedWriter:<ul><li>void newLine():写一个换行符，这个换行符由系统决定,不同的操作系统newLine()方法使用的换行符不同<br> windows:\r\n<br> linux:\n<br> mac:\r</li></ul></li><li>BufferedReader<ul><li>String readLine():一次读取一行数据，但是不读取换行符</li></ul></li></ul></li><li>缓冲流的特有方法复制文件:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedCopyFileDemo2</span> </span>&#123;<span class="comment">//a.txt-&gt;b.txt</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入缓冲流对象</span></span><br><span class="line">        BufferedReader br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">&quot;f://a.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//创建输出缓冲流对象</span></span><br><span class="line">        BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">&quot;f://b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读写数据</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            bw.write(line);</span><br><span class="line">            bw.newLine();</span><br><span class="line">            bw.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        bw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="static静态关键字"><a href="#static静态关键字" class="headerlink" title="static静态关键字"></a>static静态关键字</h2><ul><li>静态概述：<ul><li>当在定义类的时候，类中都会有相应的属性和方法。而属性和方法都是通过创建本类对象调用的。当在调用对象的某个方法时，这个方法没有访问到对象的特有数据时，方法创建这个对象有些多余。可是不创建对象，方法又调用不了，这时就会想，那么我们能不能不创建对象，就可以调用方法呢？<br>答案是可以的，我们可以通过static关键字来实现。static它是静态修饰符，一般用来修饰类中的成员。</li></ul></li><li>静态的特点：<ul><li>被static修饰的成员变量属于类，不属于这个类的某个对象，被所有的对象所共享。<br>(也就是说，多个对象在访问或修改static修饰的成员变量时，其中一个对象将static成员变量值进行了修改，其他对象中的static成员变量值跟着改变，即多个对象共享同一个static成员变量)</li><li>被static修饰的成员可以并且建议通过类名直接访问<br>  访问静态成员的格式:<ul><li>类名.静态成员变量名</li><li>类名.静态成员方法名(参数)</li></ul></li><li>静态的加载优先于对象。</li><li>随着类的加载而加载。</li></ul></li><li>静态的注意事项：<ul><li>静态成员只能直接访问静态成员。</li><li>非静态成员既可以访问非静态成员也可以访问静态成员。</li><li>即：<ul><li>静态方法：<pre><code>- 可以调用静态的成员变量</code></pre><ul><li>可以调用静态的成员方法<ul><li>不可以调用非静态成员变量</li><li>不可以调用非静态成员方法</li><li>静态方法只能调用静态的成员</li></ul></li><li>非静态方法：<ul><li>可以调用静态的成员变量</li><li>可以调用静态的成员方法</li><li>可以调用非静态的成员变量</li><li>可以调用非静态的成员方法</li></ul></li></ul></li><li>静态的方法中没有this这个对象。</li></ul></li></ul></li><li>静态的优缺点：<ul><li>优点:<ul><li>对对象的共享数据提供单独空间的存储，节省空间，没有必要每一个对象都存储一份</li><li>可以直接被类名调用,不用在堆内存创建对象</li><li>静态成员可以通过类名直接访问,相对创建对象访问成员方便</li></ul></li><li>弊端:<ul><li>访问出现局限性。（静态虽好，但只能访问静态）<h2 id="静态的应用-Math类"><a href="#静态的应用-Math类" class="headerlink" title="静态的应用(Math类)"></a>静态的应用(Math类)</h2></li></ul></li></ul></li><li>Math.abs(double a)//返回绝对值</li><li>Math.ceil(double a)//天花板   向上取整</li><li>Math.floor(double a)//地板  向下取整</li><li>Math.round(double a)//四舍五入</li><li>Math.pow(double a, double b)//返回第一个参数的第二个参数次幂(a的b次方)</li><li>Math.random()//返回一个随机数，大于零且小于一<h2 id="类变量与实例变量辨析"><a href="#类变量与实例变量辨析" class="headerlink" title="类变量与实例变量辨析"></a>类变量与实例变量辨析</h2></li><li>类变量:其实就是静态变量<ul><li>定义位置:定义在类中方法外</li><li>所在内存区域:方法区</li><li>生命周期:随着类的加载而加载</li><li>特点:无论创建多少对象,类变量仅在方法区中,并且只有一份</li></ul></li><li>实例变量:其实就是非静态变量<ul><li>定义位置:定义在类中方法外</li><li>所在内存区域:堆</li><li>生命周期:随着对象的创建而加载</li><li>特点:每创建一个对象,堆中的对象中就有一份实例变量<h2 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h2></li></ul></li><li>局部代码块：定义在方法或语句中。<ul><li>以”{}”划定的代码区域，此时只需要关注作用域的不同即可</li><li>方法和类都是以代码块的方式划定边界的</li></ul></li><li>构造代码块：定义在类中成员位置的代码块。<ul><li>优先于构造方法执行，构造代码块用于执行所有对象均需要的初始化动作</li><li>每创建一个对象<strong>均会执行</strong>一次构造代码块。</li></ul></li><li>静态代码块：定义在成员位置，使用static修饰的代码块。<ul><li>随着类的加载而加载，只加载一次，加载类时需要做的一些初始化，比如加载驱动等。</li><li>它优先于主方法执行、优先于构造代码块执行，当以任意形式第一次使用到该类时执行。</li><li>该类不管创建多少对象，静态代码块<strong>只执行一次</strong>。</li><li>可用于给静态变量赋值，用来给类进行初始化。</li></ul></li></ul><h2 id="继承-面向对象三大特性之一"><a href="#继承-面向对象三大特性之一" class="headerlink" title="继承(面向对象三大特性之一)"></a>继承(面向对象三大特性之一)</h2><h3 id="继承的概述："><a href="#继承的概述：" class="headerlink" title="继承的概述："></a>继承的概述：</h3><ul><li>在现实生活中，继承一般指的是子女继承父辈的财产。在程序中，继承描述的是事物之间的所属关系，通过继承可以使多种事物之间形成一种关系体系。</li><li>多个类有共同的成员变量和成员方法，抽取到另外一个类中（父类），在让多个类去继承这个父类，我们的多个类就可以获取到父类中的成员了。<h3 id="继承的格式及使用："><a href="#继承的格式及使用：" class="headerlink" title="继承的格式及使用："></a>继承的格式及使用：</h3></li><li>在程序中，如果想声明一个类继承另一个类，需要使用extends关键字。</li><li>格式：<code>class 子类 extends 父类 &#123;&#125;</code>。<h3 id="继承的特点："><a href="#继承的特点：" class="headerlink" title="继承的特点："></a>继承的特点：</h3></li><li>在Java中，类只支持单继承，不允许多继承，也就是说一个类只能有一个直接父类。</li><li>多个类可以继承一个父类。</li><li>在Java中，多层继承是可以的，即一个类的父类可以再去继承另外的父类。</li><li>在Java中，子类和父类是一种相对概念，也就是说一个类是某个类父类的同时，也可以是另一个类的子类。<h3 id="继承中成员变量的特点："><a href="#继承中成员变量的特点：" class="headerlink" title="继承中成员变量的特点："></a>继承中成员变量的特点：</h3></li><li>子类只能获取父类<strong>非私有成员</strong><ul><li>子父类中成员变量的名字不一样直接获取父类的成员变量。</li><li>子父类中成员变量名字是一样的获取的是子类的成员变量。</li></ul></li><li>就近原则：谁离我近我就用谁<ul><li>如果有局部变量就使用局部变量。</li><li>如果没有局部变量，有子类的成员变量就使用子类的成员变量。</li><li>如果没有局部变量和子类的成员变量，有父类的成员变量就使用父类的成员变量。</li></ul></li><li>super:可以获取父类的成员变量和成员方法,用法和this是相似的。<h3 id="继承中成员方法的特点及方法重写"><a href="#继承中成员方法的特点及方法重写" class="headerlink" title="继承中成员方法的特点及方法重写"></a>继承中成员方法的特点及方法重写</h3></li><li>子类中没有这个方法,则调用父类的。</li><li>子类中重写了这个方法，则调用子类的。<ul><li><strong>方法的重写</strong>：在子父类当中，子类的方法和父类的完全一样，子类重写了父类的方法（覆盖），当子类重写了父类的方法之后，使用子类对象调用的就是子类的方法。</li><li><strong>方法的重载</strong>：在一个类中，有多个重名的方法，但是其参数不一样（参数的个数，参数的类型，参数的顺序），和返回值无关。<h3 id="方法重写的应用场景及注意事项"><a href="#方法重写的应用场景及注意事项" class="headerlink" title="方法重写的应用场景及注意事项"></a>方法重写的应用场景及注意事项</h3></li></ul></li><li>应用场景：当父类的方法不能完全满足子类使用的时候，既可以保留父类的功能（沿袭、传承），还可以有自己特有的功能</li><li>注意事项：<ul><li>不能重写父类私有的成员方法，压根就看不到父类的私有成员</li><li>权限必须大于等于父类方法的权限<ul><li>注解：@Override(方法重写，说明下面的方法是重写父类的方法)<h3 id="继承中构造方法的执行顺序"><a href="#继承中构造方法的执行顺序" class="headerlink" title="继承中构造方法的执行顺序"></a>继承中构造方法的执行顺序</h3></li></ul></li></ul></li><li><code>super(实参列表);</code>：在子类的构造方法中使用,用来调用父类中的构造方法(具体哪一个由传递的参数决定),并且只能在构造方法第一行使用</li><li><code>this(实参列表);</code>:在类的构造方法中使用,用来调用本类中的其它构造方法(具体哪一个由传递的参数决定),并且只能在构造方法的第一行使用</li><li>在子类的构造方法的第一行代码如果没有调用父类的构造或者没有调用子类的其他构造，则默认调用父类无参构造。</li><li>为什么要调用父类构造？<ul><li>因为需要给父类的成员变量初始化。</li></ul></li><li>肯定会先把父类的构造执行完毕，在去执行子类构造中的其他代码。<h3 id="this和super的区别"><a href="#this和super的区别" class="headerlink" title="this和super的区别"></a>this和super的区别</h3></li><li>this:当前对象的引用<ul><li>调用子类的成员变量。</li><li>调用子类的成员方法。</li><li>在子类的构造方法第一行调用子类其他构造方法。</li></ul></li><li>super:子类对象的父类引用<ul><li>调用父类的成员变量。</li><li>调用父类的成员方法。</li><li>在子类的构造方法第一行调用父类的构造方法。<h3 id="继承优缺点"><a href="#继承优缺点" class="headerlink" title="继承优缺点"></a>继承优缺点</h3></li></ul></li><li>优点<ul><li>提高了代码的复用性</li><li>提高了代码的可维护性</li></ul></li><li>缺点：<ul><li>类的耦合性增强了</li><li>开发的原则：高内聚低耦合<ul><li>内聚：就是自己完成某件事情的能力</li><li>耦合：类与类的关系<h2 id="匿名对象及final"><a href="#匿名对象及final" class="headerlink" title="匿名对象及final"></a>匿名对象及final</h2><h3 id="匿名对象定义及使用"><a href="#匿名对象定义及使用" class="headerlink" title="匿名对象定义及使用"></a>匿名对象定义及使用</h3></li></ul></li></ul></li><li>匿名对象即无名对象,直接使用new关键字来创建对象。</li><li>应用场景：<ul><li>当方法只调用一次的时候可以使用匿名对象。</li><li>可以当作参数进行传递，但是无法在传参之前做其他的事情。</li></ul></li><li>注意：匿名对象可以调用成员变量并赋值，但是赋值并没有意义。<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3></li><li><strong>final</strong>：修饰符，可以用于修饰类、成员方法和成员变量<ul><li>final所修饰的类：不能被继承，不能有子类</li><li>final所修饰的方法:不能被重写</li><li>final所修饰的变量：是不可以修改的，是常量<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2></li></ul></li><li>概述：<ul><li>当编写一个类时，我们往往会为该类定义一些方法，这些方法是用来描述该类的功能具体实现方式，那么这些方法都有具体的方法体。</li><li>但是有的时候，某个父类只是知道子类应该包含怎么样的方法，但是无法准确知道子类如何实现这些方法。比如一个图形类应该有一个求周长的方法，但是不同的图形求周长的算法不一样。那该怎么办呢？</li><li>分析事物时，发现了共性内容，就出现向上抽取。会有这样一种特殊情况，就是<strong>方法功能声明相同</strong>，但<strong>方法功能主体不同</strong>。那么这时也可以抽取，但只抽取方法声明，不抽取方法主体。那么此方法就是一个<strong>抽象方法</strong>。</li></ul></li><li><strong>abstract</strong>:关键字，用于修饰方法和类<ul><li>抽象方法：不同类的方法是相似，但是具体内容又不太一样，所以我们只能抽取他的声明，没有具体的方法体。</li><li>抽象类：有抽象方法的类必须是抽象类</li></ul></li><li>抽象类的特点<ul><li>抽象方法<strong>只能</strong>在抽象类里面<ul><li>抽象类和抽象方法<strong>必须被abstract修饰</strong></li><li>抽象类不能创建对象（不能实例化）</li><li>抽象类中可以有非抽象的方法</li><li>抽象类和类的关系也是继承</li><li>一个类继承了抽象类要么<strong>重写所有</strong>的抽象方法，要么他自己是<strong>抽象类</strong></li></ul></li></ul></li><li>抽象类的成员的特点:<ul><li>成员变量<ul><li>可以有成员变量</li><li>可以有常量</li></ul></li><li>成员方法<ul><li>可以有抽象方法</li><li>可以有非抽象方法</li></ul></li><li>构造方法<ul><li>可以有构造方法的，需要对抽象类的成员变量进行初始化</li></ul></li></ul></li><li>抽象类的细节:<ul><li>抽象类关键字abstract<strong>不可以</strong>和哪些关键字共存?<ul><li>private：私有的方法子类是无法继承到的，也不存在覆盖，而abstract和private一起使用修饰方法，abstract既要子类去实现这个方法，而private修饰子类根本无法得到父类这个方法。互相矛盾。</li><li>final: <ul><li>抽象类不能和final共存,因为抽象类自身无法创建对象,我们需要通过子类创建对象,一旦抽象类使用final关键字,那么抽象类就没有子类</li><li>抽象方法不能和final共存,因为抽象方法后期需要被子类重写,一旦加final无法重写   </li></ul></li><li>static：抽象方法不能和static关键字共存,因为一旦加static我们就可以通过类名直接访问抽象方法,由于抽象方法没有方法体,没有任何意义,也不允许这样做</li></ul></li><li>抽象类中是否可以不定义抽象方法?<ul><li>是可以的，那这个抽象类的存在到底有什么意义呢？不让该类创建对象,方法可以直接让子类去使用</li></ul></li><li>抽象类是否有构造函数?<ul><li>有,抽象类的构造函数,是由子类的super语句来调用,用于给抽象类中的成员初始化</li></ul></li></ul></li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><ul><li>概述：<ul><li>接口是功能的集合，同样可看做是一种<strong>数据类型</strong>，是比抽象类更为抽象的”类”。</li><li>接口<strong>只描述</strong>所应该具备的方法，并没有具体实现，具体的实现由接口的实现类(相当于接口的子类)来完成。这样将功能的定义与实现分离，优化了程序设计。</li></ul></li><li>格式：<ul><li>与定义类的class不同，接口定义时需要使用<strong>interface</strong>关键字。</li><li>定义接口所在的仍为.java文件，虽然声明时使用的为interface关键字的编译后仍然会产生.class文件。这点可以让我们将接口看做是一种只包含了功能声明的特殊类。</li><li>定义格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> 接口名 </span>&#123;</span><br><span class="line">    抽象方法<span class="number">1</span>;</span><br><span class="line">    抽象方法<span class="number">2</span>;</span><br><span class="line">    抽象方法<span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>接口的使用:<ul><li>接口中的方法全是<strong>抽象方法</strong>,直接new接口来调用方法没有意义,Java也不允许这样干</li><li>类与接口的关系为实现关系，即<strong>类实现接口</strong>。实现的动作类似继承，只是关键字不同，实现使用<strong>implements</strong></li><li>其他类(实现类)实现接口后，就相当于声明：”我应该具备这个接口中的功能”。实现类仍然必须要重写方法以实现具体的功能。</li><li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类 <span class="keyword">implements</span> 接口 </span>&#123;</span><br><span class="line">    重写接口中方法</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure></li><li>在类实现接口后，该类就会将接口中的抽象方法继承过来，此时该类必须重写该抽象方法，完成具体的逻辑。</li></ul></li><li>接口中成员的特点:<ul><li>接口中可以<strong>定义变量</strong>，但是变量必须有<strong>固定</strong>的修饰符修饰，<strong>public static final</strong> 所以接口中的变量也称之为<strong>常量</strong>，其值不能改变。</li><li>接口中可以定义方法，方法也有<strong>固定</strong>的修饰符，<strong>public abstract</strong></li><li>接口不可以创建对象。</li><li>子类<strong>必须覆盖</strong>掉接口中<strong>所有</strong>的抽象方法后，子类才可以实例化。<strong>否则</strong>子类是一个<strong>抽象类</strong>。</li></ul></li><li>接口和类的关系：<ul><li>类与类之间:<strong>继承</strong>关系,一个类<strong>只能直接继承一个</strong>父类,但是支持<strong>多层继承</strong></li><li>类与接口之间:只有<strong>实现</strong>关系,一个类可以<strong>实现多个接口</strong></li><li>接口与接口之间:只有<strong>继承</strong>关系,一个接口可以<strong>继承多个接口</strong></li></ul></li><li>接口的思想：<ul><li>举例：我们都知道电脑上留有很多个插口，而这些插口可以插入相应的设备，这些设备为什么能插在上面呢？主要原因是这些设备在生产的时候符合了这个插口的使用规则，否则将无法插入接口中，更无法使用。发现这个插口的出现让我们使用更多的设备。</li><li>接口的出现方便后期使用和维护，一方是在使用接口（如电脑），一方在实现接口（插在插口上的设备）。例如：笔记本使用这个规则（接口），电脑外围设备实现这个规则（接口）。</li><li>集合体系中大量使用接口<ul><li>Collection接口<ul><li>List接口<ul><li>ArrayList实现类</li><li>LinkedList实现类</li></ul></li><li>Set接口</li></ul></li></ul></li></ul></li><li>接口优点：<ul><li><strong>类与接口</strong>的关系，<strong>实现</strong>关系，而且是<strong>多实现</strong>，一个类可以实现多个接口，<strong>类与类</strong>之间是<strong>继承</strong>关系，java中的继承是<strong>单一继承</strong>，一个类只能有一个父类，<strong>打破了继承的局限性</strong>。</li><li>对外提供规则（USB接口）</li><li>降低了程序的耦合性（可以实现模块化开发，定义好规则，每个人实现自己的模块，提高了开发的效率）</li></ul></li><li>接口和抽象类的区别：<ul><li>共性：不断的进行抽取，抽取出抽象的，没有具体实现的方法,都不能实例化（不能创建对象）</li><li>区别:    <ul><li>与类的关系：类与接口是实现关系，而且是多实现，一个类可以实现多个接口，类与抽象类是继承关系，Java中的继承是单一继承，多层继承，一个类只能继承一个父类，但是可以有爷爷类</li><li>成员上的区别：<ul><li>成员变量<ul><li><strong>抽象类</strong>可以有成员变量，也可以有常量</li><li><strong>接口</strong>只能有常量，默认修饰符public static final</li></ul></li><li>成员方法<ul><li><strong>抽象类</strong>可以有抽象方法，也可以有非抽象方法</li><li><strong>接口</strong>只能有抽象方法，默认修饰符 public abstract</li></ul></li><li>构造方法<ul><li><strong>抽象类</strong>有构造方法，为子类提供</li><li><strong>接口</strong>没有构造方法 <h2 id="多态-面向对象三大特性之一"><a href="#多态-面向对象三大特性之一" class="headerlink" title="多态(面向对象三大特性之一)"></a>多态(面向对象三大特性之一)</h2></li></ul></li></ul></li></ul></li></ul></li><li>概述：<ul><li>现实事物经常会体现出多种形态，如学生，学生是人的一种，则一个具体的同学张三既是学生也是人，即出现两种形态。    </li><li>Java作为面向对象的语言，同样可以描述一个事物的多种形态。如Student类继承了Person类，一个Student的对象便既是Student，又是Person</li></ul></li><li>多态的定义格式:<br>&emsp;&emsp;就是<strong>父类的引用变量指向子类对象</strong>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">父类类型  变量名 = <span class="keyword">new</span> 子类类型();</span><br><span class="line">变量名.方法名();</span><br></pre></td></tr></table></figure></li><li><strong>普通类多态</strong>定义的格式:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类 变量名 = <span class="keyword">new</span> 子类();</span><br></pre></td></tr></table></figure>  如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;&#125;</span><br><span class="line"><span class="comment">//类的多态使用</span></span><br><span class="line">   Fu f = <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li><li><strong>抽象类多态</strong>定义的格式:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">抽象类 变量名 = <span class="keyword">new</span> 抽象类子类();</span><br></pre></td></tr></table></figure>  如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">extends</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“重写父类抽象方法”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类的多态使用</span></span><br><span class="line">Fu fu= <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li><li><strong>接口多态</strong>定义的格式:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口 变量名 = <span class="keyword">new</span> 接口实现类();</span><br></pre></td></tr></table></figure>  如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zi</span> <span class="keyword">implements</span> <span class="title">Fu</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(“重写接口抽象方法”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//接口的多态使用</span></span><br><span class="line">Fu fu = <span class="keyword">new</span> Zi();</span><br></pre></td></tr></table></figure></li><li>多态的前提：<ul><li>子父类的继承关系</li><li>方法的重写</li><li>父类引用指向子类对象</li></ul></li><li>动态绑定：运行期间调用的方法，是根据其具体的类型</li><li>多态成员的特点:<ul><li>多态<strong>成员变量</strong><ul><li>当子父类中出现同名的成员变量时，多态调用该变量时：<ul><li>编译时期：参考的是引用型变量所属的类中是否有被调用的成员变量。没有，编译失败。</li><li>运行时期：也是调用引用型变量所属的类中的成员变量。</li></ul></li><li>简单记：编译和运行都参考等号的左边。编译运行看左边。</li></ul></li><li>多态<strong>成员方法</strong><ul><li>当子父类中出现同名的成员方法时，多态调用该方法时：<ul><li>编译时期：参考引用变量所属的类，如果没有类中没有调用的方法，编译失败。</li><li>运行时期：参考引用变量所指的对象所属的类，并运行对象所属类中的成员方法。</li></ul></li><li>简而言之：编译看左边，运行看右边</li></ul></li><li>多态<strong>静态方法</strong><ul><li>简而言之：编译时看的是左边，运行时看的也是左边</li></ul></li><li>总结：<strong>编译</strong>时看的都是<strong>左边</strong>，<strong>运行</strong>时<strong>成员方法</strong>看的是<strong>右边</strong>，其他（成员变量和静态的方法）看的都是左边</li></ul></li><li>多态中<strong>向上转型</strong>与<strong>向下转型</strong>：<ul><li>多态的转型分为向上转型与向下转型两种：</li><li><strong>向上转型</strong>(由小到大,子类型转换成父类型)：当有子类对象赋值给一个父类引用时，便是向上转型，多态本身就是向上转型的过程。<br>使用格式：<br><code>父类类型  变量名 = new 子类类型();</code><br>如：<br><code>Person p = new Student();</code></li><li><strong>向下转型</strong>(由大到小)：一个已经向上转型的子类对象可以使用强制类型转换的格式，将父类引用转为子类引用，这个过程是向下转型。如果是直接创建父类对象，是无法向下转型的。<br>使用格式：<br><code>子类类型 变量名 = (子类类型) 父类类型的变量;</code><br>如:<br><code>Student stu = (Student) p;  //变量p 实际上指向Student对象</code></li><li>引用类型之间的转换:<ul><li>向上转型:由小到大(子类型转换成父类型)</li><li>向下转型:由大到小</li></ul></li><li>基本数据类型的转换:<ul><li>自动类型转换:由小到大<br>byte short char —&gt; int —&gt; long —&gt; float —&gt; double</li><li>强制类型转换:由大到小</li></ul></li></ul></li><li>多态的优缺点：<ul><li>优点：可以提高可维护性（多态前提所保证的），提高代码的可扩展性。</li><li>缺点：无法直接访问子类特有的成员。</li></ul></li></ul><h2 id="包和权限修饰符"><a href="#包和权限修饰符" class="headerlink" title="包和权限修饰符"></a>包和权限修饰符</h2><ul><li><p>包的概述：</p><ul><li>java的包，其实就是我们电脑系统中的文件夹，包里存放的是类文件。</li><li>当类文件很多的时候，通常我们会采用多个包进行存放管理他们，这种方式称为<strong>分包管理</strong>。</li><li>在项目中，我们将相同功能的类放到一个包中，方便管理。并且日常项目的分工也是以包作为边界。</li></ul></li><li><p>包的声明格式：</p><ul><li>通常使用公司网址反写，<strong>可以有多层包</strong>，包名采用全部小写字母，多层包之间用”.”连接,不同包下的文件名可以重复。</li><li>类中包的声明格式：<code>package 包名.包名.包名…;</code></li><li>注意：声明包的语句，必须写在程序有效代码的第一行（注释不算)</li></ul></li><li><p>包之间互相访问：</p><ul><li>在访问类时，为了能够找到该类，必须使用含有包名的类全名（包名.类名）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">包名.包名….类名</span><br><span class="line">如：java.util.Scanner</span><br><span class="line">    java.util.Random</span><br><span class="line"> cn.lxy.Demo</span><br><span class="line">带有包的类，创建对象格式：</span><br><span class="line">包名.类名 变量名 = <span class="keyword">new</span>包名.类名();</span><br><span class="line">如：cn.lxy.Demo d = <span class="keyword">new</span> cn.lxy.Demo();</span><br></pre></td></tr></table></figure></li><li>前提：<strong>包的访问与访问权限密切相关</strong>，这里以一般情况来说，即类用public修饰的情况。</li><li>类的简化访问:<ul><li>当我们要使用一个类时，这个类与当前程序在同一个包中（即同一个文件夹中），或者这个类是java.lang包中的类时通常可以省略掉包名，直接使用该类。</li></ul></li><li>我们每次使用类时，都需要写很长的包名。很麻烦，我们可以通过import导包的方式来简化。<ul><li>可以通过导包的方式使用该类，可以避免使用全类名编写（即，包类.类名）。</li><li>导包的格式：<code>import 包名.类名;</code></li></ul></li><li>注意：’*’代表的是通配符，代表导入了这个包下所有的类，并没有导入子包下的类</li></ul></li><li><p>权限修饰符:<br>在Java中提供了四种访问权限，使用不同的访问权限时，被修饰的内容会有不同的访问权限，以下表来说明不同权限的访问能力：</p><table><thead><tr><th></th><th>public</th><th>protected</th><th>default</th><th>private</th></tr></thead><tbody><tr><td>同一类中</td><td>√</td><td>√</td><td>√</td><td>√</td></tr><tr><td>同一包中(子类与无关类)</td><td>√</td><td>√</td><td>√</td><td></td></tr><tr><td>不同包的子类</td><td>√</td><td>√</td><td></td><td></td></tr><tr><td>不同包中的无关类</td><td>√</td><td></td><td></td><td></td></tr><tr><td>归纳一下：在日常开发过程中，编写的类、方法、成员变量的访问</td><td></td><td></td><td></td><td></td></tr><tr><td>&emsp;&emsp;A:要想仅能在本类中访问使用private修饰</td><td></td><td></td><td></td><td></td></tr><tr><td>&emsp;&emsp;B:要想本包中的类都可以访问除了private修饰符,其它都可以</td><td></td><td></td><td></td><td></td></tr><tr><td>&emsp;&emsp;C:要想本包中的类与其他包中的子类可以访问使用protected修饰</td><td></td><td></td><td></td><td></td></tr><tr><td>&emsp;&emsp;D:要想所有包中的所有类都可以访问使用public修饰。</td><td></td><td></td><td></td><td></td></tr><tr><td>注意：如果类用public修饰，则类名必须与文件名相同。一个文件中<strong>只能有一个public修饰的类</strong>。</td><td></td><td></td><td></td><td></td></tr></tbody></table></li><li><p>权限修饰符：</p><ul><li>public:当前类，相同包下不同的类,不同包下的类</li><li>default:当前类，相同包下不同的类(当前包下使用)</li><li>private:当前类</li><li>protected:当前类，相同包下不同的类(让子类对象使用)</li></ul></li><li><p>修饰符总结:</p><table><thead><tr><th>修饰符</th><th>类</th><th>成员变量</th><th>成员方法</th><th>构造方法</th></tr></thead><tbody><tr><td>public</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>default</td><td>Y</td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>protected</td><td></td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>private</td><td></td><td>Y</td><td>Y</td><td>Y</td></tr><tr><td>abstract</td><td>Y</td><td></td><td>Y</td><td></td></tr><tr><td>static</td><td></td><td>Y</td><td>Y</td><td></td></tr><tr><td>final</td><td>Y</td><td>Y</td><td>Y</td><td></td></tr></tbody></table><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2></li><li><p>概述：</p><ul><li>什么是内部类？<ul><li>将类写在其他类的内部，可以写在其他类的成员位置和局部位置，这时写在其他类内部的类就称为内部类。其他类也称为外部类。</li></ul></li><li>什么时候使用内部类？<ul><li>在描述事物时，若一个事物内部还包含其他可能包含的事物，比如在描述汽车时，汽车中还包含这发动机，这时发动机就可以使用内部类来描述。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 汽车 </span>&#123; <span class="comment">//外部类</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> 发动机 </span>&#123; <span class="comment">//内部类</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>成员内部类</strong>:</p><ul><li>定义在外部类中的成员位置。与类中的成员变量相似，可通过外部类对象进行访问</li><li>在类的成员位置，和成员变量以及成员方法所在的位置是一样的</li><li>在内部类当中，可以直接访问外部类的成员，包括私有成员</li><li>定义格式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123; </span><br><span class="line">    修饰符 <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">        <span class="comment">//其他代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>访问方式:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">外部类名.内部类名 变量名 = <span class="keyword">new</span> 外部类名().new 内部类名();</span><br></pre></td></tr></table></figure></li><li>成员内部类可以使用的修饰符:<strong>private,public,procted,final,static,abstract</strong></li></ul></li><li><p><strong>局部内部类</strong>:</p><ul><li>定义在外部类方法中的局部位置。与访问方法中的局部变量相似，可通过调用方法进行访问.</li><li>在方法内，出了方法之后就无法使用</li><li>定义格式<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123; </span><br><span class="line">    修饰符 返回值类型 方法名(参数) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">class</span> 内部类 </span>&#123;</span><br><span class="line">        <span class="comment">//其他代码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>访问方式:在外部类方法中，创建内部类对象，进行访问</li></ul></li><li><p><strong>匿名内部类</strong>:</p><ul><li>作用：匿名内部类是<strong>创建某个类型子类对象</strong>的<strong>快捷方式</strong>。</li><li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> 父类或接口()&#123;</span><br><span class="line"> <span class="comment">//如果是创建了继承这个类的子类对象，我们可以重写父类的方法</span></span><br><span class="line">    <span class="comment">//如果是创建了实现这个接口的子类对象，我们必须要实现该接口的所有方法</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li>可以把匿名内部类看成是一个没有名字的局部内部类</li><li>定义在方法当中</li><li>必须在定义匿名内部类的时候创建他的对象</li><li>原理：创建了<strong>继承</strong>这个<strong>类</strong>的子类对象或者是创建了<strong>实现</strong>这个<strong>接口</strong>的子类对象</li></ul></li></ul><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><ul><li>概述：Object类是Java语言中的根类，即<strong>所有类的父类</strong>。它中描述的所有方法子类都可以使用。所有类在创建对象的时候，最终找的父类就是Object。</li><li>获取字节码对象的方式：<ul><li>通过Object类的getClass()方法获取。</li><li>通过类名调用属性class来获取。</li><li>通过Class类的静态方法forName()来获取。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException  </span>&#123;</span><br><span class="line">        <span class="comment">//方式1通过Object类的getClass()方法获取</span></span><br><span class="line">        Teacher t = <span class="keyword">new</span> Teacher();</span><br><span class="line">        Class clazz = t.getClass();<span class="comment">//返回一个字节码对象</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式2通过类名调用属性class来获取</span></span><br><span class="line">        Class clazz2 = Teacher.class;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//方式3通过Class类的静态方法forName()来获取</span></span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">&quot;com.lxy.Teacher&quot;</span>);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>toString()方法<ul><li>由于toString方法返回的结果是<strong>内存地址</strong>，而在开发中，经常需要按照对象的属性得到相应的字符串表现形式，因此也需要<strong>重写</strong>它。</li></ul></li><li>equals()方法 <ul><li>用于比较两个对象是否相同，它其实就是使用两个对象的<strong>内存地址</strong>在<strong>比较</strong>。Object类中的equals方法内部使用的就是==比较运算符。</li><li>在开发中要比较两个对象是否相同，经常会根据对象中的属性值进行比较，也就是在开发经常需要子类重写equals方法根据对象的属性值进行比较。<h2 id="System类"><a href="#System类" class="headerlink" title="System类"></a>System类</h2>&emsp;&emsp;&emsp;System类包含一些有用的类字段和方法。它不能被实例化。</li></ul></li><li>成员方法<ul><li><code>static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length)</code>：从src源数组的srcPos索引开始,复制length个元素，从destPost位置开始将这些元素放至到dest数组中</li><li><code>static long currentTimeMillis()</code>：返回以毫秒为单位的当前时间(1970-1-1 0:0:0至今过了多少毫秒)</li><li><code>static void exit(int status)</code>:终止当前正在运行的Java虚拟机<h2 id="日期相关类"><a href="#日期相关类" class="headerlink" title="日期相关类"></a>日期相关类</h2><h3 id="Date类"><a href="#Date类" class="headerlink" title="Date类"></a>Date类</h3></li></ul></li><li>Date:表示特定的瞬间，精确到毫秒，他可以通过方法来设定自己所表示的时间，可以表示任意的时间</li><li>Date类的构造方法<ul><li><code>Date()</code>：创建的是一个表示当前系统时间的Date对象</li><li><code>Date(long date)</code>：根据”指定时间”创建Date对象</li></ul></li><li>Date类<strong>常用方法</strong><ul><li><code>void setTime(long time)</code>:设置时间（毫秒）</li><li><code>long getTime()</code>：获取时间（毫秒）<h3 id="DateFormat类-amp-SimpleDateFormat类-日期-时间格式化类"><a href="#DateFormat类-amp-SimpleDateFormat类-日期-时间格式化类" class="headerlink" title="DateFormat类&amp;SimpleDateFormat类(日期/时间格式化类)"></a>DateFormat类&amp;SimpleDateFormat类(日期/时间格式化类)</h3></li></ul></li><li>DateFormat：是日期/时间格式化子类的抽象类，它以与语言无关的方式格式化并解析日期或时间。日期/时间格式化子类（如 SimpleDateFormat类）允许进行格式化（也就是日期-&gt;文本）、解析（文本-&gt;日期）和标准化。<ul><li>我们通过这个类可以帮我们完成日期和文本之间的转换。</li></ul></li><li>DateFormat&amp;SimpleDateFormat的常用方法<ul><li>要格式化一个当前语言环境下的日期也就是日期-&gt;文本），要通过下面的方法来完成。DateFormat是抽象类，我们需要使用其子类SimpleDateFormat来创建对象。</li><li>SimpleDateFormat构造方法：<ul><li><code>SimpleDateFormat()</code>:用默认的模式和默认语言环境的日期格式符号构造SimpleDateFormat。</li><li><code>SimpleDateFormat(String pattern)</code>:用给定的模式和默认语言环境的日期格式符号构造SimpleDateFormat。<h3 id="Calendar类-日历类"><a href="#Calendar类-日历类" class="headerlink" title="Calendar类(日历类)"></a>Calendar类(日历类)</h3></li></ul></li></ul></li><li>概述：<ul><li>Calendar是<strong>日历类</strong>，在Date后出现，替换掉了许多Date的方法。该类将所有可能用到的时间信息封装为静态成员变量，方便获取。</li><li>Calendar为<strong>抽象类</strong>，由于语言敏感性，Calendar类在创建对象时并非直接创建，而是通过静态方法创建，将语言敏感内容处理好，再返回子类对象，如下：<ul><li>Calendar类静态方法:<ul><li><code>static Calendar getInstance()</code>:使用默认时区和语言环境获得一个日历</li><li><code>Calendar c = Calendar.getInstance()</code>:返回当前时间</li></ul></li></ul></li></ul></li><li>Calendar类常用方法:<ul><li><code>abstract void add(int field,int amount)</code>:根据日历规则，为给定的日历字段添加或减去制定的时间量。</li><li><code>int get(int field)</code>：返回给定日历字段的值。</li><li><code>Date getTime()</code>：返回一个表示此Calendar时间值(从历元至现在的毫秒偏移量)的Date对象。</li><li><code>void set(int field,int value)</code>：将给定的日历字段设置为给定值。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalendarDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//static Calendar getInstance()</span></span><br><span class="line">        Calendar c = Calendar.getInstance();<span class="comment">//返回当前时间</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//void set(int field, int value) ：把指定的字段修改成指定的值</span></span><br><span class="line">        c.set(Calendar.DAY_OF_MONTH, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//void add(int field, int amount): 在指定的字段上加上指定的值</span></span><br><span class="line">        c.add(Calendar.DAY_OF_MONTH, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> year = c.get(Calendar.YEAR);</span><br><span class="line">        <span class="keyword">int</span> month = c.get(Calendar.MONTH) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> day = c.get(Calendar.DAY_OF_MONTH);</span><br><span class="line">        System.out.println(year + <span class="string">&quot;年&quot;</span> + month + <span class="string">&quot;月&quot;</span> + day + <span class="string">&quot;日&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="包装类-amp-正则表达式"><a href="#包装类-amp-正则表达式" class="headerlink" title="包装类&amp;正则表达式"></a>包装类&amp;正则表达式</h2><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3></li></ul></li><li>在实际程序使用中，程序界面上用户输入的数据都是以字符串类型进行存储的。而程序开发中，我们需要把字符串数据，根据需求转换成指定的基本数据类型，如年龄需要转换成int类型，考试成绩需要转换成double类型等。那么，想<strong>实现字符串与基本数据之间转换</strong>怎么办呢？</li><li>Java中提供了相应的对象来解决该问题，基本数据类型对象包装类：java将基本数据类型值封装成了对象。封装成对象有什么好处？可以提供更多的操作基本数值的功能。</li><li>8种基本类型对应的包装类如下：<table><thead><tr><th>字节型</th><th>短整型</th><th>整型</th><th>长整型</th><th>字符型</th><th>布尔型</th><th>浮点型</th><th>浮点型</th></tr></thead><tbody><tr><td>byte</td><td>short</td><td>int</td><td>long</td><td>char</td><td>boolean</td><td>float</td><td>double</td></tr><tr><td>Byte</td><td>Short</td><td>Integer</td><td>Long</td><td>Character</td><td>Boolean</td><td>Float</td><td>Double</td></tr></tbody></table></li><li>包装类的常用方法<ul><li>构造方法:<ul><li><code>Integer(int value)</code>：构造一个新分配的Integer对象，它表示制定的int值。</li><li><code>Integer(String s)</code>：构造一个新分配的Integer对象，它表示String参数所指示的int值。</li></ul></li><li>成员方法:<ul><li><code>int intValue()</code>：以int类型返回该Integer的值。</li><li><code>static int parseInt(String s)</code>：将字符串参数作为有符号的十进制整数进行解析。</li><li><code>String toString()</code>：返回一个表示该Integer值的String对象。</li></ul></li></ul></li><li>包装类的<strong>自动装箱</strong>与<strong>自动拆箱</strong><ul><li>在需要的情况下，<strong>基本类型与包装类型</strong>可以<strong>通用</strong>。有些时候我们必须使用引用数据类型时，可以传入基本数据类型。</li><li>比如：基本类型可以使用运算符直接进行计算，但是引用类型不可以。而基本类型包装类作为引用类型的一种却可以计算，原因在于，Java’偷偷地’自动地<strong>进行了对象向基本数据类型的转换</strong>。</li><li>相对应的，引用数据类型变量的值必须是new出来的内存空间地址值，而我们可以将一个基本类型的值赋值给一个基本类型包装类的引用。原因同样在于Java又’偷偷地’自动地<strong>进行了基本数据类型向对象的转换</strong>。</li><li><strong>自动拆箱</strong>：对象转成基本数值</li><li><strong>自动装箱</strong>：基本数值转成对象<h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3></li></ul></li><li><a href="./%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F.md">正则表达式</a></li></ul><h2 id="集合-amp-迭代器"><a href="#集合-amp-迭代器" class="headerlink" title="集合&amp;迭代器"></a>集合&amp;迭代器</h2><p>集合体系结构图:<br><img src="https://i.loli.net/2021/04/25/L8EQGW4rcveuTjz.png" alt="集合体系结构图.png"><br>在最顶层的父接口Collection中定义了所有子类集合的共同属性和方法,因此我们首先需要学习Collection中共性方法,然后再去针对每个子类集合学习它的特有方法。</p><ul><li>集合的体系结构：<ul><li>由于不同的数据结构（数据的组织，存储方式），所以Java为我们提供了不同的集合，但是不同的集合他们的功能都是相似，不断的向上提取，将共性抽取出来，这就是集合体系结构形成的原因。</li></ul></li><li>Collection中的常用功能：<ul><li><code>boolean add(Object e)</code>: 向集合中添加元素</li><li><code>void clear()</code>:清空集合中所有元素</li><li><code>boolean contains(Object o)</code>:判断集合中是否包含某个元素</li><li><code>boolean isEmpty()</code>:判断集合中的元素是否为空</li><li><code>boolean remove(Object o)</code>:根据元素的内容来删除某个元素</li><li><code>int size()</code>:获取集合的长度</li><li><code>Object[] toArray()</code>:能够将集合转换成数组并把集合中的元素存储到数组中</li></ul></li><li>迭代器:<ul><li>java中提供了很多个集合，它们在存储元素时，采用的存储方式不同。我们要取出这些集合中的元素，可通过一种<strong>通用的获取方式</strong>来完成。</li><li>Collection集合元素的<strong>通用获取方式</strong>：<ul><li>在取元素之前先要判断集合中有没有元素，如果有，就把这个元素取出来，继续再判断，如果还有就再取出出来。一直把集合中的所有元素全部取出。这种取出方式专业术语称为<strong>迭代</strong>。</li><li>集合中把这种取元素的方式描述在Iterator接口中。</li><li>Iterator接口的常用方法如下<ul><li><code>boolean hasNext()</code>方法：判断集合中是否有元素可以迭代 </li><li><code>E next()</code>方法：用来返回迭代的下一个元素，并把指针向后移动一位。</li></ul></li></ul></li><li>注意：在使用迭代器遍历集合时，不允许对元素进行增加或删除操作。<h2 id="增强for-amp-泛型"><a href="#增强for-amp-泛型" class="headerlink" title="增强for&amp;泛型"></a>增强for&amp;泛型</h2></li></ul></li><li>增强for：<ul><li>增强for循环是JDK1.5以后出来的一个高级for循环，专门用来遍历数组和集合的。</li><li>它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。</li><li>格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(元素的数据类型 变量 : Collection集合or数组)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>注意：它用于遍历Collection和数组。通常只进行遍历元素，不要在遍历的过程中对集合元素进行增删操作。</li></ul></li><li>泛型: <ul><li>在前面学习集合时，我们都知道集合中是可以存放任意对象的，只要把对象存储集合后，那么这时他们都会被提升成Object类型。当我们在取出每一个对象，并且进行相应的操作，这时必须采用类型转换。<h2 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h2></li></ul></li><li>数组：<ul><li>数组，采用该结构的集合，对元素的存取有如下的特点：<ul><li>数组的长度一旦定义则不可改变。</li><li>数组中的元素都有整数索引。</li><li>数组只能存储同一类型的元素。</li><li>数组既可以存储基本数据类型，也可以存储引用数据类型。</li><li>查找元素快：通过索引，可以快速访问指定位置的元素。</li><li>增删元素慢：每次添加元素需要移动大量元素或者创建新的数组。</li></ul></li></ul></li><li>链表：<ul><li>链表，采用该结构的集合，对元素的存取有如下的特点：<ul><li>多个节点之间，通过地址进行连接。例如，多个人手拉手，每个人使用自己的右手拉住下个人的左手，依次类推，这样多个人就连在一起了。</li><li>查找元素慢：想查找某个元素，需要通过连接的节点，依次向后查找指定元素。</li><li>增删元素快。</li><li>增加元素：只需要修改连接下个元素的地址即可。</li><li>删除元素：只需要修改连接下个元素的地址即可。</li></ul></li></ul></li><li>栈：<ul><li>堆栈，采用该结构的集合，对元素的存取有如下的特点：<ul><li><strong>先进后出</strong>（即，存进去的元素，要在后它后面的元素依次取出后，才能取出该元素）。例如，子弹压进弹夹，先压进去的子弹在下面，后压进去的子弹在上面，当开枪时，先弹出上面的子弹，然后才能弹出下面的子弹。</li></ul></li></ul></li><li>队列：<ul><li>队列，采用该结构的集合，对元素的存取有如下的特点：<ul><li><strong>先进先出</strong>（即，存进去的元素，要在后它前面的元素依次取出后，才能取出该元素）。例如，安检。排成一列，每个人依次检查，只有前面的人全部检查完毕后，才能排到当前的人进行检查。<h2 id="List子体系"><a href="#List子体系" class="headerlink" title="List子体系"></a>List子体系</h2></li></ul></li></ul></li><li>List子体系特点<ul><li><strong>有序的</strong>（存储和读取的顺序是一致的） </li><li>有整数<strong>索引</strong></li><li><strong>允许重复</strong>的</li></ul></li><li>List的特有功能：<ul><li><code>void add(int index, E element)</code> :将元素添加到index索引位置上<ul><li><code>E get(int index)</code> :根据index索引获取元素</li><li><code>E remove(int index)</code> :根据index索引删除元素</li><li><code>E set(int index, E element)</code>:将index索引位置的的元素设置为element</li></ul></li></ul></li><li><strong>LinkedList</strong>特有功能:<ul><li>LinkedList底层使用的是<strong>链表</strong>结构,因此增删快,查询相对ArrayList较慢</li><li><code>void addFirst(E e)</code>:向链表的头部添加元素</li><li><code>void addLast(E e)</code>:向链表的尾部添加元素</li><li><code>E getFirst()</code>:获取链头的元素,不删除元素</li><li><code>E getLast()</code>:获取链尾的元素,不删除元素</li><li><code>E removeFirst()</code>:返回链头的元素并删除链头的元素</li><li><code>E removeLast()</code>:返回链尾的元素并删除链尾的元素</li></ul></li><li>如何选择使用不同的集合？<ul><li>如果查询多，增删少，则使用ArrayList</li><li>如果查询少，增删多，则使用LinkedList</li><li>如果你不知道使用什么，则使用ArrayList</li></ul></li></ul><h2 id="HashSet集合"><a href="#HashSet集合" class="headerlink" title="HashSet集合"></a>HashSet集合</h2><ul><li>Set接口的特点:<ul><li>存入集合的顺序和取出集合的<strong>顺序不一致</strong></li><li><strong>没有索引</strong></li><li><strong>不可重复</strong></li></ul></li><li>HashSet唯一性原理:<ul><li>规则:新添加到HashSet集合的元素都会与集合中已有的元素一一比较<ul><li>首先比较哈希值(每个元素都会调用hashCode()产生一个哈希值)</li><li>如果新添加的元素与集合中已有的元素的哈希值都不同,新添加的元素存入集合</li><li>如果新添加的元素与集合中已有的某个元素哈希值相同,此时还需要调用equals(Object obj)比较<ul><li>如果equals(Object obj)方法返回true,说明新添加的元素与集合中已有的某个元素的属性值相同,那么新添加的元素不存入集合。</li><li>如果equals(Object obj)方法返回false, 说明新添加的元素与集合中已有的元素的属性值都不同, 那么新添加的元素存入集合。</li></ul></li></ul></li><li>hashCode方法优化:<ul><li>如果让hashCode()方法返回一个固定值,那么每个新添加的元素都要调用equals(Object obj)方法比较,那么效率较低</li><li>只需要让不同属性的值的元素产生不同的哈希值,那么就可以不再调用equals方法比较提高效率<h2 id="Collections中的方法"><a href="#Collections中的方法" class="headerlink" title="Collections中的方法"></a>Collections中的方法</h2></li></ul></li></ul></li><li>面试题：Collection和Collections有什么区别？<ul><li>Collection是集合体系的最顶层，包含了集合体系的共性</li><li>Collections是一个工具类，方法都是用于操作Collection</li></ul></li><li><code>static void swap(List list, int i, int j);</code> :将指定列表中的两个索引进行位置互换</li><li><code>static void  sort(List&lt;T&gt; list);</code> :按照列表中元素的自然顺序进行排序</li><li><code>static void shuffle(List list);</code>:将元素的顺序随机置换</li><li><code>static void reverse(List list);</code>:将元素的顺序反转</li><li><code>static void fill(List list, Object obj);</code>:使用指定的对象填充指定列表的<strong>所有</strong>元素</li><li><code>static void copy(List dest, List src);</code>:是把源列表中的数据覆盖到目标列表(注意：目标列表的长度至少等于源列表的长度)</li><li><code>static int  binarySearch(List list, Object key);</code>:使用二分查找法查找指定元素在指定列表的索引位置<h2 id="HashMap集合"><a href="#HashMap集合" class="headerlink" title="HashMap集合"></a>HashMap集合</h2></li><li>Map接口概述:<ul><li>我们通过查看Map接口描述，发现Map接口下的集合与Collection接口下的集合，它们存储数据的形式不同:<ul><li>Collection中的集合，元素是孤立存在的（理解为单身），向集合中存储元素采用一个个元素的方式存储</li><li>Map中的集合，元素是成对存在的(理解为夫妻)。每个元素由键与值两部分组成，通过键可以找对所对应的值。</li><li>Collection中的集合称为单列集合，Map中的集合称为<strong>双列集合</strong>。</li><li>需要注意的是，Map中的集合不能包含重复的键，值可以重复；每个键只能对应一个值。</li></ul></li></ul></li><li>Map常用功能:<ul><li>映射功能：<ul><li><code>V put(K key, V value);</code> :以键=值的方式存入Map集合(如果key存在，则覆盖value，并将原来的value返回)</li></ul></li><li>获取功能：<ul><li><code>V get(Object key);</code>:根据键获取值</li><li><code>int size();</code>:返回Map中键值对的个数</li></ul></li><li>判断功能：<ul><li><code>boolean containsKey(Object key);</code>:判断Map集合中是否包含键为key的键值对</li><li><code>boolean containsValue(Object value);</code>:判断Map集合中是否包含值为value键值对</li><li><code>boolean isEmpty();</code>:判断Map集合中是否没有任何键值对 </li></ul></li><li>删除功能：<ul><li><code>void clear();</code>:清空Map集合中所有的键值对</li><li><code>V remove(Object key);</code>:根据键值删除Map中键值对,并返回key所对应的值，如果没有删除成功则返回null</li></ul></li><li>遍历功能：<ul><li><code>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet()</code>:将每个键值对封装到一个个Entry对象中,再把所有Entry的对象封装到Set集合中返回</li><li><code>Set&lt;K&gt; keySet();</code> :将Map中所有的键装到Set集合中返回</li><li><code>Collection&lt;V&gt; values();</code>:返回集合中所有的value的值的集合</li></ul></li></ul></li><li>Map的两种遍历方式:<ul><li>利用keySet()方法遍历:<ul><li>首先召集所有的key</li><li>遍历所有的key</li><li>获取每一个key</li><li>让每一个key去找对应的value</li></ul></li><li>利用entrySet()方法遍历：<ul><li>通过Map.Entry对象来获取Key和Value<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    K key;</span><br><span class="line">    V value;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Entry</span><span class="params">(K key，V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() </span><br></pre></td></tr></table></figure><h2 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h2></li></ul></li></ul></li><li>概述:<ul><li>当参数不确定的时候, 类型要明确</li><li>Java可以把多个参数直接帮我们转成数组</li></ul></li><li>理解: 可变参数本质就是一个长度可变的数组.</li><li>格式:<ul><li>实参: 一个参数一个参数的传递</li><li>形参: <code>类型...变量名</code>例如<code>String... strs</code>。</li></ul></li><li>注意：<ul><li>在可变参数之后不可以再追加参数</li><li>参数的数量定义, 可以给多个甚至也可以一个都不给</li></ul></li></ul><h2 id="异常产生-amp-异常处理"><a href="#异常产生-amp-异常处理" class="headerlink" title="异常产生&amp;异常处理"></a>异常产生&amp;异常处理</h2><ul><li>异常概述：<ul><li>什么是异常？Java代码在运行时期发生的问题就是异常。</li><li>在Java中，把异常信息封装成了一个类。当出现了问题时，就会创建异常类对象并抛出异常相关的信息（如异常出现的位置、原因等）。</li><li>在Java中使用Exception类来描述异常。</li><li>API中Exception的描述：“Exception类及其子类是Throwable的一种形式，它用来表示java程序中可能会产生的异常，并要求对产生的异常进行合理的异常处理。”</li><li>Exception有继承关系，它的父类是Throwable。Throwable是Java语言中所有错误或异常的<strong>超类</strong>，即<strong>祖宗类</strong>。</li><li>另外，在异常Exception类中，有一个子类要特殊说明一下，RuntimeException子类，RuntimeException及其它的子类只能在Java程序运行过程中出现。</li><li>我们再来观察Throwable类，能够发现与异常Exception平级的有一个Error，它是Throwable的子类，它用来表示java程序中可能会产生的严重错误。解决办法只有一个，<strong>修改代码</strong>避免Error错误的产生。</li></ul></li><li>异常的体系结构：<ul><li>Throwable（最顶层）<ul><li>Error:出现的不能够处理的严重问题</li><li>Exception:可以处理的问题</li></ul></li></ul></li><li>异常处理：<ul><li>1.JVM默认处理方式：如果出现异常我们没有处理，jvm会帮我们进行处理，他会把异常的类型，原因还有位置显示在命令行并且还终止了程序，异常后面的代码将不再执行。</li><li>2.try…catch方式处理异常:<ul><li>捕获：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理捕获异常格式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//需要被检测的语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span>(异常类 变量) &#123; <span class="comment">//参数。</span></span><br><span class="line">    <span class="comment">//异常的处理语句。</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">//一定会被执行的语句。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>try：该代码块中编写可能产生异常的代码。</li><li>catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。</li><li>finally:无论try…catch语句如何执行，finally的代码一定会执行。</li></ul></li><li>3.throws方式处理异常<ul><li>throws使用:使用关键字throws在方法的声明出抛出异常<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">权限修饰符 返回值类型 方法名(形参列表) <span class="keyword">throws</span> 异常类型<span class="number">1</span>,异常类型<span class="number">2.</span>..&#123;</span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure></li></ul></li><li>4.多异常处理<ul><li>对代码进行异常检测，并对检测的异常传递给catch处理。对每种异常信息进行不同的捕获处理。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>&#123;<span class="comment">//不用throws </span></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Exception();<span class="comment">//产生异常，直接捕获处理</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(XxxException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(YyyException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">    &#125;<span class="keyword">catch</span>(ZzzException e)&#123;</span><br><span class="line"><span class="comment">//处理方式</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。<h2 id="Throwable常用方法-amp-自定义异常"><a href="#Throwable常用方法-amp-自定义异常" class="headerlink" title="Throwable常用方法&amp;自定义异常"></a>Throwable常用方法&amp;自定义异常</h2></li></ul></li></ul></li><li>Throwable常用方法:<ul><li><code>String getMessage();</code>:返回此throwable的详细消息字符串</li><li><code>String toString();</code>:返回此throwable的简短描述</li><li><code>void printStackTrace();</code>:打印异常的堆栈的跟踪信息</li></ul></li><li>finally的概述和应用场景  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 异常变量)&#123;</span><br><span class="line">&#125;<span class="keyword">finally</span>&#123;</span><br><span class="line"><span class="comment">//释放资源的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>无论try…catch语句如何执行，finally的代码一定会执行。</li></ul></li><li>编译时异常&amp;运行时异常<ul><li>编译时期异常:是Exception的子类，非RuntimeExcpetion的子类，在编译时期必须处理。</li><li>运行时期异常：RuntimeException和他的所有子类异常,都属于运行时期异常。<ul><li>NullPointerException,ArrayIndexOutOfBoundsException等都属于运行时期异常.</li><li>运行时期异常的特点:<ul><li>方法中抛出运行时期异常,方法定义中无需throws声明,调用者也无需处理此异常</li><li>运行时期异常一旦发生,需要程序人员修改源代码。<h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2></li></ul></li></ul></li></ul></li><li>递归，指在当前方法内调用自己的这种现象  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(“递归的演示”);</span><br><span class="line">    <span class="comment">//在当前方法内调用自己</span></span><br><span class="line">    method();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>递归注意事项：<ul><li>递归一定要有出口，否则会内存溢出。</li><li>递归次数不宜过多，否则会内存溢出。</li></ul></li></ul><p>##File类</p><ul><li>File概述：<ul><li>File文件和目录路径名的抽象表示形式。即，Java中把<strong>文件</strong>或者目录（<strong>文件夹</strong>）都封装成File对象。也就是说如果我们要去操作硬盘上的文件，或者文件夹只要找到File这个类即可,那么我们就要研究研究File这个类中都有那些功能可以操作文件或者文件夹呢。</li></ul></li><li>File类的<strong>构造</strong>函数：<ul><li><code>File(String pathname);</code> :将一个字符串路径封装成File对象</li><li><code>File(String parent,String child);</code>:传入一个父级路径和子级路径</li><li><code>File(File parent,String child);</code>:传入一个File类型的父级路径和子级路径</li></ul></li><li>File类<strong>创建</strong>和<strong>删除</strong>功能：<ul><li><code>boolean createNewFile();</code>:指定路径不存在该文件时时创建文件,返回true,否则返回false</li><li><code>boolean mkdir();</code>:当指定的<strong>单级文件夹</strong>不存在时创建文件夹，并返回true，否则返回false  </li><li><code>boolean mkdirs();</code>:当指定的<strong>多级文件夹</strong>某一级文件夹**不存在时,创建多级文件夹，并返回true,否则返回false</li><li><code>boolean delete();</code>:删除文件或者删除单级文件夹(注意：删除一个文件夹，这个文件夹下面不能有其他的文件和文件夹)</li></ul></li><li>File类的<strong>判断</strong>功能：<ul><li><code>boolean exists();</code>:判断指定路径的文件或文件夹是否存在</li><li><code>boolean isAbsolute();</code>:判断当前路径是否是绝对路径</li><li><code>boolean isDirectory();</code>:判断当前的目录是否存在</li><li><code>boolean isFile();</code>:判断当前路径是否是一个文件</li><li><code>boolean isHidden();</code>:判断当前路径是否是隐藏文件</li></ul></li><li>File类的<strong>获取</strong>功能和<strong>修改名字</strong>功能<ul><li><code>File getAbsoluteFile();</code>:获取文件的绝对路径,返回File对象</li><li><code>String getAbsolutePath();</code>:获取文件的绝对路径,返回路径的字符串</li><li><code>String getParent();</code>:获取当前路径的父级路径,以字符串形式返回该父级路径</li><li><code>File getParentFile();</code>:获取当前路径的父级路径,以字File对象形式返回该父级路径</li><li><code>String getName();</code>:获取文件或文件夹的名称</li><li><code>String getPath();</code>:获取File对象中封装的路径</li><li><code>long lastModified();</code>:以毫秒值返回最后修改时间</li><li><code>long length();</code>:返回文件的字节数</li><li><code>boolean renameTo(File dest);</code>: 将当前File对象所指向的路径 修改为 指定File所指向的路径</li></ul></li><li>File类的<strong>其它获取</strong>功能<ul><li><code>String[] list();</code>:以字符串数组的形式返回当前路径下所有的文件和文件夹的名称(注意：只有指向文件夹的File对象才可以调用该方法)</li><li><code>File[] listFiles();</code>:以File对象的形式返回当前路径下所有的文件和文件夹的名称(注意：只有指向文件夹的File对象才可以调用该方法)</li><li><code>static File[] listRoots();</code>:获取计算机中所有的盘符</li></ul></li><li>File类的两个案例：<ul><li>一、列出当前路径下（包含子目录）的所有以’.java’结尾的文件名称<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;src&quot;</span>);</span><br><span class="line">        listAllFileName(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 列出当前路径下（包含子目录）的所有以&#x27;.java&#x27;结尾的文件名称</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> file 文件夹</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">listAllFileName</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="comment">//判断是否是文件对象</span></span><br><span class="line">                <span class="keyword">if</span> (f.isFile()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (f.getName().endsWith(<span class="string">&quot;.java&quot;</span>)) &#123;</span><br><span class="line">                        System.out.println(f.getName());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">//是一个目录对象</span></span><br><span class="line">                    listAllFileName(f);<span class="comment">//递归调用</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>二、删除指定目录下所有文件和目录（包含子目录）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        File f = <span class="keyword">new</span> File(<span class="string">&quot;e:\\threadFile&quot;</span>);</span><br><span class="line">        delAllFiles(f);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 删除指定目录下所有文件和目录（包含子目录）</span></span><br><span class="line"><span class="comment">    * 注意：如果要删除一个目录，则需要先删除这个目录下的所有子文件和子目录</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> file 文件夹</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">delAllFiles</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(file.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">//干掉自己所有的子文件和子目录</span></span><br><span class="line">            <span class="comment">//获取所有的子文件和子目录</span></span><br><span class="line">            File[] files = file.listFiles();</span><br><span class="line">            <span class="keyword">for</span> (File f : files) &#123;</span><br><span class="line">                <span class="keyword">if</span>(f.isFile()) &#123;</span><br><span class="line">                    <span class="comment">//直接干掉他</span></span><br><span class="line">                    System.out.println(f.getName());</span><br><span class="line">                    f.delete();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(f.isDirectory()) &#123;</span><br><span class="line">                    <span class="comment">//继续查看是否还有文件和子目录</span></span><br><span class="line">                    delAllFiles(f);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//干掉自己</span></span><br><span class="line">            System.out.println(file.getName());</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="字符流与字节流"><a href="#字符流与字节流" class="headerlink" title="字符流与字节流"></a>字符流与字节流</h2></li></ul></li><li>IO流分类：<ul><li>按<strong>流向</strong>分：<ul><li>输入流–读取数据–FileReader–Reader</li><li>输出流–写出数据–FileWriter–Writer</li></ul></li><li>按<strong>数据类型</strong>分：<ul><li>字节流    <ul><li>字节输入流–读取数据–InputStream</li><li>字节输出流–写出数据–OutputStream</li></ul></li><li>字符流<ul><li>字符输入流–读取数据–Reader</li><li>字符输出流–写出数据–Writer</li></ul></li></ul></li></ul></li><li>字符流与字节流的区别：<ul><li><strong>字节流</strong>可以操作<strong>所有类型</strong>的文件,因为<strong>所有的文件</strong>在计算机中都是以<strong>字节</strong>形式存储。</li><li>而<strong>字符流</strong>只能用来操作<strong>纯文本类型</strong>的文件,不能操作字节类型的文件。</li></ul></li><li>二进制文件只能使用<strong>字节流</strong>进行复制（使用windows自带记事本打开读不懂的）</li><li>文本文件的复制即可使用字符流，也可以使用字节流</li></ul><h2 id="标准输入流-amp-转换流-amp-打印流"><a href="#标准输入流-amp-转换流-amp-打印流" class="headerlink" title="标准输入流 &amp; 转换流 &amp; 打印流"></a>标准输入流 &amp; 转换流 &amp; 打印流</h2><ul><li>标准输入输出流：<ul><li><code>public static final InputStream in;</code>:标准输入流–字节输入流,用来读取键盘录入的数据.</li><li><code>public static final PrintStream out;</code>:标准输出流–字节输出流,将数据输出到命令行.</li></ul></li><li>转换流<ul><li><code>OutputStreamWriter</code>:将字节输出流转换为字符输出流</li><li><code>InputStreamReader</code>:将字节输入流转换为字符输入流</li></ul></li><li>打印流<ul><li>打印流添加输出数据的功能，使它们能够方便地打印各种数据值表示形式.</li><li>字符打印流：PrintWriter<ul><li><code>void print(String str);</code>: 输出任意类型的数据，</li><li><code>void println(String str);</code>: 输出任意类型的数据，自动写入换行操作<h2 id="对象操作流"><a href="#对象操作流" class="headerlink" title="对象操作流"></a>对象操作流</h2></li></ul></li></ul></li><li>概述：<ul><li>用于从流中读取对象。</li><li><code>ObjectInputStream</code> 称为<strong>反序列化流</strong>,利用输入流从文件中读取对象。</li><li><code>ObjectOutputStream</code> 称为<strong>序列化流</strong>,利用输出流向文件中写入对象。</li><li>特点：<ul><li>用于操作对象。可以将对象写入到文件中，也可以从文件中读取对象。</li><li>可以用于读写任意类型的对象.</li><li>使用对象输出流写出对象，只能使用对象输入流来读取对象.</li><li>只能将支持 java.io.Serializable 接口的对象写入流中.</li></ul></li></ul></li><li>ObjectOutputStream<ul><li><code>writeObject</code></li><li><code>ObjectOutputStream(OutputStream out)</code></li></ul></li><li>ObjectInputStream<ul><li><code>readObject</code></li><li><code>ObjectInputStream(InputStream in)</code><h3 id="利用序列化流读写对象"><a href="#利用序列化流读写对象" class="headerlink" title="利用序列化流读写对象"></a>利用序列化流读写对象</h3></li></ul></li><li>Serializable:<ul><li><strong>序列号</strong>，是一个标识接口，只起标识作用，没有方法</li><li>当一个类的对象需要IO流进行读写的时候，这个类必须实现该接口<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStreamDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//对象输出到文件</span></span><br><span class="line">        method();</span><br><span class="line">        <span class="comment">//读取对象文件</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象输出流的对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E://b.txt&quot;</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建学生对象</span></span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        Student s2 = <span class="keyword">new</span> Student(<span class="string">&quot;lisi&quot;</span>, <span class="number">19</span>);</span><br><span class="line">        <span class="comment">//写出学生对象</span></span><br><span class="line">        oos.writeObject(s);</span><br><span class="line">        oos.writeObject(s2);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象输入流的对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E://b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取对象</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                Object obj = ois.readObject();</span><br><span class="line">                System.out.println(obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (EOFException e) &#123;<span class="comment">//读取到末尾会报异常</span></span><br><span class="line">            System.out.println(<span class="string">&quot;读到了文件的末尾&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h3 id="解决对象输入流读取对象出现异常的问题"><a href="#解决对象输入流读取对象出现异常的问题" class="headerlink" title="解决对象输入流读取对象出现异常的问题"></a>解决对象输入流读取对象出现异常的问题</h3></li></ul></li><li>用集合解决<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObjectOutputStreamDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//对象输出到文件</span></span><br><span class="line">        method();</span><br><span class="line">        <span class="comment">//读取对象文件</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;finish&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象输出流的对象</span></span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">&quot;E://b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//创建集合对象</span></span><br><span class="line">        List&lt;Student&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//添加学生对象</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;wangwu&quot;</span>, <span class="number">30</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Student(<span class="string">&quot;zhaoliu&quot;</span>, <span class="number">28</span>));</span><br><span class="line">        <span class="comment">//写出集合对象</span></span><br><span class="line">        oos.writeObject(list);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        oos.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建对象输入流的对象</span></span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">&quot;E://b.txt&quot;</span>));</span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        Object obj = ois.readObject();</span><br><span class="line">        List&lt;Student&gt; list = (List) obj;</span><br><span class="line">        <span class="keyword">for</span> (Student student : list) &#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ois.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解决读写对象版本不一致问题-解决对实现序列化接口出现的黄色警告问题"><a href="#解决读写对象版本不一致问题-解决对实现序列化接口出现的黄色警告问题" class="headerlink" title="解决读写对象版本不一致问题(解决对实现序列化接口出现的黄色警告问题)"></a>解决读写对象版本不一致问题(解决对实现序列化接口出现的黄色警告问题)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6361890890437825953L</span>;<span class="comment">//显式声明序列化ID</span></span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Properties集合"><a href="#Properties集合" class="headerlink" title="Properties集合"></a>Properties集合</h2></li><li>Properties介绍:<ul><li>Properties类表示了一个持久的属性集。</li><li>Properties可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。</li><li>特点：<ul><li>Hashtable的子类，map集合中的方法都可以用。</li><li>该集合没有泛型。键值都是字符串。</li><li>它是一个可以持久化的属性集。键值可以存储到集合中，也可以存储到持久化的设备(硬盘、U盘、光盘)上。键值的来源也可以是持久化的设备。</li><li>有和流技术相结合的方法。<ul><li><code>void load(InputStream instream)</code>:从输入流中读取属性列表（键和元素对）</li><li><code>void load(Reader reader)</code>:按简单的面向行的格式从输入字符流中读取属性列表（键和元素对）</li><li><code>void store(OutputStream outputStream,String comments)</code>:以适合使用load(InputStream)方法加载到Properties表中的格式，将此Properties表中的属性列表(键和元素对)写入输出流</li><li><code>void store(Writer writer,String comments)</code>:以适合使用load(Reader)方法的格式，将此Properties表中的属性列表(键和元素对)写入输出字符</li></ul></li></ul></li></ul></li><li>利用Properties存储键值对<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建属性列表对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//添加映射关系</span></span><br><span class="line">        prop.put(<span class="string">&quot;CZBK001&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;CZBK002&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        prop.put(<span class="string">&quot;CZBK003&quot;</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        <span class="comment">//遍历属性列表</span></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Object, Object&gt; entry : prop.entrySet()) &#123;</span><br><span class="line">            System.out.println(entry.getKey() + <span class="string">&quot;=&quot;</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>Properties与流结合使用<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将属性列表写入文件</span></span><br><span class="line">        method();</span><br><span class="line">        <span class="comment">//将属性列表写入文件（并加入注释）</span></span><br><span class="line">        <span class="comment">//method3();</span></span><br><span class="line">        <span class="comment">//从文件读取写入列表</span></span><br><span class="line">        <span class="comment">//method2();</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建属性列表对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//添加映射关系</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK001&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK002&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK003&quot;</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建打印流对象</span></span><br><span class="line">        PrintWriter out = <span class="keyword">new</span> PrintWriter(<span class="string">&quot;E://d.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//void list(PrintWriter out)</span></span><br><span class="line">        prop.list(out);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建属性列表对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//创建一个输入流对象</span></span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">&quot;E://d.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//void load(Reader reader)</span></span><br><span class="line">        prop.load(fr);<span class="comment">//不会读取注释信息</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fr.close();</span><br><span class="line">        System.out.println(prop);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建属性列表对象</span></span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        <span class="comment">//添加映射关系</span></span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK001&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK002&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        prop.setProperty(<span class="string">&quot;CZBK003&quot;</span>, <span class="string">&quot;wangwu&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//创建输出流对象</span></span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">&quot;E://d.txt&quot;</span>);</span><br><span class="line">        <span class="comment">//void store(Writer writer, String comments)</span></span><br><span class="line">        prop.store(fw, <span class="string">&quot;hello world&quot;</span>);<span class="comment">//会加入注释和日期</span></span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编码表"><a href="#编码表" class="headerlink" title="编码表"></a>编码表</h2></li><li>概述:<ul><li>编码表：把计算机底层的二进制数据转换成我们能看到的字符<ul><li>ASCII</li><li>GB2312:GBK</li><li>Unicode:所有的字符都占2个字节</li><li>UTF-8    长度可变的码表</li><li>ANSI：本地编码表(gbk)</li></ul></li><li>Java中的字符串默认使用的ANSI（gbk）</li><li>乱码：编码保持前后一致即可解决</li></ul></li><li>Java中字符串的编码<ul><li>常用方法<ul><li>构造方法（字节数组转字符串）：<ul><li><code>String()</code>:初始化一个新创建的String对象，使其表示一个空字符序列。</li><li><code>String(byte[] bytes)</code>:使用平台的默认字符集解码指定的byte数组，构造一个新的String。</li><li><code>String(byte[] bytes, Charset charset)</code>:通过使用指定的charset解码指定的byte数组，构造一个新的String。</li></ul></li><li>成员方法（字符串转字节数组）<ul><li><code>getBytes()</code>:使用平台的默认字符集将此String编码为byte序列，并将结果存储到一个新的byte数组中。</li><li><code>getBytes(Charset charset)</code>:使用给定的charset将此String编码到byte序列，并将结果存储到新的byte数组。</li></ul></li></ul></li></ul></li><li>字符流中的编码<ul><li>常见对象<ul><li><code>InputStreamReader(InputStream in,CharsetDecoder dec)</code>:创建使用给定字符集解码器的InputStreamReader</li><li><code>OutputStreamWriter(OutputStream out,CharsetEncoder enc)</code>:创建使用给定字符集编码器的OutputStreamWriter</li></ul></li><li>字符流 = 字节流 + 编码</li></ul></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><ul><li>概述：<ul><li>学习多线程之前，我们先要了解几个关于多线程有关的概念。</li><li><strong>进程</strong>：指正在运行的程序。确切的来说，当一个程序进入内存运行，即变成一个进程，进程是处于运行过程中的程序，并且具有一定独立功能。</li><li><strong>线程</strong>：是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中是可以有多个线程的，这个应用程序也可以称之为<strong>多线程程序</strong>。</li><li>简而言之：一个程序运行后至少有一个进程，一个进程中可以包含多个线程。</li><li>什么是多线程呢？<ul><li>即一个程序中有多个线程在同时执行。</li></ul></li></ul></li><li>线程实现：                <ul><li>实现线程一:继承<strong>Thread类</strong>:<ul><li>Thread是程序中的执行线程。Java虚拟机允许应用程序并发地运行多个执行线程。</li><li>CPU执行程序的随机性。</li><li>创建线程的步骤：<ul><li>1.定义一个类继承Thread。</li><li>2.重写run方法。</li><li>3.创建子类对象，就是创建线程对象。</li><li>4.调用start方法，开启线程并让线程执行，同时还会告诉jvm去调用run方法</li></ul></li><li>Thread<ul><li><code>String getName()</code>:返回该线程的名称。 </li><li><code>void setName(String name)</code>:改变线程名称，使之与参数name相同。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            System.out.println(getName() + <span class="string">&quot;:&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程实例</span></span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        <span class="comment">//修改线程名字</span></span><br><span class="line">        mt.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程实例</span></span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt2.setName(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        mt2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>实现线程二:实现<strong>Runnable接口</strong>:<ul><li>Runnable接口用来指定每个线程要执行的任务。包含了一个run的无参数抽象方法，需要由接口实现类重写该方法。</li><li>创建线程的步骤。<ul><li>1、定义类实现Runnable接口。</li><li>2、覆盖接口中的run方法。</li><li>3、创建Thread类的对象。</li><li>4、将Runnable接口的子类对象作为参数传递给Thread类的构造函数。</li><li>5、调用Thread类的start方法开启线程。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//链式编程</span></span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + i );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建线程实例</span></span><br><span class="line">        Thread mt = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2());</span><br><span class="line">        <span class="comment">//修改线程名字</span></span><br><span class="line">        mt.setName(<span class="string">&quot;张三&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        mt.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建线程实例</span></span><br><span class="line">        Thread mt2 = <span class="keyword">new</span> Thread(<span class="keyword">new</span> MyThread2());</span><br><span class="line">        mt2.setName(<span class="string">&quot;老王&quot;</span>);</span><br><span class="line">        <span class="comment">//启动线程</span></span><br><span class="line">        mt2.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li>多线程安全问题产生&amp;解决方案<ul><li>问题出现的原因：<ul><li>要有多个线程</li><li>要有被多个线程所共享的数据</li><li>多个线程并发的访问共享的数据</li></ul></li><li>使用<strong>同步代码块</strong>解决:<ul><li>synchronized:同步（锁），可以修饰代码块和方法，被修饰的代码块和方法一旦被某个线程访问，则直接锁住，其他的线程将无法访问</li><li>注意：锁对象需要被所有的线程所共享</li><li>同步：安全性高，效率低</li><li>非同步：效率高，但是安全性低<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式:</span></span><br><span class="line"><span class="keyword">synchronized</span>(锁对象)&#123;</span><br><span class="line">    <span class="comment">//需要同步的代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>使用<strong>同步方法</strong>解决:<ul><li>同步方法:使用关键字synchronized修饰的方法，一旦被一个线程访问，则整个方法全部锁住，其他线程则无法访问</li><li>注意：<ul><li>非静态同步方法的锁对象是this</li><li>静态的同步方法的锁对象是当前类的字节码对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式:</span></span><br><span class="line">修饰符 <span class="keyword">synchronized</span> 返回值 方法名()&#123;</span><br><span class="line">    <span class="comment">//需要同步的代码 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li></ul><h2 id="面向网络编程"><a href="#面向网络编程" class="headerlink" title="面向网络编程"></a>面向网络编程</h2><h3 id="网络编程概述"><a href="#网络编程概述" class="headerlink" title="网络编程概述"></a>网络编程概述</h3><ul><li>网络协议:<ul><li>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中,这些<strong>连接和通信的规则</strong>被称为<strong>网络通信协议</strong>，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。</li><li>网络通信协议有很多种，目前应用最广泛的是<strong>TCP/IP协议</strong>(Transmission Control Protocal/Internet Protoal传输控制协议/英特网互联协议)，它是一个包括TCP协议和IP协议，UDP（User Datagram Protocol）协议和其它一些协议的协议组，在学习具体协议之前首先了解一下TCP/IP协议组的层次结构。</li><li>在进行数据传输时，要求发送的数据与收到的数据完全一样，这时，就需要在原有的数据上添加很多信息，以保证数据在传输过程中数据格式完全一致。TCP/IP协议的层次结构比较简单，共分为四层，如图所示。<br><img src="https://i.loli.net/2021/04/25/NoIZBKWE1AYDcUj.png" alt="TCP-IP网络模型.png"></li><li>上图中，TCP/IP协议中的四层分别是应用层、传输层、网络层和链路层，每层分别负责不同的通信功能，接下来针对这四层进行详细地讲解。<ul><li><strong>链路层</strong>：用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。</li><li><strong>网络层</strong>：是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。</li><li><strong>传输层</strong>：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。</li><li><strong>应用层</strong>：主要负责应用程序的协议，例如HTTP协议、FTP协议等。</li></ul></li></ul></li><li>IP地址和端口号:<ul><li>要想使网络中的计算机能够进行通信，必须为每台计算机指定一个<strong>标识号</strong>，通过这个标识号来指定接受数据的计算机或者发送数据的计算机。</li><li>在TCP/IP协议中，这个标识号就是<strong>IP地址</strong>，它可以唯一标识一台计算机，目前，IP地址广泛使用的版本是<strong>IPv4</strong>，它是由<strong>4个字节大小的二进制数</strong>来表示，如：00001010000000000000000000000001。由于二进制形式表示的IP地址非常不便记忆和处理，因此通常会将IP地址写成十进制的形式，每个字节用一个十进制数字(0-255)表示，数字间用符号“.”分开，如 “192.168.1.100”。</li><li>随着计算机网络规模的不断扩大，对IP地址的需求也越来越多，IPV4这种用4个字节表示的IP地址面临枯竭，因此<strong>IPv6</strong>便应运而生了，IPv6使用<strong>16个字节</strong>表示IP地址，它所拥有的地址容量约是IPv4的8×1028倍，达到2128个（算上全零的），这样就解决了网络地址资源数量不够的问题。</li><li>通过IP地址可以连接到指定计算机，但如果想访问目标计算机中的某个应用程序，还需要指定端口号。在计算机中，<strong>不同的应用程序是通过端口号区分</strong>的。端口号是用<strong>两个字节</strong>（16位的二进制数）表示的，它的取值范围是0<del>65535，其中，0</del>1023之间的端口号用于一些知名的网络服务和应用，用户的普通应用程序需要使用1024以上的端口号，从而避免端口号被另外一个应用或服务所占用。</li><li>接下来通过一个图例来描述IP地址和端口号的作用，如下图所示。<br><img src="https://i.loli.net/2021/04/25/uP8qJtYjdcSEfkC.jpg" alt="IP地址和端口号的作用.jpg"></li><li>从上图中可以清楚地看到，位于网络中一台计算机可以通过IP地址去访问另一台计算机，并通过端口号访问目标计算机中的某个应用程序。</li></ul></li><li>InetAddress:<ul><li>了解了IP地址的作用，我们看学习下JDK中提供了一个InetAdderss类，该类用于封装一个IP地址，并提供了一系列与IP地址相关的方法，下面列出了InetAddress类的一些常用方法。<ul><li><code>static InetAddress getByName(String host)</code>:在给定主机名的情况下确定主机的IP地址</li><li><code>static InetAddress getLocalHost()</code>:返回本地主机</li><li><code>String getHostName()</code>:获取此IP地址的主机名</li><li><code>String getHostAddress()</code>:返回IP地址字符串(以文本表现形式)<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InetAddressDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> UnknownHostException </span>&#123;</span><br><span class="line"><span class="comment">//        InetAddress address = InetAddress.getByName(&quot;DESKTOP-IHI76E3&quot;);</span></span><br><span class="line"><span class="comment">//        InetAddress address = InetAddress.getByName(&quot;172.16.132.177&quot;);</span></span><br><span class="line">        InetAddress address = InetAddress.getLocalHost();</span><br><span class="line">        System.out.println(address.getHostAddress());<span class="comment">//172.16.132.177返回IP地址</span></span><br><span class="line">        System.out.println(address.getHostName());<span class="comment">//DESKTOP-IHI76E3返回主机名</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="UDP协议"><a href="#UDP协议" class="headerlink" title="UDP协议"></a>UDP协议</h3></li></ul></li></ul></li><li>概述：<ul><li>UDP是<strong>无连接通信协议</strong>，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在收到数据时，也不会向发送端反馈是否收到数据。</li><li>由于使用UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输例如视频会议都使用UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太大影响。</li><li>但是在使用UDP协议传送数据时，由于UDP的面向无连接性，<strong>不能保证数据的完整性</strong>，因此在传输重要数据时不建议使用UDP协议。UDP的交换过程如下图所示。<br><img src="https://i.loli.net/2021/04/25/ZeLuTz6WxB4P3kG.jpg" alt="UDP的交换过程.jpg"></li></ul></li><li>DatagramPacket类<ul><li>前面介绍了UDP是一种面向无连接的协议，因此，在通信时发送端和接收端不用建立连接。UDP通信的过程就像是货运公司在两个码头间发送货物一样。在码头发送和接收货物时都需要使用集装箱来装载货物，UDP通信也是一样，发送和接收的数据也需要使用“<strong>集装箱</strong>”进行打包，为此JDK中提供了一个DatagramPacket类，该类的实例对象就相当于一个集装箱，<strong>用于封装UDP通信中发送或者接收的数据</strong>。</li><li>想要创建一个DatagramPacket对象，首先需要了解一下它的构造方法。在创建发送端和接收端的DatagramPacket对象时，使用的构造方法有所不同，接收端的构造方法只需要接收一个字节数组来存放接收到的数据，而发送端的构造方法不但要接收存放了发送数据的字节数组，还需要指定发送端IP地址和端口号。</li><li>接下来根据API文档的内容，对DatagramPacket的构造方法进行逐一详细地讲解。<ul><li><code>DatagramPacket(byte[] buf,int length)</code>:构造DatagramPacket，用来接收长度为length的数据包。<ul><li>使用该构造方法在创建DatagramPacket对象时，指定了封装数据的字节数组和数据的大小，没有指定IP地址和端口号。很明显，这样的对象只能用于接收端，不能用于发送端。因为发送端一定要明确指出数据的目的地(ip地址和端口号)，而接收端不需要明确知道数据的来源，只需要接收到数据即可。</li></ul></li><li><code>DatagramPacket(byte[] buf,int length,InetAddress address,int port)</code>:构造数据报包，用来将长度为length的包发送到指定主机的指定端口号。<ul><li>使用该构造方法在创建DatagramPacket对象时，不仅指定了封装数据的字节数组和数据的大小，还指定了数据包的目标IP地址（address）和端口号（port）。该对象通常用于发送端，因为在发送数据时必须指定接收端的IP地址和端口号，就好像发送货物的集装箱上面必须标明接收人的地址一样。</li></ul></li></ul></li><li>上面我们讲解了DatagramPacket的构造方法，接下来对DatagramPacket类中的常用方法进行详细地讲解，如下所示。<ul><li><code>InetAddress getAddress()</code>:返回某台机器的IP地址，此数据报将要发往该机器或者是从该机器接收到的</li><li><code>int getPort()</code>:返回某台远程主机的端口号，此数据报将要发往该主机或者是从该主机接收到的</li><li><code>byte[] getData()</code>:返回数据缓存区</li><li><code>int getLength()</code>:返回将要发送或者接收的数据长度</li></ul></li></ul></li><li>DatagramSocket类<ul><li>DatagramPacket数据包的作用就如同是“集装箱”，可以将发送端或者接收端的数据封装起来。然而运输货物只有“集装箱”是不够的，还需要有码头。在程序中需要实现通信只有DatagramPacket数据包也同样不行，为此JDK中提供的一个DatagramSocket类。DatagramSocket类的作用就<strong>类似于码头</strong>，使用这个类的实例对象就可以<strong>发送和接收DatagramPacket数据包</strong>，发送数据的过程如下图所示。<br><img src="https://i.loli.net/2021/04/25/xV87UpzObvKY3Nl.jpg" alt="DatagramPacket和DatagramSocket发送数据的过程.jpg"></li><li>在创建发送端和接收端的DatagramSocket对象时，使用的构造方法也有所不同，下面对DatagramSocket类中常用的构造方法进行讲解。<ul><li><code>DatagramSocket()</code>:构造数据报套接字并将其绑定到本机上任何可用的端口。<ul><li>该构造方法用于创建<strong>发送端</strong>的DatagramSocket对象，在创建DatagramSocket对象时，并没有指定端口号，此时，系统会分配一个没有被其它网络程序所使用的端口号。</li></ul></li><li><code>DatagramSocket(int port)</code>:构造数据报套接字并将其绑定到本机上的指定端口。<ul><li>该构造方法既可用于创建<strong>接收端</strong>的DatagramSocket对象，又可以创建<strong>发送端</strong>的DatagramSocket对象，在创建接收端的DatagramSocket对象时，必须要指定一个端口号，这样就可以监听指定的端口。</li></ul></li></ul></li><li>上面我们讲解了DatagramSocket的构造方法，接下来对DatagramSocket类中的常用方法进行详细地讲解。<ul><li><code>void receive(DatagramPacket p)</code>:从此套接字接收数据报包</li><li><code>void send(DatagramPacket p)</code>:从此套接字发送数据报包</li></ul></li></ul></li><li>UDP实现<br>先运行ReceiveDemo，试其进入到阻塞模式，以等待SendDemo发送数据报包。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiveDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建接收端Socket对象</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket(<span class="number">8888</span>);</span><br><span class="line">        <span class="comment">//接收数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, bys.length);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收数据&quot;</span>);</span><br><span class="line">        ds.receive(dp);<span class="comment">//阻塞</span></span><br><span class="line">        System.out.println(<span class="string">&quot;接收到数据了&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//解析数据</span></span><br><span class="line">        InetAddress address = dp.getAddress();<span class="comment">//获取发送端的IP对象</span></span><br><span class="line">        <span class="keyword">byte</span>[] data = dp.getData();<span class="comment">//获取接收到的数据，也可以直接使用创建包对象时的数组</span></span><br><span class="line">        <span class="keyword">int</span> length = dp.getLength();<span class="comment">//获取具体收到数据的长度</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//输出数据</span></span><br><span class="line">        System.out.println(<span class="string">&quot;sender ---&gt; &quot;</span> + address.getHostAddress());</span><br><span class="line">        <span class="comment">//System.out.println(new String(data,0,length));</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, length));</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SendDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建发送端Socket对象</span></span><br><span class="line">        DatagramSocket ds = <span class="keyword">new</span> DatagramSocket();</span><br><span class="line">        <span class="comment">//创建数据</span></span><br><span class="line">        String s = <span class="string">&quot;hello udp,i&#x27;m coming!&quot;</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] bys = s.getBytes();</span><br><span class="line">        <span class="keyword">int</span> length = bys.length;</span><br><span class="line">        InetAddress address = InetAddress.getLocalHost();<span class="comment">//发送给当前设备</span></span><br><span class="line">        <span class="keyword">int</span> port = <span class="number">8888</span>;</span><br><span class="line">        <span class="comment">//打包（数据内容，数据长度，ip，端口）</span></span><br><span class="line">        DatagramPacket dp = <span class="keyword">new</span> DatagramPacket(bys, length, address, port);</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        ds.send(dp);</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        ds.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TCP协议"><a href="#TCP协议" class="headerlink" title="TCP协议"></a>TCP协议</h3></li><li>概述：<ul><li>TCP通信同UDP通信一样，都能实现两台计算机之间的通信，通信的两端都需要创建socket对象。</li><li>区别在于，<strong>UDP中只有发送端和接收端</strong>，<strong>不区分客户端与服务器端</strong>，计算机之间可以任意地发送数据。</li><li>而TCP通信是<strong>严格区分客户端与服务器端</strong>的，在通信时，必须先<strong>由客户端去连接服务器端</strong>才能实现通信，服务器端不可以主动连接客户端，并且服务器端程序需要事先启动，等待客户端的连接。</li><li>在JDK中提供了两个类用于实现TCP程序，一个是ServerSocket类，用于表示服务器端，一个是Socket类，用于表示客户端。</li><li>通信时，首先创建代表服务器端的ServerSocket对象，该对象相当于开启一个服务，并等待客户端的连接，然后创建代表客户端的Socket对象向服务器端发出连接请求，服务器端响应请求，两者建立连接开始通信。</li></ul></li><li>ServerSocket类<ul><li>在开发TCP程序时，首先需要创建服务器端程序。JDK的java.net包中提供了一个ServerSocket类，该类的实例对象可以实现一个服务器段的程序。</li><li>通过查阅API文档可知，ServerSocket类提供了多种构造方法，接下来就对ServerSocket的构造方法进行逐一地讲解。<ul><li><code>ServerSocket(int port)</code>:创建绑定到特定端口的服务器套接字。<ul><li>使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上（参数port就是端口号）。</li></ul></li></ul></li><li>接下来学习一下ServerSocket的常用方法，如下所示。<ul><li><code>Socket accept()</code>:侦听并接受到此套接字的连接。</li><li><code>InetAddress getInetAddress()</code>:返回此服务器套接字的本地地址。</li><li>ServerSocket对象负责监听某台计算机的某个端口号，在创建ServerSocket对象后，需要继续调用该对象的accept()方法，接收来自客户端的请求。当执行了accept()方法之后，服务器端程序会发生<strong>阻塞</strong>，直到客户端发出连接请求，accept()方法才会返回一个Scoket对象用于和客户端实现通信，程序才能继续向下执行。</li></ul></li></ul></li><li>Socket类<ul><li>讲解了ServerSocket对象可以实现服务端程序，但只实现服务器端程序还不能完成通信，此时还需要一个客户端程序与之交互，为此JDK提供了一个Socket类，用于实现TCP客户端程序。</li><li>通过查阅API文档可知Socket类同样提供了多种构造方法，接下来就对Socket的常用构造方法进行详细讲解。<ul><li><code>Socket(String host,int port)</code>:创建一个流套接字并将其连接到指定主机上的指定端口号。<ul><li>使用该构造方法在创建Socket对象时，会根据参数去连接在指定地址和端口上运行的服务器程序，其中参数host接收的是一个字符串类型的IP地址。</li></ul></li><li><code>Socket(InetAddress address,int port)</code>:创建一个流套接字并将其连接到指定IP地址的指定端口号。<ul><li>该方法在使用上与第一个构造方法类似，参数address用于接收一个InetAddress类型的对象，该对象用于封装一个IP地址。</li></ul></li><li>在以上Socket的构造方法中，最常用的是第一个构造方法。</li></ul></li><li>接下来学习一下Socket的常用方法，如下所示。<ul><li><code>int getPort()</code>:返回一个int类型对象，该对象是Socket对象与服务器端连接的端口号</li><li><code>InetAddress getLocalAddress()</code>:用于获取Socket对象绑定的本地IP地址，并将IP地址封装成InetAddress类型的对象返回</li><li><code>void close()</code>:用于关闭Socket连接，结束本次通信。在关闭socket之前，应将与socket相关的所有的输入/输出流全部关闭，这是因为一个良好的程序应该在执行完毕时释放所有的资源</li><li><code>InputStream getInputStream()</code>:返回一个InputStream类型的输入流对象，如果该对象是由服务器端的Socket返回，就用于读取客户端发送的数据，反之，用于读取服务器端发送的数据</li><li><code>OutputStream getOutputStream()</code>:返回一个OutputStream类型的输出流对象，如果该对象是由服务器端的Socket返回，就用于向客户端发送数据，反之，用于向服务器端发送数据</li><li>在Socket类的常用方法中，getInputStream()和getOutStream()方法分别用于获取输入流和输出流。当客户端和服务端建立连接后，<strong>数据是以IO流的形式</strong>进行交互的，从而实现通信。</li></ul></li><li>接下来通过一张图来描述服务器端和客户端的数据传输，如下图所示。<br><img src="https://i.loli.net/2021/04/25/3hlNw71XLtIBj5f.png" alt="服务器端和客户端的数据传输.png"></li></ul></li><li>TCP协议实现<br>先运行服务端(ServerDemo)，试其进入到阻塞模式，以等待客户端(ClientDemo)发送数据报包。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServerDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建接收端Socket对象</span></span><br><span class="line">        ServerSocket ss = <span class="keyword">new</span> ServerSocket(<span class="number">10086</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;等待接收数据&quot;</span>);</span><br><span class="line">        <span class="comment">//监听（阻塞）</span></span><br><span class="line">        Socket s = ss.accept();</span><br><span class="line">        System.out.println(<span class="string">&quot;接收到数据了&quot;</span>);</span><br><span class="line">        <span class="comment">//获取输入流对象</span></span><br><span class="line">        InputStream is = s.getInputStream();</span><br><span class="line">        <span class="comment">//获取数据</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;<span class="comment">//用于存储读到的字节个数</span></span><br><span class="line">        len = is.read(bys);</span><br><span class="line">        <span class="comment">//输出数据</span></span><br><span class="line">        InetAddress address = s.getInetAddress();</span><br><span class="line">        System.out.println(<span class="string">&quot;client ---&gt; &quot;</span> + address.getHostName());</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, len));</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        s.close();</span><br><span class="line">        <span class="comment">//ss.close();</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//创建发送端Socket对象（创建连接）</span></span><br><span class="line">        Socket s = <span class="keyword">new</span> Socket(InetAddress.getLocalHost(), <span class="number">10086</span>);</span><br><span class="line">        <span class="comment">//获取输出流对象</span></span><br><span class="line">        OutputStream os = s.getOutputStream();</span><br><span class="line">        <span class="comment">//发送数据</span></span><br><span class="line">        String str = <span class="string">&quot;hello tcp,i&#x27;m coming!!!&quot;</span>;</span><br><span class="line">        os.write(str.getBytes());</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        <span class="comment">//os.close();</span></span><br><span class="line">        s.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>TCP相关案例(见提高篇day12Word文档)</li></ul><h2 id="反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性"><a href="#反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性" class="headerlink" title="反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性"></a>反射机制概述、字节码对象的获取方式、反射操作构造方法、成员方法、成员属性</h2><h3 id="反射机制的概述和字节码对象的获取方式"><a href="#反射机制的概述和字节码对象的获取方式" class="headerlink" title="反射机制的概述和字节码对象的获取方式"></a>反射机制的概述和字节码对象的获取方式</h3><ul><li>反射介绍：<ul><li>JAVA反射机制是在运行状态中,对于任意一个类,都能够知道这个类的所有属性和方法<ul><li>对于任意一个对象,都能够调用它的任意一个方法</li><li>这种动态获取的以及动态调用对象的方法的功能称为java语言的反射机制.</li></ul></li><li>简单来说, 就可以把.class文件比做动物的尸体, 而反射技术就是对尸体的一种解剖.</li><li>通过反射技术, 我们可以拿到该字节码文件中所有的东西, 例如成员变量, 成员方法, 构造方法, 而且还包括私有。</li></ul></li><li>字节码对象获取的三种方式<ul><li>1.<code>对象名.getCalss();</code>//此方法来自于Object—对象已经存在的情况下, 可以使用这种方式</li><li>2.<code>类名.class;</code>//类名.class这是一个静态的属性,只要知道类名, 就可以获取 </li><li>3.<code>Class.forName(&quot;com.lxy.Student&quot;);</code>//通过Class类中的静态方法, 指定字符串, 该字符串是类的全类名(包名+类名),此处将会抛出异常都系ClassNotFoundException防止传入错误的类名</li></ul></li><li>反射：<ul><li>在运行时，我们可以获取任意一个类的所有方法和属性</li><li>在运行时，让我们调用任意一个对象的所有方法和属性</li></ul></li><li>反射的前提：<ul><li>要获取类的对象（Class对象）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">// 1.通过Object的getClass()方法获取，必须要有对象</span></span><br><span class="line">        Student s = <span class="keyword">new</span> Student();</span><br><span class="line">        Class clazz = s.getClass();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.通过类名获取字节码对象</span></span><br><span class="line">        Class clazz2 = Student.class;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 通过全类名获取字节码对象</span></span><br><span class="line">        Class clazz3 = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(clazz == clazz2);</span><br><span class="line">        System.out.println(clazz == clazz3);</span><br><span class="line">        System.out.println(clazz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>字节码对象是用来描述什么的?<ul><li>用来描述.class文件的.</li><li>面向对象阶段的时候讲过java中描述事物都是通过类的形式</li><li>而字节码文件也可以看做为一种事物, 如何描述这种事物? 那就看看这个事物是由什么组成的了<ul><li><ol><li>成员变量</li></ol></li><li><ol start="2"><li>成员方法</li></ol></li><li><ol start="3"><li>构造方法<h3 id="反射操作构造方法"><a href="#反射操作构造方法" class="headerlink" title="反射操作构造方法"></a>反射操作构造方法</h3></li></ol></li></ul></li></ul></li><li>通过获取的构造创建对象<ul><li>步骤:<ul><li>1.获得Class对象</li><li>2.获得构造</li><li>3.通过构造对象获得实例化对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line"><span class="comment">//        method(clazz);</span></span><br><span class="line"><span class="comment">//        method2(clazz);</span></span><br><span class="line"><span class="comment">//        method3(clazz);</span></span><br><span class="line">        Object obj = clazz.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取所有public修饰的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Constructor&lt;?&gt;[] getConstructors() :</span></span><br><span class="line">        Constructor[] cs = clazz.getConstructors();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cs.length; i++) &#123;</span><br><span class="line">            System.out.println(cs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取无参构造</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">        Constructor c = clazz.getConstructor();<span class="comment">//获取无参构造</span></span><br><span class="line">        System.out.println(c);</span><br><span class="line">        Object obj = c.newInstance();</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取有参构造，其参数1类型为String，参数2类型为Integer</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(Class clazz)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</span></span><br><span class="line">        Constructor c = clazz.getConstructor(String.class, Integer.class);</span><br><span class="line">        System.out.println(c);</span><br><span class="line">        Object obj = c.newInstance(<span class="string">&quot;lisi&quot;</span>, <span class="number">30</span>);</span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>直接通过Class类中的newInstance()和获取getConstructor()有什么区别?<ul><li><code>newInstance()</code>方法, 只能通过无参的构造方法创建对象</li><li><code>getConstructor(Class&lt;T&gt;… parameterTypes)</code>方法, 方法接受一个可变参数, 可以根据传入的类型来匹配对应的构造方法</li></ul></li><li>总结<ul><li><code>Constructor&lt;?&gt;[] getConstructors()</code>:获取该类中所有的构造方法, 返回的是一个数组</li><li><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code>: 方法接受一个可变参数, 可以根据传入的类型, 来匹配对应的构造方法<h3 id="反射操作公共成员变量"><a href="#反射操作公共成员变量" class="headerlink" title="反射操作公共成员变量"></a>反射操作公共成员变量</h3></li></ul></li><li>反射public成员变量(字段) <ul><li>通过反射运行public变量流程<ul><li><ol><li>通过反射获取该类的字节码对象:<code>Class clazz = Class.forName(&quot;com.lxy.Person&quot;);</code></li></ol></li><li><ol start="2"><li>创建该类对象:<code>Object p = clazz.newInstance();</code></li></ol></li><li><ol start="3"><li>获取该类中需要操作的字段(成员变量):<code>getField(String name)</code> –&gt; 方法传入字段的名称.</li></ol><ul><li>注意: 此方法只能获取公共的字段<br><code>Field f = clazz.getField(&quot;age&quot;);</code></li></ul></li><li><ol start="4"><li>通过字段对象中的方法修改属性值:<code>void set(Object obj, Object value)</code></li></ol><ul><li>参数1: 要修改的对象。</li><li>参数2: 将字段修改为什么值。<br><code>f.set(p, 23);</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo3</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//        method();</span></span><br><span class="line">        <span class="comment">//获取学生类的字节码对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        method2(clazz);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取学生类的字节码对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//获取学生类的对象</span></span><br><span class="line">        Object stu = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Field getField(String name)  :根据字段名称获取公共的字段对象</span></span><br><span class="line">        Field f = clazz.getField(<span class="string">&quot;age&quot;</span>);<span class="comment">//获取成员变量对象(成员变量age需要是public的)</span></span><br><span class="line">        <span class="comment">//void set(Object obj, Object value)</span></span><br><span class="line">        f.set(stu, <span class="number">28</span>);<span class="comment">//通过成员变量对象，修改指定对为指定的值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//Object get(Object obj)</span></span><br><span class="line">        Object age = f.get(stu);<span class="comment">//通过对象获取成员变量的值</span></span><br><span class="line">        System.out.println(age);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(Class clazz)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//Field[] getFields()  :获取公共的成员变量</span></span><br><span class="line">        Field[] fs = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fs.length; i++) &#123;</span><br><span class="line">            System.out.println(fs[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;---------------------------------&quot;</span>);</span><br><span class="line">        <span class="comment">//getDeclaredFields()  ：获取所有的成员变量(包含私有的)</span></span><br><span class="line">        Field[] fs2 = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fs2.length; i++) &#123;</span><br><span class="line">            System.out.println(fs2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li>总结:<ul><li>通过反射获取成员变量并使用:  <ul><li><code>Field[] getFields();</code>//返回该类所有(公共)的字段</li><li><code>Field getField(String name);</code>//返回指定名称字段</li><li><code>Field[] getDeclaredFields();</code>//暴力反射获取所有字段(包括私有) </li><li><code>Field getDeclaredField(String name);</code>//暴力反射获取指定名称字段</li><li>Field:<ul><li><code>Object get(Object obj);</code>//Field对象调用, 返回传入对象的具体字段</li><li><code>void set(Object obj, Object value);</code>//Field对象调用<ul><li>参数1: 要修改的对象。</li><li>参数2: 将此对象的字段修改为什么值。<h3 id="反射操作私有成员变量"><a href="#反射操作私有成员变量" class="headerlink" title="反射操作私有成员变量"></a>反射操作私有成员变量</h3></li></ul></li></ul></li></ul></li></ul></li><li>反射private成员变量(字段)<ul><li>执行流程<ul><li><ol><li>获取学生类字节码对象</li></ol></li><li><ol start="2"><li>获取学生对象</li></ol></li><li><ol start="3"><li>通过<code>Field[] getDeclaredFields();</code>方法获取私有字段</li></ol></li><li><ol start="4"><li>通过<code>void setAccessible(boolean flag)</code>让jvm不检查权限</li></ol></li><li><ol start="5"><li>通过set方法设置对象为具体的值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo4</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ReflectiveOperationException </span>&#123;</span><br><span class="line">        <span class="comment">//获取学生类的字节码对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//获取学生对象</span></span><br><span class="line">        Object stu = clazz.newInstance();</span><br><span class="line">        <span class="comment">//获取私有的字段对象</span></span><br><span class="line">        Field f = clazz.getDeclaredField(<span class="string">&quot;name&quot;</span>);</span><br><span class="line">        f.setAccessible(<span class="keyword">true</span>);<span class="comment">//设置反射时取消Java的访问检查,暴力访问</span></span><br><span class="line">        <span class="comment">//设置具体值</span></span><br><span class="line">        f.set(stu, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line"></span><br><span class="line">        Object name = f.get(stu);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过反射获取成员方法并使用"><a href="#通过反射获取成员方法并使用" class="headerlink" title="通过反射获取成员方法并使用"></a>通过反射获取成员方法并使用</h3></li></ol></li></ul></li></ul></li><li>反射获取普通成员方法<ul><li>执行流程:<ul><li><ol><li>获取学生类字节码对象</li></ol></li><li><ol start="2"><li>反射手段创建学生对象</li></ol></li><li><ol start="3"><li>调用getMethod方法获取Method对象, 方法形参接受方法的名字</li></ol></li><li><ol start="4"><li>调用Method方法中的invoke()将方法<strong>运行</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@AllArgsConstructor</span></span><br><span class="line"><span class="meta">@NoArgsConstructor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">public</span> Integer age;</span><br><span class="line">    <span class="keyword">public</span> String address;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.method&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">privateMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Student.privateMethod&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo5</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取学生类的字节码对象</span></span><br><span class="line">        Class clazz = Class.forName(<span class="string">&quot;reflect.Student&quot;</span>);</span><br><span class="line">        <span class="comment">//获取学生类的对象</span></span><br><span class="line">        Object stu = clazz.newInstance();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;获取无参无返回值的方法(public)&quot;</span>);</span><br><span class="line">        method(clazz,stu);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取有参无返回值的方法&quot;</span>);</span><br><span class="line">        method2(clazz,stu);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取无参有返回值的方法&quot;</span>);</span><br><span class="line">        method3(clazz,stu);</span><br><span class="line">        System.out.println(<span class="string">&quot;获取无参无返回值的方法(private)&quot;</span>);</span><br><span class="line">        method4(clazz,stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(Class clazz, Object stu)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取无参无返回值的方法</span></span><br><span class="line">        Method m = clazz.getMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line">        m.invoke(stu);<span class="comment">//并执行方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method4</span><span class="params">(Class clazz, Object stu)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取无参无返回值的方法</span></span><br><span class="line">        <span class="comment">// 暴力反射获取方法</span></span><br><span class="line">        Method method = clazz.getDeclaredMethod(<span class="string">&quot;privateMethod&quot;</span>);</span><br><span class="line">        <span class="comment">// 让jvm不检查权限</span></span><br><span class="line">        method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 执行方法</span></span><br><span class="line">        method.invoke(stu);<span class="comment">//并执行方法</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">(Class clazz, Object stu)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取有参无返回值的方法</span></span><br><span class="line">        Method m = clazz.getMethod(<span class="string">&quot;setName&quot;</span>, String.class);</span><br><span class="line">        m.invoke(stu, <span class="string">&quot;lisi&quot;</span>);<span class="comment">//并执行方法</span></span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method3</span><span class="params">(Class clazz, Object stu)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//获取无参有返回值的方法</span></span><br><span class="line">        Method m = clazz.getMethod(<span class="string">&quot;getName&quot;</span>);</span><br><span class="line">        Object obj = m.invoke(stu);<span class="comment">//并执行方法</span></span><br><span class="line">        System.out.println(obj);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol></li></ul></li></ul></li><li>方法总结：<ul><li>Class:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span></span>;  </span><br><span class="line">    <span class="comment">// 此方法由字节码对象调用</span></span><br><span class="line">    <span class="comment">// 参数1: 要反射的方法名称</span></span><br><span class="line">    <span class="comment">// 参数2: 此方法需要接受的参数类型(注意,传入的都是字节码)</span></span><br></pre></td></tr></table></figure></li><li>Method:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">invoke</span><span class="params">(Object obj, Object... args)</span></span>;  </span><br><span class="line">    <span class="comment">// 方法由Method对象调用</span></span><br><span class="line">    <span class="comment">// 参数1: 要由那个对象调用方法</span></span><br><span class="line">    <span class="comment">// 参数2: 方法需要的具体实参(实际参数)</span></span><br></pre></td></tr></table></figure></li></ul></li><li>私有的成员方法怎么玩?  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 获取字节码对象</span></span><br><span class="line">Class clazz = Class.forName(<span class="string">&quot;com.lxy.Student&quot;</span>);</span><br><span class="line"><span class="comment">// 创建学生对象</span></span><br><span class="line">Object stu = clazz.newInstance();</span><br><span class="line"><span class="comment">// 暴力反射获取方法</span></span><br><span class="line">Method method = clazz.getDeclaredMethod(<span class="string">&quot;method&quot;</span>);</span><br><span class="line"><span class="comment">// 让jvm不检查权限</span></span><br><span class="line">method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"><span class="comment">// 执行方法</span></span><br><span class="line">method.invoke(stu);</span><br></pre></td></tr></table></figure><h2 id="JavaBean的概述、BeanUtils的使用"><a href="#JavaBean的概述、BeanUtils的使用" class="headerlink" title="JavaBean的概述、BeanUtils的使用"></a>JavaBean的概述、BeanUtils的使用</h2><h3 id="JavaBean的概述和规范"><a href="#JavaBean的概述和规范" class="headerlink" title="JavaBean的概述和规范"></a>JavaBean的概述和规范</h3></li><li>JavaBean的概述:<ul><li>将需要操作的多个属性封装成JavaBean, 简单来说就是用于封装数据的.</li></ul></li><li>规范：<ul><li>类使用公共进行修饰</li><li>提供私有修饰的成员变量</li><li>为成员变量提供公共getter和setter方法</li><li>提供公共无参的构造<h3 id="BeanUtils"><a href="#BeanUtils" class="headerlink" title="BeanUtils"></a>BeanUtils</h3></li></ul></li><li>BeanUtils的由来:<ul><li>Apache commons提供的一个组件，主要功能就是为了简化JavaBean封装数据的操作</li><li>之前我们使用的类都是来自Java编写好的源代码</li><li>而这个BeanUtils却是一个叫做Apache的组织编写.<ul><li>那么这个组织编写的代码当中, 有一个系列可以很方便的提高我们今后的开发效率.</li><li>这个系列为Commons, BeanUtils就是其中之一</li></ul></li></ul></li><li>BeanUtils的常用方法<ul><li><code>static void setProperty(Object bean, String name, Object value)</code> <ul><li>用来给对象中的属性赋值(了解)</li><li>参数1: 需要设置属性的对象</li><li>参数2: 需要修改的属性名称</li><li>参数3: 需要修改的具体元素    </li></ul></li><li><code>static String getProperty(Object bean, String name)</code> <ul><li>用来获取对象中的属性(了解)</li><li>参数1: 要获取的javaBean对象</li><li>参数2: 对象中的哪个属性</li></ul></li><li>注意：BeanUtils的setProperty和getProperty方法底层并不是直接操作成员变量，而是操作和成员变量名有关的get和set方法</li><li><code>static void populate(Object bean, Map properties)</code> <ul><li>用来给对象中的属性赋值(掌握)</li><li>参数1: 要设置属性的对象</li><li>参数2: 将属性以Map集合的形式传入<ul><li>Key : 属性的名称</li><li>Value:  属性具体的值<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanUtilsDemo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//通过static void setProperty(Object bean, String name, Object value)</span></span><br><span class="line">        <span class="comment">//和static String getProperty(Object bean, String name)</span></span><br><span class="line">        <span class="comment">//进行设置属性及获取属性</span></span><br><span class="line">        method();</span><br><span class="line">        <span class="comment">//通过static void populate(Object bean, Map properties)</span></span><br><span class="line">        method2();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static void setProperty(Object bean, String name, Object value) ：给JavaBean对象的成员变量进行赋值</span></span><br><span class="line">        BeanUtils.setProperty(stu, <span class="string">&quot;name&quot;</span>, <span class="string">&quot;zhangsan&quot;</span>);</span><br><span class="line">        BeanUtils.setProperty(stu, <span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static String getProperty(Object bean, String name)</span></span><br><span class="line">        String name = BeanUtils.getProperty(stu, <span class="string">&quot;name&quot;</span>);</span><br><span class="line">        System.out.println(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//static void populate(Object bean, Map properties)</span></span><br><span class="line">        Map&lt;String, Object&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="string">&quot;name&quot;</span>, <span class="string">&quot;lisi&quot;</span>);</span><br><span class="line">        map.put(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>);</span><br><span class="line">        map.put(<span class="string">&quot;gender&quot;</span>, <span class="string">&quot;male&quot;</span>);</span><br><span class="line"></span><br><span class="line">        BeanUtils.populate(stu, map);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li>方法总结:<ul><li>三个方法底层是通过反射实现, 而且反射操作的是setXxx方法和getXxx方法.</li><li>所以编写JavaBean的时候一定要注意格式</li></ul></li></ul><h2 id="xml的概述与如何编写xml文件"><a href="#xml的概述与如何编写xml文件" class="headerlink" title="xml的概述与如何编写xml文件"></a>xml的概述与如何编写xml文件</h2><ul><li><p>xml语言的概述</p><ul><li>xml语言是具有<strong>结构性的标记语言</strong>,可以灵活的存储<strong>一对多</strong>的数据关系.</li><li>xml的使用场景:用来存储一对多的数据 </li></ul></li><li><p>xml是怎样存储数据的？</p><ul><li>以标签的形式存储。(例:  <name>Jack</name>)</li></ul></li><li><p>Xml文件的组成部分:</p><ul><li>文档声明</li><li>元素</li><li>元素的属性</li><li>注释</li><li>CDATA区：了解</li><li>特殊字符：了解</li><li>处理指令(PI:Processing Instruction)：了解</li></ul></li><li><p>xml的文档声明</p><ul><li>什么是文档声明?<ul><li>在编写XML文档时，需要先使用文档声明来声明XML文档。且必须出现在文档的第一行,这就好比我们在写java文件的时候需要声明class一样, 就是个硬性的规定.</li></ul></li><li>如何编写文档声明?  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27;?&gt;</span>`</span><br><span class="line">   //xml表示标签的名字</span><br><span class="line">//version表示当前文件的版本号</span><br><span class="line">//encoding表示当前编码, 需要跟文件的编码产生对应关系</span><br><span class="line">   //ps: standalone表示标记此文档是否独立</span><br></pre></td></tr></table></figure></li></ul></li><li><p>xml的元素</p><ul><li>什么是元素? <ul><li>xml中的元素其实就是一个个的标签</li><li>标签分为两种：<ul><li><strong>包含</strong>标签体<ul><li>尖括号全部成对儿出现, 所有的数据都用<strong>一对儿</strong>尖括号存储。<br>例如：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>不包含标签体<ul><li>只有最外层的一个尖括号,括号用/标识结束, 内部的数据都用属性来编写.<br>例如：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">student</span> </span></span><br><span class="line"><span class="tag">    <span class="attr">name</span>=<span class="string">&quot;zhangsan&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">age</span>=<span class="string">&quot;18&quot;</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>两种方式都需要掌握, 但是第二种编写起来会更加方便.</li></ul></li></ul></li><li>标签(元素的书写规范)<ul><li>严格区分大小写；<p><P></li><li>只能以字母或下划线开头；abc _abc</li><li>不能以xml(或XML、Xml等)开头—-W3C保留日后使用；</li><li>名称字符之间不能有空格或制表符；</li><li>名称字符之间不能使用冒号 : (有特殊用途)</li></ul></li><li>元素中属性的注意事项<ul><li>一个元素可以有多个属性，每个属性都有它自己的名称和取值。</li><li>属性值一定要用引号(单引号或双引号)引起来。</li><li>属性名称的命名规范与元素的命名规范相同</li><li>元素中的属性是不允许重复的</li><li>在XML技术中，标签属性所代表的信息也可以被改成用子元素的形式来描述<br>例如：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span> <span class="attr">name</span>=<span class="string">&quot;zhangsan&quot;</span> <span class="attr">age</span>=<span class="string">&quot;18&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">age</span>&gt;</span>18<span class="tag">&lt;/<span class="name">age</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>xml的注释</p><ul><li>格式编写:<code>&lt;!--被注释的内容 --&gt;</code></li><li>注意事项:注释不能嵌套定义</li></ul></li><li><p>xml的其他组成部分</p><ul><li><p>引入CDATA区</p><ul><li>为什么要使用CDATA区域?<ul><li>如果我们在标签中写入的内容, 想要带有标签的标记符号的话, 就需要对这段内容进行转义,就好比java中的打印语句, 想要打印出”这个字符就必须用\进行转义.标签也是一样, 想要将<itheima>当做内容存储的话, 就需要对他进行转义.</li></ul></li></ul></li><li><p>如何转义? </p><table><thead><tr><th>特殊符号</th><th>替代符号</th></tr></thead><tbody><tr><td>&amp;</td><td>&amp;amp;</td></tr><tr><td>&lt;</td><td>&amp;lt;</td></tr><tr><td>&gt;</td><td>&amp;gt;</td></tr><tr><td>“</td><td>&amp;quot;</td></tr><tr><td>‘</td><td>&amp;apos;</td></tr></tbody></table></li><li><p>注意:这种转义可以达到效果,但是如果操作的数据过多,编写起来会非常痛苦,所以,可以使用CDATA区来解决此问题<br>实例代码:</p>  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- </span></span><br><span class="line"><span class="comment">    如果有一个包含标签体的标签，</span></span><br><span class="line"><span class="comment">    他的标签体是一个普通文本，不是子标签，</span></span><br><span class="line"><span class="comment">    而普通文本中包含了一个标签，那这样可以吗？</span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">students</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">            &lt;![CDATA[</span><br><span class="line">                &lt;lxy&gt;www.lxy.com&lt;/lxy&gt;</span><br><span class="line">                &lt;xy&gt;www.xy.cn&lt;/xy&gt;</span><br><span class="line">            ]]&gt;</span><br><span class="line">        <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">student</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">name</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">url</span>&gt;</span></span><br><span class="line">            <span class="symbol">&amp;lt;</span>lxy<span class="symbol">&amp;gt;</span>www.lxy.com<span class="symbol">&amp;lt;</span>/lxy<span class="symbol">&amp;gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">student</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">students</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>DTD</strong></p><ul><li>为什么要有约束 (DTD)?<ul><li>XML都是用户自定义的标签，若出现小小的错误，软件程序将不能正确地获取文件中的内容而报错。(如：Tomcat)</li><li>XML技术中，可以编写一个文档来约束一个XML的书写规范，这个文档称之为<strong>约束</strong>.</li></ul></li><li>如何使用DTD约束文件?<ul><li>1.编写DTD文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="meta">&lt;!ELEMENT 书架(书+)&gt;</span></span><br><span class="line">    <span class="meta">&lt;!ELEMENT 书 (书名,作者,售价)&gt;</span></span><br><span class="line">    <span class="meta">&lt;!ELEMENT 书名 (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span><br><span class="line">    <span class="meta">&lt;!ELEMENT 作者 (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span><br><span class="line">    <span class="meta">&lt;!ELEMENT 售价 (<span class="meta-keyword">#PCDATA</span>)&gt;</span></span><br></pre></td></tr></table></figure></li><li>2.在xml文件中引入DTD文件:  <ul><li>引入了写好的DTD文件后, 格式就必须跟DTD文件保持一致<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE 书架 <span class="meta-keyword">SYSTEM</span> <span class="meta-string">&quot;book.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>DTD的细节</p><ul><li>语法细节<ul><li>在DTD文档中使用ELEMENT关键字来声明一个XML元素。<ul><li>语法：<code>&lt;!ELEMENT 元素名称 使用规则&gt;</code></li><li>使用规则：<ul><li>(#PCDATA):指示元素的主体内容只能是普通的文本.(Parsed Character Data)</li><li>EMPTY：用于指示元素的主体为空。比如<br/></li><li>ANY:用于指示元素的主体内容为任意类型。</li><li>(子元素)：指示元素中包含的子元素</li></ul></li><li>定义子元素及描述它们的关系:<ul><li>如果子元素用逗号分开，说明必须按照声明顺序去编写XML文档。<ul><li>如:<code>&lt;!ELEMENT FILE (TITLE,AUTHOR,EMAIL)</code></li></ul></li><li>如果子元素用”|”分开，说明任选其一。<ul><li>如:<code>&lt;!ELEMENT FILE (TITLE|AUTHOR|EMAIL)</code></li></ul></li><li>用+、*、？来表示元素出现的次数<ul><li>如果元素后面没有+*?:表示必须且只能出现一次</li><li>+:表示至少出现一次，一次或多次</li><li>*：表示可有可无，零次、一次或多次</li><li>?:表示可以有也可以无，有的话只能有一次。零次或一次</li></ul></li></ul></li></ul></li></ul></li><li>定义属性<ul><li>在DTD文档中使用ATTLIST关键字来为一个元素声明属性。</li><li>语法：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!ATTLIST 元素名</span></span><br><span class="line"><span class="meta">    属性名1 属性值类型 设置说明</span></span><br><span class="line"><span class="meta">    属性名2 属性值类型 设置说明</span></span><br><span class="line"><span class="meta">    …</span></span><br><span class="line"><span class="meta">&gt;</span></span><br></pre></td></tr></table></figure></li><li>属性值类型：<ul><li>CDATA：表示属性的取值为普通的文本字符串</li><li>ENUMERATED (DTD没有此关键字)：表示枚举，只能从枚举列表中任选其一，如(鸡肉|牛肉|猪肉|鱼肉)</li><li>ID:表示属性的取值不能重复</li></ul></li><li>设置说明<ul><li>#REQUIRED：表示该属性必须出现</li><li>#IMPLIED：表示该属性可有可无</li><li>#FIXED:表示属性的取值为一个固定值。语法：#FIXED “固定值”</li></ul></li><li>直接值：表示属性的取值为该默认值</li></ul></li><li>实例代码1：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">      <span class="meta">&lt;!ATTLIST 商品</span></span><br><span class="line"><span class="meta">类别 <span class="meta-keyword">CDATA</span> <span class="meta-keyword">#REQUIRED</span></span></span><br><span class="line"><span class="meta">颜色 <span class="meta-keyword">CDATA</span> <span class="meta-keyword">#IMPLIED</span></span></span><br><span class="line"><span class="meta">      &gt;</span></span><br><span class="line">      <span class="meta">&lt;?xml version = &quot;1.0&quot; encoding=&quot;GB2312&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line">          &lt;商品 类别=&quot;服装&quot;颜色=&quot;黄色&quot; /&gt;</span><br><span class="line">      ```   </span><br><span class="line">  - 实例代码2：</span><br><span class="line">      ```xml</span><br><span class="line">      <span class="meta">&lt;?xml version = &quot;1.0&quot; encoding=&quot;GB2312&quot; standalone=&quot;yes&quot;?&gt;</span></span><br><span class="line">      <span class="meta">&lt;!DOCTYPE 购物篮 [</span></span><br><span class="line"><span class="meta">      <span class="meta">&lt;!ELEMENT 购物篮 (肉+)&gt;</span></span></span><br><span class="line"><span class="meta">          <span class="meta">&lt;!ELEMENT 肉 <span class="meta-keyword">EMPTY</span>&gt;</span></span></span><br><span class="line"><span class="meta">          <span class="meta">&lt;!ATTLIST 肉 品种 ( 鸡肉 | 牛肉 | 猪肉 | 鱼肉 ) <span class="meta-string">&quot;鸡肉&quot;</span>&gt;</span></span></span><br><span class="line"><span class="meta">      ]&gt;</span> </span><br><span class="line">      &lt;购物篮&gt;</span><br><span class="line">          &lt;肉 品种=&quot;鱼肉&quot;/&gt;</span><br><span class="line">          &lt;肉 品种=&quot;牛肉&quot;/&gt;</span><br><span class="line">          &lt;肉/&gt;</span><br><span class="line">      &lt;/购物篮&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>Schema</p><ul><li>概述:<ul><li>Schema约束自身就是一个XML文件，但它的扩展名通常为.xsd</li><li>一个XML Schema文档通常称之为<strong>模式文档</strong>(约束文档)，遵循这个文档书写的xml文件称之为实例文档。</li><li>XML Schema对名称空间支持得非常好</li><li>理解:<ul><li>名称空间: 相当于package            </li><li>约束文档: 编写好的Person类         </li><li>实例文档: 通过Person类创建对象</li></ul></li></ul></li><li>Schema入门案例:  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">约束文档:</span><br><span class="line"><span class="meta">&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;UTF-8&#x27; ?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">xs:schema</span> <span class="attr">xmlns:xs</span>=<span class="string">&#x27;http://www.w3.org/2001/XMLSchema&#x27;</span> </span></span><br><span class="line"><span class="tag">                    //标准的名称空间</span></span><br><span class="line"><span class="tag">                    <span class="attr">targetNamespace</span>=<span class="string">&#x27;http://www.itheima.com&#x27;</span></span></span><br><span class="line"><span class="tag">                        //将该<span class="attr">schema</span>文档绑定到<span class="attr">http:</span>//<span class="attr">www.itheima.com</span>名称空间</span></span><br><span class="line"><span class="tag">                &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&#x27;书架&#x27;</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">xs:sequence</span> <span class="attr">maxOccurs</span>=<span class="string">&#x27;unbounded&#x27;</span> &gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&#x27;书&#x27;</span> &gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&#x27;书名&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;xs:string&#x27;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&#x27;作者&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;xs:string&#x27;</span> /&gt;</span></span><br><span class="line">                            <span class="tag">&lt;<span class="name">xs:element</span> <span class="attr">name</span>=<span class="string">&#x27;售价&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;xs:string&#x27;</span> /&gt;</span></span><br><span class="line">                        <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">xs:sequence</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">xs:complexType</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">xs:element</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">xs:schema</span>&gt;</span></span><br><span class="line"></span><br><span class="line">实例文档:</span><br><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line">&lt;itheima:书架 xmlns:itheima=&quot;http://www.itheima.com&quot;</span><br><span class="line">                xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">                xsi:schemaLocation=&quot;http://www.itheima.com book.xsd&quot;&gt;</span><br><span class="line">    &lt;itheima:书&gt;</span><br><span class="line">        &lt;itheima:书名&gt;JavaScript网页开发&lt;/itheima:书名&gt;</span><br><span class="line">        &lt;itheima:作者&gt;张孝祥&lt;/itheima:作者&gt;</span><br><span class="line">        &lt;itheima:售价&gt;28.00元&lt;/itheima:售价&gt;</span><br><span class="line">    &lt;/itheima:书&gt;</span><br><span class="line">&lt;/itheima:书架&gt;</span><br><span class="line"></span><br><span class="line">名称空间:</span><br><span class="line">&lt;itheima:书架 xmlns:itheima=&quot;http://www.itheima.com&quot;</span><br><span class="line">xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">xsi:schemaLocation=&quot;http://www.itheima.com book.xsd&quot;&gt;</span><br></pre></td></tr></table></figure><ul><li>使用默认名称空间：<ul><li>格式：<code>xmlns=&quot;URI&quot;</code></li><li>实例：<pre><code class="xml">&lt;书架 xmlns=&quot;http://www.it315.org/xmlbook/schema&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    xsi:schemaLocation=&quot;http://www.it315.org/xmlbook/schema book.xsd&quot;&gt;    &lt;书&gt;    &lt;书名&gt;JavaScript网页开发&lt;/书名&gt;    &lt;作者&gt;张孝祥&lt;/作者&gt;    &lt;售价&gt;28.00元&lt;/售价&gt;    &lt;/书&gt;&lt;书架&gt;</code></pre><h2 id="解析xml文件"><a href="#解析xml文件" class="headerlink" title="解析xml文件"></a>解析xml文件</h2></li></ul></li></ul></li></ul></li><li><p>XML解析的两种方式:</p><ul><li>DOM方式：Document Object Model，文档对象模型。这种方式是W3C推荐的处理XML的一种方式。</li><li>SAX方式：Simple API for XML。这种方式不是官方标准，属于开源社区XML-DEV，几乎所有的XML解析器都支持它。</li></ul></li><li><p>XML解析开发包</p><ul><li>JAXP：是SUN公司推出的解析标准实现。</li><li>Dom4J：是开源组织推出的解析开发包。(牛，大家都在用，包括SUN公司的一些技术的实现都在用。)</li><li>Dom for java four</li><li>Log4j</li></ul></li><li><p>总结:</p><ul><li>DOM: 将整棵树一口气全部加载到内存当中, 我们可以非常方便的操作任意的标签和属性。但是, 如果整棵树特别大的时候, 会出现内存溢出的问题。</li><li>节点: 标签、属性、文本、甚至是换行都称之为节点</li><li>SAX: 一个节点一个节点的进行解析(暂不掌握)</li></ul></li><li><p>Dom4J的方法</p><ul><li>Dom4J的常用方法：<ul><li>Document： <ul><li><code>Element getRootElement()</code>:获取根元素对象（根标签）</li></ul></li><li>Element:<ul><li><code>List elements()</code> ：获取所有的子元素</li><li><code>List elements(String name)</code>：根据指定的元素名称来获取相应的所有的子元素</li><li><code>Element element(String name)</code>：根据指定的元素名称来获取子元素对象,如果元素名称重复，则获取第一个元素 </li><li><code>String elementText(String name)</code> ：根据指定的子元素名称，来获取子元素中的文本</li><li><code>String getText()</code> ：获取当前元素对象的文本</li><li><code>void setText(String text)</code>：设置当前元素对象的文本</li><li><code>String attributeValue(String name)</code>：根据指定的属性名称获取其对应的值</li><li><code>public Element addAttribute(String name,String value)</code>：根据指定的属性名称和值进行添加或者修改BeanUtils的常用方法</li></ul></li></ul></li><li>Dom4J的案例—见提高篇Day14</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch-Query DSL详解</title>
      <link href="/2021/04/23/database/ElasticSearch-Query_DSL%E6%95%99%E7%A8%8B/"/>
      <url>/2021/04/23/database/ElasticSearch-Query_DSL%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="Query-DSL"><a href="#Query-DSL" class="headerlink" title="Query DSL"></a>Query DSL</h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.x/query-dsl.html">官方文档-ES查询语法</a></p><h3 id="0-基础操作"><a href="#0-基础操作" class="headerlink" title="0.基础操作"></a>0.基础操作</h3><ul><li>查看集群的状况:<code>GET /_cat</code></li><li>查看集群健康状态:<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># v是用来要求在结果中返回表头</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>_cat<span class="operator">/</span>health?v</span><br></pre></td></tr></table></figure>health状态值说明<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Green - 最佳状态</span><br><span class="line">Yellow - 数据和集群可用，但是集群的备份有的是坏的</span><br><span class="line">Red - 数据和集群都不可用</span><br></pre></td></tr></table></figure></li><li>查看节点状态:<code>GET /_cat/nodes?v</code></li><li>查看所有索引:<code>GET /_cat/indices?v</code></li><li>列出每个Index所包含的Type:<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 增加pretty参数，会让Es美化输出(pretty<span class="operator">-</span>print)JSON响应以便更加容易阅读</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>_mapping?pretty<span class="operator">=</span><span class="literal">true</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="1-索引-index"><a href="#1-索引-index" class="headerlink" title="1.索引(index)"></a>1.索引(index)</h3><p>注意：索引的名称必须是<strong>小写</strong>的，不可重名</p><ul><li>查询所有index:<code>GET /_cat/indices?v</code></li><li>查询index:<code>GET /test</code> or <code>GET /test*</code></li><li>新增index(新增一个名为test的index):<code>PUT /test</code></li><li>删除index(删除test这个index):<code>DELETE /test</code></li></ul><h3 id="2-文档-document"><a href="#2-文档-document" class="headerlink" title="2.文档(document)"></a>2.文档(document)</h3><p>index中的单条记录称之为document。</p><h4 id="2-1-新增document"><a href="#2-1-新增document" class="headerlink" title="2.1 新增document"></a>2.1 新增document</h4><h5 id="2-1-1-新增时指定ID-用PUT"><a href="#2-1-1-新增时指定ID-用PUT" class="headerlink" title="2.1.1 新增时指定ID(用PUT)"></a>2.1.1 新增时指定ID(用PUT)</h5><p>格式:/Index/Type/Id</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"># 指定了文档ID<span class="operator">=</span><span class="number">1</span></span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;lxy1&quot;,</span><br><span class="line">    &quot;ename&quot;: &quot;lxy1&quot;,</span><br><span class="line">    &quot;age&quot;: <span class="number">18</span>,</span><br><span class="line">    &quot;about&quot;: &quot;I am a good coder&quot;,</span><br><span class="line">    &quot;interest&quot;: [</span><br><span class="line">        &quot;eat&quot;,</span><br><span class="line">        &quot;coding&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interest_count&quot;: <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"># 指定了文档ID<span class="operator">=</span><span class="number">2</span></span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;lxy2&quot;,</span><br><span class="line">    &quot;ename&quot;: &quot;lxy2&quot;,</span><br><span class="line">    &quot;age&quot;: <span class="number">29</span>,</span><br><span class="line">    &quot;about&quot;: &quot;I am a tester&quot;,</span><br><span class="line">    &quot;interest&quot;: [</span><br><span class="line">        &quot;eat&quot;,</span><br><span class="line">        &quot;testing&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interest_count&quot;: <span class="number">2</span>,</span><br><span class="line">    &quot;job&quot;: <span class="keyword">null</span></span><br><span class="line">&#125;</span><br><span class="line"># 指定了文档ID<span class="operator">=</span><span class="number">3</span></span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">3</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;lxy3&quot;,</span><br><span class="line">    &quot;ename&quot;: &quot;lxy3&quot;,</span><br><span class="line">    &quot;age&quot;: <span class="number">3</span>,</span><br><span class="line">    &quot;about&quot;: &quot;I am a baby&quot;,</span><br><span class="line">    &quot;interest&quot;: [</span><br><span class="line">        &quot;eat&quot;,</span><br><span class="line">        &quot;play&quot;,</span><br><span class="line">        &quot;sleep&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interest_count&quot;: <span class="number">3</span>,</span><br><span class="line">    &quot;job&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-由ES自动生成ID-用POST新增文档，ES自动为文档生成20位的ID"><a href="#2-1-2-由ES自动生成ID-用POST新增文档，ES自动为文档生成20位的ID" class="headerlink" title="2.1.2 由ES自动生成ID(用POST新增文档，ES自动为文档生成20位的ID)"></a>2.1.2 由ES自动生成ID(用POST新增文档，ES自动为文档生成20位的ID)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_doc</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;小康康&quot;,</span><br><span class="line">    &quot;age&quot;: <span class="number">2</span>,</span><br><span class="line">    &quot;about&quot;: &quot;I am a cat&quot;,</span><br><span class="line">    &quot;interest&quot;: [</span><br><span class="line">        &quot;eat&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interest_count&quot;: <span class="number">1</span>,</span><br><span class="line">    &quot;job&quot;: [</span><br><span class="line">        <span class="keyword">null</span>,</span><br><span class="line">        &quot;get mouse&quot;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-3-指定操作类型参数：op-type"><a href="#2-1-3-指定操作类型参数：op-type" class="headerlink" title="2.1.3 指定操作类型参数：op_type"></a>2.1.3 指定操作类型参数：op_type</h5><p>新增文档时，可以同时指定op_type，当es里已经存在相同ID的文档时，就会新增失败</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"># 指定操作类型op_type<span class="operator">=</span><span class="keyword">create</span></span><br><span class="line"># 执行会报:document already <span class="keyword">exists</span></span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">3</span>?op_type<span class="operator">=</span><span class="keyword">create</span></span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;lxy3&quot;,</span><br><span class="line">    &quot;ename&quot;: &quot;lxy3&quot;,</span><br><span class="line">    &quot;age&quot;: <span class="number">3</span>,</span><br><span class="line">    &quot;about&quot;: &quot;I am a baby&quot;,</span><br><span class="line">    &quot;interest&quot;: [</span><br><span class="line">        &quot;eat&quot;,</span><br><span class="line">        &quot;play&quot;,</span><br><span class="line">        &quot;sleep&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interest_count&quot;: <span class="number">3</span>,</span><br><span class="line">    &quot;job&quot;: []</span><br><span class="line">&#125;</span><br><span class="line"># 等价于：指定是<span class="keyword">create</span>文档</span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">3</span><span class="operator">/</span>_create</span><br><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;lxy3&quot;,</span><br><span class="line">    &quot;ename&quot;: &quot;lxy3&quot;,</span><br><span class="line">    &quot;age&quot;: <span class="number">3</span>,</span><br><span class="line">    &quot;about&quot;: &quot;I am a baby&quot;,</span><br><span class="line">    &quot;interest&quot;: [</span><br><span class="line">        &quot;eat&quot;,</span><br><span class="line">        &quot;play&quot;,</span><br><span class="line">        &quot;sleep&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;interest_count&quot;: <span class="number">3</span>,</span><br><span class="line">    &quot;job&quot;: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-4-指定文档版本号version-新版本改为seq-no和primary-term，所以此处直接介绍seq-no方式"><a href="#2-1-4-指定文档版本号version-新版本改为seq-no和primary-term，所以此处直接介绍seq-no方式" class="headerlink" title="2.1.4 指定文档版本号version(新版本改为seq_no和primary_term，所以此处直接介绍seq_no方式)"></a>2.1.4 指定文档版本号version(新版本改为seq_no和primary_term，所以此处直接介绍seq_no方式)</h5><p>每个<strong>文档</strong>的版本号”_version”起始值都为1,每次对当前文档成功操作后都加1</p><p>而序列号”_seq_no”则可以看做是<strong>索引</strong>的信息,在第一次为索引插入数据时为0,后面每对索引内数据操作成功一次加1，并且文档会记录是第几次操作使它成为现在的情况的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#先新增一个ID<span class="operator">=</span><span class="number">100</span>的文档</span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">100</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;羽哥&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果可以看到_seq_no</span><br></pre></td></tr></table></figure><p>当我们要修改时，带上if_seq_no参数（值是我们认定的更新前，当前文档的_seq_no值），如果我们指定的与ES里文档相等，则能成功，否则报异常。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 指定更新前文档_seq_no<span class="operator">=</span><span class="number">17</span></span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">100</span>?if_seq_no<span class="operator">=</span><span class="number">17</span><span class="operator">&amp;</span>if_primary_term<span class="operator">=</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;羽哥2&quot;</span><br><span class="line">&#125;</span><br><span class="line"># id<span class="operator">=</span><span class="number">100</span>的文档的_seq_no<span class="operator">=</span><span class="number">18</span>，所以修改成功，_seq_no变为<span class="number">18</span></span><br></pre></td></tr></table></figure><h4 id="2-2-查询document"><a href="#2-2-查询document" class="headerlink" title="2.2 查询document"></a>2.2 查询document</h4><h5 id="2-2-1-查询index的所有document"><a href="#2-2-1-查询index的所有document" class="headerlink" title="2.2.1 查询index的所有document"></a>2.2.1 查询index的所有document</h5><p><code>GET /test/_search</code></p><h5 id="2-2-2-根据id查询document-查询id-1的文档"><a href="#2-2-2-根据id查询document-查询id-1的文档" class="headerlink" title="2.2.2 根据id查询document(查询id=1的文档)"></a>2.2.2 根据id查询document(查询id=1的文档)</h5><p><code>GET /test/_doc/1?pretty</code></p><h5 id="2-2-3-通过size指定返回结果条数"><a href="#2-2-3-通过size指定返回结果条数" class="headerlink" title="2.2.3 通过size指定返回结果条数"></a>2.2.3 通过size指定返回结果条数</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 只查询一条，默认返回<span class="number">10</span>条</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;&quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">  &quot;size&quot;: <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-4-用sort排序查询"><a href="#2-2-4-用sort排序查询" class="headerlink" title="2.2.4 用sort排序查询"></a>2.2.4 用sort排序查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 对age进行倒序查询</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;&quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">  &quot;sort&quot;: [&#123;&quot;age&quot;: &#123;&quot;order&quot;: &quot;desc&quot;&#125;&#125;]</span><br><span class="line">&#125;</span><br><span class="line"># 或者</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;&quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">  &quot;sort&quot;: &#123;&quot;age&quot;: &#123; &quot;order&quot;: &quot;desc&quot;&#125;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-5-用from和size分页查询"><a href="#2-2-5-用from和size分页查询" class="headerlink" title="2.2.5 用from和size分页查询"></a>2.2.5 用from和size分页查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 查询前<span class="number">2</span>条数据, <span class="keyword">from</span>是从<span class="number">0</span>开始的</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;&quot;match_all&quot;: &#123;&#125;&#125;,</span><br><span class="line">  &quot;sort&quot;: [&#123;&quot;age&quot;: &#123;&quot;order&quot;: &quot;desc&quot;&#125;&#125;],</span><br><span class="line">  &quot;from&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;size&quot;: <span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-2-6-根据ID判断是否存在"><a href="#2-2-6-根据ID判断是否存在" class="headerlink" title="2.2.6 根据ID判断是否存在"></a>2.2.6 根据ID判断是否存在</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 存在返回<span class="number">200</span>，不存在返回<span class="number">404</span></span><br><span class="line">HEAD <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br></pre></td></tr></table></figure><h5 id="2-2-7-用-source参数过滤返回的字段"><a href="#2-2-7-用-source参数过滤返回的字段" class="headerlink" title="2.2.7 用_source参数过滤返回的字段"></a>2.2.7 用_source参数过滤返回的字段</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"># 不返回_source</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span>?_source<span class="operator">=</span><span class="literal">false</span></span><br><span class="line"></span><br><span class="line"># 只返回_source</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span><span class="operator">/</span>_source</span><br><span class="line"></span><br><span class="line"># 只返回ID<span class="operator">=</span><span class="number">1</span>文档的name,age</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span>?_source<span class="operator">=</span>name,age</span><br><span class="line"></span><br><span class="line"># 只返回_source中某些字段</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;includes&quot;: [&quot;name&quot;, &quot;age&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 如果只是_source_includes可以简写如下</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_source&quot;: [&quot;name&quot;, &quot;age&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 只返回以a开头的字段</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_source&quot;: [&quot;w*&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># _source_excludes:屏蔽部分字段</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;excludes&quot;: [&quot;name&quot;, &quot;age&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 都有时，excludes优先级<span class="operator">&gt;</span>includes优先级</span><br><span class="line"># includes包含了name，但excludes也包含了name。返回结果中只有age。</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;includes&quot;: [&quot;name&quot;, &quot;age&quot;],</span><br><span class="line">    &quot;excludes&quot;: [&quot;name&quot;, &quot;interest&quot;]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 只返回a开头并且不是e结尾的字段</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_source&quot;: &#123;</span><br><span class="line">    &quot;includes&quot;: &quot;a*&quot;,</span><br><span class="line">    &quot;excludes&quot;: &quot;*e&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 带上查询条件和_source过滤</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;term&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: <span class="number">3</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, </span><br><span class="line">  &quot;_source&quot;: [&quot;name&quot;, &quot;age&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 只排除某些字段</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span>?_source_excludes<span class="operator">=</span>about,interest</span><br><span class="line"></span><br><span class="line"># 判断_source是否存在,存在返回<span class="number">200</span>，不存在返回<span class="number">404</span></span><br><span class="line">HEAD test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span><span class="operator">/</span>_source</span><br><span class="line"></span><br><span class="line"># 在ES7.X中,可以有如下写法</span><br><span class="line"><span class="keyword">GET</span> test<span class="operator">/</span>_source<span class="operator">/</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> test<span class="operator">/</span>_source<span class="operator">/</span><span class="number">1</span>?_source<span class="operator">=</span>name</span><br></pre></td></tr></table></figure><h4 id="2-3-修改document"><a href="#2-3-修改document" class="headerlink" title="2.3 修改document"></a>2.3 修改document</h4><h5 id="2-3-1-用PUT替换document"><a href="#2-3-1-用PUT替换document" class="headerlink" title="2.3.1 用PUT替换document"></a>2.3.1 用PUT替换document</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 首先查看id<span class="operator">=</span><span class="number">1</span>的文档</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line"># 用PUT方式更新id<span class="operator">=</span><span class="number">1</span>的文档</span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;羽哥&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 更新后再查看id<span class="operator">=</span><span class="number">1</span>的文档</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line"># 通过上面发现用PUT是替换了整个文档，而不是更新name这一个字段</span><br></pre></td></tr></table></figure><h5 id="2-3-2-用POST更新document"><a href="#2-3-2-用POST更新document" class="headerlink" title="2.3.2 用POST更新document"></a>2.3.2 用POST更新document</h5><p>先恢复id=1的文档数据，可通过再次执行2.1.1中id=1的语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 修改name,并新增interesting这个字段</span><br><span class="line"># POST <span class="operator">/</span>pigg<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span><span class="operator">/</span>_update,新版本格式改为<span class="operator">/</span>&#123;index&#125;<span class="operator">/</span>_update<span class="operator">/</span>&#123;id&#125;</span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_update<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;doc&quot;:&#123;</span><br><span class="line">      &quot;name&quot;: &quot;羽哥&quot;,</span><br><span class="line">      &quot;interesting&quot;: &quot;watching TV&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 这时发现用POST更新的是文档的局部字段,原来有的字段更新,没有的字段则新增这个字段</span><br></pre></td></tr></table></figure><h5 id="2-3-3-用script更新document"><a href="#2-3-3-用script更新document" class="headerlink" title="2.3.3 用script更新document"></a>2.3.3 用script更新document</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查询当前id<span class="operator">=</span><span class="number">1</span>的人的age是<span class="number">18</span>,现在要对age加<span class="number">1</span></span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_update<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &quot;ctx._source.age += 1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-用script更新document其他例子"><a href="#2-3-4-用script更新document其他例子" class="headerlink" title="2.3.4 用script更新document其他例子"></a>2.3.4 用script更新document其他例子</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"># age<span class="number">-1</span></span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_update<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.age -= 1&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># age<span class="operator">=</span><span class="number">30</span></span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_update<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.age = 30&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># name<span class="operator">=</span><span class="string">&#x27;witerking&#x27;</span></span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_update<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.name = &#x27;lxyking&#x27;&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 给数组添加一个值,就算存在也添加,语言用painless</span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_update<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.interest.add(params.interest)&quot;,</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;interest&quot;: &quot;sleep&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 给数组添加一个值,不存在才添加,语言用painless</span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_update<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;if(!ctx._source.interest.contains(params.interest)) &#123;ctx._source.interest.add(params.interest)&#125;&quot;,</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;,</span><br><span class="line">    &quot;params&quot;: &#123;</span><br><span class="line">      &quot;interest&quot;: &quot;sleeping&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 给文档添加一个新字段new_name </span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_update<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.new_name = &#x27;天才&#x27;&quot;,</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 字段直接复制</span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_update<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.new_name = ctx._source.name&quot;,</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 删除一个字段,不修改mapping</span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_update<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;script&quot;: &quot;ctx._source.remove(&#x27;new_name&#x27;)&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-4-删除document"><a href="#2-4-删除document" class="headerlink" title="2.4 删除document"></a>2.4 删除document</h4><h5 id="2-4-1-根据ID删除"><a href="#2-4-1-根据ID删除" class="headerlink" title="2.4.1 根据ID删除"></a>2.4.1 根据ID删除</h5><p><code>DELETE /test/_doc/1</code></p><h5 id="2-4-2-根据查询结果进行删除-delete-by-query"><a href="#2-4-2-根据查询结果进行删除-delete-by-query" class="headerlink" title="2.4.2 根据查询结果进行删除(delete_by_query)"></a>2.4.2 根据查询结果进行删除(delete_by_query)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># delete_by_query</span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_delete_by_query</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: &quot;5&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 忽略版本冲突,继续执行删除操作</span><br><span class="line">POST <span class="operator">/</span>pig<span class="operator">/</span>_delete_by_query?conflicts<span class="operator">=</span>proceed</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;_id&quot;: &quot;5&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-DSL文档查询"><a href="#3-DSL文档查询" class="headerlink" title="3.DSL文档查询"></a>3.DSL文档查询</h3><h4 id="3-1-准备测试数据"><a href="#3-1-准备测试数据" class="headerlink" title="3.1 准备测试数据"></a>3.1 准备测试数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;lxy&quot;,</span><br><span class="line">  &quot;age&quot;: <span class="number">18</span>,</span><br><span class="line">  &quot;hometown&quot;: &quot;杭州&quot;,</span><br><span class="line">  &quot;gender&quot;: &quot;male&quot;,</span><br><span class="line">  &quot;interesting&quot;: &quot;watching TV&quot;</span><br><span class="line">&#125;</span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;yfw&quot;,</span><br><span class="line">  &quot;age&quot;: <span class="number">28</span>,</span><br><span class="line">  &quot;hometown&quot;: &quot;福建&quot;,</span><br><span class="line">  &quot;gender&quot;: &quot;female&quot;,</span><br><span class="line">  &quot;interesting&quot;: &quot;watching movie&quot;</span><br><span class="line">&#125;</span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">3</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;yb&quot;,</span><br><span class="line">  &quot;age&quot;: <span class="number">30</span>,</span><br><span class="line">  &quot;hometown&quot;: &quot;苏州&quot;,</span><br><span class="line">  &quot;gender&quot;: &quot;female&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-查询部分字段"><a href="#3-2-查询部分字段" class="headerlink" title="3.2 查询部分字段"></a>3.2 查询部分字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;_source&quot;: [&quot;name&quot;, &quot;age&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-match"><a href="#3-3-match" class="headerlink" title="3.3 match"></a>3.3 match</h4><p>如果有多个搜索关键字,Elastic认为它们是or的关系。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 查询interesting匹配&quot;watching TV&quot;(查询watching或者TV)</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;interesting&quot;: &quot;watching TV&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 或者通过<span class="number">9200</span>端口的HTTP形式查询</span><br><span class="line">curl <span class="operator">-</span>XPOST <span class="string">&#x27;localhost:9200/test/_search?pretty&#x27;</span> <span class="operator">-</span>d <span class="string">&#x27;</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">  &quot;query&quot; : &#123; &quot;match&quot; : &#123; &quot;interesting&quot; : &quot;watching TV&quot; &#125;&#125;</span></span><br><span class="line"><span class="string">&#125;&#x27;</span></span><br></pre></td></tr></table></figure><p>看到结果也返回了”interesting”= “watching movie”的数据, 其中id=1的_score要比id=2的要高,这个_score说明是匹配的程度,id=1的要比id=2的更加匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查询interesting匹配&quot;TV&quot;或者&quot;moive&quot;</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;interesting&quot;: &quot;TV movie&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面结果命中了2个人, “_score”都是0.6931472,说明匹配度两者相同</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查询age<span class="operator">=</span><span class="number">30</span>的</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;age&quot;: <span class="number">30</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-match-phrase"><a href="#3-4-match-phrase" class="headerlink" title="3.4 match_phrase"></a>3.4 match_phrase</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 短语查询,这个会将&quot;watching TV&quot;作为一个短语去进行匹配查询(精确匹配)</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;match_phrase&quot;: &#123;</span><br><span class="line">      &quot;interesting&quot;: &quot;watching TV&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-must-且"><a href="#3-5-must-且" class="headerlink" title="3.5 must(且)"></a>3.5 must(且)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询interesting匹配&quot;watching TV&quot;,并且gender匹配&quot;female&quot;</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123;&quot;interesting&quot;: &quot;watching TV&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123;&quot;gender&quot;: &quot;female&quot; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&#123; &quot;match&quot;: &#123;&quot;interesting&quot;: &quot;watching TV&quot; &#125;&#125;</code>这条件语句能返回id=1或2的数据,<code>&#123; &quot;match&quot;: &#123;&quot;gender&quot;: &quot;female&quot; &#125;&#125;</code>这条件语句能返回id=2或3的数据,这两条语句是且的关系,所有最后返回id=2的数据</p><h4 id="3-6-should-或"><a href="#3-6-should-或" class="headerlink" title="3.6 should(或)"></a>3.6 should(或)</h4><ul><li>3.6.1 查询interesting匹配”watching mobile”,<strong>或</strong>gender匹配”female”<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#查询interesting匹配&quot;watching mobile&quot;,或gender匹配&quot;female&quot;</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123;&quot;interesting&quot;: &quot;watching movie&quot; &#125;&#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123;&quot;gender&quot;: &quot;female&quot; &#125;&#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>从上面结果看,id=2的数据匹配得分最高,另外两个匹配度相同,注意这次查询的是”watching mobile”,不是”watching TV”</li><li>3.6.2 minimum_should_match<br>这个是指或的条件,必须满足多少条<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 下面的minimum_should_match<span class="operator">=</span><span class="number">2</span>,所以一条都查不到</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;age&quot;: &#123;</span><br><span class="line">              &quot;gte&quot;: <span class="number">0</span>,</span><br><span class="line">              &quot;lte&quot;: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">         &quot;match&quot;: &#123; &quot;hometown.keyword&quot;: &quot;杭州&quot; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      &quot;minimum_should_match&quot;: <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-7-must-not-非"><a href="#3-7-must-not-非" class="headerlink" title="3.7 must_not(非)"></a>3.7 must_not(非)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询interesting不匹配&quot;watching TV&quot;,并且gender不匹配&quot;female&quot;</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123; &quot;match&quot;: &#123;&quot;interesting&quot;: &quot;watching TV&quot;&#125; &#125;,</span><br><span class="line">        &#123; &quot;match&quot;: &#123;&quot;gender&quot;: &quot;female&quot;&#125; &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>查询结果是空的,没有匹配的数据<h4 id="3-8-组合多查询bool"><a href="#3-8-组合多查询bool" class="headerlink" title="3.8 组合多查询bool"></a>3.8 组合多查询bool</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"># 用<span class="keyword">SQL</span>表示如下:<span class="keyword">where</span> gender <span class="operator">!=</span> <span class="string">&#x27;male&#x27;</span> <span class="keyword">and</span> ((age <span class="operator">&gt;=</span> <span class="number">0</span> <span class="keyword">and</span> age <span class="operator">&lt;=</span> <span class="number">3</span>) <span class="keyword">or</span> hometown <span class="operator">=</span> <span class="string">&#x27;福建&#x27;</span>)</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must_not&quot;: [&#123;&quot;match&quot;: &#123;&quot;gender&quot;: &quot;male&quot;&#125;&#125;],</span><br><span class="line">      &quot;should&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;range&quot;: &#123;</span><br><span class="line">            &quot;age&quot;: &#123;</span><br><span class="line">              &quot;gte&quot;: <span class="number">0</span>,</span><br><span class="line">              &quot;lte&quot;: <span class="number">3</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">         &quot;match&quot;: &#123;&quot;hometown.keyword&quot;: &quot;福建&quot;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-9-不影响评分的filter"><a href="#3-9-不影响评分的filter" class="headerlink" title="3.9 不影响评分的filter"></a>3.9 不影响评分的filter</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># 如果不希望age的比较影响评分,可以放到<span class="keyword">filter</span>里</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [&#123;&quot;match&quot;: &#123;&quot;interesting&quot;: &quot;watching TV&quot;&#125;&#125;], </span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: <span class="number">10</span>,</span><br><span class="line">            &quot;lte&quot;: <span class="number">29</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="4-DSL聚合查询"><a href="#4-DSL聚合查询" class="headerlink" title="4.DSL聚合查询"></a>4.DSL聚合查询</h3><h4 id="4-1-准备测试数据"><a href="#4-1-准备测试数据" class="headerlink" title="4.1 准备测试数据"></a>4.1 准备测试数据</h4><p>数据同3.1，此处略</p><h4 id="4-2-group-by-举例-按照性别分组"><a href="#4-2-group-by-举例-按照性别分组" class="headerlink" title="4.2 group by(举例: 按照性别分组)"></a>4.2 group by(举例: 按照性别分组)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SQL</span>描述</span><br><span class="line"><span class="keyword">SELECT</span> gender,<span class="built_in">COUNT</span>(<span class="number">1</span>) </span><br><span class="line"><span class="keyword">FROM</span> test </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> gender </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="built_in">COUNT</span>(<span class="number">1</span>) <span class="keyword">DESC</span> </span><br><span class="line"># DSL描述</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_gender&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;gender.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-avg-举例-求平均年龄"><a href="#4-3-avg-举例-求平均年龄" class="headerlink" title="4.3 avg(举例: 求平均年龄)"></a>4.3 avg(举例: 求平均年龄)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SQL</span>描述</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">AVG</span>(age) <span class="keyword">FROM</span> test</span><br><span class="line"># DSL描述</span><br><span class="line"># &quot;size&quot;:<span class="number">0</span>不返回查询结果，仅返回聚合结果</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;:<span class="number">0</span>,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;avg_age&quot;: &#123;</span><br><span class="line">      &quot;avg&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;age&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-4-avg和group-by组合-举例-求不同性别的平均年龄"><a href="#4-4-avg和group-by组合-举例-求不同性别的平均年龄" class="headerlink" title="4.4 avg和group by组合(举例: 求不同性别的平均年龄)"></a>4.4 avg和group by组合(举例: 求不同性别的平均年龄)</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SQL</span>描述</span><br><span class="line"><span class="keyword">SELECT</span> gender, <span class="built_in">AVG</span>(age) <span class="keyword">as</span> <span class="string">&#x27;avg_age&#x27;</span></span><br><span class="line"><span class="keyword">FROM</span> test</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> gender </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="string">&#x27;avg_age&#x27;</span> <span class="keyword">DESC</span></span><br><span class="line"># DSL描述</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>, </span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;group_by_gender&quot;:&#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;gender.keyword&quot;,</span><br><span class="line">        &quot;order&quot;: &#123;</span><br><span class="line">          &quot;avg_age&quot;: &quot;desc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;aggs&quot;: &#123;</span><br><span class="line">        &quot;avg_age&quot;: &#123;</span><br><span class="line">          &quot;avg&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;age&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-5-date-range"><a href="#4-5-date-range" class="headerlink" title="4.5 date_range"></a>4.5 date_range</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># 查询最近<span class="number">7</span>天的数据</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;date_range&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd&quot;,</span><br><span class="line">        &quot;ranges&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;from&quot;: &quot;now-7d/d&quot;,</span><br><span class="line">            &quot;to&quot;: &quot;now&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-6-date-histogram-日期直方图"><a href="#4-6-date-histogram-日期直方图" class="headerlink" title="4.6 date_histogram 日期直方图"></a>4.6 date_histogram 日期直方图</h4><p>基于日期类型字段，<strong>以日期间隔来分桶聚合</strong>。可用的时间间隔类型为：year、quarter、month、week、day、hour、minute、second，其中，除了year、quarter 和 month，其余可用小数形式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"># 统计每个月的人数</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;dates&quot;: &#123;</span><br><span class="line">      &quot;date_histogram&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;interval&quot;: &quot;month&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 去除统计的doc_count<span class="operator">=</span><span class="number">0</span>的数据</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;dates&quot;: &#123;</span><br><span class="line">      &quot;date_histogram&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;interval&quot;: &quot;month&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM&quot;,</span><br><span class="line">        &quot;min_doc_count&quot;: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 先确定日期范围，然后再统计(统计<span class="number">2021</span>年<span class="number">1</span>月之后的数据)</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;date&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: &quot;2021-01-01&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;dates&quot;: &#123;</span><br><span class="line">      &quot;date_histogram&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;interval&quot;: &quot;month&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM&quot;,</span><br><span class="line">        &quot;min_doc_count&quot;: <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-missing-缺失值的桶聚合"><a href="#4-7-missing-缺失值的桶聚合" class="headerlink" title="4.7 missing:缺失值的桶聚合"></a>4.7 missing:缺失值的桶聚合</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 总人数是<span class="number">7</span>，有friend是<span class="number">2</span>个人，所以返回值是<span class="number">5</span></span><br><span class="line">POST <span class="operator">/</span>test<span class="operator">/</span>_search?size<span class="operator">=</span><span class="number">0</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;account_without_friend&quot;: &#123;</span><br><span class="line">      &quot;missing&quot;: &#123;&quot;field&quot;: &quot;friend.keyword&quot;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-8-collapse-折叠查询"><a href="#4-8-collapse-折叠查询" class="headerlink" title="4.8 collapse:折叠查询"></a>4.8 collapse:折叠查询</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 按照阵营<span class="keyword">group</span>分组，取每个<span class="keyword">group</span>里年龄最大的人，同时展示每个<span class="keyword">group</span>里年龄前<span class="number">2</span>名的人。</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;collapse&quot;: &#123;</span><br><span class="line">    &quot;field&quot;: &quot;group.keyword&quot;,</span><br><span class="line">    &quot;inner_hits&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;old_age&quot;,</span><br><span class="line">      &quot;size&quot;: <span class="number">2</span>,</span><br><span class="line">      &quot;sort&quot;: [&#123;&quot;age&quot;: &quot;desc&quot;&#125;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;sort&quot;: [&#123;&quot;age&quot;: &#123;&quot;order&quot;: &quot;desc&quot;&#125;&#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ES的聚合功能非常强大,远不止上面的例子,除了AVG还有MAX、MIN、SUM、COUNT、STATS等</p><h3 id="5-桶聚合-Terms-Aggregation"><a href="#5-桶聚合-Terms-Aggregation" class="headerlink" title="5.桶聚合(Terms Aggregation)"></a>5.桶聚合(Terms Aggregation)</h3><p>桶聚合的种类很多，一篇短文难以覆盖，这篇先介绍Terms Aggregation（按字段分组），类似MySQL中的Group By，它是最常用的聚合方式。注意<strong>用于聚合的字段不能是text类型</strong>。</p><h4 id="5-1-准备测试数据"><a href="#5-1-准备测试数据" class="headerlink" title="5.1 准备测试数据"></a>5.1 准备测试数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: &quot;1&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;张一&quot;,</span><br><span class="line">  &quot;dept&quot;: &quot;web&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;dept1,man1&quot;,</span><br><span class="line">  &quot;birthday&quot;: &quot;2008-11-16&quot;,</span><br><span class="line">  &quot;status&quot;: &quot;1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>_doc<span class="operator">/</span><span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: &quot;2&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;张二&quot;,</span><br><span class="line">  &quot;dept&quot;: &quot;web&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;dept1,man2&quot;,</span><br><span class="line">  &quot;birthday&quot;: &quot;2008-12-17&quot;,</span><br><span class="line">  &quot;status&quot;: &quot;1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>_doc<span class="operator">/</span><span class="number">3</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: &quot;3&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;张三&quot;,</span><br><span class="line">  &quot;dept&quot;: &quot;web&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;dept1,man3&quot;,</span><br><span class="line">  &quot;birthday&quot;: &quot;2009-10-10&quot;,</span><br><span class="line">  &quot;status&quot;: &quot;1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>_doc<span class="operator">/</span><span class="number">4</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: &quot;4&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;李四&quot;,</span><br><span class="line">  &quot;dept&quot;: &quot;java&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;dept2,man4&quot;,</span><br><span class="line">  &quot;birthday&quot;: &quot;2012-01-01&quot;,</span><br><span class="line">  &quot;status&quot;: &quot;1&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>_doc<span class="operator">/</span><span class="number">5</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: &quot;5&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;王五&quot;,</span><br><span class="line">  &quot;dept&quot;: &quot;java&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;dept2,man5&quot;,</span><br><span class="line">  &quot;birthday&quot;: &quot;2012-07-01&quot;,</span><br><span class="line">  &quot;status&quot;: &quot;0&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>_doc<span class="operator">/</span><span class="number">6</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;id&quot;: &quot;6&quot;,</span><br><span class="line">  &quot;name&quot;: &quot;王六&quot;,</span><br><span class="line">  &quot;dept&quot;: &quot;data&quot;,</span><br><span class="line">  &quot;status&quot;: &quot;0&quot;,</span><br><span class="line">  &quot;path&quot;: &quot;dept3,man6&quot;,</span><br><span class="line">  &quot;birthday&quot;: &quot;2009-12-12&quot;,</span><br><span class="line">  &quot;gender&quot;: &quot;man&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-2-Terms-Aggregation（根据字段的值分组）"><a href="#5-2-Terms-Aggregation（根据字段的值分组）" class="headerlink" title="5.2 Terms Aggregation（根据字段的值分组）"></a>5.2 Terms Aggregation（根据字段的值分组）</h4><p>Terms聚合用于分组</p><h5 id="5-2-1-count-根据dept分组，求每个部门的数量"><a href="#5-2-1-count-根据dept分组，求每个部门的数量" class="headerlink" title="5.2.1 count:根据dept分组，求每个部门的数量"></a>5.2.1 count:根据dept分组，求每个部门的数量</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">GET</span> _sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;SELECT dept, COUNT(*) num FROM user GROUP BY dept&quot; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># DSL</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>_doc<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;depts&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;dept.keyword&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-2-count-order-根据dept分组，求每个部门的数量，并排序"><a href="#5-2-2-count-order-根据dept分组，求每个部门的数量，并排序" class="headerlink" title="5.2.2 count+order:根据dept分组，求每个部门的数量，并排序"></a>5.2.2 count+order:根据dept分组，求每个部门的数量，并排序</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">GET</span> _sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;SELECT dept, COUNT(*) num FROM user GROUP BY dept ORDER BY num DESC&quot;</span><br><span class="line">&#125;</span><br><span class="line"># DSL(&quot;_count&quot;按照数量排序,改成&quot;_key&quot;则按照key(这里就是指dept)排序)</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>_doc<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;depts&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;dept.keyword&quot;,</span><br><span class="line">        &quot;order&quot;: &#123;&quot;_count&quot;: &quot;desc&quot;&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-3-having-对统计结果过滤-聚合完，再过滤"><a href="#5-2-3-having-对统计结果过滤-聚合完，再过滤" class="headerlink" title="5.2.3 having:对统计结果过滤(聚合完，再过滤)"></a>5.2.3 having:对统计结果过滤(聚合完，再过滤)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">GET</span> _sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;SELECT dept, COUNT(*) num FROM user GROUP BY dept HAVING num &gt; 1 ORDER BY num DESC&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># <span class="keyword">SQL</span>转DSL语句</span><br><span class="line">POST <span class="operator">/</span>_sql<span class="operator">/</span>translate</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;SELECT dept, COUNT(*) num FROM user GROUP BY dept HAVING num &gt; 1 ORDER BY num DESC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-4-先过滤后，再聚合-类似where"><a href="#5-2-4-先过滤后，再聚合-类似where" class="headerlink" title="5.2.4 先过滤后，再聚合(类似where)"></a>5.2.4 先过滤后，再聚合(类似where)</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">SQL</span></span><br><span class="line"><span class="keyword">GET</span> _sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;SELECT dept, COUNT(*) num FROM user WHERE status = 1 GROUP BY dept ORDER BY num DESC&quot;</span><br><span class="line">&#125;</span><br><span class="line"># DSL</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span><span class="keyword">user</span><span class="operator">/</span>_doc<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;size&quot;: <span class="number">0</span>,</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;status&quot;: <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;aggs&quot;: &#123;</span><br><span class="line">    &quot;dept_count&quot;: &#123;</span><br><span class="line">      &quot;terms&quot;: &#123;</span><br><span class="line">        &quot;field&quot;: &quot;dept.keyword&quot;,</span><br><span class="line">        &quot;order&quot;: &#123;</span><br><span class="line">          &quot;_count&quot;: &quot;desc&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="6-Index-API"><a href="#6-Index-API" class="headerlink" title="6.Index API"></a>6.Index API</h3><h4 id="6-1-Index-API简介"><a href="#6-1-Index-API简介" class="headerlink" title="6.1 Index API简介"></a>6.1 Index API简介</h4><p>Index API可以把JSON文档新增或修改到指定的索引(Index)中，从而使该JSON文档能够被搜索到。下面举例在一个叫”dept”的索引(Index)中， 新增一个id为1的部门数据。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PUT <span class="operator">/</span>dept<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;部门1&quot;,</span><br><span class="line">  &quot;code&quot;: &quot;dept1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;_index&quot;</span> : <span class="string">&quot;dept&quot;</span>,<span class="comment">//index的名称是dept</span></span><br><span class="line">  <span class="attr">&quot;_type&quot;</span> : <span class="string">&quot;_doc&quot;</span>,<span class="comment">//type的名称是_doc</span></span><br><span class="line">  <span class="attr">&quot;_id&quot;</span> : <span class="string">&quot;1&quot;</span>,<span class="comment">//指定id为1</span></span><br><span class="line">  <span class="attr">&quot;_version&quot;</span> : <span class="number">1</span>,<span class="comment">//数据版本号，如果上面put语句再执行一次，_version会+1</span></span><br><span class="line">  <span class="attr">&quot;result&quot;</span> : <span class="string">&quot;created&quot;</span>,<span class="comment">//created表明是新增操作，如果上面put语句再执行一次，就会是updated，表明是修改</span></span><br><span class="line">  <span class="attr">&quot;_shards&quot;</span> : &#123;</span><br><span class="line">    <span class="attr">&quot;total&quot;</span> : <span class="number">2</span>,<span class="comment">//表明应该有多少分片（包括主分片和副本分片）执行索引，这里2表明应该有一个主分片和一个副本分片</span></span><br><span class="line">    <span class="attr">&quot;successful&quot;</span> : <span class="number">1</span>,<span class="comment">//这里是1，因为我本机就启动了一个es节点，无有效的副本分片，只有1个主分片成功</span></span><br><span class="line">    <span class="attr">&quot;failed&quot;</span> : <span class="number">0</span><span class="comment">//在副本分片上操作失败的数量，这里我本机没有副本分片，所以没有在副本分片上操作，所以是0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">&quot;_seq_no&quot;</span> : <span class="number">0</span>,</span><br><span class="line">  <span class="attr">&quot;_primary_term&quot;</span> : <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-Query-DSL-查询教程"><a href="#7-Query-DSL-查询教程" class="headerlink" title="7.Query DSL 查询教程"></a>7.Query DSL 查询教程</h3><p>ES提供了一个基于JOSN格式的查询语句-Query DSL，它包含2种类型：<strong>叶子查询</strong>和<strong>组合查询</strong></p><h4 id="7-1-叶子查询"><a href="#7-1-叶子查询" class="headerlink" title="7.1 叶子查询"></a>7.1 叶子查询</h4><p>叶子查询语句是在一个特定字段(field)上查询特定的值(value)，例如match,term或range查询，它们可以单独使用。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;age&quot;: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-2-组合查询"><a href="#7-2-组合查询" class="headerlink" title="7.2 组合查询"></a>7.2 组合查询</h4><p>组合查询套在别的叶子查询或组合查询外面，它是用来组合逻辑上复杂多样的查询。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;age&quot;: <span class="number">18</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;match&quot;: &#123;</span><br><span class="line">            &quot;name&quot;: &quot;lxy&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-词项查询（Term-Level-Query）"><a href="#7-3-词项查询（Term-Level-Query）" class="headerlink" title="7.3 词项查询（Term Level Query）"></a>7.3 词项查询（Term Level Query）</h4><p>Term Level Query是在字段上查询精确的值，而不是进行全文匹配（比如match）。通常用到的词项查询有term，terms，ids，range，prefix，exists等等，下面一一介绍。</p><h5 id="7-3-1-查看mapping"><a href="#7-3-1-查看mapping" class="headerlink" title="7.3.1 查看mapping"></a>7.3.1 查看mapping</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_mapping</span><br></pre></td></tr></table></figure><p>因为没有提前定义mapping，所以是es自生成的mapping。其中name属性如下，name本身是text类型，内部包含一个keyword类型，用精确查询时，就用name.keyword属性。</p><h5 id="7-3-2-term"><a href="#7-3-2-term" class="headerlink" title="7.3.2 term"></a>7.3.2 term</h5><p>(一定要理解term是<strong>包含</strong>的意思，不是等于)</p><p>term query判断文档的某个字段(field)是否包含某一个确定的值。一般都是用在结构化数据上，比如keyword，int，long，ip，date等，避免用在text类型的字段上，在text上应该用match匹配查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"># 准备数据</span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">10</span></span><br><span class="line">PUT <span class="operator">/</span>test<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">10</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;:&quot;刘一&quot;,</span><br><span class="line">  &quot;age&quot;:<span class="number">18</span></span><br><span class="line">&#125;</span><br><span class="line"># 查询age<span class="operator">=</span><span class="number">18</span></span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;age&quot;: <span class="number">18</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 查询name.keyword<span class="operator">=</span>&quot;刘一&quot;(能查到结果)</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name.keyword&quot;: &quot;刘一&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为何要避免在text类型上用Term Level Query</p><p>name是text类型，默认下es会分词。”刘一”被分词为”刘”，”一”这2个词项，es会根据这2个词项产生对应的倒排索引。</p><p>如果term查询name=”刘一”，因为没有”刘一”这个词项，所以下面语句是查不到数据的。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查询name<span class="operator">=</span>&quot;刘一&quot;</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;name&quot;: &quot;刘一&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-3-terms"><a href="#7-3-3-terms" class="headerlink" title="7.3.3 terms"></a>7.3.3 terms</h5><pre><code>- terms和term类似，它判断文档的某个字段(field)是否**包含某一个或多个确定的值**（value）。- value参数是一个数组，里面包含多个你想要查询的值，**只要有一个值命中就算符合**。- value数组里的最多能放65536个值，如果想修改这个限制，可以修改setting里index.max_terms_count这个配置</code></pre><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"># 包含play或sleep</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;terms&quot;: &#123;</span><br><span class="line">      &quot;interest&quot;: [&quot;play&quot;, &quot;sleep&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 用must组合查询interest<span class="operator">=</span>[&quot;eat&quot;, &quot;sleep&quot;]</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;interest.keyword&quot;: &quot;eat&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;interest.keyword&quot;: &quot;sleep&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;interest_count&quot;: <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-4-terms-set"><a href="#7-3-4-terms-set" class="headerlink" title="7.3.4 terms_set"></a>7.3.4 terms_set</h5><p>terms_set查询和terms类似，但它定义了一个<strong>最小命中数</strong>。比如value数组里有3个值，最小命中数定义为2，说明字段里的值<strong>至少命中数组里的2个</strong>，才算这个文档复合。而terms查询只要命中数组里任意1个，就算文档符合查询条件。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># 至少命中[“eat”, “play”, “sleep”]中<span class="number">2</span>个</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;terms_set&quot;: &#123;</span><br><span class="line">      &quot;interest.keyword&quot;: &#123;</span><br><span class="line">        &quot;terms&quot;: [&quot;eat&quot;,&quot;play&quot;,&quot;sleep&quot;],</span><br><span class="line">        &quot;minimum_should_match_script&quot;: &#123;</span><br><span class="line">          &quot;source&quot;: &quot;2&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 用terms_set解决interest<span class="operator">=</span>[“eat”, “sleep”]</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;terms_set&quot;: &#123;</span><br><span class="line">            &quot;interest.keyword&quot;: &#123;</span><br><span class="line">              &quot;terms&quot;: [&quot;eat&quot;,&quot;sleep&quot;],</span><br><span class="line">              &quot;minimum_should_match_script&quot;: &#123;</span><br><span class="line">                &quot;source&quot;: &quot;2&quot;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;term&quot;: &#123;</span><br><span class="line">            &quot;interest_count&quot;: &#123;&quot;value&quot;: <span class="number">2</span>&#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 用terms_set解决interest<span class="operator">=</span>[“eat”, “sleep”]且不评分</span><br><span class="line"># 文章最上面讲过用<span class="keyword">filter</span> context，这样不评分也提高查询性能，以后如果是无需评分的，最好放到<span class="keyword">filter</span>里面。</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;bool&quot;: &#123;</span><br><span class="line">          &quot;must&quot;: [</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;terms_set&quot;: &#123;</span><br><span class="line">                &quot;interest.keyword&quot;: &#123;</span><br><span class="line">                  &quot;terms&quot;: [&quot;eat&quot;,&quot;sleep&quot;],</span><br><span class="line">                  &quot;minimum_should_match_script&quot;: &#123;</span><br><span class="line">                    &quot;source&quot;: &quot;2&quot;</span><br><span class="line">                  &#125;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">              &quot;term&quot;: &#123;</span><br><span class="line">                &quot;interest_count&quot;: &#123;&quot;value&quot;: <span class="number">2</span>&#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          ]</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-5-ids"><a href="#7-3-5-ids" class="headerlink" title="7.3.5 ids"></a>7.3.5 ids</h5><p>根据文档ID查询文档</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 下面返回<span class="number">1</span>和<span class="number">4</span>两个文档，因为id<span class="operator">=</span><span class="number">100</span>的不存在。</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;ids&quot;: &#123;</span><br><span class="line">      &quot;values&quot;: [&quot;1&quot;,&quot;4&quot;,&quot;100&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-6-exists"><a href="#7-3-6-exists" class="headerlink" title="7.3.6 exists"></a>7.3.6 exists</h5><p>在MySQL中，常用<code>is null</code>和<code>is not null</code>，ES用<code>exists</code>。<br>    - 下面情况<strong>认定字段不存在</strong><br>        - 源JSON中的字段是null或[]<br>        - 字段在mapping中设置为”index” : false<br>        - 字段值的长度超出了mapping中设置的ignore_above<br>        - 字段值格式错误，并且mapping中设置的了ignore_malformed<br>    - 下面特殊情况<strong>认定字段存在</strong><br>        - 空字符串，例如””或”-“<br>        - 包含null和另一个值的数组，例如[null, “foo”]<br>        - 在mapping中设置的自定义null-value</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"># 查询interesting值存在的文档</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;exists&quot;: &#123;</span><br><span class="line">      &quot;field&quot;: &quot;interesting&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 查询gender值不存在的文档</span><br><span class="line"># 利用must_not<span class="operator">+</span><span class="keyword">exists</span>组合查询，代替之前老版本ES的missing查询</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;must_not&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">          &quot;exists&quot;: &#123;</span><br><span class="line">            &quot;field&quot;: &quot;gender&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-7-range"><a href="#7-3-7-range" class="headerlink" title="7.3.7 range"></a>7.3.7 range</h5><p>range查询判断某个字段是否在某个范围内。range有如下参数：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">gte</td><td align="center">&gt;=</td></tr><tr><td align="center">gt</td><td align="center">&gt;</td></tr><tr><td align="center">lte</td><td align="center">&lt;=</td></tr><tr><td align="center">lt</td><td align="center">&lt;</td></tr><tr><td align="center">boost</td><td align="center">查询权重，默认1.0</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"># 查询age在[<span class="number">3</span>,<span class="number">30</span>)之间的数据</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;bool&quot;: &#123;</span><br><span class="line">      &quot;filter&quot;: &#123;</span><br><span class="line">        &quot;range&quot;: &#123;</span><br><span class="line">          &quot;age&quot;: &#123;</span><br><span class="line">            &quot;gte&quot;: <span class="number">3</span>,</span><br><span class="line">            &quot;lt&quot;: <span class="number">30</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-8-prefix"><a href="#7-3-8-prefix" class="headerlink" title="7.3.8 prefix"></a>7.3.8 prefix</h5><p>prefix查询返回在指定字段中包含特定前缀的文档。这个就像我们SQL语句的 <code>like “xx%”</code>。<br>您可以使用mapping设置中的index_prefixes参数来加快前缀查询的速度。如果启用该参数，Elasticsearch只会为单独的字段索引2到5个字符的前缀。这使Elasticsearch在较大的索引上更有效率执行前缀查询，从而减少成本。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># 查询name以“y”开头的数据。</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;prefix&quot;: &#123;</span><br><span class="line">      &quot;name.keyword&quot;: &quot;y&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-9-wildcard"><a href="#7-3-9-wildcard" class="headerlink" title="7.3.9 wildcard"></a>7.3.9 wildcard</h5><p>wildcard查询就像MySQL的<code>Like</code>查询，它查询效率比较低，一般也不用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 查询hometown里包含“州”的人：</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;wildcard&quot;: &#123;</span><br><span class="line">      &quot;hometown.keyword&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;*州*&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_source&quot;: [&quot;name&quot;,&quot;hometown&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-Mapping-字段类型-keyword-text-date-numeric"><a href="#8-Mapping-字段类型-keyword-text-date-numeric" class="headerlink" title="8.Mapping 字段类型(keyword text date numeric)"></a>8.Mapping 字段类型(keyword text date numeric)</h3><p>类似于Mysql的表结构，虽然ES有mapping动态映射，但是它自动生成的不一定是我们期望的。</p><h4 id="8-1-keyword"><a href="#8-1-keyword" class="headerlink" title="8.1 keyword"></a>8.1 keyword</h4><ul><li>keyword是关键词类型，ES把keyword类型的值<strong>当作词根存在倒排索引中</strong>，<strong>不进行分词</strong>。</li><li>keyword适合存结构化数据，比如name,age,性别,手机号,status(数据状态),tags(标签)，HttpCode(404,200,500)等。</li><li>字段常用来<strong>精确查询，过滤，排序，聚合</strong>时，应设为keyword，而不是数值型。</li><li>最长支持32766个UTF-8类型的字符，但放入倒排索引时，只截取前一段字符串，长度由ignore_above参数决定。<h4 id="8-2-text"><a href="#8-2-text" class="headerlink" title="8.2 text"></a>8.2 text</h4></li><li>text文本类型，如果要对字符串进行<strong>分词分析</strong>，可以设置为text。</li><li>ES自带了很多分词器，如果是中文，可以给ES安装ik中文分词插件。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"># 分析name是怎么被分词的</span><br><span class="line"><span class="keyword">GET</span> <span class="operator">/</span>test<span class="operator">/</span>_analyze</span><br><span class="line">&#123;</span><br><span class="line">  &quot;field&quot;: &quot;name&quot;,</span><br><span class="line">  &quot;text&quot;: &quot;I am a coder&quot;</span><br><span class="line">&#125;</span><br><span class="line"># 执行结果：(可以看到这短语被分成<span class="number">4</span>个词项，其中大写&quot;I&quot;还转换为小写&quot;i&quot;)</span><br><span class="line">&#123;</span><br><span class="line">  &quot;tokens&quot; : [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;i&quot;,</span><br><span class="line">      &quot;start_offset&quot; : <span class="number">0</span>,</span><br><span class="line">      &quot;end_offset&quot; : <span class="number">1</span>,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : <span class="number">0</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;am&quot;,</span><br><span class="line">      &quot;start_offset&quot; : <span class="number">2</span>,</span><br><span class="line">      &quot;end_offset&quot; : <span class="number">4</span>,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : <span class="number">1</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;a&quot;,</span><br><span class="line">      &quot;start_offset&quot; : <span class="number">5</span>,</span><br><span class="line">      &quot;end_offset&quot; : <span class="number">6</span>,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : <span class="number">2</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;token&quot; : &quot;coder&quot;,</span><br><span class="line">      &quot;start_offset&quot; : <span class="number">7</span>,</span><br><span class="line">      &quot;end_offset&quot; : <span class="number">12</span>,</span><br><span class="line">      &quot;type&quot; : &quot;&lt;ALPHANUM&gt;&quot;,</span><br><span class="line">      &quot;position&quot; : <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-Boolean"><a href="#8-3-Boolean" class="headerlink" title="8.3 Boolean"></a>8.3 Boolean</h4><table><thead><tr><th align="center">判断</th><th align="center">ES接受的值</th></tr></thead><tbody><tr><td align="center">真</td><td align="center">true,”true”</td></tr><tr><td align="center">假</td><td align="center">false,”false”,””（空字符串）</td></tr></tbody></table><h4 id="8-4-日期类型"><a href="#8-4-日期类型" class="headerlink" title="8.4 日期类型"></a>8.4 日期类型</h4>date的格式可以被指定的，如果没有特殊指定，默认格式是”strict_date_optional_time||epoch_millis”</li></ul><p>这段话可以理解为格式为<code>strict_date_optional_time</code>或者<code>epoch_millis</code></p><ul><li>8.4.1 什么是epoch_millis？<br>epoch_millis就是从开始纪元（1970-01-01 00:00:00 UTC）开始的<strong>毫秒数</strong>-长整型。</li><li>8.4.2 什么是strict_date_optional_time？<br>strict_date_optional_time是date_optional_time的严格级别，这个严格指的是年份、月份、天必须分别以4位、2位、2位表示，不足两位的话第一位需用0补齐。<ul><li>常见的格式有如下：<ul><li>yyyy</li><li>yyyyMM</li><li>yyyyMMdd</li><li>yyyyMMddHHmmss</li><li>yyyy-MM</li><li>yyyy-MM-dd</li><li>yyyy-MM-ddTHH:mm:ss</li><li>yyyy-MM-ddTHH:mm:ss.SSS</li><li>yyyy-MM-ddTHH:mm:ss.SSSZ</li></ul></li></ul></li></ul><p>工作常见到是”yyyy-MM-dd HH:mm:ss”，但是ES是不支持这格式的，需要在dd后面加个T，这个是固定格式。上面最后一个里大写的”Z”表示时区。</p><p>如果直接插入”yyyy-MM-dd HH:mm:ss”格式会报错。</p><ul><li>8.4.3 如果你就是想用yyyy-MM-dd HH:mm:ss要怎么设置。<br>date类型，还支持一个参数format，它让我们可以自己定制化日期格式。<br>比如format配置了“格式A||格式B||格式C”，插入一个值后，会从左往右匹配，直到有一个格式匹配上。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"># 创建索引</span><br><span class="line">PUT <span class="operator">/</span>test_date_index</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;birthday&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;date&quot;,</span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#<span class="number">2020</span><span class="operator">/</span><span class="number">03</span><span class="operator">/</span><span class="number">01</span> <span class="number">17</span>:<span class="number">44</span>:<span class="number">09</span>的毫秒级时间戳</span><br><span class="line">PUT <span class="operator">/</span>test_date_index<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;: <span class="number">1583055849000</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT <span class="operator">/</span>test_date_index<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;: &quot;2020-03-01 16:29:41&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PUT <span class="operator">/</span>test_date_index<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">3</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;birthday&quot;: &quot;2020-02-29&quot;</span><br><span class="line">&#125;</span><br><span class="line">#上面<span class="number">3</span>条语句都可以保存成功</span><br></pre></td></tr></table></figure><h4 id="8-5-数字：Numeric"><a href="#8-5-数字：Numeric" class="headerlink" title="8.5 数字：Numeric"></a>8.5 数字：Numeric</h4>为了提高性能和减少存储空间，选择一个满足存放你数据的类型就可以，没有必要选择过长的类型。比如各地人口数量，一般用integer存储足够了，没有必要使用long类型。</li></ul><table><thead><tr><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">byte</td><td align="center">8位，-128 ~ 127</td></tr><tr><td align="center">short</td><td align="center">16位，-32768 ~ 32767</td></tr><tr><td align="center">integer</td><td align="center">32位，-231 ~ 231-1</td></tr><tr><td align="center">long</td><td align="center">64位，-263 ~ 263-1</td></tr><tr><td align="center">float</td><td align="center">单精度、32位、符合IEEE 754标准的浮点数</td></tr><tr><td align="center">double</td><td align="center">双精度、64位、符合IEEE 754标准的浮点数</td></tr><tr><td align="center">half_float</td><td align="center">16位半精度IEEE 754浮点类型</td></tr><tr><td align="center">scaled_float</td><td align="center">缩放类型的的浮点数</td></tr></tbody></table><h4 id="8-6-二进制类型：binary"><a href="#8-6-二进制类型：binary" class="headerlink" title="8.6 二进制类型：binary"></a>8.6 二进制类型：binary</h4><p>ES能接受以Base64编码的二进制值，binary字段是不会被分析存储和检索的。因为它的值就是一巨长的乱码，对它分析毫无意义， 它只是被原模原样的存储。</p><p>工作中可能用binary存储图像，但情况也不多，用ES存图像不是很好的选择。</p><h4 id="8-7-数值范围：range"><a href="#8-7-数值范围：range" class="headerlink" title="8.7 数值范围：range"></a>8.7 数值范围：range</h4><h5 id="8-7-1-简介"><a href="#8-7-1-简介" class="headerlink" title="8.7.1 简介"></a>8.7.1 简介</h5><ul><li>range字段类型表示一个字段的值是一个数值范围.</li><li>例如一个range类型的字段的值是[10, 20], 那么用12来匹配该字段,则会命中该文档.</li><li>range字段类型如下:</li></ul><table><thead><tr><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">integer_range</td><td align="center">[-231, 231-1 ]</td></tr><tr><td align="center">long_range</td><td align="center">[-263, 263-1]</td></tr><tr><td align="center">float_range</td><td align="center">单精度、符合IEEE 754标准的浮点数的范围</td></tr><tr><td align="center">double_range</td><td align="center">双精度、符合IEEE 754标准的浮点数的范围</td></tr><tr><td align="center">date_range</td><td align="center">日期范围, 在es内部,日期以64位long类型表示的毫秒数存储</td></tr><tr><td align="center">ip_range</td><td align="center">IP范围, 支持IPv4和IPv6的范围</td></tr></tbody></table><ul><li>区间的开闭<ul><li>设定一个范围可以有多种选择, 可以包含边界值, 也可以不包含边界值, 还可以一个边界是无界限的.</li><li>定义的时候可以用gt, gte, lt, lte表示左右界限的开闭.</li></ul></li></ul><p>下面举例说明:</p><table><thead><tr><th align="center">类型</th><th align="center">说明</th><th align="center">表达</th></tr></thead><tbody><tr><td align="center">左闭, 右闭</td><td align="center">[10, 20]</td><td align="center">gte: 10, lte: 20</td></tr><tr><td align="center">左闭, 右开</td><td align="center">[10, 20)</td><td align="center">gte: 10, lt: 20</td></tr><tr><td align="center">左闭, 右无限大</td><td align="center">[10, +∞)</td><td align="center">gte: 10</td></tr></tbody></table><h5 id="8-7-2-准备测试数据"><a href="#8-7-2-准备测试数据" class="headerlink" title="8.7.2 准备测试数据"></a>8.7.2 准备测试数据</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"># 创建一个新的索引</span><br><span class="line">PUT test_range</span><br><span class="line">&#123;</span><br><span class="line">  &quot;mappings&quot;: &#123;</span><br><span class="line">    &quot;properties&quot;: &#123;</span><br><span class="line">      &quot;range_of_integer&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;integer_range&quot;</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;range_of_date&quot;: &#123;</span><br><span class="line">        &quot;type&quot;: &quot;date_range&quot;, </span><br><span class="line">        &quot;format&quot;: &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd||epoch_millis&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"># 新增测试文档</span><br><span class="line">PUT test_range<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;range_of_integer&quot;: &#123;</span><br><span class="line">    &quot;gte&quot;: <span class="number">10</span>,</span><br><span class="line">    &quot;lte&quot;: <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;range_of_date&quot;: &#123;</span><br><span class="line">    &quot;gte&quot;: &quot;2021-05-01 10:20:00&quot;,</span><br><span class="line">    &quot;lte&quot;: &quot;2021-05-02&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">PUT test_range<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">2</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;range_of_integer&quot;: &#123;</span><br><span class="line">    &quot;gt&quot;: <span class="number">10</span>,</span><br><span class="line">    &quot;lt&quot;: <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;range_of_date&quot;: &#123;</span><br><span class="line">    &quot;gt&quot;: &quot;2021-05-01 10:20:00&quot;,</span><br><span class="line">    &quot;lt&quot;: &quot;2021-05-02&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">PUT test_range<span class="operator">/</span>_doc<span class="operator">/</span><span class="number">3</span></span><br><span class="line">&#123;</span><br><span class="line">  &quot;range_of_integer&quot;: &#123;</span><br><span class="line">    &quot;gt&quot;: <span class="number">20</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;range_of_date&quot;: &#123;</span><br><span class="line">    &quot;gt&quot;: &quot;2021-05-01 10:20:00&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-7-3-使用term查询匹配"><a href="#8-7-3-使用term查询匹配" class="headerlink" title="8.7.3 使用term查询匹配"></a>8.7.3 使用term查询匹配</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 查询包含<span class="number">10</span>的文档,</span><br><span class="line"><span class="keyword">GET</span> test_range<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;range_of_integer&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: <span class="number">10</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 查询日期范围包含&quot;2021-05-01 10:20:00&quot;的数据</span><br><span class="line"><span class="keyword">GET</span> test_range<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;term&quot;: &#123;</span><br><span class="line">      &quot;range_of_date&quot;: &#123;</span><br><span class="line">        &quot;value&quot;: &quot;2021-05-01 10:20:00&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="8-7-4-使用range查询匹配"><a href="#8-7-4-使用range查询匹配" class="headerlink" title="8.7.4 使用range查询匹配"></a>8.7.4 使用range查询匹配</h5><p>range查询有个参数<code>relation</code>,它可以有3个值INTERSECTS, CONTAINS,WITHIN.</p><table><thead><tr><th align="center">类型</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">INTERSECTS</td><td align="center">默认设置, 有交集的文档才匹配</td></tr><tr><td align="center">CONTAINS</td><td align="center">目标文档的值的范围包含查询条件</td></tr><tr><td align="center">WITHIN</td><td align="center">查询条件的范围包含目标文档的值的范围</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> test_range<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;range_of_integer&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: <span class="number">18</span>,</span><br><span class="line">        &quot;lte&quot;: <span class="number">20</span>,</span><br><span class="line">        &quot;relation&quot; : &quot;INTERSECTS&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> test_range<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;range_of_integer&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: <span class="number">18</span>,</span><br><span class="line">        &quot;lte&quot;: <span class="number">20</span>,</span><br><span class="line">        &quot;relation&quot; : &quot;CONTAINS&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">GET</span> test_range<span class="operator">/</span>_search</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &#123;</span><br><span class="line">    &quot;range&quot;: &#123;</span><br><span class="line">      &quot;range_of_integer&quot;: &#123;</span><br><span class="line">        &quot;gte&quot;: <span class="number">18</span>,</span><br><span class="line">        &quot;lte&quot;: <span class="number">20</span>,</span><br><span class="line">        &quot;relation&quot; : &quot;WITHIN&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-8-object"><a href="#8-8-object" class="headerlink" title="8.8 object"></a>8.8 object</h4><p>elasticsearch支持某个字段存储一个JSON对象, 这个字段类型就是object.</p><h4 id="8-9-nested"><a href="#8-9-nested" class="headerlink" title="8.9 nested"></a>8.9 nested</h4><h3 id="9-reindex-重建索引-备份数据"><a href="#9-reindex-重建索引-备份数据" class="headerlink" title="9.reindex 重建索引(备份数据)"></a>9.reindex 重建索引(备份数据)</h3><p>reindex不会复制index的设置，所以得先设置好目标索引的setting和mapping，然后再index。</p><h4 id="9-1-简单的reindex"><a href="#9-1-简单的reindex" class="headerlink" title="9.1 简单的reindex"></a>9.1 简单的reindex</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># source里是源index，dest里是目标索引</span><br><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-只创建目标索引中缺少的文档"><a href="#9-2-只创建目标索引中缺少的文档" class="headerlink" title="9.2 只创建目标索引中缺少的文档"></a>9.2 只创建目标索引中缺少的文档</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test2&quot;,</span><br><span class="line">    &quot;op_type&quot;: &quot;create&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-设置批次大小"><a href="#9-3-设置批次大小" class="headerlink" title="9.3 设置批次大小"></a>9.3 设置批次大小</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># reindex底层是<span class="keyword">scroll</span>，默认批次是<span class="number">1000</span>条，可以设置多点</span><br><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;size&quot;: <span class="number">5000</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-4-遇到冲突继续"><a href="#9-4-遇到冲突继续" class="headerlink" title="9.4 遇到冲突继续"></a>9.4 遇到冲突继续</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;conflicts&quot;: &quot;proceed&quot;, </span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: </span><br><span class="line">    &quot;index&quot;: &quot;test2&quot;,</span><br><span class="line">    &quot;op_type&quot;: &quot;create&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-5-只reindex符合条件的数据"><a href="#9-5-只reindex符合条件的数据" class="headerlink" title="9.5 只reindex符合条件的数据"></a>9.5 只reindex符合条件的数据</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;query&quot;: &#123;</span><br><span class="line">      &quot;term&quot;: &#123;</span><br><span class="line">        &quot;name.keyword&quot;: &#123;</span><br><span class="line">          &quot;value&quot;: &quot;lxy&quot;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-6-只同步源index里部分字段"><a href="#9-6-只同步源index里部分字段" class="headerlink" title="9.6 只同步源index里部分字段"></a>9.6 只同步源index里部分字段</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;_source&quot;: [&quot;name&quot;, &quot;age&quot;]</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-7-屏蔽掉不想同步的字段"><a href="#9-7-屏蔽掉不想同步的字段" class="headerlink" title="9.7 屏蔽掉不想同步的字段"></a>9.7 屏蔽掉不想同步的字段</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;,</span><br><span class="line">    &quot;_source&quot;: &#123;</span><br><span class="line">      &quot;excludes&quot;: [&quot;name&quot;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test2&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-8-用script脚本在同步时做数据处理"><a href="#9-8-用script脚本在同步时做数据处理" class="headerlink" title="9.8 用script脚本在同步时做数据处理"></a>9.8 用script脚本在同步时做数据处理</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.age += 2&quot;,</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-9-字段重新命名"><a href="#9-9-字段重新命名" class="headerlink" title="9.9 字段重新命名"></a>9.9 字段重新命名</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"># 同样是用script，将name属性重命名为newName</span><br><span class="line">POST _reindex</span><br><span class="line">&#123;</span><br><span class="line">  &quot;source&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;dest&quot;: &#123;</span><br><span class="line">    &quot;index&quot;: &quot;test2&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;script&quot;: &#123;</span><br><span class="line">    &quot;source&quot;: &quot;ctx._source.newName = ctx._source.remove(\&quot;name\&quot;)&quot;,</span><br><span class="line">    &quot;lang&quot;: &quot;painless&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch系列教程分享</title>
      <link href="/2021/04/23/database/ElasticSearch%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/"/>
      <url>/2021/04/23/database/ElasticSearch%E7%B3%BB%E5%88%97%E6%95%99%E7%A8%8B%E5%88%86%E4%BA%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="Elasticsearch教程"><a href="#Elasticsearch教程" class="headerlink" title="Elasticsearch教程"></a>Elasticsearch教程</h1><p><a href="https://blog.csdn.net/winterking3/article/details/82896738">Elasticsearch教程(1) Query DSL入门</a><br><a href="https://blog.csdn.net/winterking3/article/details/82899097">Elasticsearch教程(2) ES查询语句Query DSL详细教程</a><br><a href="https://blog.csdn.net/winterking3/article/details/83785750">Elasticsearch教程(3) ES聚合查询DSL</a><br><a href="https://blog.csdn.net/winterking3/article/details/103178732">Elasticsearch教程(4) High Level REST Client API 查询 聚合 分组</a><br><a href="https://blog.csdn.net/winterking3/article/details/103258409">Elasticsearch教程(5) 指标聚合 SQL DSL JavaAPI</a><br><a href="https://blog.csdn.net/winterking3/article/details/103271245">Elasticsearch教程(6) ES桶聚合Query DSL-Terms Aggregation</a><br><a href="https://blog.csdn.net/winterking3/article/details/103558784">Elasticsearch教程(7) 文档-Index API</a><br><a href="https://blog.csdn.net/winterking3/article/details/104015071">Elasticsearch教程(8) Query DSL 查询教程</a><br><a href="https://blog.csdn.net/winterking3/article/details/104565968">Elasticsearch教程(9) Mapping 字段类型 keyword text date numeric</a><br><a href="https://blog.csdn.net/winterking3/article/details/104919889">Elasticsearch教程(10) ES term terms prefix 搜索 聚合查询 详细总结</a><br><a href="https://blog.csdn.net/winterking3/article/details/105048017">Elasticsearch教程(11) elasticsearch 桶聚合 Query DSL</a><br><a href="https://blog.csdn.net/winterking3/article/details/105190030">Elasticsearch教程(12) ES 存储树形结构 整合Spring Data Elasticsearch</a><br><a href="https://blog.csdn.net/winterking3/article/details/106140122">Elasticsearch教程(13) Elasticsearch工具类 支持树形结构</a><br><a href="https://blog.csdn.net/winterking3/article/details/106801392">Elasticsearch教程(14) 图解ES文档的读写原理</a><br><a href="https://blog.csdn.net/winterking3/article/details/106937534">Elasticsearch教程(15) routing refresh version 参数详解</a><br><a href="https://blog.csdn.net/winterking3/article/details/108095851">Elasticsearch教程(16) 乐观锁并发控制 if_seq_no 和 if_primary_term 详解</a><br><a href="https://blog.csdn.net/winterking3/article/details/108235285">Elasticsearch教程(17) 返回结果过滤 _source_includes和_source_excludes使用</a><br><a href="https://blog.csdn.net/winterking3/article/details/108242124">Elasticsearch教程(18) reindex 重建索引，非常实用的功能</a><br><a href="https://blog.csdn.net/winterking3/article/details/108254346">Elasticsearch教程(19) 详解mapping之keyword</a><br><a href="https://blog.csdn.net/winterking3/article/details/108287167">Elasticsearch教程(20) 详解mapping之date date_nanos</a><br><a href="https://blog.csdn.net/winterking3/article/details/108323817">Elasticsearch教程(21) 详解mapping之boolean</a><br><a href="https://blog.csdn.net/winterking3/article/details/108326904">Elasticsearch教程(22) 详解mapping之数值类型</a><br><a href="https://blog.csdn.net/winterking3/article/details/108358266">Elasticsearch教程(23) 详解mapping之range</a><br><a href="https://blog.csdn.net/winterking3/article/details/108509545">Elasticsearch教程(24) 详解mapping之object</a><br><a href="https://blog.csdn.net/winterking3/article/details/108513261">Elasticsearch教程(25) 详解mapping之nested</a><br><a href="https://blog.csdn.net/winterking3/article/details/108790116">Elasticsearch教程(26) mapping参数doc_values fielddata enabled</a><br><a href="https://blog.csdn.net/winterking3/article/details/111933692">Elasticsearch教程(27) ES拼接查询条件的工具类</a><br><a href="https://blog.csdn.net/winterking3/article/details/114020953">Elasticsearch教程(28) text和keyword区别 term和match区别 ik中文分词器使用</a><br><a href="https://blog.csdn.net/winterking3/article/details/114031865">Elasticsearch教程(29) update by query的Script脚步更新 Java API 支持es5.6 es6.8 es7.8</a><br><a href="https://blog.csdn.net/winterking3/article/details/114033906">Elasticsearch教程(30) pipeline处理 painless script脚本详细总结 查询更新案例</a><br><a href="https://blog.csdn.net/winterking3/article/details/114117353">Elasticsearch教程(31) es mapping参数doc_values enabled ignore_above norms store详解</a><br><a href="https://blog.csdn.net/winterking3/article/details/115218486">Elasticsearch教程(32) ES 聚合查询后过滤 Distinct Group By Having功能</a></p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ClickHouse教程</title>
      <link href="/2021/04/21/database/ClickHouse%E6%95%99%E7%A8%8B/"/>
      <url>/2021/04/21/database/ClickHouse%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="ClickHouse-简单操作"><a href="#ClickHouse-简单操作" class="headerlink" title="ClickHouse 简单操作"></a>ClickHouse 简单操作</h2><p><a href="https://clickhouse.tech/docs/zh/sql-reference/syntax/">Click House官方中文文档-SQL语法</a></p><h3 id="1-创建-amp-查看-amp-使用数据库"><a href="#1-创建-amp-查看-amp-使用数据库" class="headerlink" title="1.创建&amp;查看&amp;使用数据库"></a>1.创建&amp;查看&amp;使用数据库</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法：</span></span><br><span class="line">CREATE DATABASE [IF NOT EXISTS] db_name [ON CLUSTER cluster] [ENGINE = engine(...)]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例：</span></span><br><span class="line">create database test;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看数据库</span></span><br><span class="line">show databases;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 选择/使用数据库</span></span><br><span class="line">use test;</span><br></pre></td></tr></table></figure><h3 id="2-创建表"><a href="#2-创建表" class="headerlink" title="2.创建表"></a>2.创建表</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 语法：</span></span><br><span class="line">CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]</span><br><span class="line">(</span><br><span class="line">    name1 [type1] [DEFAULT|MATERIALIZED|ALIAS expr1] [compression_codec] [TTL expr1],</span><br><span class="line">    name2 [type2] [DEFAULT|MATERIALIZED|ALIAS expr2] [compression_codec] [TTL expr2],</span><br><span class="line">    ...</span><br><span class="line">) ENGINE = engine</span><br><span class="line"><span class="meta">#</span><span class="bash"> 示例：(TinyLog是最简单的表的引擎，用于将数据存储在磁盘上。常用于小表。)</span></span><br><span class="line">create table t1 (id Int32,name String) engine=TinyLog;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看所有表</span></span><br><span class="line">show tables;</span><br></pre></td></tr></table></figure><h3 id="3-插入-amp-查询数据"><a href="#3-插入-amp-查询数据" class="headerlink" title="3.插入&amp;查询数据"></a>3.插入&amp;查询数据</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 插入数据</span></span><br><span class="line">insert into t1 (id, name) values (1, &#x27;abc&#x27;), (2, &#x27;bbbb&#x27;),(3,&#x27;sdfg&#x27;);</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询所有数据</span></span><br><span class="line">select * from t1;</span><br></pre></td></tr></table></figure><h2 id="ClickHouse-命令行客户端"><a href="#ClickHouse-命令行客户端" class="headerlink" title="ClickHouse 命令行客户端"></a>ClickHouse 命令行客户端</h2><ul><li>交互模式:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client</span><br><span class="line">clickhouse-client --host=... --port=... --user=... --password=...</span><br></pre></td></tr></table></figure></li><li>启用多行查询:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client -m</span><br><span class="line">clickhouse-client --multiline</span><br></pre></td></tr></table></figure></li><li>以批处理模式运行查询:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client --query=&#x27;SELECT 1&#x27;</span><br><span class="line">echo &#x27;SELECT 1&#x27; | clickhouse-client</span><br><span class="line">clickhouse-client &lt;&lt;&lt; &#x27;SELECT 1&#x27;</span><br></pre></td></tr></table></figure></li><li>从指定格式的文件中插入数据:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client --query=&#x27;INSERT INTO table VALUES&#x27; &lt; data.txt</span><br><span class="line">clickhouse-client --query=&#x27;INSERT INTO table FORMAT TabSeparated&#x27; &lt; data.tsv</span><br></pre></td></tr></table></figure></li></ul><h2 id="ClickHouse-HTTP-访问"><a href="#ClickHouse-HTTP-访问" class="headerlink" title="ClickHouse HTTP 访问"></a>ClickHouse HTTP 访问</h2><p>默认情况下，ClickHouse 会在<code>8123</code>端口监听 HTTP 请求。如果你发送一个不带参数的 GET 请求，它会返回一个 OK 字符串，你可以将它用在 ClickHouse 的健康检查脚本中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> curl <span class="string">&#x27;http://localhost:8123/&#x27;</span></span></span><br><span class="line">Ok.</span><br></pre></td></tr></table></figure><p>在使用 curl 等工具访问 ClickHouse 的 HTTP 接口时，可以通过 URL 中的 query 参数发送请求，或者发送 POST 请求，或者将查询的开头部分放在 query 参数中，而将其它部分放在 POST 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 可用HTTP客户端工具访问http://localhost:8123/?query=select * from test.t1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 作为 query 参数，需要对 URL 进行编码，如空格编码为`%20`。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> curl <span class="string">&#x27;http://localhost:8123/?query=select%20*%20from%20test.t1&#x27;</span></span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> ClickHouse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装ClickHouse</title>
      <link href="/2021/04/21/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85ClickHouse/"/>
      <url>/2021/04/21/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85ClickHouse/</url>
      
        <content type="html"><![CDATA[<h2 id="安装之前先查询系统以及系统是否支持SSE-4-2指令集"><a href="#安装之前先查询系统以及系统是否支持SSE-4-2指令集" class="headerlink" title="安装之前先查询系统以及系统是否支持SSE 4.2指令集"></a>安装之前先查询系统以及系统是否支持SSE 4.2指令集</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 查看系统版本</span></span><br><span class="line">more /etc/redhat-release </span><br><span class="line"><span class="meta">#</span><span class="bash"> 检测当前CPU是否支持SSE 4.2(输出SSE 4.2 supported表示支持)</span></span><br><span class="line">grep -q sse4_2 /proc/cpuinfo &amp;&amp; echo &quot;SSE 4.2 supported&quot; || echo &quot;SSE 4.2 not supported&quot;</span><br></pre></td></tr></table></figure><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://clickhouse.tech/docs/zh/getting-started/install/">官方安装文档</a></p><h3 id="首先，您需要添加官方存储库："><a href="#首先，您需要添加官方存储库：" class="headerlink" title="首先，您需要添加官方存储库："></a>首先，您需要添加官方存储库：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install yum-utils</span><br><span class="line">sudo rpm --import https://repo.clickhouse.tech/CLICKHOUSE-KEY.GPG</span><br><span class="line">sudo yum-config-manager --add-repo https://repo.clickhouse.tech/rpm/stable/x86_64</span><br></pre></td></tr></table></figure><h3 id="然后运行命令安装："><a href="#然后运行命令安装：" class="headerlink" title="然后运行命令安装："></a>然后运行命令安装：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 server 和 client</span></span><br><span class="line">sudo yum install clickhouse-server clickhouse-client</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动</span></span><br><span class="line">systemctl start clickhouse-server.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">sudo systemctl start clickhouse-server</span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止</span> </span><br><span class="line">systemctl stop clickhouse-server.service</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看状态</span></span><br><span class="line">systemctl status clickhouse-server.service</span><br></pre></td></tr></table></figure><h3 id="启动服务后，您可以使用命令行客户端连接到它"><a href="#启动服务后，您可以使用命令行客户端连接到它" class="headerlink" title="启动服务后，您可以使用命令行客户端连接到它:"></a>启动服务后，您可以使用命令行客户端连接到它:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client</span><br></pre></td></tr></table></figure><p>如果执行客户端报：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Code: 210. DB::NetException: Connection refused (localhost:9000)</span><br></pre></td></tr></table></figure><p>需要修改配置文件,操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/clickhouse-server/config.xml</span><br></pre></td></tr></table></figure><p>将<code>&lt;listen_host&gt;::&lt;/listen_host&gt;</code>的注释解开，然后重新执行启动命令。</p><h4 id="进入客户端后验证"><a href="#进入客户端后验证" class="headerlink" title="进入客户端后验证"></a>进入客户端后验证</h4><p>输入如下内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT 1</span><br></pre></td></tr></table></figure><p>看到输出内容，那么恭喜，系统已经工作了!</p><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://clickhouse.tech/docs/zh/">clickhouse官方中文文档</a><br><a href="https://mp.weixin.qq.com/s?src=11&timestamp=1618971733&ver=3021&signature=B3HhI4jPF3cv2GG*BLSxRRkRkv3chxjxIYJkYVGZGWbO83KBlWLfY-Qrv7U9arL2BsNj*XdHheyyQbbv26CTqeWX5PHY9OKepnSUn*LefVRd3NNXMaacmw1OtdNbwrJm&new=1">ClickHouse 安装&amp;使用指南</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ClickHouse </tag>
            
            <tag> Linux软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装MongoDB</title>
      <link href="/2021/03/30/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85MongoDB/"/>
      <url>/2021/03/30/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85MongoDB/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB安装"><a href="#MongoDB安装" class="headerlink" title="MongoDB安装"></a>MongoDB安装</h2><h3 id="官方下载安装包"><a href="#官方下载安装包" class="headerlink" title="官方下载安装包"></a>官方下载安装包</h3><p>MongoDB 提供了linux各发行版本64位的安装包，你可以在官网下载安装包。<br><a href="https://www.mongodb.com/download-center/community">官网</a></p><ul><li>关于版本的选择：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Amazon Linux（亚马逊）、</span><br><span class="line">Debian Linux（Debian）、</span><br><span class="line">Linux legacy（通用版）、</span><br><span class="line">RHEL Linux（红帽）、</span><br><span class="line">SUSE Linux（SuSE Linux AG）、</span><br><span class="line">Ubuntu Linux（友帮拓、优般图、乌班图）；</span><br></pre></td></tr></table></figure></li></ul><h3 id="1-下载解压"><a href="#1-下载解压" class="headerlink" title="1.下载解压"></a>1.下载解压</h3><p>将压缩包移动到<code>/usr/local</code>下,解压缩,并改名为mongoDB-4.0.12</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">解压缩</span></span><br><span class="line">tar -zxvf mongodb-linux-x86_64-rhel70-4.0.12.tgz</span><br><span class="line"><span class="meta">#</span><span class="bash">删除压缩包</span></span><br><span class="line">rm -rf mongodb-linux-x86_64-rhel70-4.0.12.tgz</span><br><span class="line"><span class="meta">#</span><span class="bash">重命名</span></span><br><span class="line">mv mongodb-linux-x86_64-rhel70-4.0.12 mongoDB-4.0.12</span><br></pre></td></tr></table></figure><h3 id="2-配置系统环境变量"><a href="#2-配置系统环境变量" class="headerlink" title="2.配置系统环境变量"></a>2.配置系统环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在文件的最后加上：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">mongodb</span></span><br><span class="line">export PATH=$PATH:/usr/local/mongoDB/mongodb-4.0.12/bin</span><br></pre></td></tr></table></figure><p>保存并退出Vim编辑器，<br>运行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile #使修改生效即可</span><br></pre></td></tr></table></figure><h3 id="3-创建MongoDB数据存放文件夹和日志记录文件夹，为后面的配置文件使用："><a href="#3-创建MongoDB数据存放文件夹和日志记录文件夹，为后面的配置文件使用：" class="headerlink" title="3.创建MongoDB数据存放文件夹和日志记录文件夹，为后面的配置文件使用："></a>3.创建MongoDB数据存放文件夹和日志记录文件夹，为后面的配置文件使用：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">注意：/data/db 是 MongoDB 默认的启动的数据库路径(--dbpath)。</span></span><br><span class="line">mkdir -p /data/db</span><br><span class="line">mkdir -p /logs</span><br></pre></td></tr></table></figure><h3 id="4-创建MongoDB运行时使用的配置文件"><a href="#4-创建MongoDB运行时使用的配置文件" class="headerlink" title="4.创建MongoDB运行时使用的配置文件"></a>4.创建MongoDB运行时使用的配置文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入bin目录下</span></span><br><span class="line">cd /usr/local/mongoDB/mongodb-4.2.0/bin</span><br><span class="line"><span class="meta">#</span><span class="bash">创建mongodb.conf配置文件：</span></span><br><span class="line">vim mongodb.conf</span><br></pre></td></tr></table></figure><p>会提示是new file，直接输入下面内容：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dbpath = /data/db #数据文件存放目录</span><br><span class="line">logpath = /logs/mongodb.log #日志文件存放目录</span><br><span class="line">port = 27017 #端口</span><br><span class="line">fork = true #以守护程序的方式启用，即在后台运行</span><br><span class="line">#auth=true #需要认证。如果放开注释，就必须创建MongoDB的账号，使用账号与密码才可远程访问，第一次安装建议注释</span><br><span class="line">bind_ip=0.0.0.0 #允许远程访问，或者直接注释，127.0.0.1是只允许本地访问</span><br></pre></td></tr></table></figure><h3 id="5-启动MongoDB"><a href="#5-启动MongoDB" class="headerlink" title="5.启动MongoDB"></a>5.启动MongoDB</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">进入bin目录下：</span></span><br><span class="line">cd /usr/local/mongoDB/mongodb-4.2.0/bin</span><br><span class="line"><span class="meta">#</span><span class="bash">加载配置文件方式启动：</span></span><br><span class="line">./mongod -f mongodb.conf</span><br></pre></td></tr></table></figure><p>看到如下内容，即为成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2019-09-03T08:55:56.198+0800 I STORAGE  [main] Max cache overflow file size custom option: 0</span><br><span class="line">about to fork child process, waiting until server is ready for connections.</span><br><span class="line">forked process: 16010</span><br><span class="line">child process started successfully, parent exiting</span><br></pre></td></tr></table></figure><p>至此，MongoDB在Linux上的安装完毕。</p><h3 id="查看安装结果"><a href="#查看安装结果" class="headerlink" title="查看安装结果"></a>查看安装结果</h3><p>查看端口映射检查是否启动成功：<code>netstat -nltp|grep mongod</code>  ，显示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcp        0      0 0.0.0.0:27017           0.0.0.0:*               LISTEN      16010/./mongod </span><br></pre></td></tr></table></figure><p>或者：<code>netstat -nltp|grep 27017</code><br>或者： <code>ps -ef | grep mongo</code></p><h3 id="进入数据库的CLI管理界面"><a href="#进入数据库的CLI管理界面" class="headerlink" title="进入数据库的CLI管理界面"></a>进入数据库的CLI管理界面</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/mongoDB/mongodb-4.2.0/bin</span><br><span class="line">./mongo #或在任意位置使用 mongo 命令即可进入(因为之前已经将改bin目录添加到系统环境变量)</span><br></pre></td></tr></table></figure><h3 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h3><h3 id="MongoDB使用教程："><a href="#MongoDB使用教程：" class="headerlink" title="MongoDB使用教程："></a>MongoDB使用教程：</h3><p><a href="../../%E6%95%B0%E6%8D%AE%E5%BA%93/Nosql/MongoDB%E5%91%BD%E4%BB%A4.md">MongoDB命令</a></p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Java</title>
      <link href="/2021/03/27/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Java/"/>
      <url>/2021/03/27/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Java/</url>
      
        <content type="html"><![CDATA[<h2 id="java（jdk安装）"><a href="#java（jdk安装）" class="headerlink" title="java（jdk安装）"></a>java（jdk安装）</h2><p>由于使用<code>yum</code>或者<code>apt-get</code>命令安装<code>openjdk</code>可能存在类库不全，从而导致用户在安装后运行相关工具时可能报错的问题，所以此处我们推荐采用<em>手动解压安装</em>的方式来安装 JDK。具体步骤如下：</p><h3 id="1-下载-JDK"><a href="#1-下载-JDK" class="headerlink" title="1.下载 JDK"></a>1.下载 JDK</h3><ul><li>进入<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html">Oracle官方网站</a>下载合适的 JDK 版本，准备安装。<br>注意：这里需要下载 Linux 版本。这里以jdk-8u202-linux-x64.tar.gz为例，你下载的文件可能不是这个版本，这没关系，只要后缀(.tar.gz)一致即可。</li></ul><h3 id="2-创建目录"><a href="#2-创建目录" class="headerlink" title="2.创建目录"></a>2.创建目录</h3><ul><li>在/usr/local/目录下创建java目录:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local</span><br><span class="line">mkdir java</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-解压-JDK"><a href="#3-解压-JDK" class="headerlink" title="3.解压 JDK"></a>3.解压 JDK</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd java</span><br><span class="line">tar -zxvf jdk-8u202-linux-x64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="4-设置环境变量"><a href="#4-设置环境变量" class="headerlink" title="4.设置环境变量"></a>4.设置环境变量</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br></pre></td></tr></table></figure><p>在profile文件最下方添加如下内容并保存：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#Java Env</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_202</span><br><span class="line">export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin</span><br></pre></td></tr></table></figure><p>or</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#Java Env</span><br><span class="line">export JAVA_HOME=/usr/local/java/jdk1.8.0_202    </span><br><span class="line">export JRE_HOME=/usr/local/java/jdk1.8.0_202/jre     </span><br><span class="line">export CLASS_PATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin</span><br></pre></td></tr></table></figure><p>注意：其中JAVA_HOME请根据自己的实际安装路径及JDK版本配置。  </p><p>让修改生效：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -version</span><br></pre></td></tr></table></figure><p>显示<code>java</code>版本信息，则说明<code>JDK</code>安装成功：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java version &quot;1.8.0_151&quot;</span><br><span class="line">Java(TM) SE Runtime Environment (build 1.8.0_151-b12)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM (build 25.151-b12, mixed mode)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux安装Zookeeper</title>
      <link href="/2021/03/25/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Zookeeper/"/>
      <url>/2021/03/25/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%AE%89%E8%A3%85Zookeeper/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux安装Zookeeper"><a href="#Linux安装Zookeeper" class="headerlink" title="Linux安装Zookeeper"></a><a href="https://www.cnblogs.com/h--d/p/10269869.html">Linux安装Zookeeper</a></h2><h3 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h3><p>服务器安装好了jdk1.8</p><h3 id="下载zookeeper"><a href="#下载zookeeper" class="headerlink" title="下载zookeeper"></a>下载zookeeper</h3><p>下载地址：</p><ul><li>下载页面：<a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a></li><li>下载地址：<a href="https://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2-bin.tar.gz">https://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2-bin.tar.gz</a></li></ul><h3 id="安装zookeeper"><a href="#安装zookeeper" class="headerlink" title="安装zookeeper"></a>安装zookeeper</h3><p>创建并进入到目录：<code>mkdir -p /usr/local/zk &amp;&amp; cd /usr/local/zk</code><br>将下载包上传到该目录或者直接下载<br><code>wget https://mirror.bit.edu.cn/apache/zookeeper/zookeeper-3.6.2/apache-zookeeper-3.6.2-bin.tar.gz</code><br>解压：<code>tar -zxvf apache-zookeeper-3.6.2-bin.tar.gz</code></p><h3 id="配置zookeeper"><a href="#配置zookeeper" class="headerlink" title="配置zookeeper"></a>配置zookeeper</h3><p>进入到zookerper/conf目录:<code>cd apache-zookeeper-3.6.2-bin/conf</code><br>执行命令：<code>cp zoo_sample.cfg zoo.cfg</code><br>执行命令(可以不修改zoo.cfg，使用默认配置就行)：<code>vim zoo.cfg</code>,保存并退出；</p><p>配置文件说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line"># tickTime：CS通信心跳数</span><br><span class="line"># Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime 时间就会发送一个心跳。tickTime以毫秒为单位。</span><br><span class="line">tickTime=2000</span><br><span class="line"></span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line"># initLimit：LF初始通信时限</span><br><span class="line"># 集群中的follower服务器(F)与leader服务器(L)之间初始连接时能容忍的最多心跳数（tickTime的数量）。</span><br><span class="line">initLimit=5</span><br><span class="line"></span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line"># syncLimit：LF同步通信时限</span><br><span class="line"># 集群中的follower服务器与leader服务器之间请求和应答之间能容忍的最多心跳数（tickTime的数量）。</span><br><span class="line">syncLimit=2</span><br><span class="line"></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line"># do not use /tmp for storage, /tmp here is just</span><br><span class="line"># example sakes.</span><br><span class="line"># dataDir：数据文件目录</span><br><span class="line"># Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。</span><br><span class="line">dataDir=/data/soft/zookeeper-3.4.12/data</span><br><span class="line"></span><br><span class="line"># dataLogDir：日志文件目录</span><br><span class="line"># Zookeeper保存日志文件的目录。</span><br><span class="line">dataLogDir=/data/soft/zookeeper-3.4.12/logs</span><br><span class="line"></span><br><span class="line"># the port at which the clients will connect</span><br><span class="line"># clientPort：客户端连接端口</span><br><span class="line"># 客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</span><br><span class="line">clientPort=2181</span><br><span class="line"></span><br><span class="line"># the maximum number of client connections.</span><br><span class="line"># increase this if you need to handle more clients</span><br><span class="line">#maxClientCnxns=60</span><br><span class="line">#</span><br><span class="line"># Be sure to read the maintenance section of the</span><br><span class="line"># administrator guide before turning on autopurge.</span><br><span class="line">#</span><br><span class="line"># http://zookeeper.apache.org/doc/current/zookeeperAdmin.html#sc_maintenance</span><br><span class="line">#</span><br><span class="line"># The number of snapshots to retain in dataDir 保留数量3</span><br><span class="line">autopurge.snapRetainCount=3</span><br><span class="line"># Purge task interval in hours</span><br><span class="line"># Set to &quot;0&quot; to disable auto purge feature 清理时间间隔1小时</span><br><span class="line">autopurge.purgeInterval=1</span><br><span class="line"></span><br><span class="line"># 服务器名称与地址：集群信息（服务器编号，服务器地址，LF通信端口，选举端口）</span><br><span class="line"># 这个配置项的书写格式比较特殊，规则如下：</span><br><span class="line"></span><br><span class="line"># server.N=YYY:A:B</span><br><span class="line"></span><br><span class="line"># 其中N表示服务器编号，YYY表示服务器的IP地址，A为LF通信端口，表示该服务器与集群中的leader交换的信息的端口。B为选举端口，表示选举新leader时服务器间相互通信的端口（当leader挂掉时，其余服务器会相互通信，选择出新的leader）。一般来说，集群中每个服务器的A端口都是一样，每个服务器的B端口也是一样。但是当所采用的为伪集群时，IP地址都一样，只能时A端口和B端口不一样。</span><br></pre></td></tr></table></figure><h3 id="启动ZooKeeper"><a href="#启动ZooKeeper" class="headerlink" title="启动ZooKeeper"></a>启动ZooKeeper</h3><p>进入bin目录：<code>cd apache-zookeeper-3.6.2-bin/bin</code></p><p>启动命令：<code>./zkServer.sh start</code></p><p>停止命令：<code>./zkServer.sh stop</code>　　</p><p>重启命令：<code>./zkServer.sh restart</code></p><p>状态查看命令：<code>./zkServer.sh status</code></p><p>查看zookeeper进程：<code>ps -ef |grep zookeeper</code></p><h3 id="配置zk环境变量-可以不用配置"><a href="#配置zk环境变量-可以不用配置" class="headerlink" title="配置zk环境变量(可以不用配置)"></a>配置zk环境变量(可以不用配置)</h3><ul><li>编辑；<code>vim /etc/profile</code></li><li>将下面的配置信息加入，保存并退出:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export ZOOKEEPER_HOME=/usr/local/zk/apache-zookeeper-3.6.2-bin/</span><br><span class="line">export PATH=$ZOOKEEPER_HOME/bin:$PATH</span><br></pre></td></tr></table></figure></li><li>环境变量生效：<code>source /etc/profile</code></li></ul><h3 id="伪集群模式-同一主机启动多个zookeeper并组成集群"><a href="#伪集群模式-同一主机启动多个zookeeper并组成集群" class="headerlink" title="伪集群模式(同一主机启动多个zookeeper并组成集群)"></a>伪集群模式(同一主机启动多个zookeeper并组成集群)</h3><p><a href="https://www.cnblogs.com/h--d/p/10269869.html">TODO</a></p><h3 id="集群模式"><a href="#集群模式" class="headerlink" title="集群模式"></a>集群模式</h3><p><a href="https://www.cnblogs.com/h--d/p/10269869.html">TODO</a></p><h3 id="ZooKeeper简单操作"><a href="#ZooKeeper简单操作" class="headerlink" title="ZooKeeper简单操作"></a>ZooKeeper简单操作</h3><h4 id="用客户端连接ZooKeeper服务"><a href="#用客户端连接ZooKeeper服务" class="headerlink" title="用客户端连接ZooKeeper服务"></a>用客户端连接ZooKeeper服务</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd apache-zookeeper-3.6.2-bin/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"> zkCli.sh 默认连接到 127.0.0.1:2181</span></span><br><span class="line">zkCli.sh -server 127.0.0.1:2181</span><br></pre></td></tr></table></figure><p>执行后可以看到：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">Welcome to ZooKeeper!</span><br><span class="line">……</span><br></pre></td></tr></table></figure><h4 id="使用ls命令来查看当前-ZooKeeper-中所包含的内容："><a href="#使用ls命令来查看当前-ZooKeeper-中所包含的内容：" class="headerlink" title="使用ls命令来查看当前 ZooKeeper 中所包含的内容："></a>使用<code>ls</code>命令来查看当前 ZooKeeper 中所包含的内容：</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /</span><br></pre></td></tr></table></figure><h4 id="创建了一个新的-znode-节点-“zk”-以及与它关联的字符串"><a href="#创建了一个新的-znode-节点-“zk”-以及与它关联的字符串" class="headerlink" title="创建了一个新的 znode 节点 “zk” 以及与它关联的字符串"></a>创建了一个新的 znode 节点 “zk” 以及与它关联的字符串</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">create /zk myData</span><br></pre></td></tr></table></figure><h4 id="获取znode节点-“zk”"><a href="#获取znode节点-“zk”" class="headerlink" title="获取znode节点 “zk”"></a>获取znode节点 “zk”</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">get /zk</span><br></pre></td></tr></table></figure><h4 id="删除znode节点-“zk”"><a href="#删除znode节点-“zk”" class="headerlink" title="删除znode节点 “zk”"></a>删除znode节点 “zk”</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">delete /zk</span><br></pre></td></tr></table></figure><h4 id="退出客户端"><a href="#退出客户端" class="headerlink" title="退出客户端"></a>退出客户端</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">quit</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p><a href="https://my.oschina.net/jackieyeah/blog/709130">https://my.oschina.net/jackieyeah/blog/709130</a></p><h2 id="Linux-安装-zkui"><a href="#Linux-安装-zkui" class="headerlink" title="Linux 安装 zkui"></a><a href="https://www.zifangsky.cn/1126.html">Linux 安装 zkui</a></h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>下载地址：<a href="https://github.com/zifangsky/zkui/releases">https://github.com/zifangsky/zkui/releases</a></p><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>下载<code>zkui-2.0.zip</code>，并修改<code>config.cfg</code>配置文件<br><img src="https://i.loli.net/2021/02/05/akjYKzxZ1cfChXJ.png" alt="image.png"></p><h3 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h3><p>Windows系统点击运行<code>start.bat</code>脚本，Linux系统则相应执行<code>start.sh</code>即可</p><h3 id="访问WEB客户端并使用："><a href="#访问WEB客户端并使用：" class="headerlink" title="访问WEB客户端并使用："></a>访问WEB客户端并使用：</h3><p>访问：<code>http://127.0.0.1:6060/</code>,并使用<code>admin/admin</code>登录。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
          <category> Linux软件安装 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux软件安装 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端学习路线</title>
      <link href="/2021/03/24/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
      <url>/2021/03/24/%E5%89%8D%E5%90%8E%E7%AB%AF%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="前端"><a href="#前端" class="headerlink" title="前端"></a>前端</h2><ul><li>HTML:文本标记语言，是一种标识性的语言</li><li>CSS:使网页更加丰富多彩灿烂的利器</li><li>JS:使网页动起来的根本，加强了网页和用户之间的交互</li><li>Ajax:异步提交，增强了用户使用网页的良好交互体验</li><li>Http协议、Servlet、request、response、cookie、seesion</li><li>JSON:比XML更小、更快、更易解析的数据传输工具</li><li>Vue:用于构建用户界面的渐进式JS框架</li><li>Node.js:一个基于Chrome V8引擎的JS运行环境</li></ul><h2 id="后端"><a href="#后端" class="headerlink" title="后端"></a>后端</h2><h3 id="网关层"><a href="#网关层" class="headerlink" title="网关层"></a>网关层</h3><ul><li>微服务、分布式、云原生</li><li>负载均衡</li><li>LVS:Linux虚拟服务器</li><li>DNS</li><li>CDN:内容分发网络</li><li>zk:分布式服务框架，可对中间件进行管理调度</li><li>Nginx:高性能的HTTP和反向代理Web服务器，同时也提供了IMAP/POP3/SMTP服务</li></ul><h3 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h3><ul><li>HTTP、HTTPS、TCP协议</li><li>三次握手、四次挥手、中间人攻击</li><li>JAVA基础：<ul><li>面向对象(包括类、对象、方法、继承、封装、抽象、多态、消息解析等)</li><li>常见API</li><li>数据结构</li><li>集合框架</li><li>设计模式(包括创建型、结构型、行为型)</li><li>多线程和并发</li><li>I/O流</li><li>Stream</li><li>网络编程</li></ul></li><li>服务器<ul><li>Linux</li><li>常用命令</li><li>Shell</li></ul></li><li>数据结构与算法<ul><li>从二叉搜索树到B+树</li><li>经典问题之字符串</li><li>经典问题之TOPK</li><li>红黑树、二叉树、hash等</li><li>贪心、分治、动态规划</li><li>队列、栈、表</li></ul></li><li>必会框架<ul><li>Spring:JavaWeb编程中明星级的框架，同样也是优点多功能强使编程工作更加简单，主要用于管理对象</li><li>Spring MVC:JavaWeb编程中明星级的框架，同样也是优点多功能强使编程工作更加简单，主要用于程序和数据库之间的交互</li><li>MyBatis:本是apache的一个开源项目iBatis，2010年这个项目由 apache software foundation 迁移到了google code,并改名为MyBatis</li><li>Spring Boot:其目的是用来简化新Spring应用的初始构建以及开发过程，该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置</li><li>Netty:高性能NIO框架</li></ul></li><li>中间件<ul><li>RPC远程调用<ul><li>Dubbo、SpringCloud</li></ul></li><li>消息队列<ul><li>RocketMQ、Kafka、RabbitMQ、ActiveMQ</li></ul></li></ul></li><li>分布式事务<ul><li>两段式</li><li>三段式</li><li>TCC</li><li>XA</li><li>阿里云的全局事务服务GTS</li><li>RocketMQ自带分布式事务解决方案</li></ul></li><li>常用工具<ul><li>IDEA</li><li>JVM问题排查工具-JMC</li><li>线上调试神器-btrace</li><li>Git原理与工作流:是一个开源的分布式版本管理控制系统、可以有效、高速地处理从小到非常大的项目版本管理</li><li>Linux常用分析工具</li><li>Maven:项目对象模型(POM)，可以通过一小段描述信息来管理项目的构建、报告和文档的项目管理工具软件</li><li>Gradle:是一个基于Apache Ant和Apache Maven概念的项目自动化构建开源工具。它使用一种基于Groovy的特定领域语言(DSL)来声明项目设置，目前也增加了基于Kotlin语言的kotlin-based DSL,抛弃了基于XML的各种繁琐配置</li></ul></li><li>容器化<ul><li>Docker</li><li>Kubernetes(k8s)</li></ul></li></ul><h3 id="数据层"><a href="#数据层" class="headerlink" title="数据层"></a>数据层</h3><ul><li>事务隔离级别</li><li>索引</li><li>SQL</li><li>主从同步</li><li>读写分离</li><li>分库分表-TDDL、Sharding-JDBC、DRDS</li><li>Redis<ul><li>持久化机制：RDB、AOF</li><li>缓存雪崩</li><li>缓存击穿</li><li>缓存穿透</li><li>集群模式<ul><li>哨兵</li><li>主从</li></ul></li><li>内存淘汰机制</li><li>位图</li><li>HyperLogLog</li><li>布隆过滤器(Bloom Filter)</li></ul></li></ul><h3 id="实时-离线数仓-大数据"><a href="#实时-离线数仓-大数据" class="headerlink" title="实时/离线数仓/大数据"></a>实时/离线数仓/大数据</h3><ul><li>离线分析：ODPS，是阿里云基于自有的云计算技术研发一套开放数据处理服务</li><li>Hadoop(HDFS):是一个由Apache基金会所开发的分布式系统基础架构。用户可以在不了解分布式底层细节的情况下，开发分布式程序。充分利用集群的威力进行高速运算和存储</li><li>Hive:基于Hadoop的一个数据仓库工具，用来进行数据提取、转化、加载，这是一种可以存储、查询和分析存储在Hadoop中的大规模数据的机制</li><li>HBase:是一个分布式的、面向列的开源数据库，该技术来源于Fay Chang所撰写的Google论文”Bigtable:一个结构化数据的分布式存储系统”。</li><li>Cassandra:是一个高可靠的大规模分布式存储系统。支持分布式的结构化key -value存储，以高可用性为主要目标。适合写多的场景，适合做一些简单查询， 不适合用来做数据分析统计。</li><li>Flink:Apache软件基金会开发的开源流处理框架，其核心是用Java和Scala编写的分布式流数据流引擎。</li><li>Spark:专为大规模数据处理而设计的快速通用的计算引擎</li></ul><h3 id="算法-机器学习-人工智能"><a href="#算法-机器学习-人工智能" class="headerlink" title="算法/机器学习/人工智能"></a>算法/机器学习/人工智能</h3><ul><li>机器学习、深度学习、人工智能、自动驾驶等</li></ul><h3 id="搜索引擎"><a href="#搜索引擎" class="headerlink" title="搜索引擎"></a>搜索引擎</h3><ul><li>ElasticSearch: 是一个基于Lucene的搜索服务器。它提供了一个分布式多用户能力的全文搜索引擎,基于RESTful web接口。</li><li>Canal:是阿里巴巴旗下的一款开源项目,纯Java开发。基于数据库增量日志解析，提供增量数据订阅&amp;消费,目前主要支持了MySQL(也支持mariaDB)。</li><li>Kibana: 是一个开源的分析和可视化平台，设计用于和Elasticsearch一起工作。</li><li>Lucene: 是apache软件基金会4 jakarta项目组的一个子项目，是一个开放源代码的全文检索引擎工具包，但它不是一个完整的全文检索引擎，而是一个全文检索引擎的架构，提供了完整的查询引擎和索引引擎，部分文本分析引擎(英文与德文两种西方语言)</li><li>Logstash: 是一个具有实时管道功能的开源数据收集引擎，Logstash可以动态地将来自不同数据源的数据统一起来，并将数据规范化为你选择的目的地，清理和大众化你的所有数据，用于各种高级下游分析和可视化用例。</li><li>Solr: 是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引;也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux内核及发行版分类</title>
      <link href="/2021/02/07/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E5%8F%91%E8%A1%8C%E7%89%88%E5%88%86%E7%B1%BB/"/>
      <url>/2021/02/07/Linux/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E5%8F%91%E8%A1%8C%E7%89%88%E5%88%86%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<p>&emsp;以Linux核心为中心，再集成搭配各种各样的系统管理软件或应用工具软件组成一套完整的操作系统，如此的组合便称为<strong>Linux发行版</strong>。</p><p>Linux的发行版本可以大体分为两类：</p><p>一类是<strong>商业公司维护</strong>的发行版本</p><p>一类是<strong>社区组织维护</strong>的发行版本</p><p>前者以著名的Redhat（RHEL）为代表，后者以Debian为代表。</p><p>下面介绍一下各个发行版本的特点：<br><img src="https://ae01.alicdn.com/kf/Ub85ae1223d0e490caa2a6b95cc38ec7ax.jpg" alt="Linux发行版本"></p><h3 id="Redhat（小红帽）"><a href="#Redhat（小红帽）" class="headerlink" title="Redhat（小红帽）"></a>Redhat（小红帽）</h3><p>应该称为<code>Redhat</code>系列，包括<code>RHEL</code>(Redhat Enterprise Linux，也就是所谓的Redhat Advance Server，收费版本)、<code>Fedora Core</code>(由原来的Redhat桌面版本发展而来，免费版本)、<code>CentOS</code>(RHEL的社区克隆版本，免费)。</p><p>Redhat应该说是在国内使用人群最多的Linux版本，甚至有人将Redhat等同于Linux，而有些老鸟更是只用这一个版本的Linux。所以这个版本的特点就是使用人群数量大，资料非常多，言下之意就是如果你有什么不明白的地方，很容易找到人来问，而且网上的一般Linux教程都是以Redhat为例来讲解的。</p><p>Redhat系列的<em>包管理方式</em>采用的是基于<code>RPM</code>包的<code>YUM</code>包管理方式，包分发方式是编译好的二进制文件。稳定性方面<code>RHEL</code>和<code>CentOS</code>的稳定性非常好，适合于服务器使用，但是<code>Fedora Core</code>的稳定性较差，最好只用于桌面应用。</p><h3 id="Debian"><a href="#Debian" class="headerlink" title="Debian"></a>Debian</h3><p><code>Debian</code>系列，包括<code>Debian</code>和<code>Ubuntu</code>等。</p><p><code>Debian</code>是社区类Linux的典范，是迄今为止最遵循GNU规范的Linux系统。Debian最早由Ian Murdock于1993年创建，分为三个版本分支（branch）： <code>stable</code>, <code>testing</code>和<code>unstable</code>。其中，<code>unstable</code>为最新的测试版本，其中包括最新的软件包，但是也有相对较多的bug，适合桌面用户。<code>testing</code>的版本都经过unstable中的测试，相对较为稳定，也支持了不少新技术（比如SMP等）。而<code>stable</code>一般只用于服务器，上面的软件包大部分都比较过时，但是稳定和安全性都非常的高。</p><p><code>Debian</code>最具特色的是<code>apt-get</code>/<code>dpkg</code><em>包管理方式</em>，其实<code>Redhat</code>的<code>YUM</code>也是在模仿<code>Debian</code>的<code>APT</code>方式，但在二进制文件发行方式中，<code>APT</code>应该是最好的了。Debian的资料也很丰富，有很多支持的社区，有问题求教也有地方可去.</p><h3 id="Ubuntu"><a href="#Ubuntu" class="headerlink" title="Ubuntu"></a>Ubuntu</h3><p><code>Ubuntu</code>严格来说不能算一个独立的发行版本，<code>Ubuntu</code>是基于<code>Debian</code>的<code>unstable</code>版本加强而来，可以这么说，Ubuntu就是一个拥有Debian所有的优点，以及自己所加强的优点的近乎完美的Linux桌面系统。根据选择的桌面系统不同，有三个版本可供选择，基于Gnome的<code>Ubuntu</code>，基于KDE的<code>Kubuntu</code>以及基于Xfc的<code>Xubuntu</code>。特点是界面非常友好，容易上手，对硬件的支持非常全面，是最适合做桌面系统的Linux发行版本。</p><h3 id="Gentoo"><a href="#Gentoo" class="headerlink" title="Gentoo"></a>Gentoo</h3><p>伟大的<code>Gentoo</code>是Linux世界最年轻的发行版本，正因为年轻，所以能吸取在她之前的所有发行版本的优点，这也是<code>Gentoo</code>被称为<em>最完美的Linux发行版本</em>的原因之一。<code>Gentoo</code>最初由Daniel Robbins（FreeBSD的开发者之一）创建，首个稳定版本发布于2002年。由于开发者对FreeBSD的熟识，所以Gentoo拥有媲美FreeBSD的广受美誉的ports系统 ——<code>Portage</code><em>包管理系统</em>。不同于<code>APT</code>和<code>YUM</code>等<em>二进制文件分发</em>的包管理系统，Portage是基于<em>源代码分发</em>的，必须编译后才能运行，对于大型软件而言比较慢，不过正因为所有软件都是在本地机器编译的，在经过各种定制的编译参数优化后，能将机器的硬件性能发挥到极致。<code>Gentoo</code>是所有Linux发行版本里<em>安装最复杂的</em>，但是又是安装完成后<em>最便于管理</em>的版本，也是在相同硬件环境下<em>运行最快</em>的版本。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux根目录介绍</title>
      <link href="/2021/02/06/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/Linux-%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/"/>
      <url>/2021/02/06/Linux/%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/Linux-%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="Linux根目录介绍"><a href="#Linux根目录介绍" class="headerlink" title="Linux根目录介绍"></a>Linux根目录介绍</h2><h3 id=""><a href="#" class="headerlink" title="/"></a>/</h3><ul><li>第一层次结构的根、整个文件系统层次结构的根路径。</li></ul><h3 id="bin"><a href="#bin" class="headerlink" title="/bin"></a>/bin</h3><ul><li>binary:二进制</li><li>此目录存放所有二进制命令（可执行文件）；面向所有用户。</li><li>和<code>/usr/bin</code>类似</li><li>例如：<code>cat</code>、<code>ls</code>、<code>cp</code>、<code>pwd</code>、<code>init</code>等等</li></ul><h3 id="boot"><a href="#boot" class="headerlink" title="/boot"></a>/boot</h3><ul><li>Linux内核及引导系统程序所需的目录</li><li>引导程序文件，例如：kernel、initrd，时常是一个单独的分区</li><li>系统启动核心目录，用于存储系统启动文件。</li></ul><h3 id="dev"><a href="#dev" class="headerlink" title="/dev"></a>/dev</h3><ul><li>device:<strong>系统硬件设备</strong>目录(linux系统所有的硬件都通过文件表示)</li><li>所有设备文件的目录（如声卡、磁盘、光驱）</li><li>例如：<ul><li><code>/dev/cdrom</code>:是光驱</li><li><code>/dev/sda</code>:是第一块scsi硬盘</li></ul></li></ul><h3 id="etc"><a href="#etc" class="headerlink" title="/etc"></a>/etc</h3><ul><li>系统主要配置文件目录，二进制安装包（yum，rpm）配置文件默认路径，服务启动命令存放目录。</li><li>例如：<ul><li><code>/etc/passwd</code>:用于存储用户信息的文件</li><li><code>/etc/group</code>:用于存储组别信息的文件</li></ul></li><li><code>/etc/opt</code>:/opt/的配置文件</li><li><code>/etc/X11</code>:X_Windows系统(版本11)的配置文件</li><li><code>/etc/sgml</code>:SGML的配置文件</li><li><code>/etc/xml</code>:XML的配置文件</li></ul><h3 id="home"><a href="#home" class="headerlink" title="/home"></a>/home</h3><ul><li>普通用户的”家目录”，包含保存的文件、个人设置等，一般为单独的分区。</li><li>给系统每增加一个“普通用户”的同时，都会在该目录为该用户设置一个文件目录</li><li>代表该用户的“家目录”，用户后期使用系统的时候会首先“进入”其家目录</li><li>家目录名字默认与当前用户名字一致</li><li>用户对家目录拥有绝对最高的权限。</li></ul><h3 id="lib"><a href="#lib" class="headerlink" title="/lib"></a>/lib</h3><ul><li>library:系统资源文件类库目录，库文件存放目录</li><li><code>/bin/</code>和<code>/sbin/</code>中二进制文件必要的库文件</li></ul><h3 id="lost-found"><a href="#lost-found" class="headerlink" title="/lost+found"></a>/lost+found</h3><ul><li>在EXT3系统中，当系统意外崩溃或意外关机时，会产生一些碎片文件在这个目录下面，系统启动fcsk工具会检查这个目录，并修复已损坏的文件系统。</li></ul><h3 id="media"><a href="#media" class="headerlink" title="/media"></a>/media</h3><ul><li>可移除媒体(如CD·ROM)的挂载点</li><li>用于临时挂载存储设备，通常情况下可以挂载LINUX ISO光盘进行无网条件下的安装其他软件包</li></ul><h3 id="mnt"><a href="#mnt" class="headerlink" title="/mnt"></a>/mnt</h3><ul><li>临时挂载的文件系统，比如cdrom，u盘等，直接插入光驱无法使用，要先挂载后使用</li></ul><h3 id="opt"><a href="#opt" class="headerlink" title="/opt"></a>/opt</h3><ul><li>自定义软件安装存放目录，用户自行安装的软件包存放目录。</li></ul><h3 id="proc"><a href="#proc" class="headerlink" title="/proc"></a>/proc</h3><ul><li>进程及内核信息存放目录。该目录下文件只能看不能改(包括root)</li><li>内存映射目录，该目录可以查看系统的相关硬件信息</li></ul><h3 id="root"><a href="#root" class="headerlink" title="/root"></a>/root</h3><ul><li>该目录是root管理员的”家目录”，root用户登录系统后首先进入该目录</li></ul><h3 id="sbin"><a href="#sbin" class="headerlink" title="/sbin"></a>/sbin</h3><ul><li>super binary:超级的二进制</li><li>系统管理员命令存放的目录（超级管理员使用的命令）,sbin目录下的命令，普通用户都执行不了。</li><li>例如：<code>init</code>、<code>ip</code>、<code>mount</code></li></ul><h3 id="srv"><a href="#srv" class="headerlink" title="/srv"></a>/srv</h3><ul><li>站点的具体数据，由系统提供</li></ul><h3 id="tmp"><a href="#tmp" class="headerlink" title="/tmp"></a>/tmp</h3><ul><li>临时文件目录，程序运行时产生的临时文件存放目录。</li><li>临时文件(参见/var/tmp)，在系统重启时该目录中文件不会被保留。</li></ul><h3 id="usr"><a href="#usr" class="headerlink" title="/usr"></a>/usr</h3><ul><li>unix system resource:unix系统资源文件目录</li><li>该目录类似win系统的 C:/Program files 目录</li><li>该目录经常用于安装各种软件</li><li>系统存放程序的目录（命令和帮助文件）</li><li>软件安装完毕会形成对应的指令，该指令对应的可执行程序文件就存放在以下目录<ul><li><code>/usr/bin</code><ul><li>用户可执行文件目录（应用程序）</li></ul></li><li><code>/usr/sbin</code><ul><li>root用户执行的指令对应的可“执行程序文件”目录</li></ul></li></ul></li></ul><h3 id="var"><a href="#var" class="headerlink" title="/var"></a>/var</h3><ul><li>variable:可变的、易变的</li><li>变量文件–在正常运行的系统中其内容不断变化的文件，如日志、脱机文件和临时电子邮件文件，有时是一个单独的分区，如果不单独分区，有可能会把整个分区充满，如果单独分区，给大给小都不合适。</li><li>该目录存储的文件经常会发生变动(增加、修改、删除)</li><li>经常用于部署项目程序(php)文件<ul><li><code>/var/www/shop</code></li><li><code>/var/www/book</code></li></ul></li></ul><h3 id="selinux"><a href="#selinux" class="headerlink" title="/selinux"></a>/selinux</h3><ul><li>secure enhanced linux:安全增强型linux</li><li>对系统形成保护</li><li>会对给系统安装软件时有干扰作用</li></ul>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>5.BootStrap</title>
      <link href="/2021/01/10/%E5%89%8D%E7%AB%AF/5.BootStrap/"/>
      <url>/2021/01/10/%E5%89%8D%E7%AB%AF/5.BootStrap/</url>
      
        <content type="html"><![CDATA[<h2 id="BootStrap"><a href="#BootStrap" class="headerlink" title="BootStrap"></a>BootStrap</h2><h3 id="什么是BootStrap"><a href="#什么是BootStrap" class="headerlink" title="什么是BootStrap?"></a>什么是BootStrap?</h3><ul><li>Bootstrap，基于 HTML、CSS、JAVASCRIPT 的前端框架（半成品）。其预定义一套CSS样式和与样式对应的jQuery代码，我们只需要提供固定HTML结构，添加固定的class样式，就可以完成指定效果的实现。</li><li>Bootstrap在jQuery的基础工作，可以理解Bootstrap就是jQuery的一个插件。</li><li>Bootstrap 使得 Web 开发更加快捷，代码优雅，美观大方。</li><li>Bootstrap 基础入门使用的都是自带CSS样式，高级开发中需要使用HTML5、CSS3、动态CSS语言Less 进行自定义开发，JavaEE课程中学习时“基础入门”。</li><li>国内一些移动开发者较为熟悉的框架，如WeX5前端开源框架等，也是基于Bootstrap源码进行性能优化而来</li><li>中文官网：<a href="http://www.bootcss.com/">http://www.bootcss.com/</a></li></ul><h3 id="什么是响应式布局"><a href="#什么是响应式布局" class="headerlink" title="什么是响应式布局"></a>什么是响应式布局</h3><ul><li>响应式布局：一个网站能够兼容多个终端(手机、iPad等)，而不需要为每个终端做一个特定的版本。此概念是为解决移动互联网浏览而诞生的。</li><li>响应式布局可以为不同终端的用户提供更加舒适的界面和更好的用户体验，而且随着目前大屏幕移动设备的普及，用“大势所趋”来形容也不为过。随着越来越多的设计师采用这个技术，我们不仅看到很多的创新，还看到了一些成形的模式。</li><li>Bootstrap就是响应式布局最成功的实现，为了兼容不同的浏览器采用jQuery，为了适配不同的终端采用CSS3 Media Query （媒体查询）</li></ul><h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><ul><li>下载：<ul><li>中文官网地址：<a href="http://d.bootcss.com/bootstrap-3.3.5.zip">http://d.bootcss.com/bootstrap-3.3.5.zip</a></li><li>GIT地址：<a href="https://github.com/twbs/bootstrap/archive/v3.3.6.zip">https://github.com/twbs/bootstrap/archive/v3.3.6.zip</a></li></ul></li><li>目录结构：<ul><li>css:css样式</li><li>fonts:字体库</li><li>js:js文件</li></ul></li><li>引入：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 响应式开发必须使用，且必须在&lt;head&gt;前三行 --&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;</span><br><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot; /&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> BootStrap </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>4.jQuery</title>
      <link href="/2021/01/09/%E5%89%8D%E7%AB%AF/4.JQuery/"/>
      <url>/2021/01/09/%E5%89%8D%E7%AB%AF/4.JQuery/</url>
      
        <content type="html"><![CDATA[<h2 id="jQuery"><a href="#jQuery" class="headerlink" title="jQuery"></a>jQuery</h2><p>jQuery是一个优秀的javascript的轻量级框架，兼容css3和各大浏览器，提供了dom、events、animate、ajax等简易的操作。并且jQuery的插件非常丰富，大多数功能都有相应的插件解决方案。jQuery的宗旨是write less do more。</p><h3 id="jQuery引入"><a href="#jQuery引入" class="headerlink" title="jQuery引入"></a>jQuery引入</h3><p>在需要使用jQuery的html中使用js的引入方式进行引入</p><ul><li><code>&lt;script type=&quot;text/javascript&quot; src=&quot;jquery-1.11.2.min.js&gt;&lt;/script&gt;</code></li><li>也可以通过http引入（无需下载包）：<code>&lt;script src=&quot;https://code.jquery.com/jquery-3.2.1.min.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</code></li></ul><h3 id="jQuery与js的区别"><a href="#jQuery与js的区别" class="headerlink" title="jQuery与js的区别"></a>jQuery与js的区别</h3><ul><li>jQuery本质上虽然也是js，但如果使用jQuery的属性和方法那么必须保证对象是jQuery对象而不是js对象。</li><li>两者的关系与区别总结如下：<ul><li><ol><li>js对象只能使用js对象的方法，jQuery对象只能使用jQuery对象的方法。</li></ol></li><li><ol start="2"><li>jQuery对象与js对象之间的转换</li></ol><ul><li>js对象转换成jQuery对象，语法：<code>$(js对象)</code></li><li>jQuery对象转换成js对象，语法：<code>jquery对象[索引]</code>或<code>jquery对象.get(索引)</code></li><li>需要注意的是：js对象是dom对象，jQuery对象其实是一个数组，这个数组里放的是一个一个的js的dom对象。</li><li>需要注意<strong>jQuery对象的命名</strong>，一般如果是jQuery对象，那么定义变量名的时候就加上<code>$</code>。</li></ul></li><li><ol start="3"><li>事件的写法不同，意义相同;</li></ol><ul><li>js的事件的写法：<code>js对象.onclick = function()&#123;......&#125;</code></li><li>jQuery的事件的写法：<code>jquery对象.click(function()&#123;......&#125;)</code></li></ul></li><li><ol start="4"><li>js的页面加载完毕与jQuery的页面加载完毕</li></ol><ul><li>js的页面加载完毕：<code>window.onload = function()&#123;......&#125;</code></li><li>jQuery的页面加载完毕：<code>$(document).ready(function()&#123;......&#125;)</code><ul><li>简写形式:<code>$(function()&#123;......&#125;);</code></li></ul></li><li>两者区别：<ul><li>jQuery的页面加载完毕有简写形式：<code>$(function()&#123;......&#125;)</code></li><li>jQuery的页面加载完毕事件可以写<strong>多次</strong>，而js只能写<strong>一次</strong>，写多次也只会执行<strong>最后一次</strong></li></ul></li></ul></li></ul></li></ul><h3 id="jQuery的选择器"><a href="#jQuery的选择器" class="headerlink" title="jQuery的选择器"></a>jQuery的选择器</h3><p>选择器的作用就是精确的选择标签.</p><ul><li>jquery常用的选择器有如下：<ul><li>基本选择器，层级选择器，属性选择器，基本过滤选择器，表单属性选择器等</li></ul></li></ul><h4 id="1．基本选择器（作用和我们学习的css中选择器作用一样）"><a href="#1．基本选择器（作用和我们学习的css中选择器作用一样）" class="headerlink" title="1．基本选择器（作用和我们学习的css中选择器作用一样）"></a>1．基本选择器（作用和我们学习的css中选择器作用一样）</h4><ul><li>标签选择器（元素选择器）：<code>$(&quot;html标签名&quot;);</code></li><li>id选择器：<code>$(&quot;#id的属性值&quot;);</code></li><li>类选择器：<code>$(&quot;.class的属性值&quot;);</code></li><li>组合选择器：<code>$(&quot;选择器名，选择器名&quot;);</code></li></ul><h4 id="2．层级选择器"><a href="#2．层级选择器" class="headerlink" title="2．层级选择器"></a>2．层级选择器</h4><ul><li>获得A元素内部的所有的B元素：<code>$(&quot;A  B&quot;)</code></li><li>获得A元素下面的所有B子元素：<code>$(&quot;A &gt; B&quot;)</code></li><li>获得A元素同级,下一个B元素：<code>$(&quot;A + B&quot;)</code></li><li>获得A元素同级,所有后面B元素：<code>$(&quot;A ~ B&quot;)</code></li><li>获得A元素同级,所有B元素：<code>$(&quot;A&quot;).siblings(&quot;B&quot;);</code></li></ul><h4 id="3．属性选择器"><a href="#3．属性选择器" class="headerlink" title="3．属性选择器"></a>3．属性选择器</h4><ul><li>获得有属性名的元素：<code>$(&quot;A[属性名]&quot;)</code></li><li>获得属性名<strong>等于</strong>值元素：<code>$(&quot;A[属性名=值]&quot;)</code></li><li>获得属性名<strong>不等于</strong>值元素：<code>$(&quot;A[属性名!=值]&quot;)</code></li><li>获得属性名以值<strong>开头</strong>元素：<code>$(&quot;A[属性名^=值]&quot;)</code></li><li>获得属性名以值<strong>结尾</strong>元素：<code>$(&quot;A[属性名$=值]&quot;)</code></li><li>获得属性名<strong>含有</strong>值元素：<code>$(&quot;A[属性名*=值]&quot;)</code></li><li>复合属性选择器，多个属性同时过滤：<code>$(&quot;A[属性名!=值][属性名!=值][属性名!=值]&quot;)</code></li></ul><h4 id="4．基本过滤选择器"><a href="#4．基本过滤选择器" class="headerlink" title="4．基本过滤选择器"></a>4．基本过滤选择器</h4><ul><li>获得选择的元素中的第一个元素：<code>:first</code></li><li>获得选择的元素中的最后一个元素：<code>:last</code></li><li>不包括指定内容的元素例如：<code>:not(selecter)</code> </li><li>偶数，从 0 开始计数：<code>:even</code></li><li>奇数，从 0 开始技术：<code>:odd</code></li><li>指定第几个：<code>:eq(index)</code></li><li>大于n个：<code>:gt(index)</code></li><li>小于n个：<code>:lt(index)</code></li><li>获得标题<code>(&lt;h1&gt;&lt;h2&gt;....):header</code>—固定写法</li><li>获得动画<code>:animated</code>—固定写法,正在执行的动画</li></ul><h4 id="5．表单属性选择器"><a href="#5．表单属性选择器" class="headerlink" title="5．表单属性选择器"></a>5．表单属性选择器</h4><ul><li>可用：<code>:enabled</code></li><li>不可用：<code>:disabled</code>        </li><li>选中(单选radio,多选checkbox,option)：<code>:checked</code></li><li>选择(下列列表<code>&lt;select&gt;</code>)：<code>:selected</code></li></ul><h3 id="jQuery的操作方法"><a href="#jQuery的操作方法" class="headerlink" title="jQuery的操作方法"></a>jQuery的操作方法</h3><h4 id="1-jQuery的DOM操作方法"><a href="#1-jQuery的DOM操作方法" class="headerlink" title="1.jQuery的DOM操作方法"></a>1.jQuery的DOM操作方法</h4><ul><li>1)html代码/文本/值/属性：<code>html()/text()/val()</code></li><li>2)html属性操作：<code>attr()/prop()</code>这2个方法一般情况下优先使用<code>attr()</code>、<code>removeAttr(属性名)</code>删除指定的属性</li><li>3)html的class属性操作：<code>addClass()</code> <code>removeClass()</code> <code>toggleClass()</code></li><li>4)html的样式的操作：<code>css()</code></li><li>5)html的元素的创建：<code>$(&quot;完整的标签&quot;);</code>例如<code>$(&quot;&lt;li&gt;&lt;/li&gt;&quot;)</code></li><li>6)html的内部插入：<code>append()</code> <code>prepend()</code> <code>before()</code> <code>after()</code></li><li>7)html元素的删除操作：<code>remove()</code> <code>empty()</code></li><li>注意：jquery中的大部分方法是集设置值与获取值为一体的</li></ul><h4 id="2-jQuery的效果"><a href="#2-jQuery的效果" class="headerlink" title="2.jQuery的效果"></a>2.jQuery的效果</h4><ul><li>1)元素的显示与隐藏<ul><li><code>show(speed,fn)</code>显示<ul><li>参数<code>speed</code>，显示速度，单位：毫秒。固定字符串：slow,normal,fast</li><li>参数<code>fn</code>，显示成功之后回调函数。</li></ul></li><li><code>hide(speed,fn)</code>隐藏</li><li><code>toggle()</code>切换,如果一开始没有显示,则显示。如果已显示,则影藏</li></ul></li><li>2)元素的滑动显示与隐藏<ul><li><code>slideDown()</code>显示，高度变大。</li><li><code>slideUp()</code>隐藏，高度变小。</li><li><code>slideToggle()</code>切换</li></ul></li><li>3)元素的淡入淡出的显示与隐藏<ul><li><code>fadeIn()</code>显示</li><li><code>fadeOut()</code>隐藏</li><li><code>fadeToggle()</code>切换</li></ul></li></ul><h3 id="jQuery的循环遍历"><a href="#jQuery的循环遍历" class="headerlink" title="jQuery的循环遍历"></a>jQuery的循环遍历</h3><ul><li>1．原始方式遍历<ul><li>跟java和js一样，既然是数组那么就可以使用原始的for循环进行遍历。</li><li>例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $options = $(<span class="string">&quot;option&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span> ; i&lt;$options.length ; i++)&#123;</span><br><span class="line">    alert(option.value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>2．jQuery对象的方法<ul><li>此方式是jQuery特有的遍历方式，使用jQuery集合对象调用<code>each()</code>方法即可遍历。</li><li>例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $options = $(<span class="string">&quot;option&quot;</span>);</span><br><span class="line">$options.each(<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;</span><br><span class="line">    alert(index); <span class="comment">//打印索引</span></span><br><span class="line">    alert(element); <span class="comment">//打印$options集合对象中的每一个元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li>3．jQuery的全局方法<ul><li>此方式是jquery特有的遍历方式，与上面jQuery的对象方法相似，但此处的<code>each()</code>方法不是某个具体jquery对象的，而是jQuery的全局对象的<code>each()</code>方法，名字和功能虽然相同，但语法不同。</li><li>例如：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $options = $(<span class="string">&quot;option&quot;</span>);</span><br><span class="line">$.each($options,<span class="function"><span class="keyword">function</span>(<span class="params">index,element</span>)</span>&#123;</span><br><span class="line">    alert(index); <span class="comment">//打印索引</span></span><br><span class="line">    alert(element); <span class="comment">//打印$options集合对象中的每一个元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li><li>注意：别管是上述的哪种遍历方法，遍历的集合中的每一个元素都是<strong>js对象</strong>，要想使用    jQuery的方法请使用<code>$(js对象)</code>进行转换。</li></ul><h3 id="jQuery的事件"><a href="#jQuery的事件" class="headerlink" title="jQuery的事件"></a>jQuery的事件</h3><h4 id="jquey中常用的事件"><a href="#jquey中常用的事件" class="headerlink" title="jquey中常用的事件"></a>jquey中常用的事件</h4><p>jquery的事件与js的事件的功能和意义一样，只是在使用语法上稍微有些差异.<br>|事件名|描述|<br>|–|–|<br>|blur([[data],fn])|失去焦点|<br>|change([[data],fn])|域内容变化|<br>|click([[data],fn])|点击事件|<br>|dblclick([[data],fn])|双击事件|<br>|focus([[data],fn])|获得焦点|<br>|keydown([[data],fn])|某个键盘的键被按下|<br>|keypress([[data],fn])|某个键盘的键被按下或按住|<br>|keyup([[data],fn])|某个键盘的键被松开|<br>|mousedown([[data],fn])|某个鼠标按键被按下|<br>|mouseleave([[data],fn])|鼠标离开|<br>|mousemove([[data],fn])|鼠标被移动|<br>|mouseout([[data],fn])|鼠标离开|<br>|mouseover([[data],fn])|鼠标被移到某个元素之上|<br>|scroll([[data],fn])|滚动事件|<br>|submit([[data],fn])|提交事件|</p><h4 id="事件的绑定与解绑"><a href="#事件的绑定与解绑" class="headerlink" title="事件的绑定与解绑"></a>事件的绑定与解绑</h4><p>这种事件的绑定方式还可以实现解除绑定的事件</p><ul><li>(1)事件的绑定：<ul><li><code>jquery对象.bind(事件类型,响应函数);</code></li><li>例如：<ul><li>绑定一个事件：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;btn&quot;</span>).bind(<span class="string">&quot;click&quot;</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li>绑定多个事件：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;button&quot;</span>).bind(&#123;</span><br><span class="line">    <span class="attr">click</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert()&#125;,</span><br><span class="line">    <span class="attr">mouseover</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert()&#125;,  </span><br><span class="line">    <span class="attr">mouseout</span>:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert()&#125;  </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li>(2)事件的解绑：<ul><li><code>jquery对象.unbind([事件类型]);</code></li><li>例如：<ul><li>解绑所有事件：<code>$(&quot;btn&quot;).unbind();</code></li><li>解绑指定事件：<code>$(&quot;button&quot;).unbind(&quot;click&quot;);</code></li></ul></li></ul></li></ul><h4 id="事件切换"><a href="#事件切换" class="headerlink" title="事件切换"></a>事件切换</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hover(fn1,fn2)是给标签同时绑定鼠标悬浮和鼠标移出事件</span></span><br><span class="line"><span class="comment">//fn1：鼠标悬浮事件执行的函数,fn2:鼠标移出事件执行的函数。</span></span><br><span class="line"><span class="comment">//hover(over,out) == mouseover + mouseout</span></span><br><span class="line">hover([over,]out)</span><br><span class="line"><span class="comment">//是对点击方法的简写形式---循环点击</span></span><br><span class="line"><span class="comment">//fn1,鼠标第一次点击执行的函数</span></span><br><span class="line"><span class="comment">//fn2,鼠标第二次点击执行的函数</span></span><br><span class="line"><span class="comment">//结束之后再来一次循环</span></span><br><span class="line">toggle(fn,fn2,[fn3,fn4,...])</span><br></pre></td></tr></table></figure><h3 id="jQuery的插件-表单校验的validate插件"><a href="#jQuery的插件-表单校验的validate插件" class="headerlink" title="jQuery的插件-表单校验的validate插件"></a>jQuery的插件-表单校验的validate插件</h3><p>插件就是将jquery实现的常用操作进行封装，封装后的小框架就可以叫做<strong>插件</strong></p><h4 id="使用方法："><a href="#使用方法：" class="headerlink" title="使用方法："></a>使用方法：</h4><ul><li>下载jquery-validation插件并引入</li><li>编写表单校验的代码：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">&quot;form表单的选择器&quot;</span>).validate(&#123;</span><br><span class="line">    <span class="attr">rules</span>:&#123;</span><br><span class="line">       表单项name值:校验规则,</span><br><span class="line">       表单项name值:校验规则...</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">messages</span>:&#123;</span><br><span class="line">       表单项name值:错误提示信息,</span><br><span class="line">       表单项name值:错误提示信息...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="常用的校验规则"><a href="#常用的校验规则" class="headerlink" title="常用的校验规则"></a>常用的校验规则</h4><ul><li>(1)、<code>required:true</code>必输字段</li><li>(2)、<code>remote:&quot;remote-valid.jsp&quot;</code>使用ajax方法调用remote-valid.jsp验证输入值</li><li>(3)、<code>email:true</code>必须输入正确格式的电子邮件</li><li>(4)、<code>url:true</code>必须输入正确格式的网址</li><li>(5)、<code>date:true</code>必须输入正确格式的日期，日期校验ie6出错，慎用</li><li>(6)、<code>dateISO:true</code>必须输入正确格式的日期(ISO)，例如：2009-06-23，1998/01/22 只验证格式，不验证有效性</li><li>(7)、<code>number:true</code>必须输入合法的数字(负数，小数)</li><li>(8)、<code>digits:true</code>必须输入整数</li><li>(9)、<code>creditcard:true</code>必须输入合法的信用卡号</li><li>(10)、<code>equalTo:&quot;#password&quot;</code>输入值必须和#password相同</li><li>(11)、<code>accept:</code>输入拥有合法后缀名的字符串（上传文件的后缀）</li><li>(12)、<code>maxlength:5</code>输入长度最多是5的字符串(汉字算一个字符)</li><li>(13)、<code>minlength:10</code>输入长度最小是10的字符串(汉字算一个字符)</li><li>(14)、<code>rangelength:[5,10]</code>输入长度必须介于5和10之间的字符串(汉字算一个字符)</li><li>(15)、<code>range:[5,10]</code>输入值必须介于5和10之间</li><li>(16)、<code>max:5</code>输入值不能大于5</li><li>(17)、<code>min:10</code>输入值不能小于10</li></ul><h4 id="自定义校验规则"><a href="#自定义校验规则" class="headerlink" title="自定义校验规则"></a>自定义校验规则</h4><ul><li>如果预定义的校验规则尚不能满足需求的话可以进行自定义校验规则：</li><li>自定义校验规则步骤如下：<ul><li>(1) 使用<code>$.validator.addMethod(&quot;校验规则名称&quot;,function(value,element,params))&#123;&#125;</code></li><li>(2) 在rules中通过校验规则名称使用校验规则</li><li>(3) 在messages中定义该规则对应的错误提示信息<ul><li>其中：<ul><li><code>value</code>是校验组件的value值</li><li><code>element</code>是校验组件的节点对象</li><li><code>params</code>是校验规则的参数</li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> jQuery </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.JS</title>
      <link href="/2021/01/08/%E5%89%8D%E7%AB%AF/3.Js/"/>
      <url>/2021/01/08/%E5%89%8D%E7%AB%AF/3.Js/</url>
      
        <content type="html"><![CDATA[<h2 id="JS"><a href="#JS" class="headerlink" title="JS"></a>JS</h2><ul><li>JavaScript,是基于<strong>对象和事件驱动</strong>的浏览器脚本语言,不需要编译即可运行,是<strong>弱语言</strong>。</li><li>js的作用：<ul><li>1、js可以动态的修改html及css的代码（修改的是浏览器内存中的那一份代码）DOM操作</li><li>2、js可以对表单进行校验</li></ul></li><li>js由三部分组成： <ul><li>1、<strong>ECMAScript</strong>：这一部分主要是js的基本语法</li><li>2、<strong>BOM</strong>：Brower Object Model浏览器对象模型,主要是获取浏览器信息或操作浏览器的,例如：浏览器的前进与后退、浏览器弹出提示框、浏览器地址栏输入网址跳转等操作等</li><li>3、<strong>DOM</strong>：Document Object Model文档(html)对象模型,此处的文档暂且理解为html,html加载到浏览器的内存中,可以使用js的DOM技术对内存中的html节点进行修改,用户从浏览器看到的是js动态修改后页面</li></ul></li></ul><h3 id="js的引入方式"><a href="#js的引入方式" class="headerlink" title="js的引入方式:"></a>js的引入方式:</h3><h4 id="1-内部js-也就是在html源码中嵌入js代码"><a href="#1-内部js-也就是在html源码中嵌入js代码" class="headerlink" title="1.内部js:也就是在html源码中嵌入js代码"></a>1.内部js:也就是在html源码中嵌入js代码</h4><p>格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">        alert(<span class="string">&quot;这里写你的js代码&quot;</span>);</span></span><br><span class="line"><span class="javascript">    </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>&lt;script&gt;</code>标签可以现在html页面中的任何地方。而且一个页面中可以有多个<code>&lt;script&gt;</code>标签.</p><h4 id="2-外部js-也就是将js代码单独写成一个js文件-扩展名是-js而不是-javascript-在html代码中引入这个封装好的js文件"><a href="#2-外部js-也就是将js代码单独写成一个js文件-扩展名是-js而不是-javascript-在html代码中引入这个封装好的js文件" class="headerlink" title="2.外部js:也就是将js代码单独写成一个js文件(扩展名是.js而不是.javascript),在html代码中引入这个封装好的js文件"></a>2.外部js:也就是将js代码单独写成一个js文件(扩展名是.js而不是.javascript),在html代码中引入这个封装好的js文件</h4><p>格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../xxx.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：无论是内部js还是外部js在html中引入的<strong>位置是随意</strong>的,<code>&lt;head&gt;</code>标签中可以引入,<code>&lt;body&gt;</code>标签一样可以引入,但js的引入有一个原则就是：在<strong>不影响页面功能的情况</strong>下js<strong>越晚加载越好</strong>,所以建议<code>&lt;script&gt;</code>标签写在<code>&lt;body&gt;</code>标签下面即可。</p><h3 id="js的基本语法"><a href="#js的基本语法" class="headerlink" title="js的基本语法"></a>js的基本语法</h3><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单行注释</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 多行注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h4 id="js变量定义"><a href="#js变量定义" class="headerlink" title="js变量定义"></a>js变量定义</h4><p>js是<strong>弱类型语言</strong>，不重视类型的定义，但js会根据为变量赋值的情况自定判断该变量是何种类型，js的变量的定义直接通过<code>var</code>关键字就行。</p><p>格式：<code>var 变量名 = 值</code></p><h4 id="js的数据类型"><a href="#js的数据类型" class="headerlink" title="js的数据类型"></a>js的数据类型</h4><p>跟java一样,js的数据类型也分为<strong>基本数据类型</strong>(原始数据类型)和<strong>引用数据类型</strong></p><ul><li>1、原始/基本数据类型：<ul><li>数字类型：number(包含了小数和整数)  </li><li>布尔类型：boolean    </li><li>字符串类型：string(在js中字符串类型包含了字符’’和””引起来的都是字符串)</li><li>未定义类型：undefined</li><li>空类型：null</li><li>重要的转换：<ul><li>数字字符串 转 数字</li><li>parseInt</li><li>parseFloat</li></ul></li></ul></li><li>2、引用数据类型：与java一样,js中的对象都是引用数据类型,所以你也可以使用我们熟知new来”造对象”<ul><li>例如：<ul><li>造一个上帝对象：<code>var obj = new Object()</code>;</li><li>造一个字符串对象：<code>var str = new String()</code>;</li><li>造一个日期对象：<code>var date = new Date()</code>;</li></ul></li></ul></li><li>在js中引用数据类型和基本数据类型的区别和java中一样。</li></ul><h4 id="js的运算符"><a href="#js的运算符" class="headerlink" title="js的运算符"></a>js的运算符</h4><ul><li>在js中,如下运算符除了极个别的,其他绝大多数的运算都是和java中一模一样的运算法则。<ul><li>1、赋值运算符：var x = 5；</li><li>2、比较运算符：&gt;、&lt;、==、!=、===</li><li>3、逻辑运算符：&amp;&amp;、||、!<ul><li>需要注意的是,在js中,不光boolean值能够参与逻辑运算。所有的值都能参与逻辑运算。</li><li>在js中,非零,非null,非undefined理解成true,</li><li>零,null,undefined理解成false。</li></ul></li><li>4、算数运算符:+、-、*、/、%</li><li>5、三元运算符:条件?a:b</li></ul></li><li>与java的运算符一样,什么赋值运算符、逻辑运算符、运算运算符等等,不用把这些运算符都记住,写程序时自然会用就OK。下面说几个与<strong>java不一样的js运算符</strong>：<ul><li>1、===：<strong>全等运算符</strong>,不仅<strong>值相等</strong>而且<strong>类型</strong>也要相等才会返回true</li><li>2、&amp;&amp; ||：<strong>逻辑运算符</strong>,js中只有双与和双或,没有单与和单或</li><li>3、- * / : <strong>算数运算符</strong>,js中数字字符串进可以进行数学运算 但+法运算除外因为字符串本身具备加法运算就是<strong>连接字符串</strong><ul><li><code>alert(&quot;44&quot;-1);</code>结果为43</li></ul></li></ul></li></ul><h3 id="js的逻辑语句"><a href="#js的逻辑语句" class="headerlink" title="js的逻辑语句"></a>js的逻辑语句</h3><p>跟java一样,js也存在if、if-else、for、switch等逻辑语句,与java使用方式一致,此处不再一一阐述</p><h3 id="js的函数"><a href="#js的函数" class="headerlink" title="js的函数"></a>js的函数</h3><p>在js中,通过<code>function</code>关键字来定义函数</p><ul><li>1、普通函数：<ul><li>格式：<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数列表</span>)</span>&#123;</span><br><span class="line">    js逻辑代码;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数调用：</span></span><br><span class="line">函数名(实际参数);</span><br></pre></td></tr></table></figure></li><li>注意：<ul><li>1.函数需要被调用才能执行。</li><li>2.js中,如果函数<strong>需要返回值</strong>我们<strong>直接return</strong>就行了。定义函数的时候不需要声明返回值的类型,因为js是弱数据类型。</li><li>3.在js中,如果我们需要给函数<strong>传递参数</strong>,那么我们<strong>直接写变量</strong>就行。也不需要声明传入变量的类型。</li><li>4.在js中,<strong>不存在函数重载</strong>的概念,如果2个函数名一样,后面出现的函数会将前面出现的函数覆盖。</li><li>5.如果函数的<strong>声明带有参数</strong>,<strong>调用时不带参数</strong>,函数可以<strong>正常被调用</strong>。</li><li>6.如果函数声明时<strong>没有参数</strong>列表,<strong>调用的时候传入参数</strong>,函数也能<strong>照样执行</strong>。</li><li>7.既然可以给函数传入参数,在js中,可以通过arguments来获取传入的参数。arguments是js专门用来<strong>存放参数的数组</strong>。</li><li>8.可以给函数起个<strong>别名</strong>,然后通过别名来调用函数。</li></ul></li></ul></li><li>2、匿名函数：<ul><li>匿名函数也就是没有名字的函数  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">参数列表</span>)</span>&#123;</span><br><span class="line">    js逻辑代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="js的事件"><a href="#js的事件" class="headerlink" title="js的事件"></a>js的事件</h3><ul><li>什么是事件？<ul><li>我们用户发出的一些动作或者行为,这些能被js检测到,那么这些行为就叫做<strong>事件</strong>。</li><li>当我们输入完用户名,鼠标光标移开的时候,这样的一个动作我们的js或者说浏览器是能够知晓这样一个动作的,所以这样的动作叫做<strong>事件</strong>。</li><li>而我眼睛盯着浏览器看这么一个动作,浏览器并不知道,所以不是一个事件。</li></ul></li><li>事件的<strong>作用</strong>：<ul><li>我们可以给事件绑定一个函数,当事件触发的时候,就会执行这个函数。</li></ul></li><li>js的事件是js不可或缺的组成部分,要学习js的事件,必须要理解如下几个概念：<ul><li>1.事件源：被监听的html元素</li><li>2.事件：某类动作,例如点击事件,移入移出事件,敲击键盘事件等</li><li>3.事件与事件源的绑定：在事件源上注册上某事件</li><li>4.事件触发后的响应行为：事件触发后需要执行的代码,一般使用函数进行封装<h4 id="常用的事件"><a href="#常用的事件" class="headerlink" title="常用的事件"></a>常用的事件</h4></li></ul></li></ul><table><thead><tr><th>事件名</th><th>描述</th></tr></thead><tbody><tr><td>onload</td><td>某个页面或图像被完成加载</td></tr><tr><td>onsubmit</td><td>当表单提交时触发该事件—注意事件源是表单form</td></tr><tr><td>onclick</td><td>鼠标点击某个对象</td></tr><tr><td>ondblclick</td><td>鼠标双击某个对象</td></tr><tr><td>onblur</td><td>元素失去焦点</td></tr><tr><td>onfocus</td><td>元素获得焦点</td></tr><tr><td>onchange</td><td>用户改变域的内容</td></tr><tr><td>onkeydown</td><td>某个键盘的键被按下</td></tr><tr><td>onkeypress</td><td>某个键盘的键被按下或按住</td></tr><tr><td>onkeyup</td><td>某个键盘的键被松开</td></tr><tr><td>onmousedown</td><td>某个鼠标按键被按下</td></tr><tr><td>onmouseup</td><td>某个鼠标按键被松开</td></tr><tr><td>onmouseover</td><td>鼠标被移到某元素之上</td></tr><tr><td>onmouseout</td><td>鼠标从某元素移开</td></tr><tr><td>onmousemove</td><td>鼠标被移动</td></tr></tbody></table><h4 id="事件绑定函数"><a href="#事件绑定函数" class="headerlink" title="事件绑定函数"></a>事件绑定函数</h4><ul><li>1、方式一:<code>&lt;标签名 事件名=函数&gt;</code></li><li>2、方式二(动态绑定):<ul><li>格式：<code>标签对象.事件名 = function()&#123;&#125;</code></li><li>例如：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">      <span class="built_in">document</span>.getElementById(<span class="string">&quot;mydiv&quot;</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">alert(<span class="string">&quot;点的好&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="js的BOM-Browser-Object-Mode-浏览器对象模型"><a href="#js的BOM-Browser-Object-Mode-浏览器对象模型" class="headerlink" title="js的BOM(Browser Object Mode,浏览器对象模型)"></a>js的BOM(Browser Object Mode,浏览器对象模型)</h3><p>是将我们使用的浏览器抽象成对象模型</p><h4 id="js的BOM对象"><a href="#js的BOM对象" class="headerlink" title="js的BOM对象"></a>js的BOM对象</h4><ul><li>1.<code>Screen对象</code>:Screen对象中存放着有关显示浏览器屏幕的信息。</li><li>2.<code>Window对象</code>:Window对象表示一个浏览器窗口或一个框架。</li><li>3.<code>Navigator对象</code>:包含的属性描述了正在使用的浏览器</li><li>4.<code>History对象</code>:其实就是来保存浏览器历史记录信息。</li><li>5.<code>Location对象</code>:Location对象是Window对象的一个部分,可通过window.location属性来访问。</li></ul><h4 id="Window对象"><a href="#Window对象" class="headerlink" title="Window对象"></a>Window对象</h4><ul><li>Window对象此处学习它的三个作用：<ul><li>1.弹框的方法</li><li>2.定时器</li><li>3.全局方法<h5 id="1-弹框的方法"><a href="#1-弹框的方法" class="headerlink" title="(1)弹框的方法"></a>(1)弹框的方法</h5></li></ul></li><li>大家都用支付宝付款过，当我们付款的时候，支付宝经常会弹出一个框框，问我们是否确认付款。这样一个弹窗非常有必要，这样防止我们用户的误操作。</li><li>1）提示框：alert(提示信息);</li><li>2）确认框：confirm(提示信息);</li><li>3）输入框：prompt(提示信息);<h5 id="2-定时器"><a href="#2-定时器" class="headerlink" title="(2)定时器"></a>(2)定时器</h5></li><li>顾名思义，定时器就是可以给我们运行的函数设置什么时候运行，怎么去运行。<ul><li>1）执行多次的定时器: <code>setInterval(函数，毫秒值);</code><ul><li>这个定时器的作用是<strong>每隔一段时间</strong>就去执行指定的<strong>函数</strong>。</li></ul></li><li>2）执行一次的定时器: <code>setTimeout(函数，毫秒值);</code></li><li><ol start="3"><li>停止周期性的执行某个函数: <code>clearInterval(id_of_setInterval);</code></li></ol><ul><li>id_of_setInterval:就是setInterval函数的返回值<h5 id="3-常用的全局方法"><a href="#3-常用的全局方法" class="headerlink" title="(3)常用的全局方法"></a>(3)常用的全局方法</h5></li></ul></li></ul></li><li>1）parseInt/parseFloat函数</li><li>2）eval函数—特点：可以将字符串解析成js脚本  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> jsonStr = <span class="string">&quot;&#123;&#x27;name&#x27;:&#x27;lxy&#x27;,&#x27;age&#x27;:&#x27;23&#x27;,&#x27;size&#x27;:&#x27;36&#x27;&#125;&quot;</span>;</span><br><span class="line">   <span class="comment">//为什么要加上()呢？</span></span><br><span class="line"><span class="keyword">var</span> json = <span class="built_in">eval</span>(<span class="string">&quot;(&quot;</span>+jsonStr+<span class="string">&quot;)&quot;</span>);</span><br><span class="line">alert(json.age);</span><br></pre></td></tr></table></figure><h4 id="Location对象"><a href="#Location对象" class="headerlink" title="Location对象"></a>Location对象</h4></li><li>重点记忆location.href可以在js中进行url访问<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> location.href去访问某个网址</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">location.href = <span class="string">&quot;http://www.baidu.com&quot;</span>;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="js的DOM-Document-Object-Model-文档对象模型"><a href="#js的DOM-Document-Object-Model-文档对象模型" class="headerlink" title="js的DOM(Document Object Model,文档对象模型)"></a>js的DOM(Document Object Model,文档对象模型)</h3><p>html文档加载到浏览器的内存中后，我们认为形成了一颗<strong>DOM树</strong>，即html标签按照层级结构而形成了一颗“家谱树”，而任何一个html标签、标签属性和文本都是这个树上的节点元素。</p><h4 id="js的DOM的操作方法"><a href="#js的DOM的操作方法" class="headerlink" title="js的DOM的操作方法"></a>js的DOM的操作方法</h4><h5 id="1-标签元素的操作"><a href="#1-标签元素的操作" class="headerlink" title="(1)标签元素的操作"></a>(1)标签元素的操作</h5><ul><li>1）获得元素对象：<ul><li><code>Document.getElementById();</code>通过标签的属性值获取标签对象，返回的是单个的标签对象.</li><li><code>Document.getElementsByName();</code>通过标签的name属性值获取标签对象，返回的是标签对象的数组。</li><li><code>Document.getElementsByTagName();</code>通过标签的名称获取标签的对象,返回的是标签对象的数组</li><li><code>Document.getElementsByClassName();</code>通过标签的class属性获取标签对象，返回的是标签对象的数组。</li></ul></li><li>2）创建一个新元素<ul><li><code>Document.createElement(tagName);</code>创建标签对象</li></ul></li><li>3）标签体的获取与设置：<ul><li><code>Element.innerHTML</code>:获取开始标签到结束标签之间的内容。包括标签</li><li><code>Element.innerText</code>:获取开始标签到结束标签之间的文本，不包括标签</li></ul></li><li>4）子节点的操作<ul><li><code>Element.hasChildNodes();</code>判断当前标签对象下是否含有子节点。返回值是boolean值</li><li><code>Element.remove();</code>删除当前标签对象</li><li><code>parentElement.removeChild(childElement);</code>通过父标签对象删除子标签对象</li><li><code>parentElement.replaceChild(newChild,oldChild);</code>替换父节点下的子节点。</li><li><code>parentElement.appendChild(ChildElement);</code>向父标签下追加子标签对象</li><li><code>ParentElement.insertBefore(newElement,refElement);</code>向父标签下指定的子节点前添加标签对象<h5 id="2-属性的操作"><a href="#2-属性的操作" class="headerlink" title="(2)属性的操作"></a>(2)属性的操作</h5></li></ul></li><li>获得属性的值：<code>element.getAtrribute(name);</code></li><li>设置属性的值：<code>element.setAtrribute(name,value);</code></li><li>删除某个属性：<code>element.removeAtrribute(name);</code></li></ul><h3 id="js的对象"><a href="#js的对象" class="headerlink" title="js的对象"></a>js的对象</h3><p>与java一样，js也内置一些现成的对象供我们使用，js中内置对象有如下几个：</p><ul><li>1．Array对象<ul><li>Array对象是数组对象，跟java中的数组一个意思，但是使用语法上稍微有些区别。</li><li>(1)创建数组对象的方式：<ul><li>创建一个空数组：<code>var arr = new Array();</code></li><li>创建一个指定大的数组：<code>var arr = new Array(size);</code></li><li>创建数组并填充元素：<code>var arr = new Array(element0, element1, ..., elementn);</code></li><li>直接创建元素数组：<code>var arr = [element0, element1, ..., elementn];</code></li></ul></li><li>(2)数组中元素的获取：跟java一样通过索引(从0开始)的方式获得数组中的元素：<ul><li>获得数组中的一个元素：<code>arr[0]</code></li><li>遍历获得数组中的所有元素：  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">    alert(arr[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li>(3)多维数组操作:js中的数组跟java中的集合相似，也就是数组中的元素还是以是数组  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arr = [</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],</span><br><span class="line">[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>],</span><br><span class="line">[<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>获取数组中的8数字可以：<code>arr[2][1]</code></li></ul></li></ul></li><li>2．日期对象<ul><li>(1)创建方式<ul><li>创建当前日期时间：<code>var date = new Date();</code></li><li>创建指定日期时间：<code>var date = new Date(毫秒值);</code></li><li>其中毫秒值为1970-01-01至今的时间毫秒值</li></ul></li><li>(2)时间的获取<ul><li>获得年：<code>getFullYear()</code>:从Date对象以四位数字返回年份。 </li><li>获得月：<code>getMonth()</code>:从Date对象返回月份 (0 ~ 11)。</li><li>获得星期：<code>getDay()</code>:从Date对象返回一周中的某一天 (0 ~ 6)。 </li><li>获得日：<code>getDate()</code>:从Date对象返回一个月中的某一天 (1 ~ 31)。 </li><li>获得毫秒值：<code>getTime()</code>:返回1970-01-01至今的毫秒数。</li></ul></li></ul></li><li>3．Math对象<ul><li>Math对象是数学对象，是一个<strong>工具对象</strong>，因此Math对象不用使用new的方式创建，直接使用Math就可以调用对象内部的方法。</li><li><code>Math.abs(x)</code>:返回数的绝对值。  </li><li><code>Math.ceil(x)</code>:对数进行上舍入。 </li><li><code>Math.floor(x)</code>:对数进行下舍入。 </li><li><code>Math.random()</code>:返回0~1之间的随机数。 </li><li><code>Math.round(x)</code>:把数四舍五入为最接近的整数。 </li></ul></li><li>4．RegExp对象  <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    js中的正则表达式要加上^  $;</span></span><br><span class="line"><span class="comment">    regExp.test(str);验证字符串的格式</span></span><br><span class="line"><span class="comment">    如果验证成功，那么返回true，失败返回false。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">var</span> regExp = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">&quot;^\\w&#123;6&#125;$&quot;</span>);</span><br><span class="line">    <span class="keyword">var</span> username = <span class="string">&quot;admin&quot;</span>;</span><br><span class="line">    <span class="keyword">var</span> res = regExp.test(username);</span><br><span class="line">    alert(res);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> JS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.CSS</title>
      <link href="/2021/01/07/%E5%89%8D%E7%AB%AF/2.Css/"/>
      <url>/2021/01/07/%E5%89%8D%E7%AB%AF/2.Css/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h2><ul><li>Cascading Style Sheet,CSS就是层叠样式表，用来控制页面内容的样式</li></ul><h3 id="CSS和HTML结合方式"><a href="#CSS和HTML结合方式" class="headerlink" title="CSS和HTML结合方式"></a>CSS和HTML结合方式</h3><h4 id="1-使用HTML标签的style属性"><a href="#1-使用HTML标签的style属性" class="headerlink" title="1.使用HTML标签的style属性"></a>1.使用HTML标签的style属性</h4><p>使用格式：</p><ul><li><code>&lt;标签名 style=&quot;样式名:样式值;样式名:样式值 样式值 样式值;&quot;&gt;&lt;/标签名&gt;</code></li><li>多个样式之间以分号隔开；一个样式可以有多个值，多个值以空格隔开</li><li>如：<code>&lt;div style=&quot;color:yellow;font-size:100px;border:1px solid red;&quot;&gt;我是div&lt;/div&gt;</code><h4 id="2-在head标签使用style标签设置-内嵌样式"><a href="#2-在head标签使用style标签设置-内嵌样式" class="headerlink" title="2.在head标签使用style标签设置(内嵌样式)"></a>2.在head标签使用style标签设置(内嵌样式)</h4>使用格式：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        标签名&#123;</span></span><br><span class="line"><span class="css">            key1:value;</span></span><br><span class="line"><span class="css">            key2:value;</span></span><br><span class="line"><span class="css">        &#125;</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-在head标签中的style标签使用-import-外部文件方式"><a href="#3-在head标签中的style标签使用-import-外部文件方式" class="headerlink" title="3.在head标签中的style标签使用@import(外部文件方式)"></a>3.在head标签中的style标签使用@import(外部文件方式)</h4>使用格式：<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css">        <span class="keyword">@IMPORT</span> url(<span class="string">&quot;css文件的地址&quot;</span>);</span></span><br><span class="line"><span class="css">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="4-在head标签中使用link标签-外部文件方式-开发中经常使用"><a href="#4-在head标签中使用link标签-外部文件方式-开发中经常使用" class="headerlink" title="4.在head标签中使用link标签(外部文件方式)(开发中经常使用)"></a>4.在head标签中使用link标签(外部文件方式)(开发中经常使用)</h4>使用格式:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;css文件路径&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h3><p>让我们的css样式选择作用在哪一些具体的标签之上</p><h4 id="标签名选择器-作用在当前页面的所有该名称标签之上"><a href="#标签名选择器-作用在当前页面的所有该名称标签之上" class="headerlink" title="标签名选择器:作用在当前页面的所有该名称标签之上"></a>标签名选择器:作用在当前页面的所有该名称标签之上</h4><p>格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">标签名称&#123;</span><br><span class="line">    css代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ID选择器-作用在页面上的某个具体的标签之上"><a href="#ID选择器-作用在页面上的某个具体的标签之上" class="headerlink" title="ID选择器:作用在页面上的某个具体的标签之上"></a>ID选择器:作用在页面上的某个具体的标签之上</h4><p>格式:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#id属性值&#123;</span><br><span class="line">    css代码;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;标签名 id=&quot;值&quot;/&gt;</span><br></pre></td></tr></table></figure><p>注意：页面的id值不允许重复。</p><h4 id="class选择器-作用在一组标签之上"><a href="#class选择器-作用在一组标签之上" class="headerlink" title="class选择器:作用在一组标签之上"></a>class选择器:作用在一组标签之上</h4><p>格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.Class属性值&#123;</span><br><span class="line">    css代码;</span><br><span class="line">&#125;</span><br><span class="line">&lt;标签 class=&quot;xxxx&quot;&gt;</span><br></pre></td></tr></table></figure><h4 id="组合选择器-不同的标签使用相同的css样式"><a href="#组合选择器-不同的标签使用相同的css样式" class="headerlink" title="组合选择器:不同的标签使用相同的css样式"></a>组合选择器:不同的标签使用相同的css样式</h4><p>格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">选择器1, 选择器2...&#123;</span><br><span class="line">    css代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="关联选择器-强调的是通过父亲查找孩子"><a href="#关联选择器-强调的是通过父亲查找孩子" class="headerlink" title="关联选择器:强调的是通过父亲查找孩子"></a>关联选择器:强调的是通过父亲查找孩子</h4><p>格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--修改该父选择器的子选择器内容--&gt;</span></span><br><span class="line">父选择器 子选择器&#123;</span><br><span class="line">css代码;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="锚伪类选择器-锚伪类选择器开发中一般就作用在a标签之上。对a标签的未访问状态和已经访问状态设置不一样的css样式。"><a href="#锚伪类选择器-锚伪类选择器开发中一般就作用在a标签之上。对a标签的未访问状态和已经访问状态设置不一样的css样式。" class="headerlink" title="锚伪类选择器:锚伪类选择器开发中一般就作用在a标签之上。对a标签的未访问状态和已经访问状态设置不一样的css样式。"></a>锚伪类选择器:锚伪类选择器开发中一般就作用在a标签之上。对a标签的未访问状态和已经访问状态设置不一样的css样式。</h4><p>格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选中的标签:伪元素名称&#123;</span><br><span class="line">    css代码;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!--例如--&gt;</span></span><br><span class="line">a : link&#123;</span><br><span class="line">    color:red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>：伪元素名称<ul><li>：link 某个html标签未被点击之前的状态</li><li>：visible 鼠标点击之后,松开了</li><li>：hover 鼠标悬浮式</li><li>：active 鼠标点击 但没有松开</li></ul></li><li>注意：上述4个伪元素是有先后顺序的。<ul><li>L V H A</li></ul></li></ul><h4 id="属性选择器-在原有选择器的基础上-通过标签的属性-再次对标签进行筛选。"><a href="#属性选择器-在原有选择器的基础上-通过标签的属性-再次对标签进行筛选。" class="headerlink" title="属性选择器:在原有选择器的基础上,通过标签的属性,再次对标签进行筛选。"></a>属性选择器:在原有选择器的基础上,通过标签的属性,再次对标签进行筛选。</h4><p>格式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">选择器名[属性名=&#x27;属性值&#x27;] &#123;</span><br><span class="line">    css样式;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">&lt;!--例如--&gt;</span></span><br><span class="line">input[id=&#x27;aaa&#x27;] &#123;</span><br><span class="line">    border: 1px solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CSS常用属性"><a href="#CSS常用属性" class="headerlink" title="CSS常用属性"></a>CSS常用属性</h3><h4 id="1、文字和文本属性"><a href="#1、文字和文本属性" class="headerlink" title="1、文字和文本属性"></a>1、文字和文本属性</h4><ul><li>color:颜色</li><li>font-size：大小</li><li>font-family：字体类型</li><li>text-decoration：线型  none underline line-through</li><li>text-align:内容对齐方式<h4 id="2、边框"><a href="#2、边框" class="headerlink" title="2、边框"></a>2、边框</h4></li><li>border：border-width border-color border-style</li><li>border-width:边框宽度</li><li>border-color:边框颜色</li><li>border-style:边框的样式        <h4 id="3、背景属性"><a href="#3、背景属性" class="headerlink" title="3、背景属性"></a>3、背景属性</h4></li><li>background-color:背景颜色</li><li>background-image：背景图片<ul><li>注意：在css中 图片的写法 url(图片地址)</li></ul></li><li>background-repeat：平铺方式<ul><li>repeat repeat-x repeat-y no-repeat</li><li>注意：开发中一般会使用background进行简写background:background-color background-image background-repeat<h4 id="4、列表属性"><a href="#4、列表属性" class="headerlink" title="4、列表属性"></a>4、列表属性</h4></li></ul></li><li>list-style-type:小标志</li><li>list-style-image:小图片</li><li>属性值：url(图片地址)<h4 id="4、尺寸属性"><a href="#4、尺寸属性" class="headerlink" title="4、尺寸属性"></a>4、尺寸属性</h4></li><li>width：宽度</li><li>height：高度<h4 id="5、显示属性"><a href="#5、显示属性" class="headerlink" title="5、显示属性"></a>5、显示属性</h4></li><li>display:是否显示某个元素  值：none/block<h4 id="6、浮动属性"><a href="#6、浮动属性" class="headerlink" title="6、浮动属性"></a>6、浮动属性</h4></li><li>float:left/right</li><li>clear:both</li></ul><h3 id="边框-盒子模型-布局"><a href="#边框-盒子模型-布局" class="headerlink" title="边框(盒子模型)布局"></a>边框(盒子模型)布局</h3><ul><li><code>&lt;div&gt;&lt;/div&gt;</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> CSS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Html</title>
      <link href="/2021/01/06/%E5%89%8D%E7%AB%AF/1.Html/"/>
      <url>/2021/01/06/%E5%89%8D%E7%AB%AF/1.Html/</url>
      
        <content type="html"><![CDATA[<h2 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h2><ul><li>HTML是Hyper Text Markup Language的英文缩写,即<strong>超文本标记语言</strong></li><li>HTML是<strong>大小写不敏感</strong>的</li></ul><h3 id="HTML实例"><a href="#HTML实例" class="headerlink" title="HTML实例"></a>HTML实例</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">title</span>&gt;</span>lxy(http://www.codingcode.cn/)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>实例解析</p><ul><li><code>&lt;!DOCTYPE html&gt;</code>声明为 HTML5 文档</li><li><code>&lt;html&gt;</code>元素是 HTML 页面的根元素</li><li><code>&lt;head&gt;</code>元素包含了文档的元（meta）数据，如 <meta charset="utf-8"> 定义网页编码格式为 utf-8。</li><li><code>&lt;title&gt;</code>元素描述了文档的标题</li><li><code>&lt;body&gt;</code>元素包含了可见的页面内容</li><li><code>&lt;h1&gt;</code>元素定义一个大标题</li><li><code>&lt;p&gt;</code>元素定义一个段落</li><li>只有<code>&lt;body&gt;</code>区域才会在浏览器中显示。</li></ul><h3 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a><a href="https://www.runoob.com/tags/tag-comment.html">常用标签</a></h3><ul><li>注释标签:<code>&lt;!-- 被注释的内容 --&gt;</code></li><li>标题标签:<code>&lt;h1&gt;&lt;/h1&gt;</code>to<code>&lt;h6&gt;&lt;/h6&gt;</code>,<code>&lt;h1&gt;</code>最大,<code>&lt;h6&gt;</code>最小</li><li>水平线标签:<code>&lt;hr/&gt;</code>,在浏览器上显示一条水平线</li><li>字体标签:<code>&lt;font&gt;&lt;/font&gt;</code>,用来修饰文本的颜色、字体、大小<ul><li><code>&lt;font color=’red’ size=’16px’ face=’楷体’&gt;&lt;/font&gt;</code><ul><li>通过标签的<code>color</code>属性修饰文本的<strong>颜色</strong>，<code>size</code>属性修饰文本的<strong>大小</strong>，<code>face</code>修饰文本的<strong>字体</strong></li></ul></li></ul></li><li>段落标签:<code>&lt;p&gt;&lt;/p&gt;</code>,修饰一段文本，被修饰的文本有段落与段落之间的<strong>间隔</strong></li><li>文档主体标签:<code>&lt;body&gt;&lt;/body&gt;</code></li><li>定义了HTML文档:<code>&lt;html&gt;&lt;/html&gt;</code></li><li>换行标签:<code>&lt;br&gt;</code>or<code>&lt;br/&gt;</code></li><li>斜体标签:<code>&lt;i&gt;&lt;/i&gt;</code></li><li>加粗标签:<code>&lt;b&gt;&lt;/b&gt;</code></li><li>下划线标签:<code>&lt;u&gt;&lt;/u&gt;</code></li><li>下标标签:<code>&lt;sub&gt;&lt;/sub&gt;</code></li><li>上标标签:<code>&lt;sup&gt;&lt;/sup&gt;</code></li><li>链接标签:<code>&lt;a href=&quot;www.baidu.com&quot;&gt;百度&lt;/a&gt;</code></li><li>图像标签:<code>&lt;img src=&quot;/images/logo.png&quot; width=&quot;258&quot; height=&quot;39&quot; /&gt;</code></li><li>特殊字符:在html中有些字符含有特殊的含义，比如&lt;、&gt;这些标签，他们并不能直接在页面显示。所以我们需要使用特殊字符,类似java中的转义字符。<ul><li><code>&amp;nbsp;</code>:空格</li><li><code>&amp;lt;</code>:小于号(&lt;)</li><li><code>&amp;gt;</code>:大于号(&gt;)</li><li><code>&amp;amp;</code>:和号(&amp;)</li><li><code>&amp;quot;</code>:引号(“)</li><li><code>&amp;apos;</code>:单引号(‘)</li></ul></li><li>列表标签:<ul><li><code>&lt;ul&gt;&lt;/ul&gt;</code>无序号的列表</li><li><code>&lt;ol&gt;&lt;/ol&gt;</code>有序号的列表</li><li><code>&lt;li&gt;&lt;/li&gt;</code>表示列表的一个列表项</li><li>使用格式：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>列表项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>表格标签:<ul><li><code>&lt;table&gt;&lt;/table&gt;</code>定义表格</li><li><code>&lt;tr&gt;&lt;/tr&gt;</code>定义行</li><li><code>&lt;td&gt;&lt;/td&gt;</code>定义列</li><li>使用格式：  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul></li><li>框架标签:<ul><li><code>&lt;frameset&gt;&lt;/frameset&gt;</code>标签定义框架的范围</li><li><code>&lt;frame src=&quot;top.html&quot;/&gt;</code>代表一个框架</li></ul></li><li>表单标签:<ul><li><code>&lt;form&gt;&lt;/form&gt;</code>创建供用户输入的 HTML 表单</li><li>按钮标签:<code>&lt;input type=&quot;...&quot;/&gt;</code></li><li>下拉列表标签:<ul><li><code>&lt;select&gt;&lt;/select&gt;</code>创建下拉列表</li><li><code>&lt;option value=&quot;选项的值&quot;&gt;显示在页面中的值&lt;/option&gt;</code>定义了列表中的可用选项</li></ul></li><li>文本区域:<code>&lt;textarea&gt;&lt;/textarea&gt;</code></li></ul></li><li>其他标签:<ul><li><code>&lt;div&gt;&lt;/div&gt;</code>、<code>&lt;span&gt;&lt;/span&gt;</code>它们仅仅是用来封装数据，而对数据不做任何的样式效果的设置</li><li><code>div+css</code>用来对页面进行<strong>布局和划分</strong></li><li><code>span+css</code>用来对数据进行<strong>样式的修饰</strong></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
          <category> Html </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VO、DTO、DO、PO的概念</title>
      <link href="/2020/12/01/VO%E3%80%81DTO%E3%80%81BO%E3%80%81DO/"/>
      <url>/2020/12/01/VO%E3%80%81DTO%E3%80%81BO%E3%80%81DO/</url>
      
        <content type="html"><![CDATA[<h1 id="VO、DTO、DO、PO的概念"><a href="#VO、DTO、DO、PO的概念" class="headerlink" title="VO、DTO、DO、PO的概念"></a>VO、DTO、DO、PO的概念</h1><p><img src="https://i.loli.net/2021/04/19/s9yhjqgIkOwLutc.png" alt="image.png"></p><p><a href="https://juejin.im/post/5e1ae3b96fb9a02fbf37a4fb">一篇文章讲清楚VO，BO，PO，DO，DTO的区别</a></p><h3 id="分层领域模型规约："><a href="#分层领域模型规约：" class="headerlink" title="分层领域模型规约："></a>分层领域模型规约：</h3><ul><li>VO(View Object)：显示层对象，通常是Web向模板渲染引擎层传输的对象。</li><li>DTO(Data Transfer Object)：数据传输对象，Service或Manager向外传输的对象。</li><li>BO(Business Object)：业务对象。 由Service层输出的封装业务逻辑的对象。</li><li>DO(Data Object)：与数据库表结构一一对应，通过DAO层向上传输数据源对象。</li><li>PO(Persistent Object)：持久化对象，它跟持久层(通常是关系型数据库)的数据结构形成一一对应的映射关系，如果持久层是关系型数据库，那么，数据表中的每个字段(或若干个)就对应PO的一个(或若干个)属性。等同于<em>Entity</em>，这俩概念是一致的</li><li>POJO(Plain Ordinary Java Object)：在本手册中， POJO专指只有setter/getter/toString的简单类，包括DO/DTO/BO/VO等。</li></ul><h3 id="领域模型命名规约："><a href="#领域模型命名规约：" class="headerlink" title="领域模型命名规约："></a>领域模型命名规约：</h3><ul><li>数据对象：xxxDO，xxx即为数据表名。</li><li>数据传输对象：xxxDTO，xxx为业务领域相关的名称。</li><li>展示对象：xxxVO，xxx一般为网页名称。</li><li>POJO是DO/DTO/BO/VO的统称，禁止命名成xxxPOJO。</li></ul><h2 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h2><p>DAO(Data Access Object)数据访问对象<br>DTO(Data Transfer Object)数据传输对象<br>DO(Domain Object)领域对象<br>VO(View Object)视图模型<br>AO(Application Object)应用对象<br>BO(Business Object)业务对象<br>POJO(Plain Ordinary Java Object)纯普通Java对象<br>PO(Persistent Object)持久化对象<br>Entity(应用程序域中的一个概念)实体<br>Model(概念实体模型)实体类和模型<br>View(概念视图模型)视图模型</p><h2 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h2><h3 id="DAO-Data-Access-Object-数据访问对象"><a href="#DAO-Data-Access-Object-数据访问对象" class="headerlink" title="DAO(Data Access Object)数据访问对象"></a>DAO(Data Access Object)数据访问对象</h3><p>是一个<strong>数据访问</strong>接口，数据访问：顾名思义就是与数据库打交道。夹在业务逻辑与数据库资源中间。</p><p>一般在<code>业务逻辑层(Service)</code>对<code>数据库(SQL)</code>的访问时使用，一般能对SQL进行操作。</p><p>xxxDAO，xxx即为实体类名（Entity实体）。</p><h3 id="DTO-Data-Transfer-Object-数据传输对象"><a href="#DTO-Data-Transfer-Object-数据传输对象" class="headerlink" title="DTO(Data Transfer Object)数据传输对象"></a>DTO(Data Transfer Object)数据传输对象</h3><p>是一种设计模式之间传输数据的软件应用系统。数据传输目标往往是数据访问对象从数据库中检索数据。数据传输对象与数据交互对象或数据访问对象之间的差异是一个以不具有任何行为除了存储和检索的数据（访问和存取器）。</p><p>一般在<code>前端(Web)</code>对<code>控制层（Controller）</code>进行数据传输时使用，说白了就是<strong>前端向后台提交数据</strong>。</p><p>xxxDTO，xxx为业务领域相关的名称。</p><h3 id="DO-（Domain-Object）领域对象"><a href="#DO-（Domain-Object）领域对象" class="headerlink" title="DO （Domain Object）领域对象"></a>DO （Domain Object）领域对象</h3><p>是从现实世界中抽象出来的有形或无形的业务实体。在与数据有关的操作中数据存在数据库使用 DAO访问被取出来时，一般会将这些数据规范化的定义成类，而这个类就是DO，<strong>用来接收数据库对应的实体</strong>，它是一种抽象化的数据状态，介于数据库与业务逻辑之间。</p><p>一般在<code>业务逻辑层（Service）</code>对<code>数据库（SQL）</code>的<strong>访问时接收数据</strong>使用。</p><p>xxxDO，xxx即为数据表名</p><p>另外：DO与Entity概念上浅显的相同，他们在实际应用中是一个东西。稍微的不同点就是DO是与数据库存在着某种映射关系的Entity，总的来说<strong>DO是Entity的一种</strong>。</p><h3 id="VO（View-Object）视图模型"><a href="#VO（View-Object）视图模型" class="headerlink" title="VO（View Object）视图模型"></a>VO（View Object）视图模型</h3><p>VO是显示视图模型，视图对象，用于展示层，它的作用是<strong>把某个指定页面（或组件）的所有数据封装起来</strong>。如果是一个DTO对应一个VO，则DTO=VO;但是如果一个DTO对应多个VO，则展示层需要把VO转换为服务层对应方法所要求的DTO，传送给服务层。从而达到服务层与展示层解耦的效果。</p><p>一般用在<code>业务逻辑层（Service）</code>对<code>前端（Web）</code>的视图模型效果控制的展示上，说白了就是<strong>后台向前端传输数据</strong>。</p><p>xxxVO，xxx一般为网页名称。</p><h3 id="AO（Application-Object）应用对象"><a href="#AO（Application-Object）应用对象" class="headerlink" title="AO（Application Object）应用对象"></a>AO（Application Object）应用对象</h3><p>AO是一个较为笼统的概念，因为太过于常见而并没有刻意的去描绘它的细节。</p><p>举一个很简单的例子：控制层（Controller） 在 业务逻辑层（Service） 查询一条或多条数据，这个数据的传输过程的运载就是AO完成。在正常的业务逻辑中一般都有很多种类型的数据，例如 整形、字符型、集合、类 等，我们把它统称为AO。</p><p>一般用在<code>控制层（Controller）</code>与<code>业务逻辑层（Service）</code>层之间抽象的复用对象模型，有时候极为贴近展示层，复用度不高。</p><h3 id="BO（-Business-Object）业务对象"><a href="#BO（-Business-Object）业务对象" class="headerlink" title="BO（ Business Object）业务对象"></a>BO（ Business Object）业务对象</h3><p>是对数据进行检索和处理的组件。主要作用是把业务逻辑封装为一个对象。这个对象可以包括一个或多个其它的对象。形象描述为一个对象的形为和动作，当然也有涉及到基它对象的一些形为和动作。</p><p>一般用在包含业务功能模块的具体实例上，比如我们写了一个Controller、一个Service、一个DAO、一个工具类等等这一系列实例组合后能实现一些功能，这些一系列实例组合为一个组件，这个组件就是BO。</p><p>其它资料：是简单的真实世界的软件抽象。业务对象通常位于中间层或者业务逻辑层。BO支持序列化和反序列化，可以轻易地将BO的Java实例转换为一个XML文件或者一个流保存起来，并且在需要的时候，将这个BO从XML或者流中转换回一个Java实例。</p><h3 id="POJO（-Plain-Ordinary-Java-Object）纯普通Java对象"><a href="#POJO（-Plain-Ordinary-Java-Object）纯普通Java对象" class="headerlink" title="POJO（ Plain Ordinary Java Object）纯普通Java对象"></a>POJO（ Plain Ordinary Java Object）纯普通Java对象</h3><p>总的来说<strong>POJO包含DO、DTO、BO、VO</strong>，这些本质上都是一个简单的java对象，实际就是普通JavaBeans，是为了避免和EJB混淆所创造的简称</p><p>使用POJO名称是为了避免和EJB混淆起来, 而且简称比较直接。其中有一些属性及其getter setter方法的类,没有业务逻辑，有时可以作为VO(View Object)或DTO(Data Transform Object)来使用。当然，这里特意说明纯普通Java对象，如果你有一个简单的运算属性也是可以的,但不允许有业务方法,也不能携带有connection之类的方法。</p><h3 id="PO（Persistent-Object）持久化对象"><a href="#PO（Persistent-Object）持久化对象" class="headerlink" title="PO（Persistent Object）持久化对象"></a>PO（Persistent Object）持久化对象</h3><p>数据库表中的记录在java对象中的显示状态。最形象的理解就是一个PO就是数据库中的一条记录。</p><p>好处是可以把一条记录作为一个对象处理，可以方便的转为其它对象。</p><p>例如我们有一条数据，现在有一个简单类而且已经是被赋予了这条数据的实例，那么目前这条数据在这个简单类的存在状态就是PO，不管这个简单类是DO还是BO还是其他。PO只是数据持久化的一个状态。</p><h3 id="Entity（应用程序域中的一个概念）实体"><a href="#Entity（应用程序域中的一个概念）实体" class="headerlink" title="Entity（应用程序域中的一个概念）实体"></a>Entity（应用程序域中的一个概念）实体</h3><p>说白了Eitity是一个未被持久化的对象，它是一个类，从现实抽象到代码的一个类。</p><h3 id="Model-（概念实体模型）实体类和模型"><a href="#Model-（概念实体模型）实体类和模型" class="headerlink" title="Model （概念实体模型）实体类和模型"></a>Model （概念实体模型）实体类和模型</h3><p>Model是计算机程序设计中有两个概念：一个是三层架构中的<strong>实体类</strong>，另一个是MVC架构中的<strong>模型</strong>。</p><p>在”三层架构”中，为了面向对象编程，将各层传递的数据封装成实体类，便于数据传递和提高可读性。</p><p>在MVC（模型Model-视图View-控制器Controller）模式中，Model代表模型，是业务流程/状态的处理以及业务规则的制定，接受视图请求的数据，并返回最终的处理结果。业务模型的设计可以说是MVC最主要的核心。</p><h3 id="View-（概念视图模型）视图模型"><a href="#View-（概念视图模型）视图模型" class="headerlink" title="View （概念视图模型）视图模型"></a>View （概念视图模型）视图模型</h3><p>在MVC（模型Model-视图View-控制器Controller）模式中，View代表视图，用来解析Model带来的数据模型，以展示视图数据，View的模型觉决定了需要什么样的Model来对接，相互联系。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpEL表达式</title>
      <link href="/2020/11/02/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/11/02/SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="SpEL表达式"><a href="#SpEL表达式" class="headerlink" title="SpEL表达式"></a>SpEL表达式</h1><h2 id="SpEL概述"><a href="#SpEL概述" class="headerlink" title="SpEL概述"></a>SpEL概述</h2><p>Spring表达式语言全称为<code>&quot;Spring Expression Language&quot;</code>，缩写为<code>&quot;SpEL&quot;</code>，类似于Struts2x中使用的OGNL表达式语言，能在运行时构建复杂表达式、存取对象图属性、对象方法调用等等，并且能与Spring功能完美整合，如能用来配置Bean定义。</p><p>表达式语言给静态Java语言增加了动态功能。</p><p>SpEL是单独模块，只依赖于core模块，不依赖于其他模块，可以单独使用。</p><h2 id="SpEL能干什么"><a href="#SpEL能干什么" class="headerlink" title="SpEL能干什么?"></a>SpEL能干什么?</h2><p>表达式语言一般是用最简单的形式完成最主要的工作，减少我们的工作量。</p><h2 id="SpEL支持如下表达式："><a href="#SpEL支持如下表达式：" class="headerlink" title="SpEL支持如下表达式："></a>SpEL支持如下表达式：</h2><h3 id="一、基本表达式"><a href="#一、基本表达式" class="headerlink" title="一、基本表达式"></a>一、基本表达式</h3><p>字面量表达式、关系，逻辑与算数运算表达式、字符串连接及截取表达式、三目运算及Elivis表达式、正则表达式、括号优先级表达式</p><h3 id="二、类相关表达式"><a href="#二、类相关表达式" class="headerlink" title="二、类相关表达式"></a>二、类相关表达式</h3><p>类类型表达式、类实例化、instanceof表达式、变量定义及引用、赋值表达式、自定义函数、对象属性存取及安全导航表达式、对象方法调用、Bean引用</p><h3 id="三、集合相关表达式"><a href="#三、集合相关表达式" class="headerlink" title="三、集合相关表达式"></a>三、集合相关表达式</h3><ul><li>内联List、内联数组、集合，字典访问、列表，字典，数组修改、集合投影、集合选择</li><li>不支持多维内联数组初始化</li><li>不支持内联字典定义</li></ul><h3 id="四、其他表达式"><a href="#四、其他表达式" class="headerlink" title="四、其他表达式"></a>四、其他表达式</h3><p>模板表达式。</p><p><strong>注：SpEL表达式中的关键字是不区分大小写的。</strong></p><h2 id="SpEL语法"><a href="#SpEL语法" class="headerlink" title="SpEL语法"></a>SpEL语法</h2><h3 id="一、基本表达式-1"><a href="#一、基本表达式-1" class="headerlink" title="一、基本表达式"></a>一、基本表达式</h3><h4 id="1-字面量表达式"><a href="#1-字面量表达式" class="headerlink" title="1.字面量表达式"></a>1.字面量表达式</h4><p>SpEL支持：<code>字符串</code>、<code>数字类型（int、long、float、double)</code>、<code>布尔类型</code>、<code>null类型</code>。</p><h4 id="2-算数运算表达式"><a href="#2-算数运算表达式" class="headerlink" title="2.算数运算表达式"></a>2.算数运算表达式</h4><p>SpEL支持：<code>加(+)</code>、<code>减(-)</code>、<code>乘(*)</code>、<code>除(/或div)</code>、<code>求余（%或mod)</code>、<code>幂（^)</code>运算。</p><h4 id="3-关系表达式"><a href="#3-关系表达式" class="headerlink" title="3.关系表达式"></a>3.关系表达式</h4><p>SpEL支持：<code>等于（==或eq)</code>、<code>不等于(!=或ne)</code>、<code>大于(&gt;或gt)</code>、<code>大于等于(&gt;=或ge)</code>、<code>小于(&lt;或lt)</code>、<code>小于等于(&lt;=或le)</code>，<code>区间（between)</code>运算。</p><h4 id="4-逻辑表达式"><a href="#4-逻辑表达式" class="headerlink" title="4.逻辑表达式"></a>4.逻辑表达式</h4><p>SpEL支持：<code>且（and或&amp;&amp;)</code>、<code>或(or或||)</code>、<code>非(!或NOT)</code>。</p><h4 id="5-字符串连接及截取表达式"><a href="#5-字符串连接及截取表达式" class="headerlink" title="5.字符串连接及截取表达式"></a>5.字符串连接及截取表达式</h4><p>使用<code>&quot;+&quot;</code>进行字符串连接，如<code>&quot;&#39;Hello &#39; + &#39;World!&#39;&quot;</code>-&gt;<code>&quot;Hello World!&quot;</code></p><p>使用<code>&quot;&#39;String&#39;[index]&quot;</code>来截取一个字符，目前只支持截取一个，如<code>&quot;&#39;Hello World!&#39;[0]&quot;</code>-&gt;<code>&quot;H&quot;</code>。</p><h4 id="6-三目运算"><a href="#6-三目运算" class="headerlink" title="6.三目运算"></a>6.三目运算</h4><p>三目运算符<code>“表达式1?表达式2:表达式3”</code>用于构造三目运算表达式，如<code>“2&gt;1?true:false”</code>-&gt;<code>true</code></p><h4 id="7-Elivis运算符"><a href="#7-Elivis运算符" class="headerlink" title="7.Elivis运算符"></a>7.Elivis运算符</h4><p>Elivis运算符<code>“表达式1?:表达式2”</code>从<code>Groovy语言</code>引入<strong>用于简化三目运算符</strong>的，当表达式1为非null时则返回表达式1，当表达式1为null时则返回表达式2，简化了三目运算符方式<code>“表达式1? 表达式1:表达式2”</code>，如<code>“null?:false”</code>-&gt;<code>false</code>，而<code>“true?:false”</code>-&gt;<code>true</code></p><p>如：<code>name != null? name : &quot;other&quot;</code>简写为：<code>name?:&quot;other&quot;</code></p><h4 id="8-正则表达式"><a href="#8-正则表达式" class="headerlink" title="8.正则表达式"></a>8.正则表达式</h4><p>使用<code>“str matches regex</code>，如<code>“&#39;123&#39; matches &#39;\d&#123;3&#125;&#39;”</code>-&gt;<code>true</code></p><h4 id="9-括号优先级表达式"><a href="#9-括号优先级表达式" class="headerlink" title="9.括号优先级表达式"></a>9.括号优先级表达式</h4><p>使用<code>“(表达式)”</code>构造，括号里的<strong>具有高优先级</strong>。</p><h3 id="二、类相关表达式-1"><a href="#二、类相关表达式-1" class="headerlink" title="二、类相关表达式"></a>二、类相关表达式</h3><h4 id="1-类类型表达式"><a href="#1-类类型表达式" class="headerlink" title="1.类类型表达式"></a>1.类类型表达式</h4><p>使用<code>“T(Type)”</code>来表示<code>java.lang.Class</code>实例，<code>Type</code>必须是<strong>类全限定名</strong>，<code>java.lang</code>包除外，即该包下的类可以不指定包名；使用类类型表达式还可以进行访问类静态方法及类静态字段。可以进行静态字段访问如<code>“T(Integer).MAX_VALUE”</code>；也可以进行静态方法访问如<code>“T(Integer).parseInt(&#39;1&#39;)”</code>。</p><h4 id="2-类实例化"><a href="#2-类实例化" class="headerlink" title="2.类实例化"></a>2.类实例化</h4><p>类实例化同样使用java关键字<code>“new”</code>，类名必须是<strong>全限定名</strong>，但<code>java.lang</code>包内的类型除外，如<code>String</code>、<code>Integer</code>。如<code>new String(&#39;lxy&#39;)</code>、<code>new java.util.Date()</code></p><h4 id="3-instanceof表达式"><a href="#3-instanceof表达式" class="headerlink" title="3.instanceof表达式"></a>3.instanceof表达式</h4><p>SpEL支持<code>instanceof运算符</code>，跟Java内使用同义；如<code>&#39;haha&#39; instanceof T(String)</code>-&gt;<code>true</code></p><h4 id="4-变量定义及引用"><a href="#4-变量定义及引用" class="headerlink" title="4.变量定义及引用"></a>4.变量定义及引用</h4><p>变量定义通过<code>EvaluationContext</code>接口的<code>setVariable(variableName, value)</code>方法定义；在表达式中使用<code>&quot;#variableName&quot;</code>引用；</p><p>除了引用自定义变量，SpE还允许引用根对象及当前上下文对象，使用<code>&quot;#root&quot;</code>引用<strong>根对象</strong>，使用<code>&quot;#this&quot;</code>引用<strong>当前上下文对象</strong></p><h4 id="5-自定义函数"><a href="#5-自定义函数" class="headerlink" title="5.自定义函数"></a>5.自定义函数</h4><p>目前只支持<strong>类静态方法</strong>注册为自定义函数</p><h4 id="6-表达式赋值"><a href="#6-表达式赋值" class="headerlink" title="6.表达式赋值"></a>6.表达式赋值</h4><p>使用<code>Expression#setValue</code>方法可以给表达式赋值</p><h4 id="7-对象属性存取及安全导航表达式"><a href="#7-对象属性存取及安全导航表达式" class="headerlink" title="7.对象属性存取及安全导航表达式"></a>7.对象属性存取及安全导航表达式</h4><p>对象属性获取非常简单，即使用如<code>“a.property.property”</code>这种点缀式获取，SpEL对于属性名<strong>首字母</strong>是<strong>不区分大小写</strong>的；</p><p>SpEL还引入了Groovy语言中的安全导航运算符<code>“(对象|属性)?.属性”</code>，用来避免<code>“?.”</code>前边的表达式为null时抛出空指针异常，而是返回null；修改对象属性值则可以通过赋值表达式或Expression接口的setValue方法修改。</p><h4 id="8-对象方法调用"><a href="#8-对象方法调用" class="headerlink" title="8.对象方法调用"></a>8.对象方法调用</h4><p>对象方法调用更简单，跟Java语法一样；如<code>&#39;haha&#39;.substring(2,4)</code>-&gt;<code>ha</code>；而对于根对象可以直接调用方法；</p><h4 id="9-Bean引用"><a href="#9-Bean引用" class="headerlink" title="9.Bean引用"></a>9.Bean引用</h4><p>SpEL支持使用<code>“@”</code>符号来引用Bean，在引用Bean时需要使用BeanResolver接口实现来查找Bean，Spring提供BeanFactoryResolver实现。</p><h3 id="三、集合相关表达式-1"><a href="#三、集合相关表达式-1" class="headerlink" title="三、集合相关表达式"></a>三、集合相关表达式</h3><h4 id="1-内联List"><a href="#1-内联List" class="headerlink" title="1.内联List"></a>1.内联List</h4><p>从Spring3.0.4开始支持<strong>内联List</strong>，使用<code>&#123;表达式,...&#125;</code>定义内联List，如<code>“&#123;1,2,3&#125;”</code>将返回一个<strong>整型的ArrayList</strong>，而<code>“&#123;&#125;”</code>将返回<strong>空的List</strong>，对于字面量表达式列表，SpEL会使用<code>java.util.Collections.unmodifiableList</code>方法将列表设置为<strong>不可修改</strong>。</p><h4 id="2-内联数组"><a href="#2-内联数组" class="headerlink" title="2.内联数组"></a>2.内联数组</h4><p>和Java 数组定义类似，只是在定义时进行<strong>多维数组</strong>初始化。</p><h4 id="3-集合，字典元素访问"><a href="#3-集合，字典元素访问" class="headerlink" title="3.集合，字典元素访问"></a>3.集合，字典元素访问</h4><p>SpEL目前支持所有<strong>集合类型</strong>和<strong>字典类型</strong>的元素访问，使用<code>&quot;集合[索引]&quot;</code>访问集合元素，使用<code>&quot;map[&#39;key&#39;]&quot;</code>访问字典元素</p><h4 id="4-列表，字典，数组元素修改"><a href="#4-列表，字典，数组元素修改" class="headerlink" title="4.列表，字典，数组元素修改"></a>4.列表，字典，数组元素修改</h4><p>可以使用赋值表达式或<code>Expression</code>接口的<code>setValue</code>方法修改</p><h4 id="5-集合投影"><a href="#5-集合投影" class="headerlink" title="5.集合投影"></a>5.集合投影</h4><p>在SQL中投影指从表中选择出列，而在SpEL指根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素；SpEL使用<code>&quot;(list|map).![投影表达式]&quot;</code>来进行投影运算：如<code>&quot;#list.![#this+1]&quot;</code>即每个元素+1、<code>&quot;#map.![value+1]&quot;</code>即map的每个value+1。</p><p>对于集合或数组使用如上表达式进行投影运算，其中投影表达式中<code>“#this”</code>代表每个集合或数组元素，可以使用比如<code>“#this.property”</code>来获取集合元素的属性，其中<code>“#this”</code>可以省略。</p><p>Map投影最终只能得到List结果，如上所示，对于投影表达式中的<code>&quot;#this&quot;</code>将是<code>Map.Entry</code>，所以可以使用<code>&quot;value&quot;</code>来获取值，使用<code>&quot;key&quot;</code>来获取键。</p><h4 id="6-集合选择"><a href="#6-集合选择" class="headerlink" title="6.集合选择"></a>6.集合选择</h4><p>在SQL中指使用select进行选择行数据，而在SpEL指根据原集合通过条件表达式选择出满足条件的元素并构造为新的集合，SpEL使用<code>&quot;(list|map).?[选择表达式]&quot;</code>，其中选择表达式结果必须是<strong>boolean类型</strong>，如果true则选择的元素将添加到新集合中，false将不添加到新集合中。如<code>#list.?[#this&gt;4]</code>，使用<code>“#this”</code>表示当前元素、<code>&quot;#map.?[key!=&#39;a&#39;]&quot;</code>、<code>&quot;#map.?[key!=&#39;a&#39;].![value+1]&quot;</code></p><p>对于字典选择，如<code>“#map.?[#this.key != &#39;a&#39;]”</code>将选择键值不等于<code>”a”</code>的，其中选择表达式中<code>“#this”</code>是<code>Map.Entry</code>类型，而最终结果还是<code>Map</code>，这点和投影不同；集合选择和投影可以一起使用，如<code>“#map.?[key != &#39;a&#39;].![value+1]”</code>将首先选择键值不等于<code>”a”</code>的，然后在选出的<code>Map</code>中再进行<code>“value+1”</code>的投影。</p><h4 id="7-表达式模板"><a href="#7-表达式模板" class="headerlink" title="7.表达式模板"></a>7.表达式模板</h4><p>模板表达式就是<strong>由字面量与一个或多个表达式块组成</strong>。每个表达式块由<code>“前缀+表达式+后缀”</code>形式组成，如<code>“$&#123;1+2&#125;”</code>即<strong>表达式块</strong>。如<code>“Error $&#123;#v0&#125; $&#123;#v1&#125;”</code>表达式表示由字面量<code>“Error ”</code>、模板表达式<code>“#v0”</code>、模板表达式<code>“#v1”</code>组成，其中v0和v1表示自定义变量，需要在上下文定义。</p><p>解析表达式的时候需要指定模板，模板通过<code>ParserContext</code>接口来定义</p><h2 id="在Bean定义中使用spel表达式"><a href="#在Bean定义中使用spel表达式" class="headerlink" title="在Bean定义中使用spel表达式"></a>在Bean定义中使用spel表达式</h2><h3 id="注解风格的配置-Value"><a href="#注解风格的配置-Value" class="headerlink" title="注解风格的配置(@Value)"></a>注解风格的配置(@Value)</h3><p>基于注解风格的SpEL配置也非常简单，使用<code>@Value</code>注解来指定SpEL表达式，该注解可以放到<strong>字段</strong>、<strong>方法</strong>及<strong>方法参数</strong>上。</p><p>测试Bean类如下，使用<code>@Value</code>来指定<code>SpEL表达式</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpELBean</span> </span>&#123;  </span><br><span class="line">    <span class="meta">@Value(&quot;#&#123;&#x27;Hello World&#x27;&#125;&quot;)</span>  </span><br><span class="line">    <span class="keyword">private</span> String value;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/27fd3754bb9c">更多SpEL介绍及案例</a></p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP Content-Type</title>
      <link href="/2020/10/20/Content-Type/"/>
      <url>/2020/10/20/Content-Type/</url>
      
        <content type="html"><![CDATA[<h2 id="Content-Type"><a href="#Content-Type" class="headerlink" title="Content-Type"></a><a href="https://blog.csdn.net/woaixiaoyu520/article/details/76690686">Content-Type</a></h2><h3 id="关于Content-Type"><a href="#关于Content-Type" class="headerlink" title="关于Content-Type"></a>关于Content-Type</h3><p>即<code>MediaType</code>，即是<code>Internet Media Type</code>，<strong>互联网媒体类型</strong>；也叫做<code>MIME类型</code>，在Http协议消息头中，使用Content-Type来表示具体请求中的媒体类型信息。</p><p>Content-Type是实体头域（或称为实体头部，entity header）用于向接收方指示实体（entity body）的介质类型的，或称为资源的MIME类型，现在通常称media type更为合适。（例如，指定HEAD方法送到接收方的实体介质类型，或GET方法发送的请求介质类型，表示后面的文档属于什么MIME类型。）</p><p>POST请求的消息主体放在entity body中，服务端根据请求头中的Content-Type字段来获取消息主体的编码方式，进而进行解析数据。</p><h3 id="Content-Type的格式："><a href="#Content-Type的格式：" class="headerlink" title="Content-Type的格式："></a>Content-Type的格式：</h3><p><code>Content-Type：type/subtype ;parameter</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">type     ：主类型，任意的字符串，如text，如果是*号代表所有；</span><br><span class="line">subtype  ：子类型，任意的字符串，如html，如果是*号代表所有，用“/”与主类型隔开；</span><br><span class="line">parameter：可选参数，如charset，boundary等。</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text/html;</span><br><span class="line">Content-Type: application/json;charset:utf-8;</span><br></pre></td></tr></table></figure><h3 id="常见的媒体格式类型如下："><a href="#常见的媒体格式类型如下：" class="headerlink" title="常见的媒体格式类型如下："></a>常见的媒体格式类型如下：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">text/html  ：HTML格式</span><br><span class="line">text/plain ：纯文本格式      </span><br><span class="line">text/xml   ：XML格式</span><br><span class="line">image/gif  ：gif图片格式    </span><br><span class="line">image/jpeg ：jpg图片格式 </span><br><span class="line">image/png  ：png图片格式</span><br></pre></td></tr></table></figure><p>以application开头的媒体格式类型：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">application/xhtml+xml  ：XHTML格式</span><br><span class="line">application/xml        ：XML数据格式</span><br><span class="line">application/atom+xml   ：Atom XML聚合格式    </span><br><span class="line">application/json       ：JSON数据格式</span><br><span class="line">application/pdf        ：pdf格式  </span><br><span class="line">application/msword     ：Word文档格式</span><br><span class="line">application/octet-stream ： 二进制流数据（如常见的文件下载）</span><br><span class="line">application/x-www-form-urlencoded ： &lt;form encType=&quot;&quot;&gt;中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）</span><br></pre></td></tr></table></figure><p>另外一种常见的媒体格式是上传文件之时使用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式</span><br></pre></td></tr></table></figure><p>以上就是我们在日常的开发中，经常会用到的若干content-type的内容格式。</p><h3 id="HTTP请求中，几种常见的Content-Type类型"><a href="#HTTP请求中，几种常见的Content-Type类型" class="headerlink" title="HTTP请求中，几种常见的Content-Type类型"></a>HTTP请求中，几种常见的Content-Type类型</h3><h4 id="一、application-x-www-form-urlencoded"><a href="#一、application-x-www-form-urlencoded" class="headerlink" title="一、application/x-www-form-urlencoded"></a>一、application/x-www-form-urlencoded</h4><p>最常见的<code>POST</code>提交数据的方式，原生<code>Form</code>表单，如果不设置 enctype 属性，<strong>默认</strong>为<code>application/x-www-form-urlencoded</code>方式提交数据。</p><p>HTTP会将请求参数用<code>key1=val1&amp;key2=val2</code>的方式进行组织，并放到请求实体里面，<strong>注意</strong>如果是中文或特殊字符如<code>&quot;/&quot;、&quot;,&quot;、&quot;:&quot;</code>等会自动进行<strong>URL转码</strong>。<strong>不支持文件</strong>，一般用于表单提交。</p><h4 id="二、multipart-form-data"><a href="#二、multipart-form-data" class="headerlink" title="二、multipart/form-data"></a>二、multipart/form-data</h4><p>与<code>application/x-www-form-urlencoded</code>不同，这是一个<strong>多部分多媒体类型</strong>。首先生成了一个<code>boundary</code>用于分割不同的字段，在请求实体里(<code>Content-disposition</code>)每个参数以<code>------boundary开始</code>，然后是<strong>附加信息和参数名</strong>，然后是<strong>空行</strong>，最后是<strong>参数内容</strong>。</p><p>多个参数将会有多个<code>boundary块</code>。如果参数是文件会有特别的文件域。最后以<code>------boundary–-</code>为结束标识。<code>multipart/form-data</code>支持<strong>文件上传的格式</strong>，一般<strong>需要上传文件的表单</strong>则用该类型。</p><p>boundary的<strong>作用</strong>：</p><p>当<code>content-type</code>为<code>multipart/form-data</code>类型时，需要用<code>boundary</code>指定<strong>分隔符</strong>。所以boundary后面跟的<strong>随机数</strong>，就是<strong>分隔符</strong>，后端就是通过解析到boundary的值作为分隔符来分隔参数的。</p><p>一般来说都不需要手动添加boundary值，浏览器、python的request库都会自动设定boundary的值</p><h4 id="三、application-json"><a href="#三、application-json" class="headerlink" title="三、application/json"></a>三、application/json</h4><p><code>Content-Type: application/json</code>作为响应头比较常见。实际上，现在越来越多的人把它作为请求头，用来告诉服务端消息主体是<strong>序列化后的JSON字符串</strong>，其中一个好处就是JSON 格式支持比键值对复杂得多的结构化数据。</p><p>JSON 是一种轻量级的数据格式，以<code>“键-值”对</code>的方式组织的数据。这个使用这个类型，需要参数本身就是json格式的数据，参数会被直接放到<strong>请求实体</strong>里，不进行任何处理。服务端/客户端会按json格式解析数据（约定好的情况下）。</p><p>Google 的 AngularJS 中的 Ajax 功能，默认就是提交 JSON 字符串。</p><h4 id="四、application-xml-和-text-xml"><a href="#四、application-xml-和-text-xml" class="headerlink" title="四、application/xml 和 text/xml"></a>四、application/xml 和 text/xml</h4><p>与<code>application/json</code>类似，这里用的是<strong>xml格式的数据</strong>，text/xml的话，将忽略xml数据里的编码格式</p><h4 id="五、binary-application-octet-stream"><a href="#五、binary-application-octet-stream" class="headerlink" title="五、binary (application/octet-stream)"></a>五、binary (application/octet-stream)</h4><p>在Chrome浏览器的Postman工具中，还可以看到<code>binary</code>这一类型，指的就是一些<strong>二进制文件类型</strong>。</p><p>如<code>application/pdf</code>，指定了特定二进制文件的MIME类型。就像对于text文件类型若没有特定的子类型（subtype），就使用 text/plain。类似的，二进制文件没有特定或已知的 subtype，即使用 application/octet-stream，这是应用程序文件的默认值，一般很少直接使用 。</p><p>对于application/octet-stream，<strong>只能提交二进制</strong>，而且只能提交<strong>一个</strong>二进制，如果提交文件的话，只能提交一个文件，后台接收参数只能有一个，而且只能是流（或者字节数组）。</p><p>很多web服务器使用默认的 application/octet-stream 来发送未知类型。出于一些安全原因，对于这些资源浏览器不允许设置一些自定义默认操作，导致用户必须存储到本地以使用。一般来说，设置正确的MIME类型很重要。</p><h3 id="request-的Content-Type-建议："><a href="#request-的Content-Type-建议：" class="headerlink" title="request 的Content-Type 建议："></a>request 的Content-Type 建议：</h3><ul><li>如果是一个<strong>restful接口</strong>（json格式），一般将<code>Content-Type</code>设置为<code>application/json; charset=UTF-8</code></li><li>如果是<strong>文件上传</strong>，一般<code>Content-Type</code>设置为<code>multipart/form-data</code></li><li>如果是<strong>普通表单</strong>提交，一般<code>Content-Type</code>设置为<code>application/x-www-form-urlencoded</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP Authorization 之 Basic Auth</title>
      <link href="/2020/10/13/Http/HTTP_Authorization_%E4%B9%8B_Basic_Auth/"/>
      <url>/2020/10/13/Http/HTTP_Authorization_%E4%B9%8B_Basic_Auth/</url>
      
        <content type="html"><![CDATA[<h1 id="Basic-Auth"><a href="#Basic-Auth" class="headerlink" title="Basic Auth"></a><a href="https://www.jianshu.com/p/4cd42f7359f4">Basic Auth</a></h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>在HTTP中，<strong>基本认证</strong>（<code>Basic access authentication</code>）是一种用来允许网页浏览器或其他客户端程序在请求时提供用户名和口令形式的身份凭证的一种<strong>登录验证方式</strong>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>基本认证的一个优点是基本上所有流行的网页浏览器都支持基本认证。基本认证很少在可公开访问的互联网网站上使用，有时候会在小的私有系统中使用（如路由器网页管理接口）。后来的机制HTTP摘要认证是为替代基本认证而开发的，允许密钥以相对安全的方式在不安全的通道上传输。</p><p>程序员和系统管理员有时会在可信网络环境中使用基本认证，使用<code>Telnet</code>或其他明文网络协议工具手动地测试Web服务器。这是一个麻烦的过程，但是网络上传输的内容是人可读的，以便进行诊断。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>虽然基本认证非常容易实现，但该方案创建在以下的假设的基础上，即：客户端和服务器主机之间的连接是安全可信的。特别是，如果没有使用SSL/TLS这样的传输层安全的协议，那么以明文传输的密钥和口令很容易被拦截。该方案也同样没有对服务器返回的信息提供保护。</p><p>现存的浏览器保存认证信息直到标签页或浏览器被关闭，或者用户清除历史记录。HTTP没有为服务器提供一种方法指示客户端丢弃这些被缓存的密钥。这意味着服务器端在用户不关闭浏览器的情况下，并没有一种有效的方法来让用户注销。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><p>要知道 Basic Auth 的使用场景，它是最简单的一种认证方式，说白了就是<strong>用户名 + 密码</strong>， 这种方式有很多问题， 比如它通过网络发送用户名和密码， 而这些都是以一种<strong>很容易解码</strong>的形式表示的。 虽然它是用 base64_encode 加密过了， 但这种加密的作用也仅仅是让可信任的用户不太可能在进行网络观测时<strong>无意中看到密码</strong>, 而<strong>不能防止恶意用户</strong>。 所以也仅限在一些安全要求不是那么高的场景下使用。</p><h2 id="原理和实现"><a href="#原理和实现" class="headerlink" title="原理和实现"></a>原理和实现</h2><p>简单来说，它是检查你的<code>Headers</code>中的<code>Authorization</code>. 从中解析出<code>username</code>和<code>password</code>, 和服务器保存的进行对比，如果一致则通过.</p><p>其名称与值的形式是这样的：<br><code>Authorization: Basic base64encode(username+&quot;:&quot;+password)</code></p>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP Authorization 之 Bearer Token</title>
      <link href="/2020/10/13/Http/HTTP_Authorization_%E4%B9%8B_Bearer_Token(JWT)/"/>
      <url>/2020/10/13/Http/HTTP_Authorization_%E4%B9%8B_Bearer_Token(JWT)/</url>
      
        <content type="html"><![CDATA[<h1 id="Bearer-Token（Token-令牌）"><a href="#Bearer-Token（Token-令牌）" class="headerlink" title="Bearer Token（Token 令牌）"></a>Bearer Token（Token 令牌）</h1><p>定义：为了验证使用者的身份，需要客户端向服务器端提供一个<strong>可靠的验证信息</strong>，称为<code>Token</code>，这个token通常由Json数据格式组成，通过<strong>hash散列算法</strong>生成一个字符串，所以称为<code>Json Web Token</code>（Json表示令牌的原始值是一个Json格式的数据，web表示是在互联网传播的，token表示令牌，简称<code>JWT</code>)</p><h2 id="JWT分为三部分："><a href="#JWT分为三部分：" class="headerlink" title="JWT分为三部分："></a>JWT分为三部分：</h2><h3 id="第一部分header：头部"><a href="#第一部分header：头部" class="headerlink" title="第一部分header：头部"></a>第一部分header：头部</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;typ&quot;</span> : <span class="string">&quot;JWT&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;alg&quot;</span> : <span class="string">&quot;HS256&quot;</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>typ</code>：<strong>类型</strong></p><p><code>alg</code>：<strong>算法</strong>,HS256表示哈希算法的mac值。SHA256/HmacSHA256,SHA256表示直接加密,HmacSHA256表示用秘钥进行加密。SHA  Hash Algorithm,安全散列算法, HMAC(Hash Message Authentication Code,散列消息鉴别码)</p><h3 id="第二部分payload：（Claim正文部分）Base64加密的"><a href="#第二部分payload：（Claim正文部分）Base64加密的" class="headerlink" title="第二部分payload：（Claim正文部分）Base64加密的"></a>第二部分payload：（Claim正文部分）Base64加密的</h3><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;iss&quot;</span> : <span class="string">&quot;joe&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;exp&quot;</span>: <span class="number">1300819380</span>,</span><br><span class="line">    <span class="attr">&quot;http://example.com/is_root&quot;</span> :<span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JWT官方规定了下面几个官方的字段供选用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间,毫秒数计算</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure><h3 id="第三部分：签名（将上面的两个部分组合在一起-本地信息做的一个的签名（头部在前）"><a href="#第三部分：签名（将上面的两个部分组合在一起-本地信息做的一个的签名（头部在前）" class="headerlink" title="第三部分：签名（将上面的两个部分组合在一起+本地信息做的一个的签名（头部在前）"></a>第三部分：签名（将上面的两个部分组合在一起+本地信息做的一个的签名（头部在前）</h3><p>签名是把<code>header</code>和<code>payload</code>（载荷）对应的json结构进行<code>base64url</code>编码之后得到的两个串，用英文句点号拼接起来，然后根据header里面alg指定的签名算法生成出来的。</p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ul><li>1.避免在使用中不断的输入账号和密码，<strong>比较安全</strong></li><li>2.如果要测试带token的接口，首先要进行登录，登录成功会有个token信息，向api接口发送请求的时候必须带上这个token，故需要做2次请求（1.登录，拿到token;2.正式对接口进行测试）</li></ul><h2 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h2><ul><li>1.token一般有时间限制。测试前需要跟开发确认token可以用多久，什么时候算token失效</li><li>2.token放在哪儿，怎么传回去，需要有开发文档，或者咨询开发，登录成功返回的token需要了解从什么地方获取</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP Authorization 之 Digest Auth</title>
      <link href="/2020/10/13/Http/HTTP_Authorization_%E4%B9%8B_Digest_Auth/"/>
      <url>/2020/10/13/Http/HTTP_Authorization_%E4%B9%8B_Digest_Auth/</url>
      
        <content type="html"><![CDATA[<h1 id="Digest-Auth"><a href="#Digest-Auth" class="headerlink" title="Digest Auth"></a><a href="https://www.jianshu.com/p/78faeb3a90e6">Digest Auth</a></h1><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>Digest Auth(<strong>摘要访问认证</strong>)是一种协议规定的Web服务器用来同网页浏览器进行认证信息协商的方法。它在密码发出前，先对其应用哈希函数，这相对于<strong>HTTP基本认证</strong>发送明文而言，更安全。</p><p>从技术上讲，<strong>摘要认证</strong>是<strong>使用随机数来阻止进行密码分析的MD5加密哈希函数应用</strong>。它使用HTTP协议。<br>　　<br><code>HTTP Digest Auth</code>是对<code>HTTP Basic Auth</code>的增强。由于<code>HTTP Basic Auth</code>几乎是以明文传输用户名和密码，容易泄露。而<code>HTTP Digest Auth</code>能够传递认证信息，但是传递的是使用摘要算法（如：MD5）产生的密文，服务端也不用存储明文用户信息，降低了泄密的可能性。但是这种方式仍然可以通过中间人攻击的方式拦截、模拟，所以算是一种折中方案。</p><h2 id="二、原理"><a href="#二、原理" class="headerlink" title="二、原理"></a>二、原理</h2><p><strong>摘要访问认证</strong>最初由RFC 2069 (HTTP的一个扩展：摘要访问认证)中被定义。RFC 2069 大致定义了一个传统的由服务器生成随机数来维护安全性的摘要认证架构。认证响应由下列组成（HA1、HA2、A1、及A2为字符串变量的名称）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HA1 = MD5(A1) = MD5(username:realm:password)</span><br><span class="line">HA2 = MD5(A2) = MD5(method:digestURI)</span><br><span class="line">response = MD5(HA1:nonce:HA2)</span><br></pre></td></tr></table></figure><p>这只是最基本的情况，为了防止中间人攻击，增加安全性，还有其他选项，不过这些都不影响总体原理。</p><h2 id="三、认证过程"><a href="#三、认证过程" class="headerlink" title="三、认证过程"></a>三、认证过程</h2><p>典型的认证过程包括如下步骤：</p><ul><li>客户端请求一个需要认证的页面，但是不提供<strong>用户名</strong>和<strong>密码</strong>。通常这是由于用户简单的输入了一个地址或者在页面中点击了某个<strong>超链接</strong>。</li><li>服务器返回<code>401 &quot;Unauthorized&quot;</code>响应代码，并提供<strong>认证域(realm)<strong>，以及一个随机生成的、只使用一次的数值，称为</strong>密码随机数 nonce</strong>。</li><li>此时，浏览器会向用户提示认证域(realm)（通常是所访问的计算机或系统的描述），并且提示用户名和密码。用户此时可以选择取消。</li><li>一旦提供了用户名和密码，客户端会重新发送同样的请求，但是添加了一个认证头包括了响应代码。</li><li>在这个例子中，服务器接受了认证并且返回了请求页面。如果用户名非法和/或密码不正确，服务器将返回”401”响应代码，然后客户端会再次提示用户输入用户名及密码。</li></ul>]]></content>
      
      
      <categories>
          
          <category> HTTP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dockerfile详解</title>
      <link href="/2020/09/20/Dockerfile%E8%AF%A6%E8%A7%A3/"/>
      <url>/2020/09/20/Dockerfile%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="Dockerfile的常用命令如下，大家使用时也可以到官网查阅所有的命令，不用记忆："><a href="#Dockerfile的常用命令如下，大家使用时也可以到官网查阅所有的命令，不用记忆：" class="headerlink" title="Dockerfile的常用命令如下，大家使用时也可以到官网查阅所有的命令，不用记忆："></a>Dockerfile的常用命令如下，大家使用时也可以到<a href="https://docs.docker.com/engine/reference/builder/">官网</a>查阅所有的命令，不用记忆：</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FROM image_name:tag</td><td>使用哪个基础镜像启动构建流程,每个Dockerfile的第一条命令必须是FROM,FROM指令指定一个已存在的镜像,后续指令都继续该镜像进行,这个镜像也称为基础镜像</td></tr><tr><td>MAINTAINER user_name</td><td>声明镜像的创建者</td></tr><tr><td>ENV key value</td><td>设置环境变量 (可以写多条)</td></tr><tr><td>RUN command</td><td>Dockerfile的核心部分(可以写多条)</td></tr><tr><td>ADD source_dir/file dest_dir/file</td><td>将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制后自动解压</td></tr><tr><td>COPY source_dir/file dest_dir/file</td><td>和ADD相似，但是如果有压缩文件并不能解压</td></tr><tr><td>WORKDIR path_dir</td><td>设置工作目录,指定在创建容器后,终端默认登陆的进来工作目录,一个落脚点</td></tr><tr><td>EXPOSE port1 prot2</td><td>用来指定端口，使容器内的应用可以通过端口和外界交互</td></tr><tr><td>CMD argument</td><td>在构建容器时使用，会被docker run 后的argument覆盖</td></tr><tr><td>ENTRYPOINT argument</td><td>和CMD相似，但是并不会被docker run指定的参数覆盖</td></tr><tr><td>VOLUME</td><td>将本地文件夹或者其他容器的文件挂载到容器中</td></tr></tbody></table><p>参考：<a href="https://mp.weixin.qq.com/s/0hePvXK8SgpThxQnvwXysQ">https://mp.weixin.qq.com/s/0hePvXK8SgpThxQnvwXysQ</a></p><h2 id="基础命令："><a href="#基础命令：" class="headerlink" title="基础命令："></a>基础命令：</h2><h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 制作基准镜像</span></span><br><span class="line">FROM 镜像</span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如我们要发布一个应用到tomcat里，那么的第一步就是FROM tomcat</span></span><br><span class="line">FROM tomcat&lt;:tags&gt;</span><br></pre></td></tr></table></figure><h3 id="LABEL-amp-MAINTAINER"><a href="#LABEL-amp-MAINTAINER" class="headerlink" title="LABEL &amp; MAINTAINER"></a>LABEL &amp; MAINTAINER</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> MAINTAINER，一般写个人id或组织id</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LABEL 就是注释，方便阅读的，纯注释说明。不会对Dockerfile造成任何影响</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 比如：</span></span><br><span class="line">MAINTAINER baidu.com</span><br><span class="line">LABEL version = &quot;1.0.0&quot;</span><br><span class="line">LABEL description = &quot;我们是大百度！&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> ...等等描述性信息，纯注释。</span></span><br></pre></td></tr></table></figure><h3 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 类似于Linux中的<span class="built_in">cd</span>命令，但是他比<span class="built_in">cd</span>高级的地方在于，我先<span class="built_in">cd</span>，发现没有这个目录，我就自动创建出来，然后在<span class="built_in">cd</span>进去</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这个路径建议使用绝对路径。</span></span><br><span class="line">WORKDIR /usr/local/testdir</span><br></pre></td></tr></table></figure><h3 id="COPY-amp-ADD"><a href="#COPY-amp-ADD" class="headerlink" title="COPY &amp; ADD"></a>COPY &amp; ADD</h3><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将1.txt拷贝到根目录下。它不仅仅能拷贝单个文件，还支持Go语言风格的通配符，比如如下：</span></span><br><span class="line">COPY 1.txt /</span><br><span class="line"><span class="meta">#</span><span class="bash"> 拷贝所有 abc 开头的文件到testdir目录下</span></span><br><span class="line">COPY abc* /testdir/</span><br><span class="line"><span class="meta">#</span><span class="bash"> ? 是单个字符的占位符，比如匹配文件 abc1.log</span></span><br><span class="line">COPY abc?.log /testdir/</span><br></pre></td></tr></table></figure><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将1.txt拷贝到根目录的abc目录下。若/abc不存在，则会自动创建</span></span><br><span class="line">ADD 1.txt /abc</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将test.tar.gz解压缩然后将解压缩的内容拷贝到/home/work/<span class="built_in">test</span></span></span><br><span class="line">ADD test.tar.gz /home/work/test</span><br></pre></td></tr></table></figure><p>docker官方建议当要从远程复制文件时，尽量用curl/wget命令来代替ADD。因为用ADD的时候会创建更多的镜像层。镜像层的size也大。</p><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li>二者都是只复制目录中的文件，而不包含目录本身。</li><li>COPY能干的事ADD都能干，甚至还有附加功能。</li><li>ADD可以支持拷贝的时候顺带解压缩文件，以及添加远程文件（不在本宿主机上的文件）。</li><li>只是文件拷贝的话可以用COPY，有额外操作可以用ADD代替。</li></ul><h3 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 设置环境常量，方便下文引用，比如：</span></span><br><span class="line">ENV JAVA_HOME /usr/local/jdk1.8</span><br><span class="line"><span class="meta">#</span><span class="bash"> 引用上面的常量，下面的RUN指令可以先不管啥意思，目的是想说明下文可以通过<span class="variable">$&#123;xxx&#125;</span>的方式引用</span></span><br><span class="line">RUN $&#123;JAVA_HOME&#125;/bin/java -jar xxx.jar</span><br></pre></td></tr></table></figure><p>ENV设置的常量，其他地方都可以用${xxx}来引用，将来改的时候只改ENV的变量内容就行。</p><h2 id="运行指令"><a href="#运行指令" class="headerlink" title="运行指令:"></a>运行指令:</h2><h3 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h3><h4 id="执行时机"><a href="#执行时机" class="headerlink" title="执行时机"></a>执行时机</h4><p>RUN指令是在构建镜像时运行，在构建时能修改镜像内部的文件。</p><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><p>命令格式不光是RUN独有，而是下面的CMD和ENTRYPOINT都通用。</p><ul><li>SHELL命令格式:<ul><li>比如:<code>RUN yum -y install vim</code></li></ul></li><li>EXEC命令格式:<ul><li>比如:<code>RUN [&quot;yum&quot;,&quot;-y&quot;,&quot;install&quot;,&quot;vim&quot;]</code></li></ul></li><li>二者对比<ul><li>SHELL：当前shell是父进程，生成一个子shell进程去执行脚本，脚本执行完后退出子shell进程，回到当前父shell进程。</li><li>EXEC：用EXEC进程替换当前进程，并且保持PID不变，执行完毕后直接退出，不会退回原来的进程。</li><li>总结：也就是说shell会创建子进程执行，EXEC不会创建子进程。</li></ul></li><li>推荐EXEC命令格式</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><p>举个最简单的例子，<strong>构建镜像</strong>时输出一句话，那么在Dockerfile里写如下即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;echo&quot;, &quot;image is building!!!&quot;]</span><br></pre></td></tr></table></figure><p>再比如我们要下载vim，那么在Dockerfile里写如下即可：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUN [&quot;yum&quot;,&quot;-y&quot;,&quot;install&quot;,&quot;vim&quot;]</span><br></pre></td></tr></table></figure><h3 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h3><h4 id="执行时机-1"><a href="#执行时机-1" class="headerlink" title="执行时机"></a>执行时机</h4><p>容器启动时执行，而不是镜像构建时执行。</p><h4 id="解释说明"><a href="#解释说明" class="headerlink" title="解释说明"></a>解释说明</h4><p>在容器启动的时候执行此命令，且Dockerfile中只有最后一个ENTRYPOINT会被执行，推荐用EXEC格式。重点在于如果容器启动的时候有其他额外的附加指令，则CMD指令不生效。</p><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;echo&quot;, &quot;container starting...&quot;]</span><br></pre></td></tr></table></figure><h3 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h3><h4 id="执行时机-2"><a href="#执行时机-2" class="headerlink" title="执行时机"></a>执行时机</h4><p>容器创建时执行，而不是镜像构建时执行。</p><h4 id="解释说明-1"><a href="#解释说明-1" class="headerlink" title="解释说明"></a>解释说明</h4><p>在容器启动的时候执行此命令，且Dockerfile中只有最后一个ENTRYPOINT会被执行，推荐用EXEC格式。</p><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ENTRYPOINT [&quot;ps&quot;,&quot;-ef&quot;]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker入门教程</title>
      <link href="/2020/09/20/%E5%85%A8%E7%BD%91%E6%9C%80%E5%AE%9E%E5%9C%A8%E7%9A%84docker%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/"/>
      <url>/2020/09/20/%E5%85%A8%E7%BD%91%E6%9C%80%E5%AE%9E%E5%9C%A8%E7%9A%84docker%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li><p>系列一</p><ul><li><a href="https://mp.weixin.qq.com/s/zO-yzxc70wJgW6A83p2zTA">全网最实在的docker入门教程一</a></li><li><a href="https://mp.weixin.qq.com/s/5HK1khkGcTgsH8vKtrR4Pg">全网最实在的docker入门教程二</a></li><li><a href="https://mp.weixin.qq.com/s/AZRcEkFMqwD4gFr0f7eiZw">全网最实在的docker入门教程三</a></li><li><a href="https://mp.weixin.qq.com/s/kJ54xTF-iM22xSlO-0iaOQ">全网最实在的docker入门教程四(创建自己的私有仓库容器)</a><ul><li>遇到mavn-docker插件报timeout:<ul><li><a href="https://blog.csdn.net/weixin_40628102/article/details/104060420">https://blog.csdn.net/weixin_40628102/article/details/104060420</a></li><li>执行<code>iptables -I INPUT -p tcp --dport 2375 -j ACCEPT</code></li><li>当浏览器中访问<code>http://192.168.68.128:2375/version</code>，正确显示内容即配置正确</li><li>maven配置：  <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.spotify<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>docker-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.4.13<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--标记镜像名project.artifactId就是push到私有仓库的名字，：后面的project.version会成为版本号--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">imageName</span>&gt;</span>192.168.68.128:5000/$&#123;project.artifactId&#125;:$&#123;project.version&#125;<span class="tag">&lt;/<span class="name">imageName</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">baseImage</span>&gt;</span>jdk1.8<span class="tag">&lt;/<span class="name">baseImage</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">entryPoint</span>&gt;</span>[&quot;java&quot;, &quot;-jar&quot;,&quot;/$&#123;project.build.finalName&#125;.jar&quot;]<span class="tag">&lt;/<span class="name">entryPoint</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">resources</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">resource</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">targetPath</span>&gt;</span>/<span class="tag">&lt;/<span class="name">targetPath</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">directory</span>&gt;</span>$&#123;project.build.directory&#125;<span class="tag">&lt;/<span class="name">directory</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">include</span>&gt;</span>$&#123;project.build.finalName&#125;.jar<span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">resource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">resources</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dockerHost</span>&gt;</span>http://192.168.68.128:2375<span class="tag">&lt;/<span class="name">dockerHost</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>该maven-docker插件是进行COPY操作，所以要自己手动先打成jar包</li></ul></li></ul></li></ul></li><li><p>系列二</p><ul><li><a href="https://www.cnblogs.com/niugang0920/category/1631814.html">拾荒者-Docker系列</a></li></ul></li><li><p>系列三：</p><ul><li><a href="https://blog.51cto.com/13886290/2159751">如何轻松搞定基于Docker的容器化部署</a></li></ul></li><li><p>系列四</p><ul><li><a href="https://www.cnblogs.com/haoprogrammer/p/11008786.html">docker(部署常见应用)：docker部署mysql</a></li><li><a href="https://www.cnblogs.com/haoprogrammer/p/10983407.html">docker(部署常见应用)：docker部署nginx</a></li><li><a href="https://www.cnblogs.com/haoprogrammer/p/11018312.html">docker(部署常见应用)：docker部署redis</a></li><li><a href="https://www.cnblogs.com/haoprogrammer/p/11103301.html">docker(常见调试技巧)：docker打包镜像调试技巧</a></li></ul></li></ul><p><a href="https://zhuanlan.zhihu.com/p/257289976">Dockerfile里RUN、CMD、ENTRYPOINT的区别</a></p><p><a href="https://www.cnblogs.com/klvchen/p/9238410.html">Dockerfile里RUN、CMD、ENTRYPOINT的区别</a></p><h2 id="Docker常用命令集合"><a href="#Docker常用命令集合" class="headerlink" title="Docker常用命令集合"></a>Docker常用命令集合</h2><p><img src="https://maichong.io/help/images/docker-induction.jpg" alt="docker 命令流程"></p><p><a href="https://www.runoob.com/docker/docker-command-manual.html">Docker命令大全</a></p><h3 id="Docker-images"><a href="#Docker-images" class="headerlink" title="Docker images"></a>Docker images</h3><p>列出本机主机上的镜像：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>结果各项说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY：表示镜像的仓库源</span><br><span class="line">TAG：镜像的标签</span><br><span class="line">IMAGE ID：镜像ID</span><br><span class="line">CREATED：镜像创建时间</span><br><span class="line">SIZE：镜像大小</span><br></pre></td></tr></table></figure><h3 id="Docker-search"><a href="#Docker-search" class="headerlink" title="Docker search"></a>Docker search</h3><p>搜索镜像(运行该命令实质是去：<a href="https://hub.docker.com搜索了)：">https://hub.docker.com搜索了)：</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker search [options] &lt;keyword&gt;</span><br><span class="line">e.g.:docker search redis</span><br></pre></td></tr></table></figure><h3 id="Docker-pull"><a href="#Docker-pull" class="headerlink" title="Docker pull"></a>Docker pull</h3><p>获取镜像(下载镜像)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull &lt;imageName&gt;[:TAG]</span><br><span class="line">[:TAG]默认为latest</span><br></pre></td></tr></table></figure><h3 id="Docker-rmi"><a href="#Docker-rmi" class="headerlink" title="Docker rmi"></a>Docker rmi</h3><p>删除和清理镜像</p><h4 id="使用标签TAG删除"><a href="#使用标签TAG删除" class="headerlink" title="使用标签TAG删除"></a>使用标签TAG删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker rmi [option] &lt;imageName&gt;[:TAG]</span><br><span class="line">[:TAG]默认为latest</span><br><span class="line">-f,-force: 强制删除镜像，即使有容器依赖它；</span><br><span class="line">-no-prune: 不要清理未带标签的父镜像。</span><br></pre></td></tr></table></figure><h4 id="使用imageID删除"><a href="#使用imageID删除" class="headerlink" title="使用imageID删除"></a>使用imageID删除</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rmi &lt;imageID&gt;</span><br></pre></td></tr></table></figure><h3 id="Docker-run"><a href="#Docker-run" class="headerlink" title="Docker run"></a>Docker run</h3><p>创建一个新的容器并运行一个命令:<br>docker run等价于先执行docker create命令，再执行docker start命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">docker run [options]</span><br><span class="line">-d: 后台运行容器，并返回容器ID，也即启动守护式容器；</span><br><span class="line">-i: 以交互模式运行容器，通常与-t同时使用；</span><br><span class="line">-t: 为容器重新分配一个伪输入终端，通常与-i同时使用；</span><br><span class="line">--name=&quot;容器新名字&quot;: 为容器指定一个名称，没有名字默认就是ID；</span><br><span class="line">-P: 随机端口映射；</span><br><span class="line">-p: 指定端口映射，有以下四种格式：</span><br><span class="line">    ip:hostPort:containerPort</span><br><span class="line">    ip::containerPort</span><br><span class="line">    hostPort:containerPort</span><br><span class="line">    containerPort</span><br><span class="line">-e username=&quot;ritchie&quot;: 设置环境变量；</span><br><span class="line">-v : 挂载数据卷</span><br><span class="line">    本地目录:容器目录</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用镜像nginx:latest以交互模式启动一个容器,在容器内执行/bin/bash命令。</span></span><br><span class="line">docker run -it nginx:latest /bin/bash</span><br><span class="line">对于所创建的bash容器，当用户使用`exit`命令退出 bash 进程之后，容器也会自动退出。这是因为对于容器来说，当其中的应用退出后，容器的使命完成，也就没有继续运行的必要了。</span><br></pre></td></tr></table></figure><h3 id="Docker-start-stop-restart"><a href="#Docker-start-stop-restart" class="headerlink" title="Docker start|stop|restart"></a>Docker start|stop|restart</h3><h3 id="Docker-ps"><a href="#Docker-ps" class="headerlink" title="Docker ps"></a>Docker ps</h3><p>列出当前所有正在运行的容器:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker ps [options]   (默认是当前正在运行的容器)</span><br><span class="line">-a :列出当前所有正在运行的容器+历史上运行过的</span><br><span class="line">-l :显示最近创建的容器。</span><br><span class="line">-n :显示最近n个创建的容器。</span><br><span class="line">-q :静默模式，只显示容器编号。</span><br><span class="line">–no-trunc :不截断输出。</span><br></pre></td></tr></table></figure><h3 id="Docker-exec"><a href="#Docker-exec" class="headerlink" title="Docker exec"></a>Docker exec</h3><p>在运行的容器中执行命令(可以用来进入容器)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">docker exec [options] &lt;容器ID 或 容器名称&gt;</span><br><span class="line">-t :分配一个伪终端</span><br><span class="line">-d :分离模式: 在后台运行</span><br><span class="line">-i :即使没有附加也保持STDIN 打开</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过 <span class="built_in">exec</span> 命令对指定的容器执行 bash or sh:</span></span><br><span class="line">docker exec -it &lt;容器ID&gt; /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> or</span></span><br><span class="line">docker exec -it &lt;容器ID&gt; /bin/sh</span><br></pre></td></tr></table></figure><h3 id="Docker-logs"><a href="#Docker-logs" class="headerlink" title="Docker logs"></a>Docker logs</h3><p>查看容器日志</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f -t --tail &lt;行数&gt; &lt;容器ID&gt;</span><br><span class="line">-t ：是加入时间戳</span><br><span class="line">-f ：跟随最新的日志打印</span><br><span class="line">–-tail 数字 ：显示最后多少条</span><br></pre></td></tr></table></figure><h3 id="Docker-top"><a href="#Docker-top" class="headerlink" title="Docker top"></a>Docker top</h3><p>查看容器内运行的进程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker top &lt;容器ID&gt;</span><br></pre></td></tr></table></figure><h3 id="Docker-inspect"><a href="#Docker-inspect" class="headerlink" title="Docker inspect"></a>Docker inspect</h3><p>查看容器内部细节</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker inspect &lt;容器ID 或 容器名称&gt;</span><br></pre></td></tr></table></figure><h3 id="Docker-cp"><a href="#Docker-cp" class="headerlink" title="Docker cp"></a>Docker cp</h3><p>从容器内拷贝文件到主机上:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;容器ID&gt;:&lt;容器内路径&gt; &lt;目的主机路径&gt;</span><br><span class="line">e.g.:docker cp 0d32c7830086:/tmp/yum.log /home/lxy</span><br></pre></td></tr></table></figure><p>从主机拷贝文件到容器内:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker cp &lt;目的主机路径&gt; &lt;容器ID&gt;:&lt;容器内路径&gt;</span><br><span class="line"><span class="meta">#</span><span class="bash"> /lxy 文件夹需存在</span></span><br><span class="line">docker cp a.txt 0d32c7830086:/lxy/b.txt</span><br></pre></td></tr></table></figure><h3 id="Docker-rm"><a href="#Docker-rm" class="headerlink" title="Docker rm"></a>Docker rm</h3><p>删除容器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm &lt;容器ID&gt;</span><br></pre></td></tr></table></figure><p><img src="../../pic/Linux/Docker%E5%91%BD%E4%BB%A4%E6%B5%81%E7%A8%8B%E5%9B%BE.png" alt="Docker命令流程图"></p><h2 id="使用Docker安装常用软件"><a href="#使用Docker安装常用软件" class="headerlink" title="使用Docker安装常用软件"></a>使用Docker安装常用软件</h2><h3 id="自定义的SpringBoot项目"><a href="#自定义的SpringBoot项目" class="headerlink" title="自定义的SpringBoot项目"></a>自定义的SpringBoot项目</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 以交互模式启动一个容器,<span class="built_in">exit</span>后会关闭容器</span></span><br><span class="line">docker run -it -p 8005:8005 --name ms-demo-service ms-demo-service:1.0 /bin/bash</span><br><span class="line"><span class="meta">#</span><span class="bash"> 后台运行容器(脚本内不能加nohup 和 &amp;)</span></span><br><span class="line">docker run -d -p 8005:8005 --name ms-demo-service ms-demo-service:1.0</span><br></pre></td></tr></table></figure><h3 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 搜索mysql镜像</span></span><br><span class="line">docker search mysql</span><br><span class="line"><span class="meta">#</span><span class="bash"> 下载mysql镜像,下载的TAG是latest</span></span><br><span class="line">docker pull centos/mysql-57-centos7</span><br><span class="line"><span class="meta">#</span><span class="bash"> –-name 指定容器名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 设置对外映射对端.如果不设置，客户端工具可能无法连接，因为没有映射端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -e MYSQL_ROOT_PASSWORD=123456：初始化root用户的密码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -d 后台运行容器，并返回容器ID</span></span><br><span class="line">docker run -d -p 3306:3306 --name=docker_mysql -e MYSQL_ROOT_PASSWORD=123456 centos/mysql-57-centos7</span><br></pre></td></tr></table></figure><h3 id="安装Redis"><a href="#安装Redis" class="headerlink" title="安装Redis"></a>安装Redis</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 下载redis镜像,下载的TAG是latest</span></span><br><span class="line">docker pull redis</span><br><span class="line"><span class="meta">#</span><span class="bash"> –-name 指定容器名</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -p 设置对外映射对端.如果不设置，客户端工具可能无法连接，因为没有映射端口</span></span><br><span class="line">docker run -d -p 6379:6379 --name docker_redis redis</span><br></pre></td></tr></table></figure><h2 id="Docker-通过-Dockerfile-进行打镜像包，然后运行容器，然后进入容器"><a href="#Docker-通过-Dockerfile-进行打镜像包，然后运行容器，然后进入容器" class="headerlink" title="Docker 通过 Dockerfile 进行打镜像包，然后运行容器，然后进入容器"></a>Docker 通过 Dockerfile 进行打镜像包，然后运行容器，然后进入容器</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 先准备Dockerfile，然后打包</span></span><br><span class="line">docker build -t 镜像名称:版本号 .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 将打好的镜像包保存成tar包</span></span><br><span class="line">docker save -o 保存的名称.tar 镜像名称:版本号</span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行(mysql为例)</span></span><br><span class="line">docker run -d -p 3306:3306 --name=容器名称 -e MYSQL_ROOT_PASSWORD=123456 镜像名称:版本号</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查询容器进程ID</span></span><br><span class="line">docker ps|grep 容器名称</span><br><span class="line"><span class="meta">#</span><span class="bash"> 进入容器</span></span><br><span class="line">docker exec -ti 容器ID /bin/sh</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>证书格式</title>
      <link href="/2020/09/13/CA%E8%AF%81%E4%B9%A6%E7%B1%BB%E5%9E%8B/"/>
      <url>/2020/09/13/CA%E8%AF%81%E4%B9%A6%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="证书格式"><a href="#证书格式" class="headerlink" title="证书格式"></a>证书格式</h2><h3 id="证书格式分类"><a href="#证书格式分类" class="headerlink" title="证书格式分类"></a>证书格式分类</h3><p>分为2大类：<strong>密钥库</strong>（含私钥，也可能有公钥）和<strong>公钥证书</strong>（仅含公钥）</p><h4 id="密钥库文件格式【Keystore】"><a href="#密钥库文件格式【Keystore】" class="headerlink" title="密钥库文件格式【Keystore】"></a>密钥库文件格式【Keystore】</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">格式     :  JKS</span><br><span class="line">扩展名   : .jks/.ks</span><br><span class="line">描述     : 【Java Keystore】密钥库的Java实现版本，provider为SUN</span><br><span class="line">特点     :  密钥库和私钥用不同的密码进行保护</span><br><span class="line"></span><br><span class="line">格式     :  JCEKS</span><br><span class="line">扩展名   :  .jce</span><br><span class="line">描述     : 【JCE Keystore】密钥库的JCE实现版本，provider为SUN JCE</span><br><span class="line">特点     :  相对于JKS安全级别更高，保护Keystore私钥时采用TripleDES</span><br><span class="line"></span><br><span class="line">格式     :  PKCS12</span><br><span class="line">扩展名   :  .p12/.pfx</span><br><span class="line">描述     : 【PKCS #12】个人信息交换语法标准</span><br><span class="line">特点     :  1、包含私钥、公钥及其证书</span><br><span class="line">            2、密钥库和私钥用相同密码进行保护</span><br></pre></td></tr></table></figure><h4 id="证书文件格式【Certificate】"><a href="#证书文件格式【Certificate】" class="headerlink" title="证书文件格式【Certificate】"></a>证书文件格式【Certificate】</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">格式      :  DER </span><br><span class="line">扩展名    :  .cer/.crt/.rsa</span><br><span class="line">描述      : 【ASN .1 DER】用于存放证书 </span><br><span class="line">特点      :  不含私钥、二进制</span><br><span class="line"></span><br><span class="line">格式      :  PEM</span><br><span class="line">扩展名    : .pem </span><br><span class="line">描述      : 【Printable Encoded Message】 </span><br><span class="line">特点      : 1、该编码格式在RFC1421中定义，其实PEM是【Privacy-Enhanced Mail】的简写，但他也同样广泛运用于密钥管理</span><br><span class="line">            2、ASCII文件</span><br><span class="line">            3、一般基于base 64编码</span><br><span class="line"></span><br><span class="line">格式      :  PKCS10 </span><br><span class="line">扩展名    : .p10/.csr </span><br><span class="line">描述      : 【PKCS #10】公钥加密标准【Certificate Signing Request】</span><br><span class="line">特点      :  1、证书签名请求文件</span><br><span class="line">            2、ASCII文件</span><br><span class="line">            3、CA签名后以p7r文件回复</span><br></pre></td></tr></table></figure><h3 id="常用证书文件格式"><a href="#常用证书文件格式" class="headerlink" title="常用证书文件格式"></a>常用证书文件格式</h3><p>CA中心普遍采用的规范是<code>X.509[13]</code>系列和<code>PKCS</code>系列.</p>]]></content>
      
      
      <categories>
          
          <category> 证书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenSSL</title>
      <link href="/2020/09/13/openssl/"/>
      <url>/2020/09/13/openssl/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h2 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a><a href="https://www.cnblogs.com/yangxiaolan/p/6256838.html">OpenSSL</a></h2><p>OpenSSL 是一个开源项目，其组成主要包括一下三个组件：</p><ul><li>openssl：多用途的命令行工具</li><li>libcrypto：加密算法库</li><li>libssl：加密模块应用库，实现了ssl及tls</li></ul><p>openssl可以实现：<strong>秘钥证书管理</strong>、<strong>对称加密</strong>和<strong>非对称加密</strong> </p><h2 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h2><p>对称加密需要使用的标准命令为<code>enc</code>，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl enc -ciphername [-in filename] [-out filename] [-pass arg] [-e] [-d] [-a/-base64]</span><br><span class="line">       [-A] [-k password] [-kfile filename] [-K key] [-iv IV] [-S salt] [-salt] [-nosalt] [-z] [-md]</span><br><span class="line">       [-p] [-P] [-bufsize number] [-nopad] [-debug] [-none] [-engine id]</span><br></pre></td></tr></table></figure><p>常用选项有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-in filename：指定要加密的文件存放路径</span><br><span class="line">-out filename：指定加密后的文件存放路径</span><br><span class="line">-salt：自动插入一个随机数作为文件内容加密，默认选项</span><br><span class="line">-e：可以指明一种加密算法，若不指的话将使用默认加密算法</span><br><span class="line">-d：解密，解密时也可以指定算法，若不指定则使用默认算法，但一定要与加密时的算法一致</span><br><span class="line">-a/-base64：使用-base64位编码格式</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 加密(加密需要输入加密密码)</span></span><br><span class="line">openssl enc -e -des3 -a -salt -in mimi.txt -out mimi-jiami.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 解密(接密需要输入加密时使用的密码)</span></span><br><span class="line">openssl enc -d -des3 -a -salt -in mimi-jiami.txt -out mimi-jiemi.txt</span><br></pre></td></tr></table></figure><h2 id="单向加密"><a href="#单向加密" class="headerlink" title="单向加密"></a>单向加密</h2><p>单向加密需要使用的标准命令为<code>dgst</code>，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst [-md5|-md4|-md2|-sha1|-sha|-mdc2|-ripemd160|-dss1] [-c] [-d] [-hex] [-binary]</span><br><span class="line">       [-out filename] [-sign filename] [-keyform arg] [-passin arg] [-verify filename] [-prverify</span><br><span class="line">       filename] [-signature filename] [-hmac key] [file...]</span><br></pre></td></tr></table></figure><p>常用选项有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[-md5|-md4|-md2|-sha1|-sha|-mdc2|-ripemd160|-dss1] ：指定一种加密算法</span><br><span class="line">-out filename：将加密的内容保存到指定文件中</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">openssl dgst -md5 mimi.txt</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">echo &quot;lxylxy&quot; |openssl dgst -md5</span><br></pre></td></tr></table></figure><p>单向加密除了<code>openssl dgst</code>工具还有：<code>md5sum</code>，<code>sha1sum</code>，<code>sha224sum</code>，<code>sha256sum</code>，<code>sha384sum</code>，<code>sha512sum</code></p><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sha512sum mimi.txt</span><br><span class="line">md5sum mimi.txt</span><br></pre></td></tr></table></figure><h2 id="生成密码"><a href="#生成密码" class="headerlink" title="生成密码"></a>生成密码</h2><p>生成密码需要使用的标准命令为<code>passwd</code>，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl passwd [-crypt] [-1] [-apr1] [-salt string] [-in file] [-stdin] [-noverify] [-quiet] [-table] &#123;password&#125;</span><br></pre></td></tr></table></figure><p>常用选项有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-1：使用md5加密算法</span><br><span class="line">-salt string：加入随机数，最多8位随机数</span><br><span class="line">-in file：对输入的文件内容进行加密</span><br><span class="line">-stdion：对标准输入的内容进行加密</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;yao jia mi de nei rong&quot;|openssl passwd -1 -stdin</span><br><span class="line"><span class="meta">#</span><span class="bash"> -salt string：加入随机数</span></span><br><span class="line">openssl passwd -1 -in mimi.txt -salt 123456</span><br></pre></td></tr></table></figure><h2 id="生成随机数"><a href="#生成随机数" class="headerlink" title="生成随机数"></a>生成随机数</h2><p>生成随机数需要用到的标准命令为<code>rand</code>，用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rand [-out file] [-rand file(s)] [-base64] [-hex] num</span><br></pre></td></tr></table></figure><p>常用选项有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-out file：将生成的随机数保存至指定文件中</span><br><span class="line">-base64：使用base64 编码格式</span><br><span class="line">-hex：使用16进制编码格式</span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">openssl rand -hex 10</span><br><span class="line"></span><br><span class="line">openssl rand -base64 10</span><br><span class="line"></span><br><span class="line">openssl rand -base64 10 -out aa.txt</span><br></pre></td></tr></table></figure><h2 id="生成秘钥对"><a href="#生成秘钥对" class="headerlink" title="生成秘钥对"></a>生成秘钥对</h2><p>首先需要先使用<code>genrsa</code>标准命令<strong>生成私钥</strong>，然后再使用<code>rsa</code>标准命令<strong>从私钥中提取公钥</strong>。</p><p><code>genrsa</code>的用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa [-out filename] [-passout arg] [-des] [-des3] [-idea] [-f4] [-3] [-rand file(s)] [-engine id] [numbits]</span><br></pre></td></tr></table></figure><p>常用选项有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-out filename：将生成的私钥保存至指定的文件中</span><br><span class="line">-des|-des3|-idea：不同的加密算法</span><br><span class="line">numbits：指定生成私钥的大小，默认是2048</span><br></pre></td></tr></table></figure><p>一般情况下秘钥文件的权限一定要控制好，只能自己读写，因此可以使用<code>umask</code>命令设置生成的<strong>私钥权限</strong>，示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 生成私钥文件：private.key(<span class="built_in">umask</span> 077;可不设置)</span></span><br><span class="line">umask 077;openssl genrsa -out private.key 4096</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看生成的私钥文件</span></span><br><span class="line">cat private.key</span><br></pre></td></tr></table></figure><p><code>rsa</code>的用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl rsa [-inform PEM|NET|DER] [-outform PEM|NET|DER] [-in filename] [-passin arg] [-out filename] [-passout arg] [-sgckey] [-des] [-des3] [-idea] [-text] [-noout] [-modulus] [-check] [-pubin] [-pubout] [-engine id]</span><br></pre></td></tr></table></figure><p>常用选项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-in filename：指明私钥文件</span><br><span class="line">-out filename：指明将提取出的公钥保存至指定文件中 </span><br><span class="line">-pubout：根据私钥提取出公钥 </span><br></pre></td></tr></table></figure><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 从私钥文件private.key中提取出公钥文件public.pubkey</span></span><br><span class="line">openssl rsa -in private.key -out public.pubkey -pubout</span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看公钥</span></span><br><span class="line">cat public.pubkey</span><br></pre></td></tr></table></figure><h2 id="创建CA和申请证书"><a href="#创建CA和申请证书" class="headerlink" title="创建CA和申请证书"></a>创建CA和申请证书</h2><p>使用<code>openssl</code>工具创建CA证书和申请证书时，需要先查看<strong>配置文件</strong>，因为配置文件中对证书的<strong>名称</strong>和<strong>存放位置</strong>等相关信息都做了定义，具体可参考 <code>/etc/pki/tls/openssl.cnf</code>文件</p><p>示例如下：</p><h3 id="1-创建自签证书"><a href="#1-创建自签证书" class="headerlink" title="(1)创建自签证书"></a>(1)<a href="https://www.cnblogs.com/loleina/p/8418111.html">创建自签证书</a></h3><p>生成CA根证书（root ca证书）步骤：生成CA私钥（.key或者.pem）–&gt;生成CA证书请求（.csr）–&gt;自签名得到根证书（.crt或.pem）（CA给自已颁发的证书）</p><h4 id="第一步：创建为-CA-提供所需的目录及文件"><a href="#第一步：创建为-CA-提供所需的目录及文件" class="headerlink" title="第一步：创建为 CA 提供所需的目录及文件"></a>第一步：创建为 CA 提供所需的目录及文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -pv /etc/pki/CA/&#123;certs,crl,newcerts,private&#125;</span><br><span class="line">touch /etc/pki/CA/&#123;serial,index.txt&#125;</span><br></pre></td></tr></table></figure><p>使用<code>tree</code>命令查看目录结构：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">tree</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行结果：</span></span><br><span class="line">.</span><br><span class="line">├── certs//存放已颁发的证书</span><br><span class="line">├── crl//存放已吊销的证书</span><br><span class="line">├── index.txt//openSSL定义的已签发证书的文本数据库文件</span><br><span class="line">├── newcerts//存放CA指令生成的新证书</span><br><span class="line">├── private//存放私钥</span><br><span class="line">└── serial//证书签发时使用的序列号参考文件，该文件的序列号是以16进制格式进行存放的，该文件必须提供并且包含一个有效的序列号</span><br></pre></td></tr></table></figure><h4 id="第二步：指明证书的开始编号"><a href="#第二步：指明证书的开始编号" class="headerlink" title="第二步：指明证书的开始编号"></a>第二步：指明证书的开始编号</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 01 &gt;&gt; serial </span><br></pre></td></tr></table></figure><h4 id="第三步：生成私钥"><a href="#第三步：生成私钥" class="headerlink" title="第三步：生成私钥"></a>第三步：生成私钥</h4><p>(私钥的文件名与存放位置要与配置文件中的设置相匹配)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out cakey.pem 2048</span><br></pre></td></tr></table></figure><h4 id="第四步：生成自签证书"><a href="#第四步：生成自签证书" class="headerlink" title="第四步：生成自签证书"></a>第四步：生成自签证书</h4><p>(自签证书的存放位置也要与配置文件中的设置相匹配，生成证书时需要填写相应的信息)</p><p>此处直接根据key文件获取CA根证书的命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 命令中用到的选项解释：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -new：表示生成一个新证书签署请求</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -x509：专用于CA生成自签证书，如果不是自签证书则不需要此项</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -key：生成请求时用到的私钥文件</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -out：证书的保存路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -days：证书的有效期限，单位是day（天），默认是365天</span></span><br><span class="line">openssl req -new -x509 -key cakey.pem -out cacert.pem -days 3650</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果不想填写那些注册信息，执行以下命令：</span></span><br><span class="line">openssl req -new -x509 -key cakey.pem -out cacert.pem -days 3650 subj &quot;/C=ZJ/ST=ZHEJIANG/L=hangzhou/O=eastcom/CN=eastcom.cn&quot;</span><br></pre></td></tr></table></figure><p>执行后需要输入如下信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Country Name (2 letter code) [XX]:ZJ</span><br><span class="line">State or Province Name (full name) []:ZHEJIANG</span><br><span class="line">Locality Name (eg, city) [Default City]:hangzhou</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:eastcom</span><br><span class="line">Organizational Unit Name (eg, section) []:eastcom</span><br><span class="line">Common Name (eg, your name or your server&#x27;s hostname) []:eastcom.cn</span><br><span class="line">Email Address []:eastcom.com</span><br></pre></td></tr></table></figure><p>说明：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Country Name             :C=国家</span><br><span class="line">State or Province Name   :ST=省份(州)</span><br><span class="line">Locality Name            :L=市/县</span><br><span class="line">Organization Name        :O=组织名称</span><br><span class="line">Organizational Unit Name :OU=组织单位名称</span><br><span class="line">Common Name              :CN=公司名称</span><br><span class="line">Email Address            :emailAddress=邮箱</span><br></pre></td></tr></table></figure><p>成功后会生成<code>cacert.pem</code>文件</p><h3 id="2-颁发证书"><a href="#2-颁发证书" class="headerlink" title="(2)颁发证书"></a>(2)颁发证书</h3><p>在需要使用证书的主机上生成证书请求，以<code>httpd</code>服务为例，步骤如下：</p><h4 id="第一步：在需要使用证书的主机上生成私钥，这个私钥文件的位置可以随意定"><a href="#第一步：在需要使用证书的主机上生成私钥，这个私钥文件的位置可以随意定" class="headerlink" title="第一步：在需要使用证书的主机上生成私钥，这个私钥文件的位置可以随意定"></a>第一步：在需要使用证书的主机上生成私钥，这个私钥文件的位置可以随意定</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl genrsa -out httpd.key 2048</span><br></pre></td></tr></table></figure><h4 id="第二步：生成证书签署请求"><a href="#第二步：生成证书签署请求" class="headerlink" title="第二步：生成证书签署请求"></a>第二步：生成证书签署请求</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl req -new -key httpd.key -out httpd.csr -days 365</span><br></pre></td></tr></table></figure><p>需要填写想应的信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Country Name (2 letter code) [XX]:ZJ</span><br><span class="line">State or Province Name (full name) []:ZHEJIANG</span><br><span class="line">Locality Name (eg, city) [Default City]:hangzhou</span><br><span class="line">Organization Name (eg, company) [Default Company Ltd]:eastcom</span><br><span class="line">Organizational Unit Name (eg, section) []:eastcom.cn</span><br><span class="line">Common Name (eg, your name or your server&#x27;s hostname) []:www.eastcom.cn</span><br><span class="line">Email Address []:httpd@eastcom.cn</span><br><span class="line"></span><br><span class="line">Please enter the following &#x27;extra&#x27; attributes</span><br><span class="line">to be sent with your certificate request</span><br><span class="line">A challenge password []:eastcom</span><br><span class="line">An optional company name []:eastcom</span><br></pre></td></tr></table></figure><h4 id="第三步：将请求通过可靠方式发送给-CA-主机"><a href="#第三步：将请求通过可靠方式发送给-CA-主机" class="headerlink" title="第三步：将请求通过可靠方式发送给 CA 主机"></a>第三步：将请求通过可靠方式发送给 CA 主机</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp httpd.csr ../CA</span><br></pre></td></tr></table></figure><h4 id="第四步：CA-服务器拿到证书签署请求文件后颁发证书，这一步是在-CA-服务器上做的"><a href="#第四步：CA-服务器拿到证书签署请求文件后颁发证书，这一步是在-CA-服务器上做的" class="headerlink" title="第四步：CA 服务器拿到证书签署请求文件后颁发证书，这一步是在 CA 服务器上做的"></a>第四步：CA 服务器拿到证书签署请求文件后颁发证书，这一步是在 CA 服务器上做的</h4><p>创建openssl.cnf(默认使用的是/etc/pki/tls/openssl.cnf)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cp /etc/pki/tls/openssl.cnf .</span><br><span class="line"><span class="meta">#</span><span class="bash"> 修改配置文件中的dir指向的路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> dir= /home/liuxy/genCA/CA</span></span><br><span class="line">vim openssl.cnf </span><br><span class="line">cp cakey.pem private/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 连续输入2个y进行确认</span></span><br><span class="line">openssl ca -in httpd.csr -config openssl.cnf -out httpd.crt -days 365</span><br></pre></td></tr></table></figure><p>查看证书信息的命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl x509 -in httpd.crt -noout -serial -subject</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">serial=01</span><br><span class="line">subject= /C=ZJ/ST=ZHEJIANG/O=eastcom/OU=eastcom.cn/CN=www.eastcom.cn/emailAddress=httpd@eastcom.cn</span><br></pre></td></tr></table></figure><h3 id="3-吊销证书"><a href="#3-吊销证书" class="headerlink" title="(3)吊销证书"></a>(3)吊销证书</h3><p>吊销证书的步骤也是在<strong>CA服务器</strong>上执行的，以刚才新建的<code>httpd.crt</code>证书为例，吊销步骤如下：</p><ul><li>第一步：在客户机上获取要吊销证书的<code>serial</code>和<code>subject</code>信息 </li><li>第二步：根据客户机提交的<code>serial</code>和<code>subject</code>信息，对比其余本机数据库<code>index.txt</code>中存储的是否一致 </li><li>第三步：执行吊销操作<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -config openssl.cnf -revoke newcerts/01.pem</span><br></pre></td></tr></table></figure></li><li>第四步：生成吊销证书的吊销编号 （第一次吊销证书时执行）<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo 01 &gt; crlnumber</span><br></pre></td></tr></table></figure></li><li>第五步：更新证书吊销列表<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl ca -config openssl.cnf -gencrl -out crl/ca.crl</span><br></pre></td></tr></table></figure>查看 crl 文件命令：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">openssl crl -in crl/ca.crl -noout -text</span><br></pre></td></tr></table></figure>所有示例的最终目录结构如下(使用tree命令查看)<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── cacert.pem//CA服务器的公钥</span><br><span class="line">├── cakey.pem//CA服务器的私钥</span><br><span class="line">├── certs//存放已颁发的证书</span><br><span class="line">├── crl//存放已吊销的证书</span><br><span class="line">│   └── ca.crl</span><br><span class="line">├── crlnumber</span><br><span class="line">├── crlnumber.old</span><br><span class="line">├── httpd.crt//httpd服务的证书</span><br><span class="line">├── httpd.csr</span><br><span class="line">├── index.txt//openSSL定义的已签发证书的文本数据库文件</span><br><span class="line">├── index.txt.attr</span><br><span class="line">├── index.txt.attr.old</span><br><span class="line">├── index.txt.old</span><br><span class="line">├── newcerts//存放CA指令生成的新证书</span><br><span class="line">│   └── 01.pem</span><br><span class="line">├── openssl.cnf</span><br><span class="line">├── private//存放私钥</span><br><span class="line">│   └── cakey.pem</span><br><span class="line">├── serial//证书签发时使用的序列号参考文件，该文件的序列号是以16进制格式进行存放的，该文件必须提供并且包含一个有效的序列号</span><br><span class="line">└── serial.old</span><br></pre></td></tr></table></figure></li></ul><h2 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h2><h3 id="版本和编译参数"><a href="#版本和编译参数" class="headerlink" title="版本和编译参数"></a>版本和编译参数</h3><ul><li>显示版本和编译参数： <code>openssl version -a</code></li></ul><h3 id="支持的子命令、密码算法"><a href="#支持的子命令、密码算法" class="headerlink" title="支持的子命令、密码算法"></a>支持的子命令、密码算法</h3><ul><li>查看支持的子命令： <code>openssl ?</code></li><li>SSL 密码组合列表： <code>openssl ciphers</code></li></ul><h3 id="测试密码算法速度"><a href="#测试密码算法速度" class="headerlink" title="测试密码算法速度"></a>测试密码算法速度</h3><ul><li>测试所有算法速度： <code>openssl speed</code></li><li>测试 RSA 速度： <code>openssl speed rsa</code></li><li>测试 DES 速度： <code>openssl speed des</code></li></ul><h3 id="RSA-密钥操作"><a href="#RSA-密钥操作" class="headerlink" title="RSA 密钥操作"></a>RSA 密钥操作</h3><ul><li>产生 RSA 密钥对： <code>openssl genrsa -out 1.key 1024</code><ul><li>生成<code>1.ley</code>文件，里面为可读的私钥信息</li></ul></li><li>取出 RSA 公钥： <code>openssl rsa -in 1.key -pubout -out 1.pubkey</code><ul><li>通过<code>1.key</code>文件，取出可读的公钥信息，生成文件<code>1.pubkey</code><h3 id="加密文件"><a href="#加密文件" class="headerlink" title="加密文件"></a>加密文件</h3></li></ul></li><li>加密文件： <code>openssl enc -e -rc4 -in 1.key -out 1.key.enc</code><ul><li>将<code>1.key</code>文件进行加密</li></ul></li><li>解密文件： <code>openssl enc -d -rc4 -in 1.key.enc -out 1.key.dec</code><ul><li>将<code>1.key.enc</code>文件进行解密<h3 id="计算-Hash-值"><a href="#计算-Hash-值" class="headerlink" title="计算 Hash 值"></a>计算 Hash 值</h3></li></ul></li><li>计算文件的 MD5 值： <code>openssl md5 &lt; 1.key</code></li><li>计算文件的 SHA1 值： <code>openssl sha1 &lt; 1.key</code></li></ul><h2 id="安全协议"><a href="#安全协议" class="headerlink" title="安全协议"></a>安全协议</h2><p>OpenSSL的目标是实现安全协议。其中相关协议和标准包括：<code>SSL/TLS</code>、<code>PKCS#1</code>、<code>PCKS#10</code>、<code>X.509</code>、<code>PEM</code>、<code>OCSP</code>等</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.51cto.com/11512826/2054578">https://blog.51cto.com/11512826/2054578</a></p>]]></content>
      
      
      <categories>
          
          <category> 证书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>证书介绍</title>
      <link href="/2020/09/13/%E8%AF%81%E4%B9%A6/"/>
      <url>/2020/09/13/%E8%AF%81%E4%B9%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="证书"><a href="#证书" class="headerlink" title="证书"></a><a href="https://www.cnblogs.com/sewain/p/14250884.html">证书</a></h2><h3 id="证书包含"><a href="#证书包含" class="headerlink" title="证书包含"></a>证书包含</h3><ul><li>申请者的基本信息：网站使用的加密算法、网站使用的hash算法；</li><li>申请者的公钥；</li><li>认证机构的信息：认证机构的名称，证书到期时间。</li><li>认证机构的证书签名。</li></ul><p>总之：证书的<strong>核心功能</strong>就是<strong>安全的传递公钥</strong>！</p><h3 id="证书编码"><a href="#证书编码" class="headerlink" title="证书编码"></a>证书编码</h3><p>标识证书编码类型，表明证书是以什么编码存在</p><h4 id="Der-Distinguished-Encoding-Rules"><a href="#Der-Distinguished-Encoding-Rules" class="headerlink" title="Der (Distinguished Encoding Rules) "></a>Der (Distinguished Encoding Rules) <span id="der"/></h4><ul><li>二进制编码的<strong>证书</strong>或<strong>公私钥</strong></li><li>正确的理解是:”我有二进制编码的证书”,而不是”我有一个DER证书”</li><li>der格式的证书文件内容是经过加密的二进制数据，也就是说文件内容打开后是乱码</li></ul><h4 id="Pem-Privacy-Enhanced-Mail"><a href="#Pem-Privacy-Enhanced-Mail" class="headerlink" title="Pem (Privacy Enhanced Mail)"></a>Pem (Privacy Enhanced Mail)<span id="pem"/></h4><p>pem格式的证书内容是经过加密的文本文件，一般是base64编码格式的Der证书，增加头尾了</p><p>可直接用记事本打开查看</p><p>PEM<strong>私钥</strong>增加： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN RSA PRIVATE KEY----- </span><br><span class="line">-----END RSA PRIVATE KEY----- </span><br></pre></td></tr></table></figure><p>PEM<strong>公钥</strong>增加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN PUBLIC KEY----- </span><br><span class="line">-----END PUBLIC KEY----- </span><br></pre></td></tr></table></figure><p>PEM<strong>证书</strong>增加：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-----BEGIN CERTIFICATE----- </span><br><span class="line">-----END CERTIFICATE----- </span><br></pre></td></tr></table></figure><p><strong>pem</strong>格式和<strong>der</strong>格式的证书文件可以相互转换</p><h3 id="证书相关后缀"><a href="#证书相关后缀" class="headerlink" title="证书相关后缀"></a>证书相关后缀</h3><h4 id="key-pem格式的私钥，也有人认为这是公钥"><a href="#key-pem格式的私钥，也有人认为这是公钥" class="headerlink" title=".key(pem格式的私钥，也有人认为这是公钥)"></a>.key(pem格式的私钥，也有人认为这是公钥)</h4><p>通常标识这个是<strong>证书</strong>文件，公钥和私钥可以被编码为<code>二进制DER</code>或<code>ASCII PEM</code>。</p><h4 id="pub-pem格式的公钥"><a href="#pub-pem格式的公钥" class="headerlink" title=".pub(pem格式的公钥)"></a>.pub(pem格式的公钥)</h4><p>通常是<strong>公钥</strong>文件</p><h4 id="pem"><a href="#pem" class="headerlink" title=".pem"></a>.pem</h4><p>见<a href="#pem">证书编码-Pem</a>, 我有一个以”-BEGIN…”为前缀的ASCII(Base64)数据格式的证书。</p><h4 id="der-der格式的证书"><a href="#der-der格式的证书" class="headerlink" title=".der(der格式的证书)"></a>.der(der格式的证书)</h4><p>见<a href="#der">证书编码-Der</a>, 我有一个”DER编码的证书”,而不是”我有一个DER证书”。</p><h4 id="csr-通过该文件去向CA机构签发证书"><a href="#csr-通过该文件去向CA机构签发证书" class="headerlink" title=".csr(通过该文件去向CA机构签发证书)"></a>.csr(通过该文件去向CA机构签发证书)</h4><p>证书请求，网站生成请求供CA签发证书使用</p><h4 id="req-申请证书时发送给CA认证机构的请求文件"><a href="#req-申请证书时发送给CA认证机构的请求文件" class="headerlink" title=".req(申请证书时发送给CA认证机构的请求文件)"></a>.req(申请证书时发送给CA认证机构的请求文件)</h4><p>含义和<code>.csr</code>等同</p><h4 id="crt-per格式的证书"><a href="#crt-per格式的证书" class="headerlink" title=".crt(per格式的证书)"></a>.crt(per格式的证书)</h4><p>常用于<strong>linux</strong>系统，表示我是一个”可以被pem或der编码的证书”，<code>crt</code>和<code>cer</code>含义基本相同</p><h4 id="cer"><a href="#cer" class="headerlink" title=".cer"></a>.cer</h4><p>常用于<strong>windows</strong>系统，表示我是一个”可以被pem或der编码的证书”, <code>crt</code>和<code>cer</code>含义基本相同,windows下可以将crt导出成cer</p><h4 id="p12-Pkcs-12"><a href="#p12-Pkcs-12" class="headerlink" title=".p12(Pkcs#12)"></a>.p12(Pkcs#12)</h4><ul><li>Pkcs#1 RSA格式的公私或私钥 </li><li>Pkcs#8 相比pkcs#1而言不仅仅是RSA格式的更通用的公私或私钥</li><li>Pkcs#12 记录对称的公钥和私钥 </li></ul><h4 id="jks-Java-Key-Store-证书钱包"><a href="#jks-Java-Key-Store-证书钱包" class="headerlink" title=".jks(Java Key Store,证书钱包)"></a>.jks(Java Key Store,证书钱包)</h4><h4 id="keystore-jks的常用名"><a href="#keystore-jks的常用名" class="headerlink" title=".keystore(jks的常用名)"></a>.keystore(jks的常用名)</h4><h3 id="证书工具"><a href="#证书工具" class="headerlink" title="证书工具"></a>证书工具</h3><h4 id="Jdk-keytool"><a href="#Jdk-keytool" class="headerlink" title="Jdk keytool"></a>Jdk keytool</h4><p>Jdk提供的证书工具，常用于java或tomcat程序</p><h4 id="OpenSSL"><a href="#OpenSSL" class="headerlink" title="OpenSSL"></a>OpenSSL</h4><p>通用证书工具,见<a href="./openssl.md">OpenSSL</a></p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><h4 id="查看证书文件内容（只针对证书文件，不包含公私钥）"><a href="#查看证书文件内容（只针对证书文件，不包含公私钥）" class="headerlink" title="查看证书文件内容（只针对证书文件，不包含公私钥）"></a>查看证书文件内容（只针对证书文件，不包含公私钥）</h4><ul><li>der:<code>openssl x509 -in es190.crt -inform der -text –noout</code></li><li>pem:<code>openssl x509 -in es190.crt -text –noout</code></li></ul><h4 id="生成p12证书"><a href="#生成p12证书" class="headerlink" title="生成p12证书"></a>生成p12证书</h4><p><code>openssl pkcs12 -export -in 公钥.pem -inkey 私钥.pem -out admin.p12</code><br>(只能是pem编码，不能是der的)</p><h4 id="转换证书格式（只针对证书文件，不包含公私钥）"><a href="#转换证书格式（只针对证书文件，不包含公私钥）" class="headerlink" title="转换证书格式（只针对证书文件，不包含公私钥）"></a>转换证书格式（只针对证书文件，不包含公私钥）</h4><ul><li><strong>pem-&gt;der</strong>:<code>openssl x509 -in cert.crt -outform der-out cert.der</code></li><li><strong>der-&gt;pem</strong>:<code>openssl x509 -in cert.crt -inform der -outform pem -out cert.pem</code></li><li><strong>jks-&gt;p12</strong>:<code>keytool -importkeystore -srckeystore eastcom -srcstoretype jks -destkeystore eastcom.p12 -deststoretype pkcs12</code></li><li><strong>p12-&gt;jks</strong>:<code>keytool -importkeystore -srckeystore eastcom.p12 -srcstoretype PKCS12 -deststoretype JKS -destkeystore es.jks</code></li><li><strong>p12-&gt;crt</strong>:<code>openssl pkcs12 -in client.p12 -clcerts -nokeys -out client.crt</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 证书 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 证书 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql EXPLAIN说明</title>
      <link href="/2020/09/12/database/EXPLAIN%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E/"/>
      <url>/2020/09/12/database/EXPLAIN%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 align="center">EXPLAIN说明</h2><table class="a164" border="1" cellspacing="0" cellpadding="0">    <tbody>    <tr>        <th>列名</th>        <th>类型</th>        <th>解释</th>    </tr>    <tr>        <td>id</td>        <td>&nbsp;</td>        <td>SELECT语句的ID编号,优先执行编号较大的查询,如果编号相同,则从上向下执行</td>    </tr>    <tr>        <td rowspan="8">select_type</td>        <td>SIMPLE</td>        <td>一条没有UNION或子查询部分的SELECT语句</td>    </tr>    <tr>        <td>PIMARY</td>        <td>最外层或最左侧的SELECT语句</td>    </tr>    <tr>        <td>UNION</td>        <td>UNION语句里的第二条或最后一条SELECT语句</td>    </tr>    <tr>        <td>DEPENDENT UNION</td>        <td>和UNION类型的含义相似,但需要依赖于某个外层查询</td>    </tr>    <tr>        <td>UNION RESULT</td>        <td>一条UNION语句的结果</td>    </tr>    <tr>        <td>SUBQUERY</td>        <td>子查询中的第一个SELECT子句</td>    </tr>    <tr>        <td>DEPENDENT SUBQUERY</td>        <td>和SUBQUERY类型的含义相似,但需要依赖于某个外层查询</td>    </tr>    <tr>        <td>DERIVED</td>        <td>FROM子句里的子查询</td>    </tr>    <tr>        <td>table</td>        <td>t1</td>        <td>各输出行里的信息是关于哪个数据表的</td>    </tr>    <tr>        <td>Partitions</td>        <td>NULL</td>        <td>将要使用的分区.只有EXPLAIN PARTITIONS ...语句才会显示这一列.非分区表显示为NULL</td>    </tr>    <tr>        <td rowspan="13">type</td>        <td>&nbsp;</td>        <td>联接操作的类型,<b>性能由好到差</b>依次如下</td>    </tr>        <tr>        <td>NULL</td>        <td>MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成</td>    </tr>    <tr>        <td>system</td>        <td>表中仅有一行</td>    </tr>    <tr>        <td>const</td>        <td>单表中最多有一个匹配行</td>    </tr>    <tr>        <td>eq_ref</td>        <td>联接查询中,对于前表的每一行,在此表中只查询一条记录,使用了PRIMARY或UNIQUE</td>    </tr>    <tr>        <td>ref</td>        <td>联接查询中,对于前表的每一行,在此表中只查询一条记录,使用了INDEX</td>    </tr>    <tr>        <td>ref_or_null</td>        <td>联接查询中,对于前表的每一行,在此表中只查询一条记录,使用了INDEX,但是条件中有NULL值查询</td>    </tr>    <tr>        <td>index_merge</td>        <td>多个索引合并</td>    </tr>    <tr>        <td>unique_subquery</td>        <td>举例说明: value IN (SELECT primary_key FROM single_table WHERE some_expr)</td>    </tr>    <tr>        <td>index_subquery</td>        <td>举例说明: value IN (SELECT key_column FROM single_table WHERE some_expr)</td>    </tr>    <tr>        <td>range</td>        <td>只检索给定范围的行,包括如下操作符: =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, or IN()</td>    </tr>    <tr>        <td>index</td>        <td>扫描索引树(略比ALL快,因为索引文件通常比数据文件小)</td>    </tr>    <tr>        <td>ALL</td>        <td>前表的每一行数据都要跟此表匹配,全表扫描</td>    </tr>    <tr>        <td>possible_keys</td>        <td>NULL</td>        <td>MySQL认为在可能会用到的索引.NULL表示没有找到索引</td>    </tr>    <tr>        <td>key</td>        <td>NULL</td>        <td>检索时,实际用到的索引名称.如果用了index_merge联接类型,此时会列出多个索引名称,NULL表示没有找到索引</td>    </tr>    <tr>        <td>key_len</td>        <td>NULL</td>        <td>实际使用的索引的长度.如果是复合索引,那么只显示使用的最左前缀的大小</td>    </tr>    <tr>        <td>ref</td>        <td>NULL</td>        <td>MySQL用来与索引值比较的值, 如果是单词const或者???,则表示比较对象是一个常数.如果是某个数据列的名称,则表示比较操作是逐个数据列进行的.NULL表示没有使用索引</td>    </tr>    <tr>        <td>rows</td>        <td>&nbsp;</td>        <td>MySQL为完成查询而需要在数据表里检查的行数的估算值.这个输出列里所有的值的乘积就是必须检查的数据行的各种可能组合的估算值</td>    </tr>    <tr>        <td rowspan="4">Extra</td>        <td>Using filesort</td>        <td>需要将索引值写到文件中并且排序,这样按顺序检索相关数据行</td>    </tr>    <tr>        <td>Using index</td>        <td>MySQL可以不必检查数据文件, 只使用索引信息就能检索数据表信息</td>    </tr>    <tr>        <td>Using temporary</td>        <td>在使用 GROUP BY 或 ORDER BY 时,需要创建临时表,保存中间结果集</td>    </tr>    <tr>        <td>Using where</td>        <td>利用SELECT语句中的WHERE子句里的条件进行检索操作</td>    </tr>    </tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch</title>
      <link href="/2020/09/07/database/ElasticSearch/"/>
      <url>/2020/09/07/database/ElasticSearch/</url>
      
        <content type="html"><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="Node-与-Cluster"><a href="#Node-与-Cluster" class="headerlink" title="Node 与 Cluster"></a>Node 与 Cluster</h3><ul><li>Elastic 本质上是一个分布式数据库，允许多台服务器协同工作，每台服务器可以运行多个 Elastic 实例。</li><li>单个 Elastic 实例称为一个节点（node）。一组节点构成一个集群（cluster）。</li></ul><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><ul><li>Elastic 会索引所有字段，经过处理后写入一个反向索引（Inverted Index）。查找数据的时候，直接查找该索引。</li><li>所以，Elastic 数据管理的顶层单位就叫做 Index（索引）。它是单个数据库的同义词。每个 Index （即数据库）的名字必须是小写。</li><li>下面的命令可以查看当前节点的所有 Index:<code>$ curl -X GET &#39;http://localhost:9200/_cat/indices?v&#39;</code></li></ul><h3 id="Document"><a href="#Document" class="headerlink" title="Document"></a>Document</h3><ul><li>Index 里面单条的记录称为 Document（文档）。许多条 Document 构成了一个 Index。</li><li>Document 使用 JSON 格式表示，下面是一个例子。  <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;user&quot;</span>: <span class="string">&quot;张三&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;title&quot;</span>: <span class="string">&quot;工程师&quot;</span>,</span><br><span class="line">    <span class="attr">&quot;desc&quot;</span>: <span class="string">&quot;数据库管理&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>同一个 Index 里面的 Document，不要求有相同的结构（scheme），但是最好保持相同，这样有利于提高搜索效率。</li></ul><h3 id="Type"><a href="#Type" class="headerlink" title="Type"></a>Type</h3><ul><li>Document 可以分组，比如weather这个 Index 里面，可以按城市分组（北京和上海），也可以按气候分组（晴天和雨天）。这种分组就叫做 Type，它是虚拟的逻辑分组，用来过滤 Document。</li><li>type 指定只能是<code>_doc</code>值，同时也是不支持多 type 的</li></ul><h3 id="索引-Index、类型-Type-和文档-Document"><a href="#索引-Index、类型-Type-和文档-Document" class="headerlink" title="索引 Index、类型 Type 和文档 Document"></a>索引 Index、类型 Type 和文档 Document</h3><p>对比我们比较熟悉的 MySQL 数据库：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">index → db</span><br><span class="line">type → table</span><br><span class="line">document → row</span><br></pre></td></tr></table></figure><h2 id="ES-SQL-6-3版本后支持"><a href="#ES-SQL-6-3版本后支持" class="headerlink" title="ES SQL(6.3版本后支持)"></a><a href="http://blog.itpub.net/31559359/viewspace-2285170/">ES SQL(6.3版本后支持)</a></h2><p><a href="https://elasticsearch.cn/article/687">玩转 Elasticsearch 的 SQL 功能</a></p><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># format类型有：json,yaml,smile,cbor,txt,csv,tsv,默认为json格式</span><br><span class="line"># fetch_size 每页返回多少个结果</span><br><span class="line"># <span class="operator">/</span>_sql、_sql两种都可以</span><br><span class="line">POST _sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&quot;select id,name,pwd,sex from \&quot;index<span class="operator">-</span><span class="keyword">user</span><span class="number">-2020.09</span><span class="number">.08</span>\&quot; where sex=1&quot;,</span><br><span class="line">  &quot;fetch_size&quot;:<span class="number">20</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配索引名称"><a href="#匹配索引名称" class="headerlink" title="匹配索引名称"></a><a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.6/date-math-index-names.html">匹配索引名称</a></h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&quot;select id,name,pwd,sex from \&quot;<span class="operator">&lt;</span>index<span class="operator">-</span><span class="keyword">user</span><span class="operator">-</span>&#123;now<span class="operator">/</span>d&#125;<span class="operator">&gt;</span>\&quot; where sex=1&quot;,</span><br><span class="line">  &quot;fetch_size&quot;:<span class="number">20</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多索引查询"><a href="#多索引查询" class="headerlink" title="多索引查询"></a>多索引查询</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> _sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&quot;select id,name,pwd,sex from \&quot;index<span class="operator">-</span><span class="keyword">user</span><span class="number">-2020.09</span><span class="number">.08</span>,index<span class="operator">-</span><span class="keyword">user</span><span class="number">-2020.09</span><span class="number">.09</span>,index<span class="operator">-</span><span class="keyword">user</span><span class="operator">-</span><span class="operator">*</span>,\&quot; where sex=1&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="将SQL转化为DSL"><a href="#将SQL转化为DSL" class="headerlink" title="将SQL转化为DSL"></a>将SQL转化为DSL</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST _sql<span class="operator">/</span>translate</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&quot;select id,name,pwd,sex from \&quot;index<span class="operator">-</span><span class="keyword">user</span><span class="number">-2020.09</span><span class="number">.08</span>\&quot; where sex=1&quot;,</span><br><span class="line">  &quot;fetch_size&quot;:<span class="number">20</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SQL和DSL混合使用"><a href="#SQL和DSL混合使用" class="headerlink" title="SQL和DSL混合使用"></a>SQL和DSL混合使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">POST _sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&quot;select id,name,pwd,sex from \&quot;index<span class="operator">-</span><span class="keyword">user</span><span class="number">-2020.09</span><span class="number">.08</span>\&quot; where sex=1&quot;,</span><br><span class="line">  &quot;filter&quot;: &#123;</span><br><span class="line">    &quot;match&quot;: &#123;</span><br><span class="line">      &quot;id&quot;: <span class="number">1065706171</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;fetch_size&quot;:<span class="number">20</span> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="fetch-size游标的使用"><a href="#fetch-size游标的使用" class="headerlink" title="fetch_size游标的使用"></a>fetch_size游标的使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> _sql</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&quot;select * from weather&quot;,</span><br><span class="line">  &quot;fetch_size&quot;:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;columns&quot;:[&#123;&quot;name&quot;:&quot;name&quot;,&quot;type&quot;:&quot;text&quot;&#125;],&quot;rows&quot;:[[&quot;John Doe1&quot;],[&quot;John Doe2&quot;]],&quot;cursor&quot;:&quot;w7ysAwFzQERYRjFaWEo1UVc1a1JtVjBZMmdCQUFBQUFBSHp2bVVXU2pkdFRtMXpkMGRSTVcxaE1IRlljV3BLT0haMmR3PT3/////DwEBZgRuYW1lAQR0ZXh0AVoAAAABAQ==&quot;&#125;</span><br></pre></td></tr></table></figure><p>将获取到的cursor用于下次查询</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">GET</span> _sql</span><br><span class="line">&#123;</span><br><span class="line">  &quot;cursor&quot;:&quot;w7ysAwFzQERYRjFaWEo1UVc1a1JtVjBZMmdCQUFBQUFBSHp3OTRXU2pkdFRtMXpkMGRSTVcxaE1IRlljV3BLT0haMmR3PT3/////DwEBZgRuYW1lAQR0ZXh0AVoAAAABAQ==&quot;,</span><br><span class="line">  &quot;fetch_size&quot;:<span class="number">2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="占位符的使用"><a href="#占位符的使用" class="headerlink" title="占位符的使用"></a>占位符的使用</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="operator">/</span>_sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">&quot;query&quot;: &quot;SELECT YEAR(release_date) AS year FROM library WHERE page_count &gt; ? AND author = ? GROUP BY year HAVING COUNT(*) &gt; ?&quot;,</span><br><span class="line">&quot;params&quot;: [<span class="number">300</span>, &quot;Frank Herbert&quot;, <span class="number">0</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用DESCRIBE语句查看表（ES中为索引）中有哪些字段"><a href="#使用DESCRIBE语句查看表（ES中为索引）中有哪些字段" class="headerlink" title="使用DESCRIBE语句查看表（ES中为索引）中有哪些字段"></a>使用DESCRIBE语句查看表（ES中为索引）中有哪些字段</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="operator">/</span>_sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;DESCRIBE \&quot;index<span class="operator">-</span><span class="keyword">user</span><span class="number">-2020.09</span><span class="number">.08</span>\&quot;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用SHOW-TABLES查看所有的表（ES中为索引）"><a href="#使用SHOW-TABLES查看所有的表（ES中为索引）" class="headerlink" title="使用SHOW TABLES查看所有的表（ES中为索引）"></a>使用SHOW TABLES查看所有的表（ES中为索引）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="operator">/</span>_sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;SHOW TABLES&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询支持的函数"><a href="#查询支持的函数" class="headerlink" title="查询支持的函数"></a>查询支持的函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST <span class="operator">/</span>_sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;SHOW FUNCTIONS&quot;</span><br><span class="line">&#125;</span><br><span class="line">POST <span class="operator">/</span>_sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;: &quot;SHOW FUNCTIONS LIKE &#x27;%DATE%&#x27;&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全文搜索函数Match-全文搜索函数是ES中特有的"><a href="#全文搜索函数Match-全文搜索函数是ES中特有的" class="headerlink" title="全文搜索函数Match()(全文搜索函数是ES中特有的)"></a>全文搜索函数Match()(全文搜索函数是ES中特有的)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用<span class="keyword">MATCH</span>函数查询tag中包含spxm<span class="operator">-</span>mas的记录</span><br><span class="line">POST <span class="operator">/</span>_sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&quot;select id,name,pwd,sex from \&quot;index<span class="operator">-</span><span class="keyword">user</span><span class="number">-2020.09</span><span class="number">.08</span>\&quot; where MATCH(name,&#x27;admin&#x27;) limit 10&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全文搜索函数QUERY"><a href="#全文搜索函数QUERY" class="headerlink" title="全文搜索函数QUERY()"></a>全文搜索函数QUERY()</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 使用QUERY函数查询tag中包含spxm<span class="operator">-</span>mas的记录</span><br><span class="line">POST <span class="operator">/</span>_sql?format<span class="operator">=</span>txt</span><br><span class="line">&#123;</span><br><span class="line">  &quot;query&quot;:&quot;select id,name,pwd,sex from \&quot;index<span class="operator">-</span><span class="keyword">user</span><span class="number">-2020.09</span><span class="number">.08</span>\&quot; where QUERY(&#x27;name:admin&#x27;) limit 10&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用SQL-CLI"><a href="#使用SQL-CLI" class="headerlink" title="使用SQL CLI"></a>使用SQL CLI</h3><p>输入以下命令启动(该命令位于ES的bin目录下)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 没有密码</span></span><br><span class="line">./elasticsearch-sql-cli http://&lt;ip&gt;:9200</span><br><span class="line"><span class="meta">#</span><span class="bash"> 有密码</span></span><br><span class="line">./elasticsearch-sql-cli http://elastic:elastic@&lt;ip&gt;:9200</span><br></pre></td></tr></table></figure><h2 id="HTTP方式查询"><a href="#HTTP方式查询" class="headerlink" title="HTTP方式查询"></a>HTTP方式查询</h2><figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http://&lt;ip&gt;:9200/apigw-*/_search</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql关键字大全</title>
      <link href="/2020/09/05/database/mysql%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E5%85%A8/"/>
      <url>/2020/09/05/database/mysql%E5%85%B3%E9%94%AE%E5%AD%97%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="关键字大全"><a href="#关键字大全" class="headerlink" title="关键字大全"></a>关键字大全</h3><p>在使用MySQL的时候，一般尽量避免用关键字作为表名【如果非要使用这些关键字，则需要在关键前后添加 <code>keyword</code> 反引号以示区分】</p><p>下面列出MySQL所有关键字，希望给使用MySQL的朋友提供一些参考帮助。</p><table><thead><tr><th>ADD</th><th>ALL</th><th>ALTER</th></tr></thead><tbody><tr><td>ANALYZE</td><td>AND</td><td>AS</td></tr><tr><td>ASC</td><td>ASENSITIVE</td><td>BEFORE</td></tr><tr><td>BETWEEN</td><td>BIGINT</td><td>BINARY</td></tr><tr><td>BLOB</td><td>BOTH</td><td>BY</td></tr><tr><td>CALL</td><td>CASCADE</td><td>CASE</td></tr><tr><td>CHANGE</td><td>CHAR</td><td>CHARACTER</td></tr><tr><td>CHECK</td><td>COLLATE</td><td>COLUMN</td></tr><tr><td>CONDITION</td><td>CONNECTION</td><td>CONSTRAINT</td></tr><tr><td>CONTINUE</td><td>CONVERT</td><td>CREATE</td></tr><tr><td>CROSS</td><td>CURRENT_DATE</td><td>CURRENT_TIME</td></tr><tr><td>CURRENT_TIMESTAMP</td><td>CURRENT_USER</td><td>CURSOR</td></tr><tr><td>DATABASE</td><td>DATABASES</td><td>DAY_HOUR</td></tr><tr><td>DAY_MICROSECOND</td><td>DAY_MINUTE</td><td>DAY_SECOND</td></tr><tr><td>DEC</td><td>DECIMAL</td><td>DECLARE</td></tr><tr><td>DEFAULT</td><td>DELAYED</td><td>DELETE</td></tr><tr><td>DESC</td><td>DESCRIBE</td><td>DETERMINISTIC</td></tr><tr><td>DISTINCT</td><td>DISTINCTROW</td><td>DIV</td></tr><tr><td>DOUBLE</td><td>DROP</td><td>DUAL</td></tr><tr><td>EACH</td><td>ELSE</td><td>ELSEIF</td></tr><tr><td>ENCLOSED</td><td>ESCAPED</td><td>EXISTS</td></tr><tr><td>EXIT</td><td>EXPLAIN</td><td>FALSE</td></tr><tr><td>FETCH</td><td>FLOAT</td><td>FLOAT4</td></tr><tr><td>FLOAT8</td><td>FOR</td><td>FORCE</td></tr><tr><td>FOREIGN</td><td>FROM</td><td>FULLTEXT</td></tr><tr><td>GOTO</td><td>GRANT</td><td>GROUP</td></tr><tr><td>HAVING</td><td>HIGH_PRIORITY</td><td>HOUR_MICROSECOND</td></tr><tr><td>HOUR_MINUTE</td><td>HOUR_SECOND</td><td>IF</td></tr><tr><td>IGNORE</td><td>IN</td><td>INDEX</td></tr><tr><td>INFILE</td><td>INNER</td><td>INOUT</td></tr><tr><td>INSENSITIVE</td><td>INSERT</td><td>INT</td></tr><tr><td>INT1</td><td>INT2</td><td>INT3</td></tr><tr><td>INT4</td><td>INT8</td><td>INTEGER</td></tr><tr><td>INTERVAL</td><td>INTO</td><td>IS</td></tr><tr><td>ITERATE</td><td>JOIN</td><td>KEY</td></tr><tr><td>KEYS</td><td>KILL</td><td>LABEL</td></tr><tr><td>LEADING</td><td>LEAVE</td><td>LEFT</td></tr><tr><td>LIKE</td><td>LIMIT</td><td>LINEAR</td></tr><tr><td>LINES</td><td>LOAD</td><td>LOCALTIME</td></tr><tr><td>LOCALTIMESTAMP</td><td>LOCK</td><td>LONG</td></tr><tr><td>LONGBLOB</td><td>LONGTEXT</td><td>LOOP</td></tr><tr><td>LOW_PRIORITY</td><td>MATCH</td><td>MEDIUMBLOB</td></tr><tr><td>MEDIUMINT</td><td>MEDIUMTEXT</td><td>MIDDLEINT</td></tr><tr><td>MINUTE_MICROSECOND</td><td>MINUTE_SECOND</td><td>MOD</td></tr><tr><td>MODIFIES</td><td>NATURAL</td><td>NOT</td></tr><tr><td>NO_WRITE_TO_BINLOG</td><td>NULL</td><td>NUMERIC</td></tr><tr><td>ON</td><td>OPTIMIZE</td><td>OPTION</td></tr><tr><td>OPTIONALLY</td><td>OR</td><td>ORDER</td></tr><tr><td>OUT</td><td>OUTER</td><td>OUTFILE</td></tr><tr><td>PRECISION</td><td>PRIMARY</td><td>PROCEDURE</td></tr><tr><td>PURGE</td><td>RAID0</td><td>RANGE</td></tr><tr><td>READ</td><td>READS</td><td>REAL</td></tr><tr><td>REFERENCES</td><td>REGEXP</td><td>RELEASE</td></tr><tr><td>RENAME</td><td>REPEAT</td><td>REPLACE</td></tr><tr><td>REQUIRE</td><td>RESTRICT</td><td>RETURN</td></tr><tr><td>REVOKE</td><td>RIGHT</td><td>RLIKE</td></tr><tr><td>SCHEMA</td><td>SCHEMAS</td><td>SECOND_MICROSECOND</td></tr><tr><td>SELECT</td><td>SENSITIVE</td><td>SEPARATOR</td></tr><tr><td>SET</td><td>SHOW</td><td>SMALLINT</td></tr><tr><td>SPATIAL</td><td>SPECIFIC</td><td>SQL</td></tr><tr><td>SQLEXCEPTION</td><td>SQLSTATE</td><td>SQLWARNING</td></tr><tr><td>SQL_BIG_RESULT</td><td>SQL_CALC_FOUND_ROWS</td><td>SQL_SMALL_RESULT</td></tr><tr><td>SSL</td><td>STARTING</td><td>STRAIGHT_JOIN</td></tr><tr><td>TABLE</td><td>TERMINATED</td><td>THEN</td></tr><tr><td>TINYBLOB</td><td>TINYINT</td><td>TINYTEXT</td></tr><tr><td>TO</td><td>TRAILING</td><td>TRIGGER</td></tr><tr><td>TRUE</td><td>UNDO</td><td>UNION</td></tr><tr><td>UNIQUE</td><td>UNLOCK</td><td>UNSIGNED</td></tr><tr><td>UPDATE</td><td>USAGE</td><td>USE</td></tr><tr><td>USING</td><td>UTC_DATE</td><td>UTC_TIME</td></tr><tr><td>UTC_TIMESTAMP</td><td>VALUES</td><td>VARBINARY</td></tr><tr><td>VARCHAR</td><td>VARCHARACTER</td><td>VARYING</td></tr><tr><td>WHEN</td><td>WHERE</td><td>WHILE</td></tr><tr><td>WITH</td><td>WRITE</td><td>X509</td></tr><tr><td>XOR</td><td>YEAR_MONTH</td><td>ZEROFILL</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EL表达式</title>
      <link href="/2020/09/02/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/09/02/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="EL表达式"><a href="#EL表达式" class="headerlink" title="EL表达式"></a>EL表达式</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><h3 id="什么是EL表达式？"><a href="#什么是EL表达式？" class="headerlink" title="什么是EL表达式？"></a>什么是EL表达式？</h3><p><code>EL</code>(Expression Language,表达式语言),是一种写法非常简洁的表达式，语法简单易懂，便于使用。</p><p>表达式语言的灵感来自于ECMAScript和XPath表达式语言。</p><span id="more"></span><h3 id="EL表达式的作用"><a href="#EL表达式的作用" class="headerlink" title="EL表达式的作用"></a>EL表达式的作用</h3><p>让jsp书写起来更加的方便。简化在jsp中获取作用域数据或者请求数据的写法。也会搭配Jstl来进行使用。</p><h3 id="EL的特点"><a href="#EL的特点" class="headerlink" title="EL的特点"></a>EL的特点</h3><p>EL除了具有语法简单、使用方便的特点，还具有以下特点:</p><ul><li>(1)EL可以与JSTL结合使用，也可以与JavaScript语句结合使用。</li><li>(2)EL中会<strong>自动进行类型转换</strong>。如果想通过EL输入两个字符串型数值(例如，number1和number2)的和，可以直接通过<code>+</code>号进行连接(例如，<code>$&#123;number1+number2&#125;</code>)。</li><li>(3)EL不仅可以访问一般变量，而且还可以访问JavaBean中的属性以及嵌套属性和集合对象。</li><li>(4)在EL中可以执行<strong>算术运算</strong>、<strong>逻辑运算</strong>、<strong>关系运算</strong>和<strong>条件运算</strong>等。</li><li>(5)在EL中可以获得命名空间(PageContext对象，它是页面中所有其它内置对象的最大范围的集成对象，通过它可以访问其它内置对象)。</li><li>(6)在使用EL进行除法运算时，如果0作为除数，则返回无穷大Infinity，而不返回错误。</li><li>(7)在EL中可以访问JSP的作用域(request、session、application以及page)。</li><li>(8)扩展函数可以与Java类的静态方法进行映射。</li></ul><h2 id="EL的基本语法"><a href="#EL的基本语法" class="headerlink" title="EL的基本语法"></a>EL的基本语法</h2><h3 id="1、语法结构"><a href="#1、语法结构" class="headerlink" title="1、语法结构"></a>1、语法结构</h3><p>基本语法：<code>$&#123;expression&#125;</code></p><h3 id="2、-与-运算符"><a href="#2、-与-运算符" class="headerlink" title="2、[ ]与.运算符"></a>2、[ ]与.运算符</h3><p>EL提供<code>&quot;.&quot;</code>和<code>&quot;[ ]&quot;</code>两种运算符来存取数据。当要存取的属性名称中包含一些特殊字符，如.或<code>?</code>等并非字母或数字的符号，就一定要使用<code>[ ]</code>。</p><h4 id="1-点号操作符"><a href="#1-点号操作符" class="headerlink" title="(1)点号操作符"></a>(1)点号操作符</h4><p>在使用EL时，EL表达式一般由两部分组成，如<code>$&#123;userInfo.id&#125;</code>，其中，<code>&quot;.&quot;</code>被称作<strong>点号操作符</strong>，在点号操作符左边可以是一个JavaBean对象，也可以是EL隐式对象，点号右边可以是JavaBean属性，也可以是一个映射键。</p><h4 id="2-操作符"><a href="#2-操作符" class="headerlink" title="(2)[ ]操作符"></a>(2)[ ]操作符</h4><p>如果使用EL操作数据组，则使用<code>&quot;.&quot;</code>操作符就不能进行有效的操作，这时应该使用<code>&quot;[ ]&quot;</code>，如<code>$&#123;list[0]&#125;</code>。但是这并不代表<code>&quot;[ ]&quot;</code>只能操作数组，<code>&quot;.&quot;</code>操作符可以操作的对象，都可以使用<code>&quot;[ ]&quot;</code>来进行操作，如<code>$&#123;userInfo[&quot;id&quot;]&#125;</code>，注意使用<code>&quot;[ ]&quot;</code>操作符时，<code>&quot;[ ]&quot;</code>中必须包含有<code>&quot; &quot;</code>双引号(操作数组也可以写成<code>$&#123;list[&quot;0&quot;]&#125;</code>，等价于<code>$&#123;list[0]&#125;</code>)。</p><p>但是也不是所有情况都可以相互替代，例如，当对象的属性名中包括一些特殊的符号(<code>-</code>或<code>.</code>)时，就只能使用<code>&quot;[ ]&quot;</code>运算符来访问对象的属性。例如，<code>$&#123;userInfo[&quot;user-id&quot;]&#125;</code>是正确的，而<code>$&#123;userInfo.user-id&#125;</code>则是错误的。另外，EL的<code>&quot;[ ]&quot;</code>运算符还有一个用途，就是用来获取<strong>数组</strong>或者<strong>List集合</strong>中的数据。</p><h3 id="3、保留的关键字"><a href="#3、保留的关键字" class="headerlink" title="3、保留的关键字"></a>3、保留的关键字</h3><p>同Java一样，EL也有自己的保留关键字，在为变量命名时，应该避免使用这些关键字，包括在使用EL输出已经保存在作用域范围内的变量，也不能使用关键字，如果已经定义了，那么需要修改为其它的变量名。EL的保留关键字如下所示。</p><ul><li>and or not eq gt lt ge le </li><li>instanceof div false empty  </li></ul><h3 id="4、获取对象中的数据"><a href="#4、获取对象中的数据" class="headerlink" title="4、获取对象中的数据"></a>4、获取对象中的数据</h3><h4 id="普通对象"><a href="#普通对象" class="headerlink" title="普通对象"></a>普通对象</h4><ul><li><code>$&#123;键名.属性名.属性名...&#125;</code><h4 id="集合对象"><a href="#集合对象" class="headerlink" title="集合对象"></a>集合对象</h4></li><li>list集合:<code>$&#123;键名[下标]&#125;</code></li><li>map集合:<code>$&#123;键名.map集合存储的键名&#125;</code><h4 id="访问JavaBean对象"><a href="#访问JavaBean对象" class="headerlink" title="访问JavaBean对象"></a>访问JavaBean对象</h4></li><li>可以写成以下两种形式：<ul><li><code>$&#123;user.id&#125;</code></li><li><code>$&#123;user[&quot;id&quot;]&#125;</code></li></ul></li></ul><h3 id="4、EL表达式运算符"><a href="#4、EL表达式运算符" class="headerlink" title="4、EL表达式运算符"></a>4、EL表达式运算符</h3><ul><li>1、<strong>算术运算符</strong>：加(+)、减(-)、乘(*)、除(/或div)、取余(%或mod)。</li><li>2、<strong>逻辑运算符</strong>：与(&amp;&amp;或and)、或(||或or)、非(!或not)。</li><li>3、<strong>关系运算符</strong>：等于(==或eq)、大于(&gt;或gt)、小于(&lt;或lt)、大于等于(&gt;=或ge)、小于等于(&lt;=或le)、不等于(!=或ne)。</li><li>4、<strong>empty运算符</strong>：判断JSP作用域中是否有相应的数据，如果没有返回为true，反之为false。</li><li>5、**条件运算符(三目运算符)**：表达式1?表达式2:表达式3</li></ul><h4 id="例如："><a href="#例如：" class="headerlink" title="例如："></a>例如：</h4><ul><li><strong>逻辑运算</strong>：<code>$&#123;4&gt;2&#125;</code> -&gt; true</li><li><strong>算术运算</strong>：<code>$&#123;1+2&#125;</code> -&gt; 3 、<code>$&#123;1+&#39;2&#39;&#125;</code> -&gt; 3</li><li><strong>关系运算</strong>：<code>$&#123;4==2&#125;</code> -&gt; false</li><li><strong>三目运算</strong>：<code>$&#123;sex==1?&#39;男&#39;:&#39;女&#39;&#125;</code> -&gt; 女</li><li>注意：<code>&quot;+&quot;</code>号在EL表达式中默认做<strong>加法</strong>运算，不做字符串连接。使用EL表达式进行字符串连接会报错。</li><li><strong>EL的空值判断</strong>：<ul><li>语法格式：<code>$&#123;empty 键名&#125;</code>，<code>$&#123;not empty 键名&#125;</code></li><li>作用：判断键名对象的值是否存有数据。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> EL表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> EL表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务@Transactional详解</title>
      <link href="/2020/09/01/%E4%BA%8B%E5%8A%A1@Transactional%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/"/>
      <url>/2020/09/01/%E4%BA%8B%E5%8A%A1@Transactional%E8%AF%A6%E8%A7%A3%E5%8F%8A%E5%A4%B1%E6%95%88%E5%9C%BA%E6%99%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="Transactional详解"><a href="#Transactional详解" class="headerlink" title="@Transactional详解"></a>@Transactional详解</h1><h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p><code>@Transactional</code>注解相信大家并不陌生，平时开发中很常用的一个注解，它能保证方法内多个数据库操作<strong>要么同时成功、要么同时失败</strong>。使用<code>@Transactional</code>注解时需要注意许多的细节，不然你会发现<code>@Transactional</code>总是莫名其妙的就失效了。</p><span id="more"></span><h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><p>事务管理在系统开发中是不可缺少的一部分，Spring提供了很好事务管理机制，主要分为<strong>编程式事务</strong>和<strong>声明式事务</strong>两种。</p><h3 id="编程式事务"><a href="#编程式事务" class="headerlink" title="编程式事务"></a>编程式事务</h3><p>是指在代码中手动的管理事务的提交、回滚等操作，<strong>代码侵入性比较强</strong>，如下示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">    transactionManager.commit(status);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    transactionManager.rollback(status);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> InvoiceApplyException(<span class="string">&quot;异常失败&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h3><p>基于AOP面向切面的，它将具体业务与事务处理部分解耦，<strong>代码侵入性很低</strong>，所以在实际开发中声明式事务用的比较多。声明式事务也有两种实现方式，一是基于TX和AOP的xml配置文件方式，二种就是基于@Transactional注解了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、-Transactional介绍"><a href="#二、-Transactional介绍" class="headerlink" title="二、@Transactional介绍"></a>二、@Transactional介绍</h2><h3 id="1、-Transactional注解可以作用于哪些地方？"><a href="#1、-Transactional注解可以作用于哪些地方？" class="headerlink" title="1、@Transactional注解可以作用于哪些地方？"></a>1、@Transactional注解可以作用于哪些地方？</h3><p><code>@Transactional</code>可以作用在<strong>接口</strong>、<strong>类</strong>、<strong>类方法</strong>。</p><ul><li>作用于类：当把<code>@Transactional</code>注解放在类上时，表示所有该类的public方法都配置相同的事务属性信息。</li><li>作用于方法：当类配置了<code>@Transactional</code>，方法也配置了<code>@Transactional</code>，方法的事务会覆盖类的事务配置信息。</li><li>作用于接口：<del>不推荐这种使用方法，因为一旦标注在Interface上并且配置了Spring AOP 使用CGLib动态代理，将会导致@Transactional注解失效</del><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MybatisPlusController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> CityInfoDictMapper cityInfoDictMapper;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Transactional(rollbackFor = Exception.class)</span></span><br><span class="line">    <span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        CityInfoDict cityInfoDict = <span class="keyword">new</span> CityInfoDict();</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setCityLevel(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setCityCode(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">        <span class="keyword">return</span> insert + <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、-Transactional注有哪些属性？"><a href="#2、-Transactional注有哪些属性？" class="headerlink" title="2、@Transactional注有哪些属性？"></a>2、@Transactional注有哪些属性？</h3></li></ul><h4 id="propagation属性"><a href="#propagation属性" class="headerlink" title="propagation属性"></a>propagation属性</h4><p><code>propagation</code>代表<strong>事务的传播行为</strong>，默认值为<code>Propagation.REQUIRED</code>，其他的属性信息如下：</p><ul><li><code>Propagation.REQUIRED</code>：<ul><li>如果当前<strong>存在</strong>事务，则<strong>加入</strong>该事务;</li><li>如果当前<strong>不存在</strong>事务，则<strong>创建</strong>一个新的事务。</li><li>也就是说如果A方法和B方法都添加了注解，在默认传播模式下，A方法内部调用B方法，会把两个方法的事务合并为一个事务</li></ul></li><li><code>Propagation.SUPPORTS</code>：<ul><li>如果当前<strong>存在</strong>事务，则<strong>加入</strong>该事务;</li><li>如果当前<strong>不存在</strong>事务，则<strong>以非事务的方式</strong>继续运行。</li></ul></li><li><code>Propagation.MANDATORY</code>：<ul><li>如果当前<strong>存在</strong>事务，则<strong>加入</strong>该事务;</li><li>如果当前<strong>不存在</strong>事务，则<strong>抛出异常</strong>。</li></ul></li><li><code>Propagation.REQUIRES_NEW</code>：<ul><li><strong>重新创建</strong>一个新的事务，如果<strong>当前存在</strong>事务，<strong>暂停</strong>当前的事务。</li><li>当类A中的a方法用默认<code>Propagation.REQUIRED</code>模式，类B中的b方法加上采用<code>Propagation.REQUIRES_NEW</code>模式，然后在a方法中调用b方法操作数据库，然而a方法抛出异常后，b方法并没有进行回滚，因为<code>Propagation.REQUIRES_NEW</code>会暂停a方法的事务</li></ul></li><li><code>Propagation.NOT_SUPPORTED</code>：<ul><li>以<strong>非事务的方式</strong>运行，如果<strong>当前存在</strong>事务，<strong>暂停</strong>当前的事务。</li></ul></li><li><code>Propagation.NEVER</code>：<ul><li>以<strong>非事务的方式</strong>运行，如果<strong>当前存在</strong>事务，则<strong>抛出异常</strong>。</li></ul></li><li><code>Propagation.NESTED</code>：<ul><li>和<code>Propagation.REQUIRED</code>效果一样。</li></ul></li></ul><h4 id="isolation-属性"><a href="#isolation-属性" class="headerlink" title="isolation 属性"></a>isolation 属性</h4><p><code>isolation</code>：<strong>事务的隔离级别</strong>，默认值为<code>Isolation.DEFAULT</code>。</p><ul><li><code>Isolation.DEFAULT</code>：使用底层数据库默认的隔离级别。</li><li><code>Isolation.READ_UNCOMMITTED</code></li><li><code>Isolation.READ_COMMITTED</code></li><li><code>Isolation.REPEATABLE_READ</code></li><li><code>Isolation.SERIALIZABLE</code></li></ul><h4 id="timeout-属性"><a href="#timeout-属性" class="headerlink" title="timeout 属性"></a>timeout 属性</h4><p><code>timeout</code>：<strong>事务的超时时间</strong>，默认值为<code>-1</code>。<strong>如果超过该时间限制但事务还没有完成，则自动回滚事务</strong>。</p><h4 id="readOnly-属性"><a href="#readOnly-属性" class="headerlink" title="readOnly 属性"></a>readOnly 属性</h4><p><code>readOnly</code>：指定<strong>事务是否为只读事务</strong>，默认值为<code>false</code>；为了忽略那些不需要事务的方法，比如读取数据，可以设置<code>read-only</code>为<code>true</code>。</p><h4 id="rollbackFor-属性"><a href="#rollbackFor-属性" class="headerlink" title="rollbackFor 属性"></a>rollbackFor 属性</h4><p><code>rollbackFor</code>：用于<strong>指定能够触发事务回滚的异常类型</strong>，可以指定<strong>多个</strong>异常类型。</p><h4 id="noRollbackFor属性"><a href="#noRollbackFor属性" class="headerlink" title="noRollbackFor属性"></a>noRollbackFor属性</h4><p><code>noRollbackFor</code>：抛出指定的异常类型，<strong>不回滚事务</strong>，也可以指定<strong>多个</strong>异常类型。</p><h2 id="三、-Transactional-失效场景（6种）"><a href="#三、-Transactional-失效场景（6种）" class="headerlink" title="三、@Transactional 失效场景（6种）"></a>三、@Transactional 失效场景（6种）</h2><ul><li><a href="#3.1">1.应用在非 public 修饰的方法上</a></li><li><a href="#3.2">2.@Transactional 注解属性 propagation 设置错误</a></li><li><a href="#3.3">3.@Transactional 注解属性 rollbackFor 设置错误</a></li><li><a href="#3.4">4.同一个类中方法调用,导致@Transactional失效</a></li><li><a href="#3.5">5.异常被你的 try catch “吃了”,导致@Transactional失效</a></li><li><a href="#3.6">6.数据库引擎不支持事务</a></li></ul><h3 id="1-应用在非-public-修饰的方法上"><a href="#1-应用在非-public-修饰的方法上" class="headerlink" title="1.应用在非 public 修饰的方法上"></a>1.应用在非 public 修饰的方法上<span id="3.1"/></h3><p>如果<code>@Transactional</code>应用在<strong>非public</strong>修饰的方法上，Transactional将会失效。</p><p>之所以会失效是因为在<code>Spring AOP</code>代理时，<code>TransactionInterceptor</code>(事务拦截器)在目标方法执行前后进行拦截，<code>DynamicAdvisedInterceptor</code>(CglibAopProxy的内部类)的<code>intercept</code>方法或<code>JdkDynamicAopProxy</code>的<code>invoke</code>方法会间接调用<code>AbstractFallbackTransactionAttributeSource</code>的<code>computeTransactionAttribute</code>方法，获取Transactional注解的事务配置信息。</p><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AbstractFallbackTransactionAttributeSource#computeTransactionAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> TransactionAttribute <span class="title">computeTransactionAttribute</span><span class="params">(Method method,Class&lt;?&gt; targetClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Don&#x27;t allow no-public methods as required.</span></span><br><span class="line">    <span class="keyword">if</span> (allowPublicMethodsOnly() &amp;&amp; !Modifier.isPublic(method.getModifiers())) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>此方法会检查目标方法的修饰符是否为public，不是public则不会获取@Transactional 的属性配置信息</strong>。</p><p>注意：protected、private修饰的方法上使用<code>@Transactional</code>注解，虽然事务无效，但不会有任何报错。</p><h3 id="2-Transactional-注解属性-propagation-设置错误"><a href="#2-Transactional-注解属性-propagation-设置错误" class="headerlink" title="2.@Transactional 注解属性 propagation 设置错误 "></a>2.@Transactional 注解属性 propagation 设置错误 <span id="3.2"/></h3><p>这种失效是由于配置错误，若是错误的配置以下三种<code>propagation</code>，事务将不会发生回滚。</p><ul><li><code>Propagation.SUPPORTS</code>：如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。 </li><li><code>Propagation.NOT_SUPPORTED</code>：以非事务方式运行，如果当前存在事务，则把当前事务挂起。 </li><li><code>Propagation.NEVER</code>：以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><h3 id="3-Transactional-注解属性-rollbackFor-设置错误"><a href="#3-Transactional-注解属性-rollbackFor-设置错误" class="headerlink" title="3.@Transactional 注解属性 rollbackFor 设置错误"></a>3.@Transactional 注解属性 rollbackFor 设置错误<span id="3.3"/></h3><p><code>rollbackFor</code>可以<strong>指定能够触发事务回滚的异常类型</strong>。</p><p>Spring默认抛出了未检查<code>unchecked</code>异常(继承自<code>RuntimeException</code>的异常)或者 <code>Error</code>才回滚事务；其他异常不会触发回滚事务。</p><p>如果在事务中抛出其他类型的异常，但却期望 Spring 能够回滚事务，就需要指定<code>rollbackFor</code>属性。<br><img src="/images/Throwable%E5%88%86%E7%B1%BB.jpg" alt="Throwable分类"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 希望自定义的异常可以进行回滚</span></span><br><span class="line"><span class="meta">@Transactional(rollbackFor= MyException.class)</span></span><br></pre></td></tr></table></figure><h3 id="4-同一个类中方法调用，导致-Transactional失效"><a href="#4-同一个类中方法调用，导致-Transactional失效" class="headerlink" title="4.同一个类中方法调用，导致@Transactional失效"></a>4.同一个类中方法调用，导致@Transactional失效<span id="3.4"/></h3><p>开发中避免不了会对同一个类里面的方法调用，比如有一个类Test，它的一个方法A，A再调用本类的方法B(不论方法B是用public还是private修饰)，但<strong>方法A没有声明注解事务</strong>，而<strong>B方法有</strong>。则外部调用方法A之后，方法B的事务是不会起作用的。这也是经常犯错误的一个地方。</p><p>那为啥会出现这种情况？其实这还是由于使用<code>Spring AOP</code>代理造成的，因为只有当事务方法被当前类以外的代码调用时，才会由Spring生成的代理对象来管理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@Transactional</span></span><br><span class="line"><span class="meta">@GetMapping(&quot;/test&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CityInfoDict cityInfoDict = <span class="keyword">new</span> CityInfoDict();</span><br><span class="line">    cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    <span class="comment">// B 插入字段为 3的数据</span></span><br><span class="line">    <span class="keyword">this</span>.insertB();</span><br><span class="line">    <span class="comment">// A 插入字段为 2的数据</span></span><br><span class="line">    <span class="keyword">int</span> insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">    <span class="keyword">return</span> insert;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional()</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Integer <span class="title">insertB</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    CityInfoDict cityInfoDict = <span class="keyword">new</span> CityInfoDict();</span><br><span class="line">    cityInfoDict.setCityName(<span class="string">&quot;3&quot;</span>);</span><br><span class="line">    cityInfoDict.setParentCityId(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-异常被你的-try-catch-“吃了”-导致-Transactional失效"><a href="#5-异常被你的-try-catch-“吃了”-导致-Transactional失效" class="headerlink" title="5.异常被你的 try catch “吃了”,导致@Transactional失效"></a>5.异常被你的 try catch “吃了”,导致@Transactional失效<span id="3.5"/></h3><p>这种情况是最常见的一种@Transactional注解失效场景.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Transactional</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Integer <span class="title">A</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> insert = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        CityInfoDict cityInfoDict = <span class="keyword">new</span> CityInfoDict();</span><br><span class="line">        cityInfoDict.setCityName(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">        cityInfoDict.setParentCityId(<span class="number">2</span>);</span><br><span class="line">        <span class="comment">// A 插入字段为 2的数据</span></span><br><span class="line">        insert = cityInfoDictMapper.insert(cityInfoDict);</span><br><span class="line">        <span class="comment">// B 插入字段为 3的数据</span></span><br><span class="line">        b.insertB();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果B方法内部抛了异常，而A方法此时try catch了B方法的异常，那这个事务还能正常回滚吗？</p><p>答案：不能！</p><p>会抛出异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.transaction.UnexpectedRollbackException: Transaction rolled back because it has been marked as rollback-only</span><br></pre></td></tr></table></figure><p>因为当<code>ServiceB</code>中抛出了一个异常以后，<code>ServiceB</code>标识当前事务需要<code>rollback</code>。但是<code>ServiceA</code>中由于你手动的捕获这个异常并进行处理，<code>ServiceA</code>认为当前事务应该正常<code>commit</code>。此时就出现了前后不一致，也就是因为这样，抛出了前面的<code>UnexpectedRollbackException</code>异常。</p><p>spring的事务是在调用业务方法之前开始的，业务方法执行完毕之后才执行<code>commit</code>or<code>rollback</code>，事务是否执行取决于是否抛出<code>runtime exception</code>。如果抛出<code>runtime exception</code>并在你的业务方法中没有catch到的话，事务会回滚。</p><p>在业务方法中一般不需要catch异常，如果非要catch一定要抛出<code>throw new RuntimeException()</code>，或者注解中指定抛异常类型<code>@Transactional(rollbackFor=Exception.class)</code>，否则会导致事务失效，数据commit造成数据不一致，所以有些时候<code>try catch</code>反倒会画蛇添足。</p><h3 id="6-数据库引擎不支持事务"><a href="#6-数据库引擎不支持事务" class="headerlink" title="6.数据库引擎不支持事务"></a>6.数据库引擎不支持事务<span id="3.6"/></h3><p>这种情况出现的概率并不高，事务能否生效数据库引擎是否支持事务是关键。常用的MySQL数据库<strong>默认</strong>使用支持事务的<strong>innodb引擎</strong>。一旦数据库引擎切换成不支持事务的myisam，那事务就从根本上失效了。</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MongoDB教程</title>
      <link href="/2020/04/10/database/MongoDB%E5%91%BD%E4%BB%A4/"/>
      <url>/2020/04/10/database/MongoDB%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="MongoDB概念"><a href="#MongoDB概念" class="headerlink" title="MongoDB概念"></a>MongoDB概念</h2><p><a href="https://www.runoob.com/mongodb/mongodb-tutorial.html">MongoDB教程(菜鸟教程)</a></p><ul><li>MongoDB是由C＋＋语言编写的一种NoSQL，是一个基于分布式文件存储的开源数据库系统。</li><li>MongoDB的目的是为Web应用提供可扩展的高性能数据存储解决方案。 </li><li>MongoDB将数据存储为一个文档，数据结构由键值(key-value)对组成。  </li></ul><span id="more"></span><table><thead><tr><th>SQL术语/概念</th><th>MongoDB术语/概念</th><th>解释/说明</th></tr></thead><tbody><tr><td>database</td><td>database</td><td>数据库</td></tr><tr><td>table</td><td>collection</td><td>数据库表/集合</td></tr><tr><td>row</td><td>document</td><td>数据记录行/文档</td></tr><tr><td>column</td><td>field</td><td>数据字段/域</td></tr><tr><td>index</td><td>index</td><td>索引</td></tr><tr><td>table joins</td><td></td><td>表连接,MongoDB不支持</td></tr><tr><td>primary key</td><td>primary key</td><td>主键,MongoDB自动将_id字段设置为主键</td></tr></tbody></table><h3 id="文档-Document"><a href="#文档-Document" class="headerlink" title="文档(Document)"></a>文档(Document)</h3><ul><li>文档是一组键值(key-value)对(即BSON)。MongoDB的文档不需要设置相同的字段，并且相同的字段不需要相同的数据类型，这与关系型数据库有很大的区别，也是MongoDB非常突出的特点。</li><li>需要注意的是：<ul><li>文档中的键/值对是有序的。</li><li>文档中的值不仅可以是在双引号里面的字符串，还可以是其他几种数据类型（甚至可以是整个嵌入的文档)。</li><li>MongoDB区分类型和大小写。</li><li>MongoDB的文档不能有重复的键。</li><li>文档的键是字符串。除了少数例外情况，键可以使用任意UTF-8字符。</li></ul></li><li>文档键命名规范：<ul><li>键不能含有\0 (空字符)。这个字符用来表示键的结尾。</li><li>.和$有特别的意义，只有在特定环境下才能使用。</li><li>以下划线”_”开头的键是保留的(不是严格要求的)。</li></ul></li></ul><h3 id="集合-类似于RDBMS数据库中的表"><a href="#集合-类似于RDBMS数据库中的表" class="headerlink" title="集合(类似于RDBMS数据库中的表)"></a>集合(类似于RDBMS数据库中的表)</h3><ul><li>集合就是MongoDB文档组，类似于RDBMS（关系数据库管理系统：Relational Database Management System)中的表格。</li><li>集合存在于数据库中，集合没有固定的结构，这意味着你在对集合可以插入不同格式和类型的数据，但通常情况下我们插入集合的数据都会有一定的关联性。</li><li>合法的集合名<ul><li>集合名不能是空字符串””。</li><li>集合名不能含有\0字符（空字符)，这个字符表示集合名的结尾。</li><li>集合名不能以”system.”开头，这是为系统集合保留的前缀。</li><li>用户创建的集合名字不能含有保留字符。有些驱动程序的确支持在集合名里面包含，这是因为某些系统生成的集合中包含该字符。除非你要访问这种系统创建的集合，否则千万不要在名字里出现$。</li></ul></li></ul><h3 id="元数据"><a href="#元数据" class="headerlink" title="元数据"></a>元数据</h3><ul><li><p>数据库的信息是存储在集合中。它们使用了系统的命名空间:<code>dbname.system.*</code></p></li><li><p>在MongoDB数据库中名字空间 <dbname>.system.* 是包含多种系统信息的特殊集合(Collection)，如下:</p><table><thead><tr><th>集合命名空间</th><th>描述</th></tr></thead><tbody><tr><td>dbname.system.namespaces</td><td>列出所有名字空间。</td></tr><tr><td>dbname.system.indexes</td><td>列出所有索引。</td></tr><tr><td>dbname.system.profile</td><td>包含数据库概要(profile)信息。</td></tr><tr><td>dbname.system.users</td><td>列出所有可访问数据库的用户。</td></tr><tr><td>dbname.local.sources</td><td>包含复制对端（slave）的服务器信息和状态。</td></tr></tbody></table></li><li><p>对于修改系统集合中的对象有如下限制:</p><ul><li>在插入数据，可以创建索引。但除此之外该表信息是不可变的(特殊的drop index命令将自动更新相关信息)。</li><li>是可修改的。</li><li>是可删除的。</li></ul></li></ul><h3 id="MongoDB-数据类型"><a href="#MongoDB-数据类型" class="headerlink" title="MongoDB 数据类型"></a>MongoDB 数据类型</h3><p>下表为MongoDB中常用的几种数据类型:</p><table><thead><tr><th>数据类型</th><th>描述</th></tr></thead><tbody><tr><td>String</td><td>字符串。存储数据常用的数据类型。在 MongoDB 中，UTF-8 编码的字符串才是合法的。</td></tr><tr><td>Integer</td><td>整型数值。用于存储数值。根据你所采用的服务器，可分为 32 位或 64 位。</td></tr><tr><td>Boolean</td><td>布尔值。用于存储布尔值（真/假）。</td></tr><tr><td>Double</td><td>双精度浮点值。用于存储浮点值。</td></tr><tr><td>Min/Max keys</td><td>将一个值与 BSON（二进制的 JSON）元素的最低值和最高值相对比。</td></tr><tr><td>Array</td><td>用于将数组或列表或多个值存储为一个键。</td></tr><tr><td>Timestamp</td><td>时间戳。记录文档修改或添加的具体时间。</td></tr><tr><td>Object</td><td>用于内嵌文档。</td></tr><tr><td>Null</td><td>用于创建空值。</td></tr><tr><td>Symbol</td><td>符号。该数据类型基本上等同于字符串类型，但不同的是，它一般用于采用特殊符号类型的语言。</td></tr><tr><td>Date</td><td>日期时间。用 UNIX 时间格式来存储当前日期或时间。你可以指定自己的日期时间：创建 Date 对象，传入年月日信息。</td></tr><tr><td>Object ID</td><td>对象 ID。用于创建文档的 ID。</td></tr><tr><td>Binary Data</td><td>二进制数据。用于存储二进制数据。</td></tr><tr><td>Code</td><td>代码类型。用于在文档中存储 JavaScript 代码。</td></tr><tr><td>Regular expression</td><td>正则表达式类型。用于存储正则表达式。</td></tr></tbody></table><h2 id="进入MongoDB后台管理-Shell"><a href="#进入MongoDB后台管理-Shell" class="headerlink" title="进入MongoDB后台管理 Shell"></a>进入MongoDB后台管理 Shell</h2><ul><li><code>mongo</code></li></ul><h2 id="MongoDB命令"><a href="#MongoDB命令" class="headerlink" title="MongoDB命令"></a>MongoDB命令</h2><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><ul><li><code>use &lt;DATABASE_NAME&gt;</code></li></ul><h3 id="查看所有数据库"><a href="#查看所有数据库" class="headerlink" title="查看所有数据库"></a>查看所有数据库</h3><ul><li><code>show dbs</code><br>MongoDB中默认的数据库为test，如果你没有创建新的数据库，集合将存放在test数据库中。</li></ul><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><ul><li><code>db.dropDatabase()</code></li></ul><h3 id="显示当前数据库对象或集合"><a href="#显示当前数据库对象或集合" class="headerlink" title="显示当前数据库对象或集合"></a>显示当前数据库对象或集合</h3><ul><li><code>db</code></li></ul><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="创建集合-类似数据库中的表"><a href="#创建集合-类似数据库中的表" class="headerlink" title="创建集合(类似数据库中的表)"></a>创建集合(类似数据库中的表)</h3><ul><li><p>MongoDB 中使用 createCollection() 方法来创建集合。</p></li><li><p>语法格式：<code>db.createCollection(name, options)</code></p><ul><li><p>参数说明：</p><ul><li>name: 要创建的集合名称</li><li>options: 可选参数, 指定有关内存大小及索引的选项</li></ul></li><li><p>options 可以是如下参数：</p><table><thead><tr><th>字段</th><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>capped</td><td>布尔</td><td>（可选）如果为 true，则创建固定集合。固定集合是指有着固定大小的集合，当达到最大值时，它会自动覆盖最早的文档。<br>当该值为 true 时，必须指定 size 参数。</td></tr><tr><td>autoIndexId</td><td>布尔</td><td>（可选）如为 true，自动在 _id 字段创建索引。默认为 false。</td></tr><tr><td>size</td><td>数值</td><td>（可选）为固定集合指定一个最大值（以字节计）。<br>如果 capped 为 true，也需要指定该字段。</td></tr><tr><td>max</td><td>数值</td><td>（可选）指定固定集合中包含文档的最大数量。</td></tr></tbody></table></li><li><p>在插入文档时，MongoDB 首先检查固定集合的 size 字段，然后检查 max 字段。</p></li></ul></li></ul><h3 id="查看已有集合"><a href="#查看已有集合" class="headerlink" title="查看已有集合"></a>查看已有集合</h3><ul><li><code>show collections</code>或<code>show tables</code>命令.</li></ul><h3 id="删除集合"><a href="#删除集合" class="headerlink" title="删除集合"></a>删除集合</h3><ul><li><code>db.&lt;COLLECTION_NAME&gt;.drop()</code><br>以下实例删除了testdb数据库中的集合site：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> use testdb</span></span><br><span class="line">switched to db testdb</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.createCollection(<span class="string">&quot;lxy&quot;</span>)     <span class="comment"># 先创建集合，类似数据库中的表</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show tables</span></span><br><span class="line">lxy</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.lxy.drop()</span></span><br><span class="line">true</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> show tables</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure></li></ul><h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><h3 id="插入文档-类似于RDBMS数据库中的记录行"><a href="#插入文档-类似于RDBMS数据库中的记录行" class="headerlink" title="插入文档(类似于RDBMS数据库中的记录行)"></a>插入文档(类似于RDBMS数据库中的记录行)</h3><ul><li>文档的数据结构和JSON基本一样。</li><li>所有存储在集合中的数据都是BSON格式。</li><li>BSON是一种类似JSON的二进制形式的存储格式，是Binary JSON的简称。</li><li>MongoDB使用 <strong>insert()</strong> 或 <strong>save()</strong> 方法向集合中插入文档，语法如下：</li><li><code>db.&lt;COLLECTION_NAME&gt;.insert(document)</code></li><li>例子：<br>以下文档可以存储在MongoDB的testdb数据库的col集合中：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">db.col.insert(&#123;title: <span class="string">&#x27;MongoDB 教程&#x27;</span>,</span> </span><br><span class="line">    description: &#x27;MongoDB 是一个 Nosql 数据库&#x27;,</span><br><span class="line">    by: &#x27;菜鸟教程&#x27;,</span><br><span class="line">    url: &#x27;http://www.lxy.com&#x27;,</span><br><span class="line">    tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>以上例子中 col 是我们的集合名，如果该集合不在该数据库中，MongoDB会自动创建该集合并插入文档。</li><li>插入文档你也可以使用 <code>db.&lt;COLLECTION_NAME&gt;.save(document)</code> 命令。如果不指定_id字段save()方法类似于insert()方法。如果指定_id字段，则会更新该_id的数据。</li></ul><h3 id="查看已插入文档"><a href="#查看已插入文档" class="headerlink" title="查看已插入文档"></a>查看已插入文档</h3><ul><li><code>db.&lt;COLLECTION_NAME&gt;.find()</code></li></ul><h3 id="更新文档"><a href="#更新文档" class="headerlink" title="更新文档"></a>更新文档</h3><ul><li>MongoDB使用update()和save()方法来更新集合中的文档。接下来让我们详细来看下两个函数的应用及其区别。</li></ul><h4 id="update-方法"><a href="#update-方法" class="headerlink" title="update()方法"></a><strong>update()方法</strong></h4><p>update()方法用于更新已存在的文档。语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;COLLECTION_NAME&gt;.update(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &lt;update&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     upsert: &lt;boolean&gt;,</span><br><span class="line">     multi: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>参数说明：<ul><li>query : update的查询条件，类似sql update查询内where后面的。</li><li>update : update的对象和一些更新的操作符（如$,$inc…）等，也可以理解为sql update查询内set后面的</li><li>upsert : 可选，这个参数的意思是，如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。</li><li>multi : 可选，mongodb 默认是false,只更新找到的第一条记录，如果这个参数为true,就把按条件查出来多条记录全部更新。</li><li>writeConcern :可选，抛出异常的级别。</li></ul></li><li>例子：<ul><li>我们在集合 col 中插入如下数据：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">db.col.insert(&#123;</span></span><br><span class="line">    title: &#x27;MongoDB 教程&#x27;, </span><br><span class="line">    description: &#x27;MongoDB 是一个 Nosql 数据库&#x27;,</span><br><span class="line">    by: &#x27;菜鸟教程&#x27;,</span><br><span class="line">    url: &#x27;http://www.lxy.com&#x27;,</span><br><span class="line">    tags: [&#x27;mongodb&#x27;, &#x27;database&#x27;, &#x27;NoSQL&#x27;],</span><br><span class="line">    likes: 100</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>接着我们通过 update() 方法来更新标题(title):<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">db.col.update(&#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB 教程&#x27;</span>&#125;,&#123;<span class="variable">$set</span>:&#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB&#x27;</span>&#125;&#125;)</span></span><br><span class="line">WriteResult(&#123; &quot;nMatched&quot; : 1, &quot;nUpserted&quot; : 0, &quot;nModified&quot; : 1 &#125;)   # 输出信息</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> db.col.find().pretty()</span></span><br><span class="line">&#123;</span><br><span class="line">        &quot;_id&quot; : ObjectId(&quot;5d6e04332fbb8d7e2711535d&quot;),</span><br><span class="line">        &quot;title&quot; : &quot;MongoDB&quot;,</span><br><span class="line">        &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;,</span><br><span class="line">        &quot;by&quot; : &quot;菜鸟教程&quot;,</span><br><span class="line">        &quot;url&quot; : &quot;http://www.runoob.com&quot;,</span><br><span class="line">        &quot;tags&quot; : [</span><br><span class="line">                &quot;mongodb&quot;,</span><br><span class="line">                &quot;database&quot;,</span><br><span class="line">                &quot;NoSQL&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;likes&quot; : 100</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>可以看到标题(title)由原来的 “MongoDB 教程” 更新为了 “MongoDB”。<br>以上语句只会修改第一条发现的文档，如果你要修改多条相同的文档，则需要设置 multi 参数为 true。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">db.col.update(&#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB 教程&#x27;</span>&#125;,&#123;<span class="variable">$set</span>:&#123;<span class="string">&#x27;title&#x27;</span>:<span class="string">&#x27;MongoDB&#x27;</span>&#125;&#125;,&#123;multi:<span class="literal">true</span>&#125;)</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h4 id="save-方法"><a href="#save-方法" class="headerlink" title="save()方法"></a><strong>save()方法</strong></h4><p>save() 方法通过传入的文档来替换已有文档。语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;COLLECTION_NAME&gt;.save(</span><br><span class="line">   &lt;document&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><ul><li>参数说明：<ul><li>document : 文档数据。</li><li>writeConcern :可选，抛出异常的级别。</li></ul></li><li>例子：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">db.col.save(&#123;</span></span><br><span class="line">    &quot;_id&quot; : ObjectId(&quot;5d6e04332fbb8d7e2711535d&quot;),</span><br><span class="line">    &quot;title&quot; : &quot;MongoDB&quot;,</span><br><span class="line">    &quot;description&quot; : &quot;MongoDB 是一个 Nosql 数据库&quot;,</span><br><span class="line">    &quot;by&quot; : &quot;Runoob&quot;,</span><br><span class="line">    &quot;url&quot; : &quot;http://www.runoob.com&quot;,</span><br><span class="line">    &quot;tags&quot; : [</span><br><span class="line">            &quot;mongodb&quot;,</span><br><span class="line">            &quot;NoSQL&quot;</span><br><span class="line">    ],</span><br><span class="line">    &quot;likes&quot; : 110</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li><li>更多例子：</li><li>只更新第一条记录：<code>db.col.update( &#123; &quot;count&quot; : &#123; $gt : 1 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125; );</code></li><li>全部更新：<code>db.col.update( &#123; &quot;count&quot; : &#123; $gt : 3 &#125; &#125; , &#123; $set : &#123; &quot;test2&quot; : &quot;OK&quot;&#125; &#125;,false,true );</code></li><li>只添加第一条：<code>db.col.update( &#123; &quot;count&quot; : &#123; $gt : 4 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,false );</code></li><li>全部添加进去:<code>db.col.update( &#123; &quot;count&quot; : &#123; $gt : 5 &#125; &#125; , &#123; $set : &#123; &quot;test5&quot; : &quot;OK&quot;&#125; &#125;,true,true );</code></li><li>全部更新：<code>db.col.update( &#123; &quot;count&quot; : &#123; $gt : 15 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,true );</code></li><li>只更新第一条记录：<code>db.col.update( &#123; &quot;count&quot; : &#123; $gt : 10 &#125; &#125; , &#123; $inc : &#123; &quot;count&quot; : 1&#125; &#125;,false,false );</code></li></ul><h3 id="删除文档"><a href="#删除文档" class="headerlink" title="删除文档"></a>删除文档</h3><ul><li>MongoDB remove()函数是用来移除集合中的数据。</li><li>MongoDB数据更新可以使用update()函数。在执行remove()函数前先执行find()命令来判断执行的条件是否正确，这是一个比较好的习惯。</li><li>语法：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;COLLECTION_NAME&gt;.remove(</span><br><span class="line">   &lt;query&gt;,</span><br><span class="line">   &#123;</span><br><span class="line">     justOne: &lt;boolean&gt;,</span><br><span class="line">     writeConcern: &lt;document&gt;</span><br><span class="line">   &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li>参数说明：<ul><li>query :（可选）删除的文档的条件。</li><li>justOne : （可选）如果设为 true 或 1，则只删除一个文档，如果不设置该参数，或使用默认值 false，则删除所有匹配条件的文档。</li><li>writeConcern :（可选）抛出异常的级别。</li></ul></li><li>如果你想删除所有数据:<code>db.&lt;COLLECTION_NAME&gt;.remove(&#123;&#125;)</code></li></ul><h3 id="查询文档"><a href="#查询文档" class="headerlink" title="查询文档"></a>查询文档</h3><ul><li>MongoDB 查询文档使用 find() 方法。</li><li>find() 方法以非结构化的方式来显示所有文档。</li><li>语法：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;COLLECTION_NAME&gt;.find(query, projection)</span><br></pre></td></tr></table></figure></li><li>参数说明：<ul><li>query ：可选，使用查询操作符指定查询条件</li><li>projection ：可选，使用投影操作符指定返回的键。查询时返回文档中所有键值， 只需省略该参数即可（默认省略）。</li></ul></li><li>如果你需要以易读的方式来读取数据，可以使用 pretty() 方法，语法格式如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;COLLECTION_NAME&gt;.find().pretty()</span><br></pre></td></tr></table></figure>除了find()方法之外，还有一个findOne()方法，它只返回一个文档。</li><li>MongoDB 与 RDBMS Where 语句比较<br>如果你熟悉常规的 SQL 数据，通过下表可以更好的理解 MongoDB 的条件语句查询：</li></ul><table><thead><tr><th>操作</th><th>格式</th><th>范例</th><th>RDBMS中的类似语句</th></tr></thead><tbody><tr><td>等于</td><td>{&lt;key&gt;:&lt;value&gt;}</td><td>db.col.find({“by”:”菜鸟教程”}).pretty()</td><td>where by = ‘菜鸟教程’</td></tr><tr><td>小于</td><td>{&lt;key&gt;:{$lt:&lt;value&gt;}}</td><td>db.col.find({“likes”:{$lt:50}}).pretty()</td><td>where likes &lt; 50</td></tr><tr><td>小于或等于</td><td>{&lt;key&gt;:{$lte:&lt;value&gt;}}</td><td>db.col.find({“likes”:{$lte:50}}).pretty()</td><td>where likes &lt;= 50</td></tr><tr><td>大于</td><td>{&lt;key&gt;:{$gt:&lt;value&gt;}}</td><td>db.col.find({“likes”:{$gt:50}}).pretty()</td><td>where likes &gt; 50</td></tr><tr><td>大于或等于</td><td>{&lt;key&gt;:{$gte:&lt;value&gt;}}</td><td>db.col.find({“likes”:{$gte:50}}).pretty()</td><td>where likes &gt;= 50</td></tr><tr><td>不等于</td><td>{&lt;key&gt;:{$ne:&lt;value&gt;}}</td><td>db.col.find({“likes”:{$ne:50}}).pretty()</td><td>where likes != 50</td></tr></tbody></table><ul><li>MongoDB AND 条件<br>MongoDB的find()方法可以传入多个键(key)，每个键(key)以逗号隔开，即常规SQL的AND条件。<ul><li>语法格式如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.&lt;COLLECTION_NAME&gt;.find(&#123;key1:value1, key2:value2&#125;).pretty()</span><br></pre></td></tr></table></figure></li></ul></li><li>MongoDB OR 条件<br>MongoDB OR 条件语句使用了关键字 <strong>$or</strong>.<ul><li>语法格式如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">db.col.find(&#123;</span><br><span class="line">    $or: [</span><br><span class="line">        &#123;key1: value1&#125;, &#123;key2:value2&#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;).pretty()</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> MongoDB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cron表达式</title>
      <link href="/2020/04/09/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/04/09/Cron%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<ul><li>Cron表达式是一个字符串,字符串以5或6个空格隔开,分为<strong>6或7个域</strong>,每一个域代表一个含义,Cron有如下两种语法格式：   <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Seconds Minutes Hours DayofMonth Month DayofWeek Year</span><br><span class="line">Seconds Minutes Hours DayofMonth Month DayofWeek</span><br><span class="line">秒      分钟    小时   日期       月份   周        年</span><br></pre></td></tr></table></figure></li></ul><span id="more"></span><ul><li>每一个域可出现的字符如下： <ul><li>所有域都支持：<code>, - * /</code></li><li>每个域还额外支持：<ul><li><code>Seconds</code>:有效范围为0-59的整数 </li><li><code>Minutes</code>:有效范围为0-59的整数 </li><li><code>Hours</code>:有效范围为0-23的整数 </li><li><code>DayofMonth</code>:<code>&quot;? L W C&quot;</code>,有效范围为0-31的整数 </li><li><code>Month</code>:有效范围为1-12的整数或<code>JAN-DEC</code></li><li><code>DayofWeek</code>:<code>&quot;? L C #&quot;</code>,有效范围为1-7的整数或<code>SUN-SAT</code>两个范围。1表示星期天,2表示星期一,依次类推</li><li><code>Year</code>:有效范围为1970-2099年</li></ul></li></ul></li><li>每一个域都可使用数字,但还可以出现如下<strong>特殊字符</strong>,它们的含义是： <ul><li><code>*</code>：表示<strong>匹配该域的任意值</strong>,假如在Minutes域使用<code>*</code>, 即表示每分钟（每一天/一周的每一天）都会触发事件。</li><li><code>?</code>:只能用在<strong>DayofMonth</strong>和<strong>DayofWeek</strong>两个域。它也匹配域的任意值,但实际不会。<ul><li>因为<strong>DayofMonth</strong>和<strong>DayofWeek</strong>会相互影响。例如想在每月的20日触发调度,不管20日到底是星期几,则只能使用如下写法：<code>13 13 15 20 * ?</code>, 其中最后一位只能用<code>?</code>,而不能使用<code>*</code>,如果使用<code>*</code>表示不管星期几都会触发,实际上并不是这样。 </li></ul></li><li><code>-</code>:表示<strong>范围</strong>,例如在Minutes域使用5-20,表示从5分到20分钟每分钟触发一次 </li><li><code>/</code>：表示<strong>起始时间开始触发</strong>,然后<strong>每隔固定时间触发一次</strong>,例如在Minutes域使用5/20,则意味着第5分钟触发一次,而递增20分钟后即25,45等再分别触发一次. </li><li><code>,</code>:表示<strong>列出枚举值</strong>。例如：在Minutes域使用5,20,则意味着在5和20分每分钟触发一次。 </li><li><code>L</code>:表示<strong>最后</strong>,只能出现在<strong>DayofWeek</strong>和<strong>DayofMonth</strong>域,如果在DayofWeek域使用5L,意味着在最后的一个星期四触发。 </li><li><code>W</code>: 表示<strong>有效工作日</strong>(周一到周五),只能出现在<strong>DayofMonth</strong>域,系统将在离指定日期的<strong>最近的有效工作日</strong>触发事件。例如：在 DayofMonth使用5W,如果5日是星期六,则将在最近的工作日：星期五,即4日触发。如果5日是星期天,则在6日(周一)触发；如果5日在星期一到星期五中的一天,则就在5日触发。另外一点,<strong>W的最近寻找不会跨过月份</strong></li><li><code>LW</code>:这两个字符可以连用,表示在<strong>某个月最后一个工作日</strong>,即<strong>最后一个星期五</strong>。 </li><li><code>#</code>:用于确定<strong>每个月第几个星期几</strong>,只能出现在<strong>DayofMonth</strong>域。例如在4#2或者Wed#2,表示某月的第二个星期三。</li></ul></li></ul><h3 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&quot;0 15 10 * * ? *&quot;: 每天10点15分触发</span><br><span class="line">&quot;0 15 10 * * ? 2017&quot;: 2017年每天10点15分触发</span><br><span class="line">&quot;0 * 14 * * ?&quot;: 每天下午2点到下午2:59期间的每1分钟触发 </span><br><span class="line">&quot;0 0/5 14 * * ?&quot;: 每天下午2点到下午2:55期间的每5分钟触发 </span><br><span class="line">&quot;0 0/5 14,18 * * ?&quot;: 每天下午2点到2:55期间和下午6点到6:55期间的每5分钟触发 </span><br><span class="line">&quot;0 0-5 14 * * ?&quot;: 每天下午2点到下午2:05期间的每1分钟触发 </span><br><span class="line">&quot;0 15 10 L * ?&quot;: 每月最后一日的上午10:15触发 </span><br><span class="line">&quot;0 15 10 6L * ?&quot;: 每月倒数第6天的上午10:15触发 </span><br><span class="line">&quot;0 15 10 ? * 6L&quot;: 每月的最后一个星期五上午10:15触发 </span><br><span class="line">&quot;0 15 10 ? * 6#3&quot;: 每月的第三个星期五上午10:15触发</span><br></pre></td></tr></table></figure></code></pre><h2 id="crontab–Linux"><a href="#crontab–Linux" class="headerlink" title="crontab–Linux"></a>crontab–Linux</h2><ul><li>使用crontab你可以在指定的时间执行一个shell脚本或者一系列Linux命令。例如系统管理员安排一个备份任务使其每天都运行。</li><li>如何往crontab中添加一个作业?  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 这个命令会通过编辑器打开,修改crontab文件. 如果文件不存在会自动创建</span></span><br><span class="line">crontab –e</span><br></pre></td></tr></table></figure></li><li>相关命令：  <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 显示crontab文件</span></span><br><span class="line">crontab -l</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除crontab文件,即移除所有的crontab任务</span></span><br><span class="line">crontab -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除crontab文件前提醒用户</span></span><br><span class="line">crontab -ir</span><br></pre></td></tr></table></figure></li><li>0 5 * * * /root/bin/backup.sh</li><li>这将会在每天早上5点运行 /root/bin/backup.sh</li></ul><h3 id="以下是crontab文件的格式："><a href="#以下是crontab文件的格式：" class="headerlink" title="以下是crontab文件的格式："></a>以下是crontab文件的格式：</h3><pre><code><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 时间相关的总共5个域</span><br><span class="line">minute hour dayOfMonth month dayOfWeek full-path-to-shell-script</span><br><span class="line">分钟   小时  日期       月份   周        shell脚本地址</span><br></pre></td></tr></table></figure></code></pre><ul><li>每一个域可出现的字符如下： <ul><li><code>minute</code>: 区间为0–59 </li><li><code>hour</code>: 区间为0–23 </li><li><code>dayOfMonth</code>: 区间为0–31 </li><li><code>month</code>: 区间为1–12. 1是1月、12是12月. </li><li><code>dayOfWeek</code>: 区间为0–7. 周日可以是0或7.</li><li><code>*/数字</code> ：表示每几分钟或每几个小时</li><li><code>,</code> ：在某几个特点的时间点,如哪几个小时,哪几天。。。</li><li><code>-</code> :几点到几点,或者周几到周几。。。</li></ul></li><li>示例：  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&quot;1 0 * * *&quot;:在00:01运行,即每天凌晨过一分钟。</span><br><span class="line">&quot;59 11 * * 1,2,3,4,5&quot;:每个工作日(Mon–Fri)11:59运行</span><br><span class="line">&quot;*/5 * * * *&quot;:每5分钟运行一次命令运行</span><br><span class="line">&quot;10 13 1 * *&quot;:每个月的第一天13:10运行</span><br><span class="line">&quot;0 23 * * 1-5&quot;:每个工作日23点运行</span><br><span class="line">&quot;* 23-7/1 * * *&quot;:晚上11点到早上7点之间,每隔一小时运行</span><br><span class="line">&quot;0/25 * * * *&quot;:从0分钟开始每25分钟执行一次,即每小时的25分钟,50分钟执行一次</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Cron表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cron表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2020/04/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2020/04/09/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h1><h2 id="概述："><a href="#概述：" class="headerlink" title="概述："></a>概述：</h2><ul><li>就是一套规则，一种匹配模式，要么匹配字符，要么匹配位置。</li><li>正则表达式是专门解决字符串规则匹配的工具。</li><li>正则表达式也是一个字符串，用来定义匹配规则。</li><li>参照帮助文档，在Pattern类中有简单的规则定义，可以结合字符串类的方法使用。</li></ul><h2 id="正则表达式的匹配规则："><a href="#正则表达式的匹配规则：" class="headerlink" title="正则表达式的匹配规则："></a>正则表达式的<strong>匹配规则</strong>：</h2><p>正则表达式中明确<strong>区分大小写</strong>字母。</p><span id="more"></span><h2 id="正则表达式速查手册"><a href="#正则表达式速查手册" class="headerlink" title="正则表达式速查手册"></a>正则表达式速查手册</h2><table><thead><tr><th>字符</th><th>描述</th><th>举例</th></tr></thead><tbody><tr><td><h4>字符类：</h4></td><td></td><td></td></tr><tr><td><strong>^ $</strong></td><td>代表正则的头和尾</td><td></td></tr><tr><td><strong>x</strong></td><td>代表的是字符’x’</td><td>匹配规则为”a”，那么需要匹配的字符串内容就是”a”</td></tr><tr><td>*<em>\*</em></td><td>代表的是反斜线字符’\‘</td><td>匹配规则为”\“ ，那么需要匹配的字符串内容就是”\“</td></tr><tr><td><strong>a|b</strong></td><td>匹配a或b</td><td>匹配规则为”z|food”能匹配”z”或”food”。”(z|f)ood”则匹配”zood”或”food”</td></tr><tr><td><strong>[abc]</strong></td><td>代表的是字符a、b或c</td><td>匹配规则为”[abc]” ，那么需要匹配的内容就是字符a，或者字符b，或字符c的一个</td></tr><tr><td><strong>[^abc]</strong></td><td>代表的是除了a、b或c以外的任何字符</td><td>匹配规则为”[^abc]”，那么需要匹配的内容就是不是字符a，或者不是字符b，或不是字符c的任意一个字符</td></tr><tr><td><strong>[a-zA-Z]</strong></td><td>代表的是a到z或A到Z，两头的字母包括在内</td><td>匹配规则为”[a-zA-Z]”，那么需要匹配的是一个大写或者小写字母</td></tr><tr><td><strong>[0-9]</strong></td><td>代表的是0到9数字，两头的数字包括在内</td><td>匹配规则为”[0-9]”，那么需要匹配的是一个数字</td></tr><tr><td><strong>[a-zA-Z_0-9]</strong></td><td>代表的字母或者数字或者下划线(即单词字符)</td><td>匹配规则为”[a-zA-Z_0-9]”，那么需要匹配的是一个字母或者是一个数字或一个下滑线</td></tr><tr><td><h4>预定义字符类：</h4></td><td></td><td></td></tr><tr><td><strong>.</strong></td><td>代表的是任何字符,表示几乎任意字符。换行符、回车符、行分隔符和段分隔符除外</td><td>匹配规则为”.”，那么需要匹配的是一个任意字符。如果，就想使用.的话，使用匹配规则”\.”来实现</td></tr><tr><td><strong>\d</strong> 等价于 [0-9]</td><td>代表的是0到9数字，两头的数字包括在内</td><td>匹配规则为”\d”，那么需要匹配的是一个数字</td></tr><tr><td><strong>\D</strong> 等价于 [^0-9]</td><td>代表的是除了数字外的任意字符</td><td>匹配规则为”\D”，那么需要匹配的是一个非数字字符</td></tr><tr><td><strong>\w</strong> 等价于 [a-zA-Z_0-9]</td><td>代表的字母或者数字或者下划线(即单词字符)</td><td>匹配规则为”\w”，那么需要匹配的是一个字母或者是一个数字或一个下滑线</td></tr><tr><td><strong>\W</strong> 等价于 [^a-zA-Z_0-9]</td><td>代表的非字母并且非数字并且非下划线(即非单词字符)</td><td>匹配规则为”\W”，那么需要匹配的是一个非字母并且非数字并且非下滑线的字符</td></tr><tr><td><strong>\s</strong> 等价于 [\t\v\n\r\f]</td><td>代表的是空格、水平制表符、垂直制表符、换行符、回车符、换页符(即空白符)</td><td>匹配规则为”\s”，那么需要匹配是一个空白符</td></tr><tr><td><strong>\S</strong> 等价于 [^\t\v\n\r\f]</td><td>代表的是匹配非空白符</td><td>匹配规则为”\S”，那么需要匹配是一个非空白符</td></tr><tr><td><strong>\b</strong></td><td>匹配一个单词边界，也就是指单词和空格间的位置</td><td>匹配规则为”er\b”可以匹配”never”中的”er”，但不能匹配”verb”中的”er”</td></tr><tr><td><strong>\B</strong></td><td>匹配非单词边界</td><td>匹配规则为”er\B”能匹配”verb”中的”er”，但不能匹配”never”中的”er”</td></tr><tr><td><strong>\f、\n、\r、\t、\v</strong></td><td>分别对应匹配一个换页符、换行符、回车符、制表符、垂直制表符</td><td></td></tr><tr><td><strong>\xn</strong></td><td>匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长</td><td>匹配规则为”\x41”匹配”A”。”\x041”则等价于”\x04&amp;1”。正则表达式中可以使用ASCII编码</td></tr><tr><td><strong>\num</strong></td><td>匹配num，其中num是一个正整数。对所获取的匹配的引用。</td><td>匹配规则为”(.)\1”匹配两个连续的相同字符</td></tr><tr><td><strong>\un</strong></td><td>匹配n，其中n是一个用四个十六进制数字表示的Unicode字符</td><td>匹配规则为”\u00A9”匹配版权符号（©）</td></tr><tr><td><h4>量词：</h4></td><td></td><td></td></tr><tr><td><strong>X?</strong> 等价于 {0,1}</td><td>代表的是X出现<strong>一次或一次也没有</strong></td><td>匹配规则为”a?”，那么需要匹配的内容是一个字符a，或者一个a都没有</td></tr><tr><td><strong>X*</strong> 等价于 {0,}</td><td>代表的是X出现<strong>零次或多次</strong></td><td>匹配规则为”a*” ，那么需要匹配的内容是多个字符a，或者一个a都没有</td></tr><tr><td><strong>X+</strong> 等价于 {0,1}</td><td>代表的是X出现<strong>一次或多次</strong></td><td>匹配规则为”a+”，那么需要匹配的内容是多个字符a，或者一个a</td></tr><tr><td><strong>X{n}</strong></td><td>代表的是X出现<strong>恰好n次</strong></td><td>匹配规则为”a{5}”，那么需要匹配的内容是5个字符a</td></tr><tr><td><strong>X{n,}</strong></td><td>代表的是X出现<strong>至少n次</strong></td><td>匹配规则为”a{5,}”，那么需要匹配的内容是最少有5个字符a</td></tr><tr><td><strong>X{n,m}</strong></td><td>代表的是X出现<strong>至少n次</strong>，但是<strong>不超过m次</strong></td><td>匹配规则为”a{5,8}”，那么需要匹配的内容是有5个字符a到8个字符a之间</td></tr><tr><td>其他模式：</td><td></td><td></td></tr><tr><td><strong>(pattern)</strong></td><td>匹配pattern并获取这一匹配。所获取的匹配可以使用$0…$9属性</td><td>要匹配圆括号字符，请使用”\(“或\)”</td></tr><tr><td><strong>(?:pattern)</strong></td><td>匹配pattern但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用</td><td></td></tr><tr><td><strong>(?=pattern)</strong></td><td>正向肯定预查，在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</td><td>匹配规则为”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td></tr><tr><td><strong>(?!pattern)</strong></td><td>正向否定预查，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用</td><td>匹配规则为”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始</td></tr><tr><td><strong>(?&lt;=pattern)</strong></td><td>反向肯定预查，与正向肯定预查类拟，只是方向相反</td><td>匹配规则为”(?&lt;=95|98|NT|2000)Windows”能匹配”2000Windows”中的”Windows”，但不能匹配”3.1Windows”中的”Windows”</td></tr><tr><td><strong>(?&lt;!pattern)</strong></td><td>反向否定预查，与正向否定预查类拟，只是方向相反</td><td>匹配规则为”(?&lt;!95|98|NT|2000)Windows”能匹配”3.1Windows”中的”Windows”，但不能匹配”2000Windows”中的”Windows”</td></tr></tbody></table><h2 id="正则表达式中需要转义的字符"><a href="#正则表达式中需要转义的字符" class="headerlink" title="正则表达式中需要转义的字符"></a>正则表达式中需要转义的字符</h2><ul><li><code>$</code>:匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则<code>$</code>也匹配<code>&#39;\n&#39;</code>或<code>&#39;\r&#39;</code>。要匹配<code>$</code>字符本身，请使用<code>\$</code>。</li><li><code>( )</code>:标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用<code>\(</code>、<code>\)</code>。</li><li><code>*</code>:匹配前面的子表达式零次或多次。要匹配<code>*</code>字符，请使用<code>\*</code>。</li><li><code>+</code>:匹配前面的子表达式一次或多次。要匹配<code>+</code>字符，请使用<code>\+</code>。</li><li><code>.</code>:匹配除换行符<code>\n</code>之外的任何单字符。要匹配<code>.</code>，请使用<code>\.</code>。</li><li><code>[ ]</code>:标记一个中括号表达式的开始。要匹配<code>[ ]</code>，请使用<code>\[</code>、<code>\]</code>。</li><li><code>?</code>:匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配<code>?</code>字符，请使用<code>\?</code>。</li><li><code>\</code>:将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如，<code>&#39;n&#39;</code>匹配字符<code>&#39;n&#39;</code>。<code>&#39;\n&#39;</code>匹配换行符。序列<code>&#39;\\&#39;</code>匹配<code>\</code>，而<code>&#39;\(&#39;</code>则匹配<code>(</code>。</li><li><code>^</code>:匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配<code>^</code>字符本身，请使用<code>\^</code>。</li><li><code>&#123; &#125;</code>:标记限定符表达式的开始。要匹配<code>&#123; &#125;</code>，请使用<code>\&#123;</code>、<code>\&#125;</code>。</li><li><code>|</code>:指明两项之间的一个选择。要匹配<code>|</code>，请使用<code>\|</code>。</li></ul><p>总述一下(14个)：<code>* . ? + $ ^ [ ] ( ) &#123; &#125; | \</code></p><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><ul><li><strong>汉字</strong>:<code>^[\u4e00-\u9fa5]&#123;0,&#125;$</code></li><li><strong>用户名</strong>:<code>/^[a-z0-9_-]&#123;3,16&#125;$/</code></li><li><strong>密码</strong>:<code>/^[a-z0-9_-]&#123;6,18&#125;$/</code></li><li><strong>十六进制值</strong>:<code>/^#?([a-f0-9]&#123;6&#125;|[a-f0-9]&#123;3&#125;)$/</code></li><li><strong>电子邮箱</strong>:<code>/^([a-z0-9_\.-]+)@([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)$/</code>或<code>/^[a-z\d]+(\.[a-z\d]+)*@([\da-z](-[\da-z])?)+(\.&#123;1,2&#125;[a-z]+)+$/</code></li><li><strong>URL</strong>:<code>/^(https?:\/\/)?([\da-z\.-]+)\.([a-z\.]&#123;2,6&#125;)([\/\w \.-]*)*\/?$/</code></li><li><strong>IP地址</strong>:<code>/((2[0-4]\d|25[0-5]|[01]?\d\d?)\.)&#123;3&#125;(2[0-4]\d|25[0-5]|[01]?\d\d?)/</code>或<code>/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/</code></li><li><strong>HTML标签</strong>:<code>/^&lt;([a-z]+)([^&lt;]+)*(?:&gt;(.*)&lt;\/\1&gt;|\s+\/&gt;)$/</code></li><li><strong>删除代码</strong>//注释:<code>(?&lt;!http:|\S)//.*$</code></li><li><strong>Unicode编码中的汉字范围</strong>:<code>/^[\u2E80-\u9FFF]+$/</code></li><li><strong>16进制颜色值</strong>(#ffbbad、#Fc01DF、#FFF、#ffE等):<code>/^#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)$/</code></li><li><strong>时间</strong>(23:59):<code>/^([01][0-9]|[2][0-3]):[0-5][0-9]$/</code>、如果需要省略前面的0则使用<code>/^(0?[0-9]|1[0-9]|[2][0-3]):(0?[0-9]|[1-5][0-9])$/</code></li><li><strong>日期</strong>(yyyy-mm-dd):<code>/\^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</code></li><li><strong>window操作系统文件路径</strong>:<code>/^[a-zA-Z]:\\([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*([^\\:*&lt;&gt;|&quot;?\r\n/]+)?$/</code><ul><li>要求匹配：<ul><li>F:\study\javascript\regex\regular expression.pdf</li><li>F:\study\javascript\regex\</li><li>F:\study\javascript</li><li>F:\</li></ul></li><li>详细分析：<ul><li>整体模式是: <code>盘符:\文件夹\文件夹\文件夹\</code></li><li>其中匹配<code>F:\</code>，需要使用<code>[a-zA-Z]:\\</code>，其中盘符不区分大小写，注意<code>\</code>字符需要转义。</li><li>文件名或者文件夹名，不能包含一些特殊字符，此时我们需要排除字符组<code>[^\\:*&lt;&gt;|&quot;?\r\n/]</code>来表示合法字符。另外不能为空名，至少有一个字符，也就是要使用量词<code>+</code>。因此匹配”文件夹&quot;，可用<code>[^\\:*&lt;&gt;|&quot;?\r\n/]+\\</code>。</li><li>另外”文件夹&quot;，可以出现任意次。也就是<code>([^\\:*&lt;&gt;|&quot;?\r\n/]+\\)*</code>。其中括号提供子表达式。</li><li>路径的最后一部分可以是”文件夹”，没有<code>\</code>，因此需要添加<code>([^\\:*&lt;&gt;|&quot;?\r\n/]+)?</code>。</li></ul></li></ul></li></ul><h2 id="正则表达式的注意事项："><a href="#正则表达式的注意事项：" class="headerlink" title="正则表达式的注意事项："></a>正则表达式的注意事项：</h2><ul><li>要匹配”a”、”-“、”z”这三者中任意一个字符，不能写成[a-z]，因为其表示小写字符中的任何一个字符。可以写成如下的方式：[-az]或[az-]或[a-z]。即要么放在开头，要么放在结尾，要么转义。总之不会让引擎认为是范围表示法就行了。</li><li>如果要匹配任意字符怎么办？可以使用[\d\D]、[\w\W]、[\s\S]和[^]中任何的一个。  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">&quot;123456&quot;</span>;</span><br><span class="line"><span class="keyword">boolean</span> flag = str.matches(<span class="string">&quot;[1-9][0-9]&#123;4,14&#125;&quot;</span>);<span class="comment">//判断str是否符合该正则</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="贪婪匹配和惰性匹配"><a href="#贪婪匹配和惰性匹配" class="headerlink" title="贪婪匹配和惰性匹配"></a>贪婪匹配和惰性匹配</h3><ul><li>贪婪匹配:<ul><li>/\d{2,5}/，表示数字连续出现2到5次;其是贪婪的，它会尽可能多的匹配。</li></ul></li><li>惰性匹配:<ul><li>/\d{2,5}?/表示，虽然2到5次都行，当2个就够的时候，就不在往下尝试了。</li></ul></li><li>通过在量词后面加个问号就能实现惰性匹配，因此所有惰性匹配情形如下：<ul><li>{m,n}?</li><li>{m,}?</li><li>??</li><li>+?</li><li>*?</li><li>对惰性匹配的记忆方式是：量词后面加个问号，问一问你知足了吗，你很贪婪吗？</li></ul></li><li>多选分支:<strong>|</strong><ul><li>支持多个子模式任选其一</li><li>(p1|p2|p3)，其中p1、p2和p3是子模式，用|(管道符)分隔，表示其中任何之一。</li></ul></li></ul><h3 id="匹配位置"><a href="#匹配位置" class="headerlink" title="匹配位置"></a>匹配位置</h3><ul><li>什么是位置？<ul><li>位置是相邻字符之间的位置。</li></ul></li><li>如何匹配位置呢？<ul><li>共有6个锚字符：^ $ \b \B (?=p) (?!p)</li><li>^(脱字符)匹配开头，在多行匹配中匹配行开头。</li><li>$(美元符号)匹配结尾，在多行匹配中匹配行结尾。</li><li>\b是单词边界，具体就是\w和\W之间的位置，也包括\w和^之间的位置，也包括\w和$之间的位置。</li><li>\B就是\b的反面的意思，非单词边界。例如在字符串中所有位置中，扣掉\b，剩下的都是\B的。<ul><li>具体说来就是\w与\w、\W与\W、^与\W，\W与$之间的位置。</li></ul></li><li>(?=p)，其中p是一个子模式，即p前面的位置。</li><li>而(?!p)就是(?=p)的反面意思</li></ul></li></ul><h2 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h2><p><a href="https://mp.weixin.qq.com/s/8sSDcxUsLCNhfHLkI9XKOQ">常用正则表达式最强整理（速查手册）</a></p>]]></content>
      
      
      <categories>
          
          <category> 正则表达式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 正则表达式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一文整明白Cookie、Session、Token</title>
      <link href="/2020/01/16/%E4%B8%80%E6%96%87%E6%95%B4%E6%98%8E%E7%99%BDCookie%E3%80%81Session%E3%80%81Token/"/>
      <url>/2020/01/16/%E4%B8%80%E6%96%87%E6%95%B4%E6%98%8E%E7%99%BDCookie%E3%80%81Session%E3%80%81Token/</url>
      
        <content type="html"><![CDATA[<h2 id="Cookies"><a href="#Cookies" class="headerlink" title="Cookies"></a>Cookies</h2><p>Cookies是由服务器产生的。</p><p>Cookie就是服务器委托浏览器<strong>存储在客户端</strong>(浏览器)里的一些数据，而这些数据通常都会记录用户的关键识别信息。</p><h3 id="Cookie-产生的过程："><a href="#Cookie-产生的过程：" class="headerlink" title="Cookie 产生的过程："></a>Cookie 产生的过程：</h3><ul><li>浏览器第一次访问服务端时，服务器此时肯定不知道他的身份，所以创建一个独特的身份标识数据，格式为<code>key=value</code>，放入到<code>Set-Cookie</code>字段里，随着响应报文发给浏览器。</li><li>浏览器看到有<code>Set-Cookie</code>字段以后就知道这是服务器给的身份标识，于是就保存起来，下次请求时会自动将此<code>key=value</code>值放入到<code>Cookie</code>字段中发给服务端。</li><li>服务端收到请求报文后，发现<code>Cookie</code>字段中有值，就能根据此值识别用户的身份然后提供个性化的服务。</li></ul><span id="more"></span><h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><p>Cookie是存储在<strong>客户端</strong>方,Session是存储在<strong>服务端</strong>方，客户端只存储<code>SessionId</code>。</p><p>如果将账户的一些信息都存入<code>Cookie</code>中的话，一旦信息被拦截，那么我们所有的账户信息都会丢失掉。</p><p>所以就出现了<code>Session</code>，在一次会话中将重要信息保存在<code>Session</code>中，浏览器只记录 SessionId，一个SessionId对应一次会话请求。</p><h3 id="那么Session什么时候过期呢？"><a href="#那么Session什么时候过期呢？" class="headerlink" title="那么Session什么时候过期呢？"></a>那么Session什么时候过期呢？</h3><p><strong>客户端</strong>：和<code>Cookie</code>过期一致，如果没设置，默认是关了浏览器就没了，即再打开浏览器的时候初次请求头中是没有`SessionId了。</p><p><strong>服务端</strong>：服务端的过期是真的过期，即服务器端的<code>Session</code>存储的数据结构多久不可用了，默认是<code>30</code>分钟。</p><h3 id="Session的管理是在容器中被管理的，什么是容器呢？"><a href="#Session的管理是在容器中被管理的，什么是容器呢？" class="headerlink" title="Session的管理是在容器中被管理的，什么是容器呢？"></a>Session的管理是在容器中被管理的，什么是容器呢？</h3><p>Tomcat、Jetty 等都是容器。</p><p>Session是存储在Tomcat的容器中，所以如果后端机器是多台的话，因此多个机器间是<strong>无法共享Session</strong>的。</p><p>此时可以使用Spring提供的<strong>分布式Session</strong>的解决方案，是将<code>Session</code>放在了<code>Redis</code>中。</p><h3 id="创建出来后Session保存在哪呢？"><a href="#创建出来后Session保存在哪呢？" class="headerlink" title="创建出来后Session保存在哪呢？"></a>创建出来后Session保存在哪呢？</h3><p>创建出来后Session会被保存到一个<code>ConcurrentHashMap</code>中。</p><h2 id="Token"><a href="#Token" class="headerlink" title="Token"></a>Token</h2><p>Session是将要验证的信息存储在<strong>服务端</strong>，并以<code>SessionId</code>和数据进行对应，<code>SessionId</code>由客户端存储，在请求时将<code>SessionId</code>也带过去，因此实现了状态的对应。</p><p>而<code>Token</code>是在服务端将用户信息经过<code>Base64Url</code>编码过后传给客户端，每次用户请求的时候都会带上这一段信息，因此服务端拿到此信息进行解密后就知道此用户是谁了，这个方法叫做<code>JWT</code>(Json Web Token)。</p><p><code>Token</code>相比较于<code>Session</code>的优点在于:当后端系统有多台时，由于是客户端访问时直接带着数据，因此<strong>无需做共享数据</strong>的操作。</p><p><code>Token</code>的<strong>优点</strong>：</p><ul><li><p><strong>简洁</strong>：可以通过URL，POST参数或者是在HTTP头参数发送，因为数据量小，传输速度也很快。</p></li><li><p><strong>自包含</strong>：由于串包含了用户所需要的信息，避免了多次查询数据库。</p></li><li><p><strong>跨语言</strong>：<code>Token</code>是以<code>Json</code>的形式保存在客户端的，所以<code>JWT</code>是跨语言的。</p></li><li><p><strong>不需要在服务端保存会话信息</strong>，特别适用于分布式微服务。</p></li></ul><h2 id="JWT的结构"><a href="#JWT的结构" class="headerlink" title="JWT的结构"></a>JWT的结构</h2><p>实际的<code>JWT</code>大概长下面的这样，它是一个很长的字符串，中间用<code>.</code>分割成三部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJkeHRlc3QiLCJjcmVhdGVkIjoxNTc3MTUxMjEwNDIxLCJleHAiOjE1NzcxOTQ0MTAsInVzZXJpZCI6IjJmMWZkYTI5MzkyMzQ5NTI4OGQwODk3Yjc2NjNjMTVhIiwianRpIjoiZTFlMDZiYjU5MzExNDFjYmE3M2JiMTczM2ZjZWE2ODIifQ.rOnyuQppNJ0OeZrk4S3TkvqMeYq4EH48qPFq1FVkQlWo2cI_F7vWuKJqmHKEaITYgxJG3z_VjqHMlWsOszU7iA</span><br></pre></td></tr></table></figure><p>JWT是由三部分组成的：</p><ul><li>Header:</li></ul><p>Header 是一个 Json 对象，描述 JWT 的元数据，通常是下面这样子的：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;alg&quot;</span>: <span class="string">&quot;HS256&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;typ&quot;</span>: <span class="string">&quot;JWT&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中：</p><p><code>alg</code>属性表示签名的<strong>算法</strong>（algorithm），默认是<code>HMAC SHA256</code>(写成HS256)。</p><p><code>type</code>属性表示这个令牌(Token)的类型(type)，<code>JWT</code>令牌统一写为<code>JWT</code>。最后，将上面的Json对象使用<code>Base64URL</code>算法转成字符串。</p><p><code>JWT</code>作为一个令牌(Token)，有些场合可能会放到URL(比如 api.example.com/?token=xxx)。</p><p><code>Base64</code>有三个字符<code>+</code>、<code>/</code>和<code>=</code>，在URL里面有特殊含义，所以要被替换掉,<code>=</code>被省略,<code>+</code>替换成<code>-</code>,<code>/</code>替换成<code>_</code>,这就是<code>Base64URL</code>算法。</p><ul><li>Payload</li></ul><p><code>Payload</code>部分也是一个Json对象，用来存放实际需要传输的数据，JWT官方规定了下面几个官方的字段供选用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure><p>当然除了官方提供的这几个字段我们也能够自己定义私有字段，下面就是一个例子：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;xiaoMing&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;age&quot;</span>: <span class="number">14</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认情况下<code>JWT</code>是<strong>不加密</strong>的，任何人只要在网上进行<code>Base64</code>解码就可以读到信息，所以一般不要将秘密信息放在这个部分。这个Json对象也要用<code>Base64URL</code>算法转成字符串。</p><ul><li>Signature</li></ul><p><code>Signature</code>部分是对前面的两部分的数据进行<strong>签名</strong>，<strong>防止数据篡改</strong>。</p><p>首先需要定义一个<strong>秘钥</strong>，这个秘钥只有<strong>服务器</strong>才知道，不能泄露给用户，然后使用<code>Header</code>中指定的签名算法(默认情况是 HMAC SHA256)。</p><p>算出签名以后将<code>Header</code>、<code>Payload</code>、<code>Signature</code>三部分拼成一个字符串，每个部分用<code>.</code>分割开来，就可以返给用户了。</p><p><code>HS256</code>可以使用单个密钥为给定的数据样本创建签名。当消息与签名一起传输时，接收方可以使用相同的密钥来验证签名是否与消息匹配。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>Cookie</code>是存储在<strong>客户端</strong>的。</li><li><code>Session</code>是存储在<strong>服务端</strong>的，可以理解为一个状态列表。拥有一个唯一会话标识 SessionId。可以根据<code>SessionId</code>在服务端查询到存储的信息。</li><li><code>Session</code>会引发一个问题，即后端多台机器时<code>Session</code>共享的问题，解决方案可以使用<code>Spring</code>提供的框架(使用的是redis)。</li><li><code>Token</code>类似一个令牌，无状态的，服务端所需的信息被<code>Base64</code>编码后放到<code>Token</code>中，服务器可以直接解码出其中的数据。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式|⑨桥接模式</title>
      <link href="/2019/12/26/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A8%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/12/26/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A8%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;GOF23共有23种设计模式，前面我们讲了不到十种，但其实，我个人觉得，前面已经讲过这几篇可以说是GOF23中最重要的几个模式，时间确实隔得比较长了，如果之前读者们没有阅读过的，可以去回顾一下。</p><span id="more"></span><p>&emsp;后面的模式虽然还有很多，但是用的都不是太多，而且总体感觉难度都不是特别大，除了个别模式，比如<strong>访问者模式</strong>、<strong>解释器模式</strong>等稍微有点难懂，其它的模式要不就是实战中用的极少，要不难度不是很大，所以首先需要恭喜大家其实设计模式最大的难关已经过了。接下去的文章我挑选一些重点讲一下我自己学习中的一些理解，对于一些无关紧要的细节我就一带而过，甚至就不讲了。网上对于每一个模式你都可以搜到非常丰富的资料和讲解，但是我个人觉得花20%精力学好80%知识即可。</p><p>&emsp;那么，下面不多废话，开始今天的话题，今天开始接下去还是聊<strong>结构型模式</strong>中剩余4个模式，这四个模式用的不多，我个人对其理解也不是太深，所以接下去的内容只谈谈我个人对这几个模式的一些看法。</p><p>首先，今天我们先说<strong>桥接模式</strong>。</p><p>关于桥接模式的定义，我在准备素材时Google搜了一下，基本得到的都是一句话，</p><blockquote><p>桥接模式（Bridge Pattern），将抽象部分与它的实现部分分离，使它们都可以独立地变化。</p></blockquote><p>反正我不知道各位看官看完这句话是啥感受，反正我是看了几遍都完全一脸懵逼的状态，这说的都是些什么玩意，有种累觉不爱的感觉，要是这样学设计模式痛苦啊……</p><p>其实，桥接模式用一个生活中的例子描述一下，你会发现真是简单的不行……</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p>比如现在需要换一个新电脑，大家知道电脑种类那真是五花八门，多的不行，光从分类来看就分好几种啊，首先从外观可以分为台式机、笔记本，要是平板电脑也算电脑又是一种。从用途来分，又可以分为游戏本、商务本、上网本、超极本等。另外从电脑品牌来分，又可以分为联想、戴尔、惠普、华硕等等，相信大家一定不会陌生。</p><p>那么现在我有这么一个需求，我需要设计一个系统，根据用户在页面选择的每一维度的选项，最后输出对应类别的电脑产品，比如用户选了戴尔+台式机，那么就给他发货一台戴尔台式机，要是选了联想+笔记本，就给他发货联想笔记本，等等。</p><p>如果不使用任何设计模式的编程方式，简单实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoLaptopComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DellDesktopComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;戴尔台式机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然这种方式相信大家都知道，其实如果你要创建的对象数量并不是很多的情况下，我们就只需要这样做即可。之前也和大家说过，设计模式这玩意不是说在项目中生搬硬套上去就显得多么高大上似的，个人理解，设计模式其实是在写代码过程中，被逼无奈，用正常方式无法完成需求后的一条无奈之路，有种被逼上梁山的感觉。如果你项目中就只需要创建几个这类对象，那这样写无可厚非。</p><p>但是如果上面这系统用户量非常大，而且每个用户各种选择维度的组合大不相同，这时会发生什么？</p><p>为方便阐述，将上述需求中电脑的类别维度简化为两个维度:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">维度1：品牌</span><br><span class="line">    联想、戴尔、惠普</span><br><span class="line">维度2：外观</span><br><span class="line">    台式机、平板电脑、笔记本电脑</span><br></pre></td></tr></table></figure><p>将上述2个维度两两组合，就会产生<code>3x3=9</code>种组合，也就意味着你需要创建9个不同的类用于完成需求。而更可怕的是，这还只是一个简化的模型，假设，现在维度增多，每个维度的可选方案增多，就会产生可怕的类膨胀问题，这显然是不可行的方案。说到类结构扩展，很多人第一个想到的手段就是继承，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LenovoComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LaptopComputer</span> <span class="keyword">extends</span> <span class="title">LenovoComputer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DellComputer</span> <span class="keyword">implements</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;戴尔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DesktopComputer</span> <span class="keyword">extends</span> <span class="title">DellComputer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.run();</span><br><span class="line">        System.out.println(<span class="string">&quot;台式本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>继承方式的优点是，大家都很熟悉这种方式，毕竟这是Java自带的功能。但是前面我们也不止一次的说过，在设计模式中，组合类和类之间关系推荐使用组合方式，而不是继承，至于原因前面也都说过，继承关系比较呆板，不利于扩展。一般而言，继承多用于具有明显”Is-A”的关系，并且尽量减少继承的层级，以免带来后续扩展的问题。而上面例子中，品牌和外观显然是两个不同的维度，并且也不具有”Is-A”的关系，所以不适合使用继承来扩展。</p><p>这个时候，我们今天要讲的<strong>桥接模式</strong>就登场了，桥接模式最拿手的就是<strong>处理这种具有明显多层次多维度变化的类的结构</strong>。</p><p>顾名思义，<strong>桥接模式</strong>的关键在于桥接。什么是桥接？一个整体和另一个整体通过某一种方式联系在一起就是桥接，而在桥接模式中，对于多维度变化的场景，每一个维度就是对应一个整体，联系的方式就是采用组合方式。</p><p>现在使用代码实现：</p><p>在上面的需求中，共有两个维度，品牌和外观。</p><p>维度1：品牌</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Lenovo</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;联想&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dell</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;戴尔&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HP</span> <span class="keyword">implements</span> <span class="title">Brand</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;惠普&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>维度2：外观</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    Brand brand;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Type</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.brand = brand;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Laptop</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Laptop</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;笔记本&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Desktop</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Desktop</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;台式机&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tablet</span> <span class="keyword">extends</span> <span class="title">Type</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Tablet</span><span class="params">(Brand brand)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(brand);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;平板电脑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这边关键在于<code>Type</code>维度中持有<code>Brand</code>维度的引用，采用组合方式将两个维度联系在一起，因为<code>Brand</code>是由外部传入，因为不会与<code>Type</code>维度耦合，这样就两个维度就可以独立扩展，互不干扰，符合“<strong>单一职责原则</strong>”，而多层继承是不符合“<strong>单一职责原则</strong>”的，因为一个类承担了太多职责，导致后续扩展性变差，同时，每一个维度的变化扩展都不会对已经存在的代码有任何影响，只需要扩展新的实现类即可，符合“<strong>开闭原则</strong>”。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>简单总结一下，所谓的<strong>桥接模式</strong>就是用来<em>解决存在多个维度并且需要各自独立变化扩展的场景，将每个维度抽象为一个抽象类或者接口，然后采用组合的方式将各个类联系起来，极大的提高了代码的扩展性。</em></p><p>不过上述我们的例子是为了演示桥接模式的原理，实际开发过程中肯定不会有这么简单的业务场景，桥接模式得以施展最关键的是在于如何识别界定多个维度，这个就需要有经验的开发人员具有一定的业务敏感度了，这也是桥接模式使用的难点。</p><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>因为桥接模式特点非常鲜明，所以他的实际应用场景也就是具有明显多维度相互独立变化的场景，比如人力资源系统中的奖金计算模块，奖金计算分为多个维度，比如可以按照奖金类别分为个人奖金、团体奖金、激励奖金，按照部门分等，可以分为人事部门、销售部门、研发部门等。</p><p>另外，其实在JDK中也有使用桥接模式的例子，最典型的是<code>JDBC</code>的设计，下面我做简单的介绍。</p><p><code>JDBC</code>是<code>Java</code>为了访问数据库而抽象的一套规范，我们知道数据库的实现很多，最流行的像<code>MySQL</code>和<code>Oracle</code>等，但是在<code>JDBC API</code>中，都是抽象成统一的<code>API</code>来实现用户的透明调用。<code>JDBC</code>中每一个对数据库的访问抽象为一个<code>Connection</code>对象，不同的数据库实现，自然<code>Connection</code>对象也不同，<code>Connection</code>对象是由<code>Driver</code>通过调用其<code>connect()</code>方法创建，不同的数据库实现提供各自实现的<code>Driver</code>实现。这些不同<code>Driver</code>实现就构成了第一个维度，如下图:<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-1.png" alt="桥接模式-1"><br>那么。第二个维度又是什么呢？</p><p>光有<code>Driver</code>实现没有用，必须需要有人来调用它的<code>connect()</code>方法，从而返回一个<code>Connection</code>对象，实现数据库访问。谁来调用<code>Driver</code>？没错，就是<code>DriverManager</code>。在<code>DriverManager</code>中维护了一个<code>CopyOnWriteArrayList</code>列表，里面保存着初始化（就是调用<code>Class.forName()</code>）时所有的<code>Driver</code>实现类。然后当调用<code>DriverManager</code>的<code>getConnection()</code>方法时，触发对其调用。</p><p>请看<code>DriverManager</code>的<code>getConnection()</code>方法核心源码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略无关代码</span></span><br><span class="line"><span class="keyword">for</span>(DriverInfo aDriver : registeredDrivers) &#123;</span><br><span class="line">    <span class="keyword">if</span>(isDriverAllowed(aDriver.driver, callerCL)) &#123;</span><br><span class="line">        println(<span class="string">&quot;    trying &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">        Connection con = aDriver.driver.connect(url, info);</span><br><span class="line">        <span class="keyword">if</span> (con != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Success!</span></span><br><span class="line">            println(<span class="string">&quot;getConnection returning &quot;</span> + aDriver.driver.getClass().getName());</span><br><span class="line">            <span class="keyword">return</span> (con);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        println(<span class="string">&quot;    skipping: &quot;</span> + aDriver.getClass().getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//省略无关代码</span></span><br></pre></td></tr></table></figure><p><code>DriverManager</code>会遍历所有检测到的<code>Driver</code>实现类，依次调用其<code>connect()</code>方法。</p><p>所以，这个<code>DriverManager</code>就是第二个维度！这个之所以比较难以理解，甚至不易发现的原因在于，标准的桥接模式的每个维度一般都是抽象为一个抽象类或者接口，并且会有多个实现类，而在其中一个维度中持有另一个维度的引用一般也是一个。而在<code>JDBC</code>中运用的桥接模式可以看成是标准桥接模式的一个变种，<code>Driver</code>维度没有问题，和标准模式一样，但是<code>DriverManager</code>维度居然是一个实体类，而并没有进一步抽象。另外，<code>DriverManager</code>维度中持有的<code>Driver</code>维度是一个集合（CopyOnWriteArrayList类型），并不是单个实体。整个桥接关系如下图所示:<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-2.png" alt="桥接模式-2"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式|⑧装饰者模式</title>
      <link href="/2019/12/26/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A7%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/12/26/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A7%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;今天我们要来聊的是<strong>装饰者模式</strong>，这个模式也是属于GOF23的结构型模式中的一个模式。</p><span id="more"></span><h2 id="装饰者"><a href="#装饰者" class="headerlink" title="装饰者"></a>装饰者</h2><p>何为装饰？</p><p>比如美女脸蛋上抹点粉，这就是装饰。房子装修一下，这也是装饰。咖啡里面加点牛奶，这也是装饰……生活当中，这样的场景太多了。那装饰有啥用呢？装饰后，美女变得更加亮丽动人，房子住的更加舒适，咖啡口感更加丝滑……</p><p>说白了，<em>装饰的作用就是在原来的基础上面，加点新功能，让原来的东西功能变得更好</em>。就比如举个简单的例子，普通人都会跑步，但是能飞的肯定不是普通人，那是超人，那问题是，怎么才能成为一个像超人一样能飞的人呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">action</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonMan</span> <span class="keyword">implements</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会跑步...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在原有基础上扩展功能很容易就能想到继承，所以可以如下实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan</span> <span class="keyword">extends</span> <span class="title">CommonMan</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.action();</span><br><span class="line">        fly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会飞...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，一个普通人就加上了飞的功能，如此之轻松，不是吗？</p><p>现在假设，我还需要在飞的基础上再加无穷力量的功能，照样画瓢，如下实现，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan2</span> <span class="keyword">extends</span> <span class="title">SuperMan</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.action();</span><br><span class="line">        power();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">power</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无穷力量!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是如此之轻松，不是吗？</p><p>现在我还需要在飞和无穷力量的基础上，再加上激光发射的功能，呵呵，这有啥难呢？继续画瓢呗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan3</span> <span class="keyword">extends</span> <span class="title">SuperMan2</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.action();</span><br><span class="line">        shoot();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">shoot</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;激光发射!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有任何扩展难度啊？不是吗？</p><p>现在来了个需求，我需要一个普通人再加上无穷力量的功能，但是不要飞的功能和激光发射的功能，照原来的思路，实现如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperMan4</span> <span class="keyword">extends</span> <span class="title">CommonMan</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.action();</span><br><span class="line">        power();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">power</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无穷力量!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在假设需求又变了，我现在有想要一个普通人加上激光发射的功能，但是不要飞的功能和无穷力量……</p><p>如果此时你发现情况好像有点不妙，那恭喜你，你的直觉很准。通过上面简单的演示，我们会发现，再扩展下去，类数量会越来越多，完全不好管理维护。而这种不好管理的问题，正是继承这种扩展方式带来的。其实之前的模式当前我们也曾经说到过，<strong>继承这种模式只适合应用在，父子类之间确实存在Is-A的关系，并且子类尽量通过增加新的方法，但是不要去修改父类已有的功能</strong>。否则，在扩展的时候就会出现扩展非常呆板，后期非常不好维护的局面。这边涉及到一个设计原则——<strong>里氏替换原则</strong>。</p><blockquote><p>里氏替换原则提倡，子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p></blockquote><p>继承的主要问题在于，父子类功能耦合性比较高，后续不容易修改，因为父类的功能都会被单向的继承给子类，但是子类的功能是无法反向给父类的。那有没有一种办法可以将功能点单独抽离出来？</p><h2 id="装饰者模式"><a href="#装饰者模式" class="headerlink" title="装饰者模式"></a>装饰者模式</h2><p>这个需求使用装饰者模式来解决就特别合适了。<strong>装饰者模式</strong>采用的是<strong>组合</strong>的方式来解决的。之前我们也提到过，对于功能扩展，一般来说，<em>组合要优于继承方式</em>，因为组合耦合性更低，会更加灵活。下面我们来看看装饰者模式是怎么解决这个问题？</p><p>我们需要先提供一个<strong>抽象装饰者类</strong>，这个类封装需要增强的原始对象，然后，根据不同的功能点提供其子类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CommonManWrapper</span> <span class="keyword">implements</span> <span class="title">Man</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Man man;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonManWrapper</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.man = man;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        man.action();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比如，需要增加飞的功能，那么增加一个子类，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonManFlyWrapper</span> <span class="keyword">extends</span> <span class="title">CommonManWrapper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonManFlyWrapper</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(man);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.action();</span><br><span class="line">        fly();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;我会飞...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那这个类怎么用呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CommonManFlyWrapper(<span class="keyword">new</span> CommonMan()).action();</span><br><span class="line"><span class="comment">//输出如下:</span></span><br><span class="line">我会跑步...</span><br><span class="line">我会飞...</span><br></pre></td></tr></table></figure><p>哈哈，成功的实现了功能的扩展。有的人可能看得有点懵，这样设计有啥好处，看着好像比继承复杂多了，还不好理解啊？好，我们继续看…</p><p>现在假设重新来实现最开始的需求，我需要在飞的基础上再加无穷力量的功能。这个时候，我们可不用再需要在<code>CommonManFlyWrapper</code>基础上去做扩展哦，这样又会出现继承的问题。我们将再创建一个装饰者类，这个类专门负责加无穷力量的功能。有没有发现？这样就是和其它功能完全解耦了，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CommonManPowerWrapper</span> <span class="keyword">extends</span> <span class="title">CommonManWrapper</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CommonManPowerWrapper</span><span class="params">(Man man)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(man);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">action</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.action();</span><br><span class="line">        power();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">power</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;无穷力量!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行结果如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CommonManPowerWrapper(<span class="keyword">new</span> CommonMan()).action();</span><br><span class="line"><span class="comment">//输出如下:</span></span><br><span class="line">我会跑步...</span><br><span class="line">无穷力量!</span><br></pre></td></tr></table></figure><p>看，这次只增加了无穷力量的功能，并没有带上其它功能。功能之间完全解耦。那现在我想要多个功能呢？既要能飞，也要有无穷力量，怎么实现？这个时候再也不需要添加新的类了，只要<em>把几个装饰者类组合一下</em>即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> CommonManPowerWrapper(<span class="keyword">new</span> CommonManFlyWrapper(<span class="keyword">new</span> CommonMan())).action();</span><br><span class="line"><span class="comment">//输出如下:</span></span><br><span class="line">我会跑步...</span><br><span class="line">我会飞...</span><br><span class="line">无穷力量!</span><br></pre></td></tr></table></figure><p>有没有体会到这种设计的厉害！有心人肯定发现，这种操作方式和我们平时使用的<code>IO</code>的<code>API</code>极其相似。没错，<code>IO API</code>正是使用了<strong>装饰者模式</strong>，后面我们也会一起分析<code>IO API</code>的代码，现在我们可以来做个小总结。</p><h2 id="装饰者和继承"><a href="#装饰者和继承" class="headerlink" title="装饰者和继承"></a>装饰者和继承</h2><p>首先我们来拿<strong>装饰者模式</strong>和<strong>继承方式</strong>做个比较。</p><p>装饰者模式和继承方式都可以对类进行扩展。</p><p>但是<strong>继承</strong>的问题我们开头可以看到，一旦涉及到有<em>多个功能点相互组合的需求</em>，继承扩展的呆板之处就一览无遗。比如需要在一个基类涉及3个功能点，相互组合，极端情况下，你会需要创建6个不同的子类来应对不同的需求扩展，这还不包括有些功能之间会存在顺序问题，这为后续维护带来极大的困难。</p><p>而<strong>装饰者模式</strong>的增强主要是通过为每一个功能点创建各自的装饰者类，每一个装饰者只负责增强自己的功能，与其它的功能以及基类都不存在直接的附属关系，这样就把功能扩展点很好的解耦开来，后续通过不同的组合达到非常灵活的增强。</p><h2 id="装饰者和代理模式"><a href="#装饰者和代理模式" class="headerlink" title="装饰者和代理模式"></a>装饰者和代理模式</h2><p>另外，在上面讲装饰者模式时，不知道有没有人发现，装饰者模式的实现方式跟之前讲过的代理模式简直惊人的相似！装饰者模式的装饰者类会需要实现被装饰对象相同接口，然后再实现的方法上做增强，这跟代理模式中，代理类需要和目标对象实现相同接口，然后再实现的方法上做增强貌似完全没区别啊？那么这两个模式到底有啥<strong>区别</strong>呢？</p><p>其实关于这个问题，网上也是众说纷纭，我不想把网上的话跟着抄一遍，就谈点自己的想法。</p><p>之前就说过，设计模式这玩意就是一种思路，没必要把几种模式区别的特别清楚，泾渭分明。其实这两个模式从实现上来说很相近，从作用上来说也是很相近的，<strong>都是对一个对象增强</strong>，只能说两者的侧重点不同。</p><p><strong>装饰者模式</strong>如其名，他偏重于<em>在不改变原有对象的前提下，增强原有对象的功能，强调的是将功能一层层的包装到目标对象上，并且这个包装的过程可以在运行时动态的进行和切换</em>。</p><p>而<strong>代理模式</strong>更多强调的是<em>通过为目标对象生成一个代理对象，屏蔽真实对象的直接访问的作用</em>。但是，这样的定义其实还是非常模糊的，因为代理在访问真实对象的时候，也可以为目标对象添加一些额外的功能，无非是她更关心的是代理的作用。反过来说，装饰者模式通过装饰者类对真实对象经过层层封装后达到增强原有对象的功能，但同时，这不也是一种代理吗？无非它更关心的是功能增强的这个过程。</p><p>总之，设计模式是用来为写代码提供优雅的思路的，不是用来钻牛角尖的，所以关于两者区别，大家有自己的理解即可。</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>最后，我们还是一起看一下在实际开发场景中，装饰者模式到底是怎么使用的？</p><blockquote><p>谈到装饰者模式，首先不得不说<code>JDK</code>中<code>IO API</code>了。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InputStream inputStream = <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">&quot;xxx&quot;</span>)));</span><br></pre></td></tr></table></figure><p>上面就是我们平时开发中特别熟悉的IO的使用方式，使用<code>BufferedInputStream</code>对<code>FileInputStream</code>进行一个包装，使得<code>FileInputStream</code>增加了<strong>缓冲读取</strong>的功能，提高IO效率。其实在这里，<code>BufferedInputStream</code>就充当了<strong>装饰者</strong>的角色。那么JDK是怎么实现的呢？</p><p>进入<code>BufferedInputStream</code>源码会发现，<code>BufferedInputStream</code>继承自<code>FilterInputStream</code>（可以看做成上面例子中的CommonManWrapper抽象类），<code>FilterInputStream</code>又继承自<code>InputStream</code>（可以看做是Man接口），在<code>FilterInputStream</code>中维护着一个<code>InputStream</code>类型的属性<code>in</code>，而其继承自<code>InputStream</code>核心方法<code>read()</code>中，将<code>read()</code>的功能转发给了传入的<code>in</code>。当往<code>BufferedInputStream</code>中传入一个<code>FileInputStream</code>类型的对象，最终会被设置到<code>in</code>中。而<code>BufferedInputStream</code>作为一个<strong>装饰者类</strong>，在其实现的<code>read()</code>中，会调用继承自<code>FilterInputStream</code>的<code>in</code>的<code>read()</code>功能，但是同时添加了使用缓冲操作的功能。</p><blockquote><p>另外再说一个<code>Mybatis</code>里面的应用。</p></blockquote><p><code>Mybatis</code>当中的<strong>缓存模块</strong>使用了<strong>装饰者模式</strong>。在<code>Mybatis</code>中，缓存模块最顶层接口是<code>Cache</code>接口，他有很多实现类，如图:<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F-1.png" alt="装饰者模式-1"><br>但是这里面只有<code>PerpetualCache</code>是<em>真正具有缓存功能实现的实现类</em>，其内部会通过维护一个<code>HashMap</code>来缓存数据，而其余的<code>Cache</code>实现类<strong>都只是其装饰者类</strong>。以<code>LoggingCache</code>为例，他就会在<code>PerpetualCache</code>的功能基础上加上了日志功能。查看<code>LoggingCache</code>的<code>getObject()</code>方法:<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F-2.png" alt="装饰者模式-2"><br>其中的<code>delegate</code>就是定义在<code>LoggingCache</code>中的属性，由外部传入，将真正的缓存获取操作转发给它，同时添加打印缓存命中的日志信息。其余的<code>Cache</code>实现类如出一辙。</p><p>另外，在<code>Java Servlet API</code>中有一个<code>HttpServletRequestWrapper</code>类，从命名就可以看出，这也是一个使用了装饰者模式的类，一般运用装饰者模式的类都会以<code>Wrapper</code>或者<code>Decorator</code>结尾。那这个类是干什么用的？听名字就可以知道，这个类是对<code>HttpServletRequest</code>进行装饰。这玩意主要配合<code>Filter</code>使用。</p><p>比如现在有个需求，需要将客户端收到请求参数加密处理后再继续后传，这个时候我们可以自定义一个<code>HttpServletRequestWrapper</code>子类，然后重写其<code>getParameter()</code>方法，然后在原先的获取参数之后添加上加密逻辑，然后添加一个<code>Filter</code>，在他的<code>doFilter()</code>时候，使用我们自定义的<code>HttpServletRequestWrapper</code>对象替换掉原生的<code>HttpServletRequest</code>对象，达到偷梁换柱的效果。😊👏</p><p><img src="/images/end.gif" alt="end"></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式|⑦适配器模式</title>
      <link href="/2019/12/26/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A6%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/12/26/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A6%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;今天我们要来聊的是<strong>适配器模式</strong>，这个模式和上篇讲过的代理模式一样，也是属于GOF23的结构型模式中的一个模式。</p><span id="more"></span><h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><blockquote><p>❓何为适配器？</p></blockquote><p>很经典的一个例子，就是插座:</p><p>假设，一台电脑需要用电，他的插头是两项插头，但是呢，插座却只有三项插孔的。怎么办？插座就在那里，是不可能改变的。我们总不能为了电脑用个电把整个电脑换了吧？不现实！那我们常用的做法就是买一个<em>转接头</em>，一面是两项插孔，一面是三项插孔。这样就很好的解决了这个问题。</p><p>这个生活中常见的场景就是经典的<strong>适配器模式</strong>的体现。</p><p>那现在让我用代码来实现一下，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三项插座</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dominate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cost</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ... <span class="comment">//用电逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//电脑</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在电脑运行需要使用电，说白了，Computer或者（实现类）的<code>run()</code>需要调用<code>Dominate</code>的<code>cost()</code>方法，怎么办？你可能会如下实现:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> <span class="keyword">implements</span> <span class="title">Computer</span> <span class="keyword">extends</span> <span class="title">Dominate</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>Adaptor</code>提供了一个中间的<strong>适配器角色</strong>，因为要以<code>Computer</code>的方式去使用，所以需要实现<code>Computer</code>接口，因为其<code>run()</code>方法需要使用到<code>Dominate</code>的<code>cost()</code>逻辑，所以，通过<em>继承</em><code>Dominate</code>方式就可以实现这个需求。这样之后，我需要使用电脑，我不在直接去调用<code>Computer</code>的<code>run()</code>了，因为这个里面没有电，我通过调用<code>Adaptor</code>的<code>run()</code>方法去使用电脑就可以了。</p><p>上面这样的方式很好的解决了因为插孔不兼容而导致的问题。这种方式有什么问题吗？</p><p>我们知道，<code>Java</code>是<strong>单继承</strong>的，上面采用继承方式来达到调用<code>Dominate</code>的<code>cost()</code>方法的目的，这样也就意味着Adaptor以后无法再继承其它的类来扩展，这或多或少会影响到以后的扩展性。</p><p>更关键的是，还记得第一天说过的几大设计原则吗？这个地方就又涉及到了一个设计原则，叫做<strong>组合聚合复用原则</strong>。</p><blockquote><p>组合聚合复用原则提倡，软件复用优先使用组合或者聚合关系复用，少用继承关系复用。</p></blockquote><p>为什么呢？</p><p>这边我不特别展开关于组合和继承的阐述。一般来说，继承的方式用于真的是具有”Is－A”的父子关系。而我们的例子中，我们的适配器只是想去调用插座的用电逻辑，但它本身可并不属于插座哦？而且继承关系会导致类和类之间耦合性增大，不利于类的扩展、复用和维护。</p><p>其实等你看到后面的一些模式，你会对此更有体会，<em>在很多场合下，用组合方式扩展设计，会比继承方式灵活很多，甚至好多模式就是用组合模式来解决继承方式不易扩展的弊病</em>。</p><p>所以上面例子，我们可以使用组合方式加以改造，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> <span class="keyword">implements</span> <span class="title">Computer</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dominate dominate;</span><br><span class="line">    <span class="comment">//省略构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">        dominate.cost();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就很轻松的解决了这个问题。</p><h2 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h2><p>做个小总结，适配器模式就是解决这样一种<strong>场景</strong>，客户端需要通过一种方式（或者接口规范）去访问或者使用另一个已经存在的接口，但是由于各类原因，没有办法直接去调用。这个时候可以提供一下<em>中间媒介</em>作为<strong>适配器对象</strong>，在其内部将接口做一下转换，然后客户端就可以顺利的通过访问适配器的方式去访问目标接口了。</p><p>适配器模式的实现有两种，就是上面展示的两种，一种是通过<em>继承方式</em>，另一种是通过<em>组合方式</em>实现的。考虑到Java的单继承特点，加上组合聚合复用设计原则，一般都会采用组合方式实现。</p><p>适配器模式的<strong>优点</strong>也很明显，它使得在不需要修改已有代码的前提下，直接重用现有的类库代码。而且实现起来很简单，也很容易理解。另外对于客户端而言，适配器这种兼容转换不同接口的方式是在其内部实现的，对于客户端而言是完全透明的，客户端无需了解目标接口的细节，只需要按照当前接口的规范去调用即可。</p><h2 id="实际应用场景"><a href="#实际应用场景" class="headerlink" title="实际应用场景"></a>实际应用场景</h2><p>适配器在实际开发中应用也是相当广泛。下面我举几个很典型使用适配器模式的例子来说明，相信大家看完后会有更加清晰的认识。</p><h3 id="默认适配器"><a href="#默认适配器" class="headerlink" title="默认适配器"></a>默认适配器</h3><p>首先我先讲一个有点特殊的实际应用场景，相信大家都曾经遇到过。</p><p>假设现在有一个<code>A</code>接口，这个接口里面定义了非常多的接口方法<code>m1()</code>，<code>m2()</code>，<code>m3()</code>……针对不同功能点，然后其实现类也是根据不同的功能对A接口进行实现，但是每个实现类可能只需要实现其中自己关注的那个方法即可，至于其余无关的方法我并不想实现。但是Java语法限制，如果一个实体类要实现一个接口，必须需要实现其所有抽象方法。这也就意味着他会将自己关注的那个方法实现，而至于其余不关心都只能空实现。这样的造成了极大的代码冗余，而且这些冗余的代码毫无优雅可言，除了占用空间和美观不起任何作用。如下图:<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-1.png" alt="适配器模式-1"><br>这个时候，有一种比较特殊的适配器模式，叫<strong>默认适配器模式</strong>来解决这个问题。</p><blockquote><p>怎么解决呢？</p></blockquote><p>在接口的直接下层，定义一个抽象层作为适配器，将接口的所有方法全部空实现。而所有的具体实现类不会再直接实现顶层接口了，而且去跟这个抽象层打交道，这样的话，每个具体实现类只需要实现自己关注的方法即可。如下，<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-2.png" alt="适配器模式-2"></p><h3 id="JDK-IO转换流的实现"><a href="#JDK-IO转换流的实现" class="headerlink" title="JDK IO转换流的实现"></a>JDK IO转换流的实现</h3><p>JDK的IO API中转换流<code>InputStreamReader</code>和<code>OutputStreamWriter</code>也是应用了适配器模式，实现了由<em>字节流</em>到<em>字符流</em>的转换，下面我简单的带大家来看看其实现。</p><p><code>OutputStreamWriter</code>继承了<code>Writer</code>（目标接口），并且重写了<code>Writer</code>所有核心的方法。但是我们现在只能提供一个字节流<code>OutputStream</code>类型，<code>OutputStreamWriter</code>内会将其封装成为<code>StreamEncoder</code>对象，并且设置为<code>OutputStreamWriter</code>的属性。至于封装<code>StreamEncoder</code>对象是因为还需要考虑字符集编码的问题，这个不是重点。然后此时，客户端去访问<code>OutputStreamWriter</code>的<code>write()</code>等方法时，会将其委托给<code>StreamEncoder</code>对象的相关方法执行，从而实现由<em>字节流</em>操作到<em>字符流</em>操作的转换。</p><h3 id="开源框架中的运用"><a href="#开源框架中的运用" class="headerlink" title="开源框架中的运用"></a>开源框架中的运用</h3><p>另外，开源框架<code>Spring</code>、<code>Mybatis</code>中适配器模式的应用不计其数。</p><p><code>SpringMVC</code>中，<code>HandlerAdaptor</code>就是一个典型例子。如果有深入了解过SpringMVC原理源码的朋友应该会知道，<code>SpringMVC</code>中所有的请求会被前端控制器<code>DispatcherServlet</code>转发给次级控制器进行具体的请求处理，<code>SpringMVC</code>将其次级控制器都称之为<code>Handler</code>，我们平时绝大多数使用的<code>Controller</code>就是其中之一。很多人可能会认为次级控制器只有<code>Controller</code>，其实<code>SpringMVC</code>理论上支持任意多种控制器，包括<code>Struts2</code>中的<code>Action</code>等。那么问题来了，各类次级控制器实现原理五花八门，如下图，<code>SpringMVC</code>如何将其统一抽象呢？<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-3.png" alt="适配器模式-3"><br>这其中的关键就是在于<code>HandlerAdaptor</code>这个组件，听名字就知道这个使用了适配器模式。那他是怎么实现的呢？我带大家简单看一下<code>SpringMVC</code>的实现。<code>HandlerAdapter</code>中主要有两个方法，<code>supports()</code>和<code>handle()</code>。前者会通过传入一个具体的<code>Handler</code>实例进行判断其类型，确定当前的<code>Handler</code>是否可以被<code>SpringMVC</code>支持处理。如果可以，会通过<code>handle()</code>处理请求并返回<code>ModelAndView</code>实例进行后续视图解析返回等工作。这样<code>DispatcherServlet</code>在做请求转发的时候就不需要考虑每一个具体的<code>Handler</code>的实现了，他只需要跟一系列的<code>HandlerAdaptor</code>打交道，至于对<code>Handler</code>的类型校验，还有具体的请求处理，都是在<code>HandlerAdaptor</code>内部实现，对于<code>DispatcherServlet</code>（此处作为客户端）完全是透明的。如下图:<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-4.png" alt="适配器模式-4"><br>另外，在<code>SpringMVC</code>在实现其<code>HandlerInterceptor</code>拦截器时，使用了<code>HandlerInterceptorAdapter</code>，顾名思义也是用到了适配器模式，而且还是上面讲到过的<strong>默认适配器模式</strong>。</p><p>同样作为优秀的开源框架<code>Mybatis</code>中适配器模式也应用的非常广，最典型的就是<code>Mybatis</code>的日志模块了。众所周知，<code>Mybatis</code>支持<code>log4j</code>等各大开源日志框架，那么各大开源日志框架底层实现五花八门，他又是怎么做到<strong>统一抽象</strong>的呢？其实和上面<code>SpringgMVC</code>的<code>HandlerAdaptor</code>的思路是一样的。窥一斑而知全豹吧，技术最重要的就是举一反三，灵活运用了。限于篇幅，这两个的原理我这边就不多废话了，大家如果有兴趣可以去阅读一下其源码实现。😊👏</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>吞吐量、TPS、QPS、并发数、响应时间（RT）概念</title>
      <link href="/2019/12/05/%E5%90%9E%E5%90%90%E9%87%8F%E3%80%81TPS%E3%80%81QPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%EF%BC%88RT%EF%BC%89%E6%A6%82%E5%BF%B5/"/>
      <url>/2019/12/05/%E5%90%9E%E5%90%90%E9%87%8F%E3%80%81TPS%E3%80%81QPS%E3%80%81%E5%B9%B6%E5%8F%91%E6%95%B0%E3%80%81%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%EF%BC%88RT%EF%BC%89%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<h2 id="响应时间-RT-（Response-time）"><a href="#响应时间-RT-（Response-time）" class="headerlink" title="响应时间(RT) （Response-time）"></a>响应时间(RT) （Response-time）</h2><p>&emsp;<strong>响应时间是指系统对请求作出响应的时间</strong>。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。 </p><p>&emsp;<strong>对于单机</strong>的没有并发操作的应用系统而言，人们普遍认为<strong>响应时间是一个合理且准确的性能指标</strong>。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。 </p><span id="more"></span><h2 id="吞吐量-Throughput"><a href="#吞吐量-Throughput" class="headerlink" title="吞吐量(Throughput)"></a>吞吐量(Throughput)</h2><p>&emsp;<strong>吞吐量是指系统在单位时间内处理请求的数量</strong>。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但<strong>对于并发系统</strong>，通常需要<strong>用吞吐量作为性能指标</strong>。 </p><p>&emsp;对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多步骤难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。 </p><h2 id="并发用户数"><a href="#并发用户数" class="headerlink" title="并发用户数"></a>并发用户数</h2><p>&emsp;<strong>并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量</strong>。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。以网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。 </p><h2 id="TPS每秒事务数-Transactions-Per-Second"><a href="#TPS每秒事务数-Transactions-Per-Second" class="headerlink" title="TPS每秒事务数(Transactions Per Second)"></a>TPS每秒事务数(Transactions Per Second)</h2><p>&emsp;是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数。</p><h2 id="QPS每秒查询率-Query-Per-Second"><a href="#QPS每秒查询率-Query-Per-Second" class="headerlink" title="QPS每秒查询率(Query Per Second)"></a>QPS每秒查询率(Query Per Second)</h2><p>&emsp;每秒查询率QPS是对<strong>一个特定的查询服务器在规定时间内所处理流量多少</strong>的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即<strong>每秒的响应请求数</strong>，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）</p><p>&emsp;QPS基本类似于TPS，但是不同的是，对于一个页面的一次访问，形成一个TPS；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“QPS”之中<br>例：访问一个页面会请求服务器3次，一次放，产生一个“T”，产生3个“Q”</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式|⑥代理模式</title>
      <link href="/2019/12/02/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A5%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/12/02/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A5%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;今天我要跟大家聊的是<strong>代理模式</strong>。这一模式可以说是GOF23所有设计模式中应用最广泛，但又最难以理解的一种模式，尤其是其中的<strong>动态代理模式</strong>，但是其功能之强大，应用场景之广自然就体现出其重要性。有些场景要是没有使用这一模式，就会变得很难实现。可以这么说，我所了解过的或者阅读过源码的开源框架，底层几乎没有不用到代理模式的，尤其是接下去本文要说的重点-动态代理模式。因此，在文章的最后，我也会以一个在<code>Mybatis</code>底层使用<strong>动态代理模式</strong>解决的经典场景作为本文结束。</p><span id="more"></span><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><p>首先，我们先来说说代理。何为代理？来看张图。这就是我们日常租房的场景，客户来一个陌生城市需要租一个房子，但是他人生地不熟，根本不知道行情，也不知道地段，更没有房东的联系方式，所以，他会去找类似我爱我家之类的租房中介，而这些个中介手上会有大量房子的信息来源，自然会有个房东的联系方式，进而和房东取得联系，从而达到租房的目的。这个场景就是一个经典的代理模式的体现。<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-1.png" alt="代理模式-1"></p><h2 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h2><p>既然说到动态代理，自然联想到肯定会有静态代理。下面我们就先从简单的开始，以上面租房的这个例子，用<code>Java</code>代码实现静态代理。</p><p>首先在代理模式（甭管静态还是动态）结构中，肯定会有一个真实角色（<code>Target</code>），也是最后真正执行业务逻辑的那个对象，比如上图中的房东（因为最后租的房子所有权是他的，也是和他去办租房合同等手续），另外会有一个代理角色（<code>Proxy</code>），比如上图中的房产中介（他没有房产所有权），并且这个角色会必然实现一个与真实角色相同的抽象接口（<code>Subject</code>），为什么呢？因为虽然这个出租的房子不是他的，但是是经他之手帮忙牵线搭桥出租出去的，也就是说，他和房东都会有出租房产的行为。另外代理角色会持有一个真实角色的<strong>引用</strong>，又是为什么呢？因为他并不会（或者是不能）真正处理业务逻辑（因为房子不是他的呗），他会将真正的逻辑委托给真实角色处理。但是这个代理角色也不是一无是处，除了房子不是他的，但是他还可以给你干点跑腿的工作嘛，比如帮你挑选最好的地段，挑选合适的价格等等，等你租房后出现漏水，或者电器啥的坏了可以帮你联系维修人员等等。如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共抽象接口 - 出租的人</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//真实角色 - 房东</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;客官请进，我家的房子又大又便宜，来租我的吧...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//代理角色 - 房产中介</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    Person landlord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Agent</span><span class="params">(Person landlord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.landlord = landlord;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">//前置处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;经过前期调研，西湖边的房子环境挺好的...&quot;</span>);</span><br><span class="line">      <span class="comment">//委托真实角色处理</span></span><br><span class="line">        landlord.rent();</span><br><span class="line">      <span class="comment">//后置处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;房子漏水，帮你联系维修人员...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person landlord = <span class="keyword">new</span> Landlord();</span><br><span class="line">        Person agent = <span class="keyword">new</span> Agent(landlord);</span><br><span class="line">        agent.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">经过前期调研，西湖边的房子环境挺好的...</span><br><span class="line">客官请进，我家的房子又大又便宜，来租我的吧...</span><br><span class="line">房子漏水，帮你联系维修人员...</span><br></pre></td></tr></table></figure><p>静态代理模式实现相对比较简单，而且比较好理解，也确实实现了代理的效果。但是很遗憾，<strong>几乎没有</strong>一个开源框架的内部是采用静态代理来实现代理模式的。那是为什么呢？原因很简单，从上面这个例子可以看出，静态代理模式中的<strong>真实角色和代理角色紧耦合</strong>了。怎么理解？</p><p>下面来举个例子帮助理解静态代理模式的缺点，深入理解静态代理的缺点对于理解动态代理的应用场景是至关重要的。因为动态代理的诞生就是为了解决这一问题。</p><p>还是以上面的租房的场景，假设我现在需要你实现如下需求：有多个房东，并且每个房东都有多套房子出租，你怎么用<code>Java</code>设计？按照上面的静态代理模式的思路，你也许会有如下实现（伪代码），</p><p>第一种方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord01</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent01</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent02</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent03</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord02</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent01</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent02</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent03</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord03</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent01</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent02</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent03</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...可能还有很多房东，省略</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent01</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    Person landlord01;</span><br><span class="line">    <span class="comment">//省略构造器等信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;landlord01.rent();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent02</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    Person landlord02;</span><br><span class="line">    <span class="comment">//省略构造器等信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;landlord02.rent();&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent03</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    Person landlord03;</span><br><span class="line">    <span class="comment">//省略构造器等信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> </span>&#123;landlord03.rent();&#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>上面这种方案是为每个房东配一个对应的中介处理租房相关事宜。这种方案问题非常明显，每一个真实角色都需要手动创建一个代理角色与之对应，而这些代理类的逻辑有可能都是很相似的，因此当真实角色数量非常多时，会造成<strong>代理类数量膨胀</strong>问题和<strong>代码重复冗余</strong>，方案不可取。</p><p>第二种方案：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord01</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent01</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent02</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent03</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord02</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent01</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent02</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent03</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Landlord03</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent01</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent02</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent03</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Agent</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    Person landlord01;</span><br><span class="line">  Person landlord02;</span><br><span class="line">  Person landlord03;</span><br><span class="line">    <span class="comment">//省略构造器等信息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent01</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent02</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rent03</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种方案只创建<strong>一个代理角色</strong>，同时代理多个真实角色，这看上去貌似解决了第一种方案的弊病，但是同时引入了新的问题。那就是<strong>造成了代理类的膨胀</strong>。设计模式中有条重要原则——<strong>单一职责原则</strong>。这个代理类违反了该原则。当这个代理类为了代理其中某个真实角色时，需要将所有的真实角色的引用全部传入，显然太不灵活了。还是不可取。</p><p>而且有没有发现静态代理还有两个很大的问题，第一，当抽象接口一旦修改，真实角色和代理角色必须全部做修改，这违反了设计模式的<strong>开闭原则</strong>。第二，每次创建一个代理角色，需要手动传入一个已经存在的真实角色。但是在有些场景下，我们可能需要在并不知道真实角色的情况下创建出指定接口的代理。</p><h2 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h2><p>前面做了这么多铺垫，终于今天本文的主角——动态代理模式要登场了。此处应该有掌声……👏而动态代理模式的产生就是为了解决上面提到的静态代理所有弊病的。</p><p><code>JDK</code>动态代理的实现关键在于<code>java.lang.reflect.Proxy</code>类，其<code>newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces, InvocationHandler h)</code>方法是整个<code>JDK</code>动态代理的<strong>核心</strong>，用于生成指定接口的代理对象。这个方法有三个参数，分别表示加载动态生成的代理类的<strong>类加载器</strong><code>ClassLoader</code>，代理类<strong>需要实现的接口</strong><code>interfaces</code>以及调用<strong>处理器</strong><code>InvocationHandler</code>，这三个参数一个比一个难以理解，说实话，我第一次学动态代理模式时，看到这三个参数也是一脸懵逼的状态。动态代理模式之所以比较难理解关键也是这个原因。放心，后面会一一详解。但在这之前，我们先做一下热身，先用代码简单使用一下<code>JDK</code>的动态代理功能。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//公共抽象接口和真实角色和静态代理的例子中代码相同，省略</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义调用处理器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RentHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    Person landlord;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RentHandler</span><span class="params">(Person landlord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.landlord = landlord;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//客户端对代理对象发起的所有请求都会被委托给该方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">      <span class="comment">//前置处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;经过前期调研，西湖边的房子环境挺好的...&quot;</span>);</span><br><span class="line">      <span class="comment">//委托给真实角色处理业务逻辑</span></span><br><span class="line">        method.invoke(landlord, args);</span><br><span class="line">      <span class="comment">//后置处理</span></span><br><span class="line">        System.out.println(<span class="string">&quot;房子漏水，帮你联系维修人员...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person landlord = <span class="keyword">new</span> Landlord();</span><br><span class="line">        Person proxy = (Person) Proxy.newProxyInstance(</span><br><span class="line">          ClassLoader.getSystemClassLoader(), <span class="comment">//默认类加载器</span></span><br><span class="line">          <span class="keyword">new</span> Class[]&#123;Person.class&#125;, <span class="comment">//代理的接口</span></span><br><span class="line">          <span class="keyword">new</span> RentHandler(landlord));<span class="comment">//自定义调用处理器实现</span></span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果：</span></span><br><span class="line">经过前期调研，西湖边的房子环境挺好的...</span><br><span class="line">客官请进，我家的房子又大又便宜，来租我的吧...</span><br><span class="line">房子漏水，帮你联系维修人员...</span><br></pre></td></tr></table></figure><p>可以看出，动态代理轻松的实现了代理模式，并且输出了和静态代理相同的结果，然而我们并没有写任何的代理类，是不是很神奇？下面我们就来深度剖析<code>JDK</code>实现的动态代理的原理。</p><h2 id="Proxy-newProxyInstance"><a href="#Proxy-newProxyInstance" class="headerlink" title="Proxy.newProxyInstance()"></a>Proxy.newProxyInstance()</h2><p>在上面实现的<code>JDK</code>动态代理代码中，核心的一行代码就是调用<code>Proxy.newProxyInstance()</code>，传入类加载器等参数，然后一顿神奇的操作后居然就直接返回了我们所需要的代理对象，因此我们就从这个神奇的方法开始说起……</p><p>进入这个方法的源码中，以下是这个方法的核心代码，逻辑非常清楚，使用<code>getProxyClass0</code>获取一个<code>Class</code>对象，其实这个就是最终生成返回的代理代理类的<code>Class</code>对象，然后使用反射方式获取有参构造器，并传入我们的自定义<code>InvocationHandler</code>实例创建其对象。由此我们其实已经可以猜测，这个动态生成的代理类会有一个参数为<code>InvocationHandler</code>的构造器，这一点在之后会得到验证。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h)</span> <span class="keyword">throws</span> IllegalArgumentException </span>&#123;</span><br><span class="line">... <span class="comment">//省略一些非空校验，权限校验的逻辑</span></span><br><span class="line">    <span class="comment">//返回一个代理类，这个是整个方法的核心，后续会做详细剖析</span></span><br><span class="line">    Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line"><span class="comment">//使用反射获取其有参构造器，constructorParams是定义在Proxy类中的字段，值为&#123;InvocationHandler.class&#125;</span></span><br><span class="line">    <span class="keyword">final</span> Constructor&lt;?&gt; cons = cl.getConstructor(constructorParams);</span><br><span class="line"><span class="comment">//使用返回创建代理对象</span></span><br><span class="line">    <span class="keyword">return</span> cons.newInstance(<span class="keyword">new</span> Object[]&#123;h&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那现在很明显了，关键的核心就在于<code>getProxyClass0()</code>方法的逻辑了，于是我们继续深入虎穴查看其源码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader, Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">    <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;interface limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最开始就是检验一下实现接口数量，然后执行<code>proxyClassCache.get()</code>。<code>proxyClassCache</code>是一个定义在<code>Proxy</code>中的字段，你就将其当做一个代理类的缓存。这个也好理解，稍后大家会看到，动态代理类生成过程中会伴随大量的<code>IO</code>操作，<code>字节码</code>操作还有<code>反射</code>操作，还是比较消耗资源的。如果需要创建的代理类数量特别多，性能会比较差。所以<code>Proxy</code>提供了<code>缓存机制</code>，将已经生成的代理类缓存，当获取时，会先从缓存获取，如果获取不到再执行生成逻辑。</p><p>我们继续进入<code>proxyClassCache.get()</code>。这个方法看起来比较费劲，因为我使用的是<code>JDK8</code>，这边用到了大量的<code>Java8</code>新增的函数式编程的语法和内容，因为这边不是专门讲<code>Java8</code>的，所以我就不展开函数式编程的内容了。另外，这边会有很多对缓存的操作，这个不是我们的重点，所以也全部跳过，我们挑重点看，关注一下下面这部分代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key, P parameter)</span></span>&#123;</span><br><span class="line">  ... <span class="comment">//省略大量的缓存操作</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (supplier != <span class="keyword">null</span>) &#123;</span><br><span class="line">            V value = supplier.get();</span><br><span class="line">            <span class="keyword">if</span> (value != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> value;★</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">            factory = <span class="keyword">new</span> WeakCache.Factory(key, parameter, subKey, valuesMap); ▲</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">            supplier = valuesMap.putIfAbsent(subKey, factory);</span><br><span class="line">            <span class="keyword">if</span> (supplier == <span class="keyword">null</span>) &#123;</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (valuesMap.replace(subKey, supplier, factory)) &#123;</span><br><span class="line">                supplier = factory;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            supplier = valuesMap.get(subKey);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码非常有意思，是一个死循环。或许你和我一样，完全看不懂这代码是啥意思，没关系，可以仔细观察一下这代码你就会发现柳暗花明。这个方法最后会需要返回一个从缓存或者新创建的代理类，而这整个死循环只有一个出口，没错就是带★这一行，而value是通过<code>supplier.get()</code>获得，<code>Supplier</code>是一个函数式接口，代表了一种数据的获取操作。我们再观察会发现，<code>supplier</code>是通过<code>factory</code>赋值而来的。而<code>factory</code>是通过▲行创建出来的。<code>WeakCache.Factory</code>恰好是<code>Supplier</code>的实现。所以我们进入<code>WeakCache.Factory</code>的<code>get()</code>，核心代码如下，经观察可以发现，返回的数据最终是通过<code>valueFactory.apply()</code>返回的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> V <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">... <span class="comment">//省略一些缓存操作</span></span><br><span class="line">    V value = <span class="keyword">null</span>;</span><br><span class="line">    value = Objects.requireNonNull(valueFactory.apply(key, parameter));</span><br><span class="line">    ... <span class="comment">//省略一些缓存操作</span></span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>apply</code>是<code>BiFunction</code>的一个抽象方法，<code>BiFunction</code>又是一个函数式接口。而<code>valueFactory</code>是通过<code>WeakCache</code>的构造器传入，是一个<code>ProxyClassFactory</code>对象，而其刚好就是<code>BiFunction</code>的实现，顾名思义，这个类就是专门用来<strong>创建代理类</strong>的工厂类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader,Class&lt;?&gt;[],Class&lt;?&gt;&gt;</span><br><span class="line">    proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(),<span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p>进入<code>ProxyClassFactory</code>的<code>apply()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Class&lt;?&gt;, Boolean&gt; interfaceSet = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(interfaces.length);</span><br><span class="line"><span class="comment">//对每一个指定的Class校验其是否能被指定的类加载器加载以及校验是否是接口，动态代理只能对接口代理，至于原因，后面会说。</span></span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">    Class&lt;?&gt; interfaceClass = <span class="keyword">null</span>;</span><br><span class="line">    interfaceClass = Class.forName(intf.getName(), <span class="keyword">false</span>, loader);</span><br><span class="line">    <span class="keyword">if</span> (interfaceClass != intf) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(intf + <span class="string">&quot; is not visible from class loader&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!interfaceClass.isInterface()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(interfaceClass.getName() + <span class="string">&quot; is not an interface&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (interfaceSet.put(interfaceClass, Boolean.TRUE) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;repeated interface: &quot;</span> + interfaceClass.getName());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//下面这一大段是用来指定生成的代理类的包信息</span></span><br><span class="line"><span class="comment">//如果全是public的，就是用默认的com.sun.proxy，</span></span><br><span class="line"><span class="comment">//如果有非public的，所有的非public接口必须处于同一级别包下面，而该包路径也会成为生成的代理类的包。</span></span><br><span class="line">String proxyPkg = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">int</span> accessFlags = Modifier.PUBLIC | Modifier.FINAL;</span><br><span class="line"><span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">    <span class="keyword">int</span> flags = intf.getModifiers();</span><br><span class="line">    <span class="keyword">if</span> (!Modifier.isPublic(flags)) &#123;</span><br><span class="line">        accessFlags = Modifier.FINAL;</span><br><span class="line">        String name = intf.getName();</span><br><span class="line">        <span class="keyword">int</span> n = name.lastIndexOf(<span class="string">&#x27;.&#x27;</span>);</span><br><span class="line">        String pkg = ((n == -<span class="number">1</span>) ? <span class="string">&quot;&quot;</span> : name.substring(<span class="number">0</span>, n + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">            roxyPkg = pkg;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!pkg.equals(proxyPkg)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;non-public interfaces from different packages&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (proxyPkg == <span class="keyword">null</span>) &#123;</span><br><span class="line">    proxyPkg = ReflectUtil.PROXY_PACKAGE + <span class="string">&quot;.&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> num = nextUniqueNumber.getAndIncrement();</span><br><span class="line"><span class="comment">//代理类最后生成的名字是包名+$Proxy+一个数字</span></span><br><span class="line">String proxyName = proxyPkg + proxyClassNamePrefix + num;</span><br><span class="line"><span class="comment">//生成代理类的核心</span></span><br><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(proxyName, interfaces, accessFlags);★</span><br><span class="line"><span class="keyword">return</span> defineClass0(loader, proxyName,proxyClassFile, <span class="number">0</span>, proxyClassFile.length);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码不难发现，生成代理类的核心代码在★这一行，会使用一个<code>ProxyGenerator</code>生成代理类（以<code>byte[]</code>形式存在）。然后将生成得到的字节数组转换为一个Class对象。进入<code>ProxyGenerator.generateProxyClass()</code>。<code>ProxyGenerator</code>处于<code>sun.misc</code>包，不是开源的包，因为我这边使用的是<code>openjdk</code>，所以可以直接查看其源码，如果使用的是<code>oracle jdk</code>的话，这边只能通过反编译<code>class</code>文件查看。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] generateProxyClass(<span class="keyword">final</span> String name, Class&lt;?&gt;[] interfaces, <span class="keyword">int</span> accessFlags) &#123;</span><br><span class="line">    ProxyGenerator gen = <span class="keyword">new</span> ProxyGenerator(name, interfaces, accessFlags);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] classFile = gen.generateClassFile();</span><br><span class="line">    <span class="keyword">if</span> (saveGeneratedFiles) &#123;</span><br><span class="line">        <span class="comment">//省略一堆IO操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classFile;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述逻辑很简单，就是使用一个生成器调用<code>generateClassFile()</code>方法返回代理类，后面有个<code>if</code>判断我简单提一下，这个作用主要是将内存中动态生成的代理类以<code>class</code>文件形式保存到硬盘。<code>saveGeneratedFiles</code>这个字段是定义在<code>ProxyGenerator</code>中的字段，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">boolean</span> saveGeneratedFiles =</span><br><span class="line">    java.security.AccessController.doPrivileged(</span><br><span class="line">    <span class="keyword">new</span> GetBooleanAction(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>)).booleanValue();</span><br></pre></td></tr></table></figure><p>我简单说一下，<code>AccessController.doPrivileged</code>这个玩意会去调用<code>java.security.PrivilegedAction</code>的<code>run()</code>方法，<code>GetBooleanAction</code>这个玩意就实现了<code>java.security.PrivilegedAction</code>，在其<code>run()</code>中会通过<code>Boolean.getBoolean()</code>从系统属性中获取<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>的值，默认是<code>false</code>，如果想要将动态生成的<code>class</code>文件持久化，可以往系统属性中设置为<code>true</code>。</p><p>我们重点进入<code>ProxyGenerator.generateClassFile()</code>方法，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] generateClassFile() &#123;</span><br><span class="line">    addProxyMethod(hashCodeMethod, Object.class);</span><br><span class="line">    addProxyMethod(equalsMethod, Object.class);</span><br><span class="line">    addProxyMethod(toStringMethod, Object.class);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Method m : intf.getMethods()) &#123;</span><br><span class="line">            addProxyMethod(m, intf);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (List&lt;ProxyGenerator.ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">        checkReturnTypes(sigmethods);</span><br><span class="line">    &#125;</span><br><span class="line">    methods.add(generateConstructor());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (List&lt;ProxyGenerator.ProxyMethod&gt; sigmethods : proxyMethods.values()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ProxyGenerator.ProxyMethod pm : sigmethods) &#123;</span><br><span class="line">            fields.add(<span class="keyword">new</span> ProxyGenerator.FieldInfo(pm.methodFieldName,</span><br><span class="line">                    <span class="string">&quot;Ljava/lang/reflect/Method;&quot;</span>,</span><br><span class="line">                    ACC_PRIVATE | ACC_STATIC));</span><br><span class="line">            methods.add(pm.generateMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    methods.add(generateStaticInitializer());</span><br><span class="line">    <span class="keyword">if</span> (methods.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;method limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fields.size() &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;field limit exceeded&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cp.getClass(dotToSlash(className));</span><br><span class="line">    cp.getClass(superclassName);</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        cp.getClass(dotToSlash(intf.getName()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cp.setReadOnly();</span><br><span class="line"></span><br><span class="line">    ByteArrayOutputStream bout = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    DataOutputStream dout = <span class="keyword">new</span> DataOutputStream(bout);</span><br><span class="line"></span><br><span class="line">    dout.writeInt(<span class="number">0xCAFEBABE</span>);</span><br><span class="line">    <span class="comment">// u2 minor_version;</span></span><br><span class="line">    dout.writeShort(CLASSFILE_MINOR_VERSION);</span><br><span class="line">    <span class="comment">// u2 major_version;</span></span><br><span class="line">    dout.writeShort(CLASSFILE_MAJOR_VERSION);</span><br><span class="line"></span><br><span class="line">    cp.write(dout);<span class="comment">// (write constant pool)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// u2 access_flags;</span></span><br><span class="line">    dout.writeShort(accessFlags);</span><br><span class="line">    <span class="comment">// u2 this_class;</span></span><br><span class="line">    dout.writeShort(cp.getClass(dotToSlash(className)));</span><br><span class="line">    <span class="comment">// u2 super_class;</span></span><br><span class="line">    dout.writeShort(cp.getClass(superclassName));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// u2 interfaces_count;</span></span><br><span class="line">    dout.writeShort(interfaces.length);</span><br><span class="line">    <span class="comment">// u2 interfaces[interfaces_count];</span></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intf : interfaces) &#123;</span><br><span class="line">        dout.writeShort(cp.getClass(</span><br><span class="line">                dotToSlash(intf.getName())));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// u2 fields_count;</span></span><br><span class="line">    dout.writeShort(fields.size());</span><br><span class="line">    <span class="comment">// field_info fields[fields_count];</span></span><br><span class="line">    <span class="keyword">for</span> (ProxyGenerator.FieldInfo f : fields) &#123;</span><br><span class="line">        f.write(dout);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// u2 methods_count;</span></span><br><span class="line">    dout.writeShort(methods.size());</span><br><span class="line">    <span class="comment">// method_info methods[methods_count];</span></span><br><span class="line">    <span class="keyword">for</span> (ProxyGenerator.MethodInfo m : methods) &#123;</span><br><span class="line">        m.write(dout);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// u2 attributes_count;</span></span><br><span class="line">    dout.writeShort(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> bout.toByteArray();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有学过Java虚拟机规范中关于<strong>字节码文件结构</strong>的知识的话，上面这段代码肯定是看得一头雾水，因为本文主要是讲解动态代理，加上个人对Java虚拟机的掌握也是菜鸟级别，所以下面就简单阐述一下关于字节码结构的内容以便大家理解上面这块代码，但是不展开详说。</p><h2 id="Class文件结构简述"><a href="#Class文件结构简述" class="headerlink" title="Class文件结构简述"></a>Class文件结构简述</h2><p>在Java虚拟机规范中，Class文件是一组<strong>二进制流</strong>，每个Class文件会对应一个<strong>类</strong>或者<strong>接口</strong>的定义信息，当然，Class文件并不是一定以文件形式存在于硬盘，也有可能直接由类加载器加载到内存。每一个Class文件加载到内存后，经过一系列的加载、连接、初始化过程，然后会在方法区中形成一个Class对象，作为外部访问该类信息的的唯一入口。按照Java虚拟机规范，Class文件是具有非常严格严谨的结构规范，由一系列数据项组成，各个数组项之间没有分隔符的结构紧凑排列。每个数据项会有相应的数据类型，如下表就是一个完整Class文件结构的表。<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-2.png" alt="代理模式-2"><br>其中名称一列就是组成Class文件的数据项，限于篇幅这边就不展开详细解释每一项了，大家有兴趣可以自己去查点资料了解一下，左边是其类型，主要分两类，像u2,u4这类是无符号数，分别表示2个字节和4个字节。以info结尾的是表结构，表结构又是一个复合类型，由其它的无符号数和其他的表结构组成。</p><p>我这边以相对结构简单的<code>field_info</code>结构举个例子，<code>field_info</code>结构用来描述接口或者类中的变量。它的结构如下：<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-3.png" alt="代理模式-3"><br>其它的表结构<code>method_info</code>,<code>attribute_info</code>也都是类似，都会有自己特有的一套结构规范。</p><p>好了，简单了解一下Class文件结构后，现在再回到我们的主题来，我们再来研究<code>ProxyGenerator.generateClassFile()</code>方法内容就好理解了。其实这个方法就做了一件事情，就是根据我们传入的这些个信息，再按照Java虚拟机规范的字节码结构，用IO流的方式写入到一个字节数组中，这个字节数组就是代理类的Class文件。默认情况这个Class文件直接存在内存中，为了更加深入理解动态代理原理，该是时候去看看这个文件到底是啥结构了。怎么看？还记得前面提到过的<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>吗？只要我们往系统属性中加入该参数并将其值设为true，就会自动将该方法生成的byte[]形式的Class文件保存到硬盘上，如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">      <span class="comment">//加入该属性并设置为true</span></span><br><span class="line">        System.setProperty(<span class="string">&quot;sun.misc.ProxyGenerator.saveGeneratedFiles&quot;</span>, <span class="string">&quot;true&quot;</span>);</span><br><span class="line">        Person landlord = <span class="keyword">new</span> Landlord();</span><br><span class="line">        Person proxy = (Person) Proxy.newProxyInstance(ClassLoader.getSystemClassLoader(), <span class="keyword">new</span> Class[]&#123;Person.class&#125;, <span class="keyword">new</span> RentHandler(landlord));</span><br><span class="line">        proxy.rent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再次运行，神奇的一幕发生了，工程中多了一个类，没错，这就是<code>JDK</code>动态代理生成的代理类，因为我们的接口是public修饰，所以采用默认包名<code>com.sun.proxy</code>，类名以<code>$Proxy</code>开头，后面跟一个数字，和预期完全吻合。完美！🤩<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-4.png" alt="代理模式-4"><br>那么就让我们反编译一下这个class文件看看它的内容来一探究竟……</p><p>下面是反编译得到的代理类的内容，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123; ★</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span> &#123; ②</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span> </span>&#123;④</span><br><span class="line">        <span class="keyword">return</span> (Boolean) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m1, <span class="keyword">new</span> Object[]&#123;var1&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">rent</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;③</span><br><span class="line">        <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;④</span><br><span class="line">        <span class="keyword">return</span> (String) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m2, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span> </span>&#123;④</span><br><span class="line">        <span class="keyword">return</span> (Integer) <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m0, (Object[]) <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;①</span><br><span class="line">        m1 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;equals&quot;</span>, Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>));</span><br><span class="line">        m3 = Class.forName(<span class="string">&quot;com.dujc.mybatis.proxy.Person&quot;</span>).getMethod(<span class="string">&quot;rent&quot;</span>);</span><br><span class="line">        m2 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;toString&quot;</span>);</span><br><span class="line">        m0 = Class.forName(<span class="string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="string">&quot;hashCode&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>👉有几个关注点</p></blockquote><ul><li>标注①的是一个静态代码块，当代理类一被加载，会立刻初始化，用反射方式获取得到被代理的接口中方法和<code>Object</code>中<code>equals()</code>,<code>toString()</code>,<code>hashCode()</code>方法的<code>Method</code>对象,并将其保存在属性中，为后续请求分派做准备。</li><li>标注②的是带有一个带有<code>InvocationHandler</code>类型参数的构造器，这个也验证了我们之前的猜测，没错，代理类会通过构造器接收一个<code>InvocationHandler</code>实例，再观察标记★的地方，代理类继承了<code>Proxy</code>类，其实代理类会通过调用父类构造器将其保存在<code>Proxy</code>的属性<code>h</code>中，自然会继承给当前这个代理类，这个<code>InvocationHandler</code>实例为后续请求分派做准备。同时由此我们也可以得出结论，<code>Proxy</code>是所有的代理类的父类。另外再延伸，因为<code>Java</code>是一门单继承语言，所以意味着代理类不可能再通过继承其他类的方式来扩展。所以，<code>JDK</code>动态代理没法对不实现任何接口的类进行代理，原因就在于此。这或许也是动态代理模式不多的缺点之一。如果需要继承形式的类代理，可以使用CGLIB等类库。</li><li>标注③的是我们指定接口<code>Person</code>中的方法，标注④的是代理类继承自<code>Object</code>类中的<code>equals()</code>,<code>toString()</code>,<code>hashCode()</code>方法。再观察这些方法内部实现，所有的方法请求全部委托给之前由构造器传入的<code>InvocationHandler</code>实例的<code>invoke()</code>方法处理，将当前的代理类实例，各方法的<code>Method</code>对象和方法参数传入，最后返回执行结果。由此得出结论，动态代理过程中，所指定接口的方法以及<code>Object</code>中<code>equals()</code>,<code>toString()</code>,<code>hashCode()</code>方法会被代理，而<code>Object</code>其他方法则并不会被代理，而且所有的方法请求全部都是委托给我们自己写的自定义<code>InvocationHandler</code>的<code>invoke()</code>方法统一处理，哇塞，O了，这样的处理实在太优雅了！</li></ul><h2 id="动态代理到底有什么用"><a href="#动态代理到底有什么用" class="headerlink" title="动态代理到底有什么用"></a>动态代理到底有什么用</h2><p>其实经过上面这一堆讲解，动态代理模式中最核心的内容基本都分析完了，相信大家应该对其也有了一个本质的认知。学以致用，技术再牛逼如果没法用在实际工作中也说实话也只能拿来装逼了。那这个东西到底有什么用呢？其实我以前学完动态代理模式后第一感觉是，嗯，这玩意确实挺牛逼的，但是到底有什么用？没有一点概念。在阅读<code>Spring</code>或者<code>Mybatis</code>等经典开源框架中的代码时，时不时也经常会发现动态代理模式的身影，但是还是没有一个直接的感受。直到最近一段时间我在深入研究<code>Mybatis</code>源码时，看到其日志模块的设计，内部就是使用了动态代理，忽然灵光一闪，大受启发感觉一下子全想通了……这就是冥冥之中注定的吧?😂所以最后我就拿这个例子给大家讲解一下动态代理模式的实际应用场景。</p><p>想必使用过<code>Mybatis</code>这一优秀持久层框架的人都注意到过，每当我们执行对数据库操作，如果日志级别是<code>DEBUG</code>，控制台会打印出一些辅助信息，比如执行的<code>SQL</code>语句，绑定的参数和参数值，返回的结果等，你们有没有想过这些信息到底是怎么来的？</p><p>在<code>Mybatis</code>底层的日志模块中，有一块专门用于打印<code>JDBC</code>相关信息日志的功能。这块功能是由一系列<code>xxxLogger</code>类构成。其中最顶层的是<code>BaseJdbcLogger</code>，他有4个子类，继承关系如下图：<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-5.png" alt="代理模式-5"><br>看名字应该就能猜出来是干啥了，以<code>ConnectionLogger</code>为例，下面是<code>ConnectionLogger</code>的关键代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123; ❶</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Connection connection;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ConnectionLogger</span><span class="params">(Connection conn, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">        <span class="keyword">this</span>.connection = conn;❷</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span>❸</span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;prepareStatement&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">                debug(<span class="string">&quot; Preparing: &quot;</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">            stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">            <span class="keyword">return</span> stmt;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;prepareCall&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">                debug(<span class="string">&quot; Preparing: &quot;</span> + removeBreakingWhitespace((String) params[<span class="number">0</span>]), <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            PreparedStatement stmt = (PreparedStatement) method.invoke(connection, params);</span><br><span class="line">            stmt = PreparedStatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">            <span class="keyword">return</span> stmt;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;createStatement&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            Statement stmt = (Statement) method.invoke(connection, params);</span><br><span class="line">            stmt = StatementLogger.newInstance(stmt, statementLog, queryStack);</span><br><span class="line">            <span class="keyword">return</span> stmt;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(connection, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">newInstance</span><span class="params">(Connection conn, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> ConnectionLogger(conn, statementLog, queryStack);</span><br><span class="line">        ClassLoader cl = Connection.class.getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> (Connection) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;Connection.class&#125;, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么样？是不是有种熟悉的感觉？🙀</p><p>👉观察上面代码，可以得出以下几点结论：</p><ul><li><p><code>ConnectionLogge</code>r实现了<code>InvocationHandler</code>，通过构造器传入真实<code>Connection</code>对象，这是一个真实对象，并将其保存在属性，后续请求会委托给它执行。其静态方法<code>newInstance()</code>内部就是通过<code>Proxy.newProxyInstance()</code>并传入类加载器等一系列参数返回一个<code>Connection</code>的代理对象给前端。该方法最终会在<code>DEBUG</code>日志级别下被<code>org.apache.ibatis.executor.BaseExecutor.getConnection()</code>方法调用返回一个<code>Connection</code>代理对象。</p></li><li><p>前面说过，<code>JDK</code>动态代理会将客户端所有的请求全部派发给<code>InvocationHandler</code>的<code>invoke()</code>方法，即上面<code>ConnectionLogger</code>中的<code>invoke()</code>方法。<code>invoke()</code>方法当中，不难发现，<code>Mybatis</code>对于<code>Object</code>中定义的方法，统一不做代理处理，直接调用返回。对于<code>prepareStatement()</code>，<code>prepareCall()</code>，<code>createStatement()</code>这三个核心方法会统一委托给真实的<code>Connection</code>对象处理，并且在执行之前会以<code>DEBUG</code>方式打印日志信息。除了这三个方法，<code>Connection</code>其它方法也会被真实的<code>Connection</code>对象代理，但是并不会打印日志信息。我们以<code>prepareStatement()</code>方法为例，当真实的<code>Connection</code>对象调用<code>prepareStatement()</code>方法会返回<code>PreparedStatement</code>对象，这又是一个真实对象，但是<code>Mybatis</code>并不会将该真实对象直接返回，而且通过调用<code>PreparedStatementLogger.newInstance()</code>再次包装代理，看到这个方法名字，我相信聪明的您都能猜到这个方法的逻辑了。没错，<code>PreparedStatementLogger</code>类的套路和<code>ConnectionLogger</code>如出一辙。这边我再贴回<code>PreparedStatementLogger</code>的代码:</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">PreparedStatementLogger</span> <span class="keyword">extends</span> <span class="title">BaseJdbcLogger</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> PreparedStatement statement;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">PreparedStatementLogger</span><span class="params">(PreparedStatement stmt, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(statementLog, queryStack);</span><br><span class="line">        <span class="keyword">this</span>.statement = stmt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] params)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Object.class.equals(method.getDeclaringClass())) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, params);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (EXECUTE_METHODS.contains(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isDebugEnabled()) &#123;</span><br><span class="line">                debug(<span class="string">&quot;Parameters: &quot;</span> + getParameterValueString(), <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            clearColumnInfo();</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;executeQuery&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                ResultSet rs = (ResultSet) method.invoke(statement, params);</span><br><span class="line">                <span class="keyword">return</span> rs == <span class="keyword">null</span> ? <span class="keyword">null</span> : ResultSetLogger.newInstance(rs, statementLog, queryStack);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (SET_METHODS.contains(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;setNull&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">                setColumn(params[<span class="number">0</span>], <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                setColumn(params[<span class="number">0</span>], params[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;getResultSet&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            ResultSet rs = (ResultSet) method.invoke(statement, params);</span><br><span class="line">            <span class="keyword">return</span> rs == <span class="keyword">null</span> ? <span class="keyword">null</span> : ResultSetLogger.newInstance(rs, statementLog, queryStack);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;getUpdateCount&quot;</span>.equals(method.getName())) &#123;</span><br><span class="line">            <span class="keyword">int</span> updateCount = (Integer) method.invoke(statement, params);</span><br><span class="line">            <span class="keyword">if</span> (updateCount != -<span class="number">1</span>) &#123;</span><br><span class="line">                debug(<span class="string">&quot;   Updates: &quot;</span> + updateCount, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> updateCount;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(statement, params);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PreparedStatement <span class="title">newInstance</span><span class="params">(PreparedStatement stmt, Log statementLog, <span class="keyword">int</span> queryStack)</span> </span>&#123;</span><br><span class="line">        InvocationHandler handler = <span class="keyword">new</span> PreparedStatementLogger(stmt, statementLog, queryStack);</span><br><span class="line">        ClassLoader cl = PreparedStatement.class.getClassLoader();</span><br><span class="line">        <span class="keyword">return</span> (PreparedStatement) Proxy.newProxyInstance(cl, <span class="keyword">new</span> Class[]&#123;PreparedStatement.class, CallableStatement.class&#125;, handler);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  这个代码的逻辑我就不讲了，思路几乎和<code>ConnectionLogger</code>完全一致。无非是拦截的方法不同，因为这次被代理对象是<code>PreparedStatement</code>，所以这次会去拦截都是<code>PreparedStatement</code>的方法，比如<code>setXXX()</code>系列,<code>executeXX()</code>系列等方法。然后在指定方法执行前后添加需要的<code>DEBUG</code>日志信息，perfect！以<code>getResultSet()</code>方法为例，<code>PreparedStatement</code>对象调用<code>getResultSet()</code>后，会返回真实的<code>ResultSet</code>对象，但是一样的套路，并不会直接将该真实对象返回，而是由调用<code>ResultSetLogger.newInstance()</code>再次将该<code>ResultSet</code>对象包装，<code>ResultSetLogger</code>的代码相信聪明的您不需要我再花篇幅讲了。</p><p>  这个时候，再回过头思考一下，这个场景下，如果是采用静态代理是不是根本没法完成了？因为，每一个数据库连接都会产生一个新的<code>Connection</code>对象，而每一个<code>Connection</code>对象每次调用<code>preparedStatement()</code>方法都会产生一个新的<code>PreparedStatement</code>对象，而每一个<code>PreparedStatement</code>对象每次调用<code>getResultSet()</code>又都会产生一个新的<code>ResultSet</code>对象，跟上面的多个房东出租房子一个道理，就会产生不计其数处理逻辑极其相似的代理类，所以，这才是开源框架底层不采用静态代理的本质原因！一切都豁然开朗了！😍</p></li></ul><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><p>好了，关于<code>JDK</code>动态代理的核心原理部分到这里算全部讲解完毕了，其实我们聊了这么多，都是围绕着<code>java.lang.reflect.Proxy.newProxyInstance()</code>这个方法展开的。其实在<code>Proxy</code>类中，还有一个<code>getProxyClass()</code>方法，这个只需要传入加载代理类的类加载器和指定接口就可以动态生成其代理类，我一开始说到静态代理弊病的时候说过，静态代理创建代理时，真实角色必须要存在，否则这个模式没法进行下去，但是JDK动态代理可以做到在真实角色不存在的情况下就返回该接口的代理类。至于<code>Proxy</code>其它的方法都比较简单了，此处不再赘述。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java加密解密</title>
      <link href="/2019/11/29/Java/java%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/"/>
      <url>/2019/11/29/Java/java%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86/</url>
      
        <content type="html"><![CDATA[<p>常用的加密算法总体可以分为两类：<strong>单向加密</strong>和<strong>双向加密</strong>，双向加密又分为<strong>对称加密</strong>和<strong>非对称加密</strong>，因此主要分析下面三种加密算法：<strong>对称加密</strong>算法、<strong>非对称加密</strong>算法和<strong>单向加密</strong>算法（Hash算法）。</p><span id="more"></span><h3 id="双向加密"><a href="#双向加密" class="headerlink" title="双向加密"></a>双向加密</h3><h4 id="对称加密算法（AES、DES、3DES、PBE）"><a href="#对称加密算法（AES、DES、3DES、PBE）" class="headerlink" title="对称加密算法（AES、DES、3DES、PBE）"></a>对称加密算法（AES、DES、3DES、PBE）</h4><ul><li>AES:(Advanced Encryption Standard), 高级加密算法,这个标准用来替代DES。</li><li>DES:(Data Encryption Standard)，即数据加密算法。</li><li>3DES:(Triple DES),即三重数据加密算法，是基于DES的对称算法，对一块数据用三个不同的密钥进行三次加密，强度更高；</li><li>PBE:(Password-based encryption)，即基于密码验证。</li><li>对称加密算法是指加密和解密采用<strong>相同的密钥</strong>，是<strong>可逆</strong>的（即可解密）。</li><li><strong>AES加密</strong>算法是密码学中的高级加密标准，采用的是<strong>对称分组密码体制</strong>，密钥长度的最少支持为<strong>128</strong>。AES加密算法是美国联邦政府采用的区块加密标准，这个标准用来替代原先的DES，已经被多方分析且广为全世界使用。</li><li>优点：加密速度快。</li><li>缺点：密钥的传递和保存是一个问题，参与加密和解密的双方使用的密钥是一样的，这样密钥就很容易泄露。</li></ul><h4 id="非对称加密算法（RSA、DSA、DH、ECC）"><a href="#非对称加密算法（RSA、DSA、DH、ECC）" class="headerlink" title="非对称加密算法（RSA、DSA、DH、ECC）"></a>非对称加密算法（RSA、DSA、DH、ECC）</h4><ul><li>RSA:(算法的名字以发明者的名字命名：Ron Rivest, Adi Shamir 和Leonard Adleman)，即</li><li>DSA:(Digital Signature Algorithm)，即数字签名。</li><li>DH:(Diffie-Hellman)，即密钥一致协议。</li><li>ECC:(Elliptic Curves Cryptography)，即椭圆曲线密码编码学。</li><li>非对称加密算法是指加密和解密采用<strong>不同的密钥</strong>（公钥和私钥），因此非对称加密也叫<strong>公钥加密</strong>，是<strong>可逆</strong>的（即可解密）。</li><li><strong>RSA加密</strong>算法是基于一个十分简单的数论事实：将两个大素数相乘十分容易，但是想要对其乘积进行因式分解极其困难，因此可以将乘积公开作为加密密钥。虽然RSA的安全性一直未能得到理论上的证明，但它经历了各种攻击至今未被完全攻破。</li><li>优点：加密和解密的密钥不一致，公钥是可以公开的，只需保证私钥不被泄露即可，这样就密钥的传递变的简单很多，从而降低了被破解的几率。</li><li>缺点：加密速度慢</li><li>RSA加密算法既可以用来做<strong>数据加密</strong>，也可以用来<strong>数字签名</strong>。<blockquote><p>数据加密过程：发送者用公钥加密，接收者用私钥解密（只有拥有私钥的接收者才能解读加密的内容）</p></blockquote></li></ul><blockquote><p>数字签名过程：甲方用私钥加密，乙方用公钥解密（乙方解密成功说明就是甲方加的密，甲方就不可以抵赖）</p></blockquote><h3 id="单向加密算法-MD5、SHA、HMAC、BASE64"><a href="#单向加密算法-MD5、SHA、HMAC、BASE64" class="headerlink" title="单向加密算法(MD5、SHA、HMAC、BASE64)"></a>单向加密算法(MD5、SHA、HMAC、BASE64)</h3><h4 id="MD5-Hash加密算法"><a href="#MD5-Hash加密算法" class="headerlink" title="MD5(Hash加密算法)"></a>MD5(Hash加密算法)</h4><ul><li>MD5:(Message-Digest Algorithm 5)，即信息摘要算法5。</li><li>单向的算法<strong>不可逆</strong>（被MD5加密的数据<strong>不能被解密</strong>）。MD5加密后的数据长度要比加密数据小的多，且长度固定，且加密后的串是<strong>唯一</strong>的。</li><li>适用<strong>场景</strong>：常用在不可还原的<strong>密码存储</strong>、<strong>信息完整性校验</strong>等。</li><li>信息完整性校验：典型的应用是对一段信息产生信息摘要，以防止被篡改。如果再有一个第三方的认证机构，用MD5还可以防止文件作者的“抵赖”，这就是所谓的数字签名应用。</li></ul><h4 id="SHA加密算法"><a href="#SHA加密算法" class="headerlink" title="SHA加密算法"></a>SHA加密算法</h4><ul><li>SHA:(Secure Hash Algorithm)，即安全散列算法。</li><li>数字签名等密码学应用中重要的工具，被广泛地应用于电子商务等信息安全领域。虽然，SHA与MD5通过碰撞法都被破解了，但是SHA仍然是公认的安全加密算法，较之MD5更为安全。</li></ul><h4 id="HMAC加密算法"><a href="#HMAC加密算法" class="headerlink" title="HMAC加密算法"></a>HMAC加密算法</h4><ul><li>HMAC:(Hash Message Authentication Code)，即散列消息鉴别码。</li><li>基于密钥的Hash算法的认证协议。消息鉴别码实现鉴别的原理是，用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。使用一个密钥生成一个固定大小的小数据块，即MAC，并将其加入到消息中，然后传输。接收方利用与发送方共享的密钥进行鉴别认证等。</li></ul><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><ul><li>严格意义讲，Base64<strong>并不能算是一种加密</strong>算法，而是一种<strong>编码格式</strong>，是网络上最常见的用于传输8bid字节代码的编码方式之一。</li><li>Base64编码可用于在HTTP环境下传递较长的标识信息，Base编码不仅不仅比较简单，同时也据有<strong>不可读性</strong>（编码的数据不会被肉眼直接看到）。</li></ul><h3 id="混合加密"><a href="#混合加密" class="headerlink" title="混合加密"></a>混合加密</h3><ul><li>由于以上加密算法都有各自的缺点（RSA加密速度慢、AES密钥存储问题、MD5加密不可逆），因此实际应用时常将几种加密算法混合使用。</li><li>例如：<strong>RSA+AES</strong>：<ul><li>采用RSA加密AES的密钥，采用AES对数据进行加密，这样集成了两种加密算法的优点，既保证了数据加密的速度，又实现了安全方便的密钥管理。</li><li>那么，采用多少位的密钥合适呢？一般来讲密钥长度越长，安全性越高，但是加密速度越慢。所以密钥长度也要合理的选择，一般RSA建议采用1024位的数字，AES建议采用128位即可。</li></ul></li></ul><h3 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h3><p><a href="https://www.cnblogs.com/wangjintao-0623/p/10460268.html">各种Java加密算法的实现</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 加密解密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式|⑤建造者模式</title>
      <link href="/2019/11/28/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A4%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/28/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A4%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;今天我们要来聊的是建造者模式，这也是GOF23的创建型模式中的最后一个模式。既然是创建型模式，自然又是一个用来创建对象的模式，这从这个模式的名字上也能看出来。</p><span id="more"></span><h2 id="场景需求"><a href="#场景需求" class="headerlink" title="场景需求"></a>场景需求</h2><p>建造者，就是用来创建对象的。这听上去就是一句废话……</p><p>对象不就是建造出来的吗？这怎么还成了一个单独的模式了？而且和前面说的那些模式有啥区别？</p><p>为了方便理解，我还是不套用书上或者网上的一些理论，但就自己学过的一些理解，结合生活的一些场景跟大家说说。</p><p>举个生活当中组装电脑的例子，比如现在小明去电脑城组装一台电脑，一台完整电脑肯定会包含显示器，键盘，鼠标等等一些配件，而每个配件的配置参数那就成百上千了，而且每个硬件上都会有一些专业的参数我们也看不懂。然而，我们需要买的只是一台电脑，我们只需要告诉卖电脑的人，我们需要买什么品牌，什么档次，什么价格的电脑或配件即可，这样电脑商家就会给我们组装好一台各方面都比较合适的电脑。小明平时就简单写个文档看个视频啥的，对配置要求不高，所以只需要入门级的电脑即可。如下图：<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-1.png" alt="建造者模式-1"><br>然后小明玩了几年后上了大学，无意中染上了玩游戏的毛病，一发不可收拾，原来的电脑配置已经卡出翔了。于是，他又想换台游戏本，如下图：<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-2.png" alt="建造者模式-2"><br>然后小明大学毕业了，因为大学天天玩游戏，毕业后实在混不下去了，听说学Java技术工资高，还能装逼，于是二话没说转行学Java……但是学Java再用原来那个破电脑可不行了，怎么样也得用个MacBook Pro才配得上程序猿这个高大上的职位嘛，于是……<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-3.png" alt="建造者模式-3"><br>上面这个是日常生活中非常常见的场景，那用代码如何去实现呢？</p><p>如果你之前没学过任何设计模式，你也许会如下设计（伪代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Computer</span> </span>&#123;</span><br><span class="line">    内存</span><br><span class="line">    CPU</span><br><span class="line">    硬盘</span><br><span class="line">    鼠标</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//入门级</span></span><br><span class="line">    Computer comp = <span class="keyword">new</span> Computer();</span><br><span class="line">    comp.set内存(<span class="string">&quot;4g&quot;</span>);</span><br><span class="line">    comp.setCPU(<span class="string">&quot;i3&quot;</span>);</span><br><span class="line">    comp.set硬盘(<span class="string">&quot;128g&quot;</span>);</span><br><span class="line">    comp.set鼠标(<span class="string">&quot;杂牌&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">  把电脑交付给客户...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样写粗看没有什么毛病，我们平时大部分时候就是这样写的。</p><blockquote><p>那想想，这样写后续会有什么问题吗？</p></blockquote><p>现在小明电脑要升级了，换成游戏本，这个时候麻烦来了，他得去修改上面buy()方法体内的代码了，将原来的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">comp.set内存(<span class="string">&quot;4g&quot;</span>);</span><br><span class="line">comp.setCPU(<span class="string">&quot;i3&quot;</span>);</span><br><span class="line">comp.set硬盘(<span class="string">&quot;128g&quot;</span>);</span><br><span class="line">comp.set鼠标(<span class="string">&quot;杂牌&quot;</span>);</span><br></pre></td></tr></table></figure><p>修改成新的配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">comp.set内存(<span class="string">&quot;8g&quot;</span>);</span><br><span class="line">comp.setCPU(<span class="string">&quot;i5&quot;</span>);</span><br><span class="line">comp.set硬盘(<span class="string">&quot;256g&quot;</span>);</span><br><span class="line">comp.set鼠标(<span class="string">&quot;罗技牌&quot;</span>);</span><br></pre></td></tr></table></figure><p>再升级成MacBook Pro时也同理。而且如果我需要增加或者减少一些配置也同样需要去修改原来的代码。</p><p>显然这个是违反“<strong>开闭原则</strong>”了。</p><blockquote><p>那问题出在哪里呢？</p></blockquote><p>不难看出，comp的setXX()系列方法和Client的api紧紧耦合了，而且Client需要对象创建的细节一清二楚，否则没法完成对象创建。</p><blockquote><p>那怎么样才能把对象的创建过程单独从客户端代码中剥离出来，实现解耦呢？</p></blockquote><p>如果还记得前面学过的工厂模式，有的同学可能就会想到，工厂模式不就是解决这个问题的吗？把对象创建和对象的使用分离实现解耦，使得客户端并不需要关注对象的创建过程，需要与对应的工厂类打交道即可。因为我们这边会涉及到多个对象，而且这多个对象之间也存在一些关联，所以此处可以采用抽象工厂模式实现。所以经过优化，你可能会如下实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">    内存 create内存();</span><br><span class="line">    <span class="function">CPU <span class="title">createCPU</span><span class="params">()</span></span>;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后针对不同定位的电脑，创建其不同的Factory实现类即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 入门级 <span class="keyword">implements</span> <span class="title">ComputerFactory</span></span>&#123;</span><br><span class="line">内存 create内存()&#123;</span><br><span class="line">        生产4G内存</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">CPU <span class="title">createCPU</span><span class="params">()</span></span>&#123;</span><br><span class="line">        生产i3内存</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Client的代码会修改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//入门级</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    ComputerFactory factory;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Computer comp = <span class="keyword">new</span> Computer();</span><br><span class="line">        comp.set内存(factory.create内存());</span><br><span class="line">        comp.setCPU(factory.createCPU());</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把电脑交付给客户...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的话，如果我需要升级配置，只需要传入不同的<code>ComputerFactory</code>就可以了，业务逻辑的代码是不需要再动了。但是对于这个需求，这样的解决方法是存在一些问题的。为什么呢？</p><p>之前在讲工厂模式的时候说过，工厂模式主要是用来生产一个<strong>完整的产品</strong>的。也就是说，用工厂模式创建出来的对象，就是一个<strong>最终的产品</strong>了。虽然抽象工厂模式可以一下子创建多个产品，但是这多个产品其本身就是一个完整的最终的产品，直接就可以使用了，无非是抽象工厂模式创建的这些个产品之类有一些关联，属于同一个类型的东西。</p><p>但是我们的这个需求中，像内存、CPU、鼠标等这些，对于电脑而言，都只是整台电脑的一个<strong>组成部分</strong>而已，他们并不是一个完整的产品，需要将他们组合装配起来才能构成一个完整的电脑对象。因为这个需求中，我们需要得到的是一个电脑对象，而并不是内存、CPU、鼠标等这些个零件。</p><p>当然你也可以使用工厂模式来创建这些个零件，但是，之后你也还需要自己去对这些零部件进行组装，也就是说，你还是需要对这个对象的组成细节了解清楚，否则，你还是无法创建出一个完整的对象。另外，还会出现多一个零件，少一个零件的问题，会增加客户端的复杂度。</p><p>于是，我们今天要讲的主角——<strong>建造者模式</strong>就闪亮登场了。</p><h3 id="解决需求"><a href="#解决需求" class="headerlink" title="解决需求"></a>解决需求</h3><p><strong>建造者模式</strong>要解决的场景就是这个需求，致力于<strong>将一系列琐碎的零部件组装成一个完整的对象</strong>，而这其中具体的组装细节客户端是不需要知道的。</p><p>在建造者模式中，有一个抽象接口，里面会定义一系列对象零部件的装配的方法（组装内存、CPU、鼠标等这些个零件）。然后会有一个组装的人（比如电脑卖家），对这些个零部件进行组装，最后给客户端返回一个完整的对象。就比如上面组装电脑的例子。<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-4.png" alt="建造者模式-4"><br>实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象接口定义完整对象的零部件装配方法</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Computer comp = <span class="keyword">new</span> Computer();</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> build内存();</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">buildCPU</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">void</span> build硬盘();</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Computer <span class="title">getComputer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> comp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后针对于不同级别的电脑，可以创建其对应的抽象接口的实现类，以完成对电脑的装配，比如现在需要装配一台<code>MacBook Pro</code>，则实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacBookProBuilder</span> <span class="keyword">extends</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> build内存() &#123;</span><br><span class="line">        comp.set内存(<span class="string">&quot;16g&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        comp.setCPU(<span class="string">&quot;i7&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> build硬盘() &#123;</span><br><span class="line">        comp.set硬盘(<span class="string">&quot;1T&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还要需要一个专门负责装配的对象，比如电脑卖家，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seller</span></span>&#123;</span><br><span class="line">    ComputerBuilder builder;</span><br><span class="line">    <span class="function">Computer <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        builder.build内存();</span><br><span class="line">        builder.buildCPU();</span><br><span class="line">        builder.build硬盘();</span><br><span class="line">        <span class="keyword">return</span> builder.getComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候在Client中的代码变成了如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MacBook Pro</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span></span>&#123;</span><br><span class="line">    Seller seller;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Computer comp = seller.sell();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//把电脑交付给客户...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现，此时，客户端已经完成解耦，我们只需要告诉电脑卖家我们需要什么级别的电脑，他就会给我们返回一台装配好的完整的对象，再也不需要去了解各个零件是怎么生产的（是通过单例模式创建的？还是原型模式？还是工厂模式？），也不需要知道这些零部件是怎么拼装起来的（是先装配CPU，还是先装配硬盘？）。这样就完美的解决了解耦的问题。</p><p>现在假设小明想再换一个配置的电脑，只需要再提供一个对应的<code>Buidler</code>子类，完成对应零件的创建，然后将<code>Builder</code>交给负责装配的人（术语叫<code>Director</code>），如卖家，就可以了，<code>Client</code>再也不需要有任何的改动，符合“<strong>开闭原则</strong>”。</p><p>在对象没有那么复杂的情况下，<code>Director</code>也是可以省略的，直接将装配过程在<code>Client</code>端实现即可。当然在这种情况下，Client是需要对该对象的组成结构有所了解的，也容易导致缺胳膊少腿的情况。</p><p>另外，上面的代码其实可以修改为更为优雅的写法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MacBookProBuilder</span> <span class="keyword">extends</span> <span class="title">ComputerBuilder</span></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> build内存() &#123;</span><br><span class="line">        comp.set内存(<span class="string">&quot;16g&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildCPU</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        comp.setCPU(<span class="string">&quot;i7&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> build硬盘() &#123;</span><br><span class="line">        comp.set硬盘(<span class="string">&quot;1T&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在每一个装配的方法中都返回当前<code>Builder对象</code>，这样<code>Director</code>中装配逻辑可以直接以清爽简洁的<strong>链式风格</strong>书写。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Seller</span></span>&#123;</span><br><span class="line">    ComputerBuilder builder;</span><br><span class="line">    <span class="function">Computer <span class="title">sell</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> builder.build内存().buildCPU().build硬盘().getComputer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种<strong>链式风格</strong>可以很好的用来解决伸缩构造器反模式的问题。什么意思？</p><p>比如现在某一个类，属性极多，有上百个吧……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    属性<span class="number">1</span>;</span><br><span class="line">    属性<span class="number">2</span>;</span><br><span class="line">    属性<span class="number">3</span>;</span><br><span class="line">    属性<span class="number">4</span>;</span><br><span class="line">    ...省略<span class="number">100</span>个属性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我需要在某处创建该类对象，并且还需要对其中某一些属性进行赋值。如果这个时候我们采用构造器来创建就会比较麻烦，为什么呢？</p><p>因为我可能每一次创建所需要的属性可能是不一样的。比如在应用某处需要创建一个A对象，需要使用属性1、属性2、属性3，于是我会在A类中加入一个构造器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(属性<span class="number">1</span>,属性<span class="number">2</span>,属性<span class="number">3</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用另外一处又需要创建一个A对象，需要使用属性1、属性2、属性3、属性4，于是你又需要添加一个构造器，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略属性</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">(属性<span class="number">1</span>,属性<span class="number">2</span>,属性<span class="number">3</span>,属性<span class="number">4</span>)</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以想象，要是各处引用构造器特别多，并且参数还都不一样，那画面太美不敢想象。还有，当构造器重载太多，创建对象时选择合适构造器都是一件很费神的事情。这个时候使用建造者模式的链式风格就很好的解决了这个问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ABuilder</span></span>&#123;</span><br><span class="line">    A a = <span class="keyword">new</span> A();</span><br><span class="line">    A set属性<span class="number">1</span>(xxx)&#123;... <span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">    A set属性<span class="number">2</span>(xxx)&#123;... <span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">    A set属性<span class="number">3</span>(xxx)&#123;... <span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">    A set属性<span class="number">4</span>(xxx)&#123;... <span class="keyword">return</span> <span class="keyword">this</span>;&#125;</span><br><span class="line">    <span class="function">A <span class="title">build</span><span class="params">()</span></span>&#123;<span class="keyword">return</span> a;&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候我再创建一个A对象，如下，如果我需要修改属性设置的个数，可以很方便的进行调整，很好的解决了重载构造器的问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A a = <span class="keyword">new</span> ABuilder().set属性<span class="number">1</span>(xxx),set属性<span class="number">2</span>(xxx).set属性<span class="number">3</span>(xxx).set属性<span class="number">4</span>(xxx).build();</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>关于建造者模式的核心内容就这些，我们可以做一下总结。</p><ul><li><p>作为创建型模式，建造者模式也是用来创建对象的，而且他和工厂模式看上去会比较相似，甚至难以区分。</p><p>  不过<strong>建造者模式</strong>关键点在于<strong>建造和装配分离</strong>。建造者最终只会生成一个完整的对象，但是这个对象一般来说是比较复杂的，里面会分成好几个模块，建造者模式强调的是这个<strong>装配的过程</strong>。</p><p>  而<strong>工厂模式</strong>，主要强调的是<strong>创建</strong>，当然这个创建有可能是会同时创建一个（简单工厂或者工厂方法模式）或者多个对象（抽象工厂模式）。虽然工厂模式创建的也有可能很复杂，但是他不关心对象会不会有装配的过程，只要创建出来即可。</p><p>  如下图：<br>  <img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-5.png" alt="建造者模式-5"></p><blockquote><p>一言以蔽之，工厂模式强调创建，建造者模式强调组装。</p></blockquote><p>  其实设计模式这东西并不是很绝对很孤立的去看待，因此我们没有必要将每一个模式的区别都分得特别明确，一般来说，设计模式也不是独立使用的，会<strong>相互搭配</strong>。就比如这边的工厂模式和建造者模式，两者侧重点不同，但是完全可以结合使用。比如在使用工厂模式创建对象时，有可能每个对象都会有比较明确的装配过程，就可以结合使用。反过来吗，在使用建造者模式时，每一步的装配所需要的零件，又有可能是通过工厂模式（当然也有可能是通过原型模式，单例模式）创建所得。</p></li><li><p>在建造者模式中，客户端只需要与<code>Director</code>交互，并不需要知道内部的对象构建和装配的细节，屏蔽了系统复杂度。</p></li><li><p>可以为系统中添加多个<code>Builder</code>，比如上面例子中为不同品牌的电脑分别创建一个<code>Builder</code>对象，来达到扩展系统功能的目的。同时，通过调整每一个<code>Builder</code>内部装配的过程，有可能轻松对装配过程中的每一步进行细粒度的控制和定制。</p></li></ul><h2 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h2><p><strong>没有</strong>一个设计模式是<strong>完美</strong>的，每一个设计模式都有其特定的使用场景。通过上面分析，不难发现.</p><ul><li><p><strong>建造者模式</strong>主要用于创建那些<strong>具有明显组装过程</strong>的一类复杂对象，并且这类对象中<strong>内部结构差异性都不大</strong>，基本结构都相同，并且比较稳定。比如上面的电脑的例子，不管啥牌子的电脑，啥级别的电脑，配件都是那些，CPU，内存，硬盘等，变不出花来了，无非就是每种配件的具体参数不同。可以想象，如果是两类差异性很大的对象，一类是电脑，一类是汽车，完全是八竿子打不着的两类产品，装配过程更是天差地别，自然是没法使用建造者模式的。</p><blockquote><p>一个类的各个组成部分的具体实现类或者算法经常面临着变化，但是将他们组合在一起的算法却相对稳定。建造者模式提供一种封装机制，将稳定的组合算法与易变的各个组成部分隔离开来。</p></blockquote></li><li><p>建造者模式创建的对象一般内部变化是不大，不频繁的。对于变动很频繁的也是不适合用建造者模式的。就像买电脑，你三天两头换电脑，升级配置，而每升级一套配置，就需要重新创建一个全新的<code>Builder</code>类，如果变动太多，系统中就需要维护大量的<code>Builder</code>类，增加系统复杂度和维护难度。</p></li></ul><h2 id="抛砖引玉"><a href="#抛砖引玉" class="headerlink" title="抛砖引玉"></a>抛砖引玉</h2><p>最后我举两个我知道的在实际框架或者JDK源码中使用建造者模式的例子。其实建造者模式在实际开发中应用也是非常广泛的，而且也比较好识别，基本以<code>xxxBuilder</code>命名的都是使用了<strong>建造者模式</strong>。</p><p>比如<code>JDK</code>中，<code>StringBuilder</code>类是一个经典的建造者模式实现，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//经典用法</span></span><br><span class="line">String s = <span class="keyword">new</span> StringBuilder(<span class="string">&quot;a&quot;</span>).append(<span class="string">&quot;b&quot;</span>).append(<span class="string">&quot;c&quot;</span>).toString();</span><br></pre></td></tr></table></figure><p><code>StringBuilder</code>继承自<code>AbstractStringBuilder</code>，这是一个抽象类，在它里面定义了一个属性<code>value</code>数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractStringBuilder</span> <span class="keyword">implements</span> <span class="title">Appendable</span>, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line"><span class="comment">//省略无关代码</span></span><br><span class="line">    <span class="keyword">char</span>[] value;</span><br><span class="line">    <span class="comment">//省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们调用<code>StringBuilder</code>的构造器或者是<code>append()</code>方法时，实际上是对该<code>value</code>数组操作。比如<code>append()</code>为例，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> StringBuilder <span class="title">append</span><span class="params">(CharSequence s)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">super</span>.append(s);</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他会去调用父类的<code>append()</code>方法，同时会<code>return this</code>，实现<strong>链式风格</strong>的编程。在父类<code>append()</code>方法中，最终会调用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> AbstractStringBuilder <span class="title">append</span><span class="params">(CharSequence s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//省略一些校验扩容操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start, j = count; i &lt; end; i++, j++)</span><br><span class="line">        value[j] = s.charAt(i);</span><br><span class="line">    count += len;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实就是往<code>value</code>数组中设置传入的字符串值。有点像<code>ArrayList</code>的感觉。</p><p>当调用<code>toString()</code>方法时，其实就是把<code>value</code>数组的内容转成<code>String</code>返回罢了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(value, <span class="number">0</span>, count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，在<code>Mybatis</code>中也是大量使用了建造者模式。在<code>Mybatis</code>启动时，会做一系列的解析工作，比如<code>mybatis-config.xml</code>文件解析，各<code>Mapper.xml</code>，还有<code>Mapper</code>接口上的注解等，这一系列的解析工作都是通过一系列的<code>Builder</code>完成的。顶层是<code>BaseBuilder</code>类。这些<code>Builder</code>的层次结构如下图，比如，<code>XMLConfigBuilder</code>就是用来解析<code>mybatis-config.xml</code>文件，<code>XMLMapperBuilder</code>用来解析各<code>Mapper.xml</code>等。<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-6.png" alt="建造者模式-6"><br>在这里，<code>BaseBuilder</code>作为一个顶层抽象接口，里面只定义了一些所有具体<code>Builder</code>的属性和方法，比如全局配置<code>Configuration</code>对象。而其余<code>Builder</code>子类作为具体建造者完成各自的解析工作。我们这边以<code>XMLConfigBuilder</code>为例，<code>XMLConfigBuilder.parse()</code>方法是解析的核心方法。里面会调用<code>BseBuilder</code>中的<code>parseConfiguration()</code>方法。<code>parseConfiguration()</code>方法就是整个装配流程:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseConfiguration</span><span class="params">(XNode root)</span> </span>&#123;</span><br><span class="line">    propertiesElement(root.evalNode(<span class="string">&quot;properties&quot;</span>));</span><br><span class="line">    Properties settings = settingsAsProperties(root.evalNode(<span class="string">&quot;settings&quot;</span>));</span><br><span class="line">    loadCustomVfs(settings);</span><br><span class="line">    loadCustomLogImpl(settings);</span><br><span class="line">    typeAliasesElement(root.evalNode(<span class="string">&quot;typeAliases&quot;</span>));</span><br><span class="line">    pluginElement(root.evalNode(<span class="string">&quot;plugins&quot;</span>));</span><br><span class="line">    objectFactoryElement(root.evalNode(<span class="string">&quot;objectFactory&quot;</span>));</span><br><span class="line">    objectWrapperFactoryElement(root.evalNode(<span class="string">&quot;objectWrapperFactory&quot;</span>));</span><br><span class="line">    reflectorFactoryElement(root.evalNode(<span class="string">&quot;reflectorFactory&quot;</span>));</span><br><span class="line">    settingsElement(settings);</span><br><span class="line">    environmentsElement(root.evalNode(<span class="string">&quot;environments&quot;</span>));</span><br><span class="line">    databaseIdProviderElement(root.evalNode(<span class="string">&quot;databaseIdProvider&quot;</span>));</span><br><span class="line">    typeHandlerElement(root.evalNode(<span class="string">&quot;typeHandlers&quot;</span>));</span><br><span class="line">    mapperElement(root.evalNode(<span class="string">&quot;mappers&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们以<code>propertiesElement</code>为例，这个方法会使用<code>XPATH</code>解析<code>properties</code>字段中的<code>resource</code>，<code>url</code>属性，并且会将其设置到定义在<code>BaseBuilder</code>中的<code>configuration</code>中。其余的解析方法同理，就不再赘述了。当所有的装配工作完成之后，<code>XMLConfigBuilder.parse()</code>就会将解析后的<code>Configuration</code>对象返回。在<code>SqlSessionFactoryBuilder</code>的<code>build()</code>方法中会调用<code>XMLConfigBuilder.parse()</code>，根据组装好的<code>Configuration</code>对象生成<code>SqlSessionFactory</code>，进而创建<code>SqlSession</code>以操作数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> SqlSessionFactory <span class="title">build</span><span class="params">(InputStream inputStream, String environment, Properties properties)</span> </span>&#123;</span><br><span class="line">    XMLConfigBuilder parser = <span class="keyword">new</span> XMLConfigBuilder(inputStream, environment, properties);</span><br><span class="line">    <span class="keyword">return</span> build(parser.parse());</span><br><span class="line">    <span class="comment">//省略异常处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，今天关于建造者模式的技术分享就到此结束。随着本次建造者模式的结束，GOF23的创建型模式就都讲完了。从下一篇开始，我们会进入另外一大类——结构型模式的世界。结构型模式的模式主要关注点是如何通过一定手段，将两个或多个对象组合形成一个更大更强大的对象。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式|④原型模式</title>
      <link href="/2019/11/27/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A3%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/27/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A3%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;今天我们接下来要聊的是原型模式。</p><span id="more"></span><blockquote><p>❓何为原型？</p></blockquote><p>维基百科上给出的概念：原型是首创的模型，代表同一类型的人物、物件、或观念。</p><p>以我的理解能力解释一下，就是说，它是一种类型的首创对象。在面向对象编程中，所谓的类型就是指类，也就是说，它是这个类的一个源实例。</p><h2 id="为什么需要原型模式？"><a href="#为什么需要原型模式？" class="headerlink" title="为什么需要原型模式？"></a>为什么需要原型模式？</h2><p>我还是坚持前面几篇一贯的风格，在深入了解该模式之前，先来思考一下，这个模式它出现的原因以及存在的意义是什么？</p><p>首先，这个模式也是属于<strong>创建型模式</strong>，也是<strong>用来创建对象</strong>。还是回到之前反复说过的一个问题，就是我们创建对象为什么一定要使用原型模式呢？</p><p>像之前我们学过的<strong>单例模式</strong>是因为需要控制对象个数必须是单个。<strong>工厂模式</strong>是需要将对象创建和使用解耦，使得可以在不需要知道创建细节而使用一个对象，那今天要学习的原型模式它用在创建对象上又是出于什么原因呢？</p><blockquote><p>举个简单例子</p></blockquote><p>比如某一个公司有A和B两个产品线，现在假设需要在每一个产品销售出去之前做一次检查，检查标准是，假如该产品的重量超过10kg，就重新生产一个新的。现在希望将所有产品的检查逻辑用同一个通用方法实现，并且后续增加新产品后可以方便扩展，怎么实现这个需求？</p><p>你可能会如下实现（伪代码）:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCheck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (product.weight &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">//如果该产品是A产品就创建一个新的A对象。</span></span><br><span class="line">            <span class="comment">//如果该产品是B产品就创建一个新的B对象。</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是现在出问题了，写不下去发现没有？为什么？</p><p>因为现在检查的这个对象重量超过10kg了，所以需要创建一个新的对象，但问题这个时候我并不知道传入的product对象是什么类型啊？是A类型？还是B类型？这个在你编译时期你是不知道的，自然这代码你就没法写下去了……</p><p>那该怎么解决这个问题呢？</p><p>有聪明的程序猿说了，这还不简单吗？直接在<code>check()</code>方法中加个<code>if else</code>判断一下不就好了吗？于是代码优化成如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCheck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(Product product)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (product.weight &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (product <span class="keyword">instanceof</span> PA) &#123;</span><br><span class="line">                <span class="comment">//如果该产品是A产品就创建一个新的A对象。</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (product <span class="keyword">instanceof</span> PB) &#123;</span><br><span class="line">                <span class="comment">//如果该产品是B产品就创建一个新的B对象。</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>PA</code>和<code>PB</code>分别是<code>Product</code>接口的子类，表示A产品和B产品。上面代码看上去貌似确实没啥问题，通过对传入的<code>product</code>类型判断从而创建不同类型的对象，很正常嘛？</p><blockquote><p>❓但是这样写有个啥问题？</p></blockquote><p>上面需求是这个通用方法需要满足，后续增加新产品后可以方便扩展。现在假设这个公司新增了一种C产品，也需要使用这个检查方法怎么办？这个时候你就必须要修改<code>check()</code>方法的代码，增加<code>else if (product instanceof PC)</code>的逻辑，还记得<strong>开闭原则</strong>吗？这显然违反了<strong>开闭原则</strong>，所以这个方案不可取。如果看过上篇工厂模式的同学可能想起点什么？这个有点类似工厂模式里面的简单工厂模式嘛？</p><blockquote><p>引起这个问题的本质在于哪里？</p></blockquote><p>没错，就是因为<code>check()</code>跟具体的产品类耦合了。</p><blockquote><p>当时是怎么解决开闭原则的问题的？</p></blockquote><p>没错是通过<strong>工厂方法模式</strong>解决的，于是优化后代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCheck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ProductFactory factory)</span> </span>&#123;</span><br><span class="line">        Product product = factory.createProduct();</span><br><span class="line">        <span class="keyword">if</span> (product.weight &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            Product product2 = factory.createProduct();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中A产品和B产品各会有<code>ProductFactory</code>的实现类，这样当新增产品时就不会出现开闭原则的问题了。没错，这个问题用工厂方法模式完全可以解决，没问题。但是今天呢，我们将要聊的原型模式也可能解决这个问题。这个时候肯定会有人问了，既然工厂模式已经可以解决这一问题，那为什么还要你的原型模式呢？</p><p>这个问题我会留到后面讲，现在先让我们看一下原型模式是怎么解决这个问题的？</p><p><strong>原型模式</strong>的<strong>原理</strong>是这样的，原型模式要求，<strong>每一个对象需要定义一个克隆自己的方法</strong>。什么意思？比如一个A对象，他需要提供一个方法，调用这个方法将会返回一个自己的副本。一般来说，会给所有需要克隆自己的对象提供一个公共的接口，这个接口里面会提供一个克隆自身的方法，如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CloneableObj</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">cloneSelf</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后让所有需要克隆自己的类去实现该接口，自然会需要实现<code>cloneSelf()</code>方法，这个方法内部就是克隆自己的逻辑实现。那如何实现克隆呢？</p><p>最傻瓜的办法，直接先new一个自己对象的实例，然后把自己实例中的数据取出来，设置到新的对象实例中去，不就可以完成实例的复制了嘛？这样这个<code>cloneSelf()</code>方法返回的就是一个跟自身一模一样的对象了。以下是代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PA</span> <span class="keyword">extends</span> <span class="title">Product</span> <span class="keyword">implements</span> <span class="title">CloneableObj</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">cloneSelf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        PA a = <span class="keyword">new</span> PA();</span><br><span class="line">        a.weight = weight;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候假设你需要在工程其他代码中需要通过克隆方式快速得到一个<code>PA</code>对象，就可以通过调用原型<code>PA</code>对象（假设是a）<code>a.cloneSelf()</code>轻松快速的得到一个PA对象了。</p><p>没错，这个就是<strong>最本质</strong>的<strong>原型模式</strong>。其实说的简单一点，<strong>所谓的原型模式，就是复制（或克隆）模式，就是通过当前对象（原型对象）返回一个跟当前对象完全相同的对象，包括其中的属性值。</strong></p><p>这也是原型模式跟直接new的一个区别，我们知道new生成的对象的属性值都是默认的，而通过原型模式返回的对象是<strong>将属性值一同复制</strong>。</p><blockquote><p>其实，原型模式并不强制要求克隆生成的对象和原型对象完全相同，而且也没有规定具体采用的克隆技术，这个可以由程序自己实现。只是在大部分实际应用场景中，用原型模式生成的对象都是和原型对象完全相同或者相近。</p></blockquote><h2 id="Object-clone"><a href="#Object-clone" class="headerlink" title="Object.clone()"></a>Object.clone()</h2><p>其实，上面这个例子是为了更好的理解原型模式的本质，为了提高克隆效率，JDK已经设计了关于<strong>对象克隆</strong>的功能。在Object类中有一个<code>clone()</code>方法，该方法就可以轻松的实现对对象本身进行克隆。上面例子中底层还是采用<code>new</code>的方式创建对象，但是<code>Object.clone()</code>底层是直接对二进制数据流操作，因此效率会比直接<code>new</code>的方式高得多（看到后面，其实这句话说的不严谨）。不过要使用<code>Object.clone()</code>来对自身对象克隆有个限制，就是该对象所对应的类必须要实现<code>java.lang.Cloneable</code>接口，否则会抛出<code>CloneNotSupportedException</code>异常。另外，一般需要被克隆的类都需要重写<code>Object.clone()</code>，并且将访问修饰符改为<code>public</code>，以方便在其他类中使用。于是代码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProductCheck</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(Product product)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (product.weight &gt; <span class="number">10</span>) &#123;</span><br><span class="line">            Object o = product.clone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人又会有疑问了，这样做相比较前面的工厂模式有啥优势？工厂方法模式也完全可以实现相同的需求啊？</p><h2 id="原型模式和工厂模式"><a href="#原型模式和工厂模式" class="headerlink" title="原型模式和工厂模式"></a>原型模式和工厂模式</h2><p>原型模式和工厂方法模式一个共同的<strong>优点</strong>是，他们都可以在不知道具体的类型情况之下，创建出某类型对象。比如上面例子中的<code>Product</code>，这只是一个抽象接口，其下会有很多的子类，具体创建哪种类型的子类对象取决于运行时期。<strong>原型模式</strong>是通过克隆自身的方式实现的，而<strong>工厂方法模式</strong>是通过不同子类的工厂类实现的。</p><p>但是原型模式相比于工厂方法模式的优势在于，工厂方法模式底层还是采用<code>new</code>的方式创建对象，并且需要手动的为属性赋值，效率较差。而通过<code>Object.clone()</code>实现的原型模式直接是操作<strong>二进制流</strong>实现，而且<strong>克隆生成的对象是已经赋好值</strong>了。因此效率要高得多。</p><blockquote><p>那么，通过new的方式创建对象和调用clone()方式创建对象，效率相差多少？</p></blockquote><p>下面给出一个简单的测试例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String a = <span class="string">&quot;a&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">long</span> s1 = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> A();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> e1 = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;new cost total: &quot;</span> + TimeUnit.NANOSECONDS.toMillis(e1 - s1));</span><br><span class="line">        <span class="keyword">long</span> s2 = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">            a.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> e2 = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;clone cost total: &quot;</span> + TimeUnit.NANOSECONDS.toMillis(e2 - s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面输出的结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new cost total: 5</span><br><span class="line">clone cost total: 71</span><br></pre></td></tr></table></figure><p>相信看到这个结果的朋友肯定会大吃一惊⁉️震惊！怎么clone的速度比new还慢了这么多倍……😱和之前的认知大相径庭了。</p><blockquote><p>那结果真的是这样吗❓</p></blockquote><p>我们做一下小改动，其它代码都不做修改，但这一次我们在new所需要的构造器中加入一些耗时操作，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//其余代码和上面的例子一样，省略，唯一区别在于加入下面的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++)</span><br><span class="line">            a += <span class="string">&quot;a&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了节省测试时间，我们把Demo中的循环次数减少到10000就好，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        <span class="keyword">long</span> s1 = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">new</span> A();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> e1 = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;new cost total: &quot;</span> + TimeUnit.NANOSECONDS.toMillis(e1 - s1));</span><br><span class="line">        <span class="keyword">long</span> s2 = System.nanoTime();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">            a.clone();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> e2 = System.nanoTime();</span><br><span class="line">        System.out.println(<span class="string">&quot;clone cost total: &quot;</span> + TimeUnit.NANOSECONDS.toMillis(e2 - s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这一次测试结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new cost total: 1760</span><br><span class="line">clone cost total: 1</span><br></pre></td></tr></table></figure><p>这一次总算出现符合预期的结果了。</p><p>也就是说，对于本身创建过程不是很耗时的简单对象来说，直接<code>new</code>的效率要比<code>clone</code>要高。但是如果是创建过程很复杂很耗时的对象，那使用<code>clone</code>的方式要比<code>new</code>的方式效率高得多。这也是<code>clone()</code>方法的意义所在。</p><p>也就是说，对于创建<strong>耗时复杂</strong>的对象，用<strong>原型模式</strong>可以大大提高创建对象的效率。到这里估计很多人应该能想到，既然这样，把这两者结合一下不就可以弥补工厂方法模式的缺陷了吗？</p><p>没错，传统的工厂方法模式中，各子类的工厂类创建对象的方法，比如上面的<code>factory.createProduct()</code>底层还是采用<code>new</code>的方式，如果改成克隆方式就可以大大提高创建对象的效率了。思路比较简单，具体代码这边就不演示了。</p><p>另外，在原型模式中还会涉及到一个<strong>浅克隆</strong>和<strong>深克隆</strong>的问题，怎么理解呢？我举一个简单的例子:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//以下代码全部省略setter、getter、toString</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> b;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">  </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShallowClone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.setA(<span class="number">1</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.setA(a);</span><br><span class="line">        b.setB(<span class="number">2</span>);</span><br><span class="line">        B b2 = (B)b.clone();❶</span><br><span class="line">        System.out.println(<span class="string">&quot;b--&gt;&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;b2--&gt;&quot;</span> + b2);</span><br><span class="line">        b2.setB(<span class="number">3</span>);❷</span><br><span class="line">        System.out.println(<span class="string">&quot;b--&gt;&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;b2--&gt;&quot;</span> + b2);</span><br><span class="line">        b2.getA().setA(<span class="number">10</span>);❸</span><br><span class="line">        System.out.println(<span class="string">&quot;b--&gt;&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;b2--&gt;&quot;</span> + b2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">b--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b2--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b2--&gt;B&#123;b=<span class="number">3</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">10</span>&#125;&#125;</span><br><span class="line">b2--&gt;B&#123;b=<span class="number">3</span>, a=A&#123;a=<span class="number">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>从上面这个代码分析可得出：</p><ul><li>❶行处，b2是通过调用<code>b.clone()</code>克隆得到的，所以这两个对象除了内存地址不同，其余的内容都相同。</li><li>❷行处，修改b2对象中的b属性，发现并没有影响原型对象b中b属性值。b属性是int类型。</li><li>❸行处，修改b2对象中的a属性中的a属性值，发现原型对象b中的a属性的a属性值也发生了改变。a属性是一个A类型（<strong>引用类型</strong>）。</li></ul><p>由此，我们可以得出一个结论，<code>Object.clone()</code>实现的其实是一种<strong>浅克隆</strong>模式。</p><p>在<strong>浅克隆模式</strong>下，克隆生成对象的<strong>基本数据类型</strong>（包括对应包装类）属性和<strong>String</strong>拷贝的是<strong>值</strong>，后续修改克隆对象的该属性值，并不会影响原来的对象里的值。但如果是<strong>引用类型属性</strong>拷贝的是<strong>引用</strong>，拷贝得到的对象和原来的对象的属性<strong>指向同一个对象</strong>。所以，后续修改其属性值，就会影响原来的对象里的对应的属性值。</p><p>而在有些场合下，我们是希望原型对象和新创建的对象不要相互干扰。这就是<em>深克隆模式</em>。</p><blockquote><p>❓那怎么实现呢？</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer b;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        B b = (B) <span class="keyword">super</span>.clone();❶</span><br><span class="line">        A a = b.getA();</span><br><span class="line">        b.setA((A) a.clone());</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepClone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.setA(<span class="number">1</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.setA(a);</span><br><span class="line">        b.setB(<span class="number">2</span>);</span><br><span class="line">        B b2 = (B)b.clone();</span><br><span class="line">        System.out.println(<span class="string">&quot;b--&gt;&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;b2--&gt;&quot;</span> + b2);</span><br><span class="line">        b2.setB(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b--&gt;&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;b2--&gt;&quot;</span> + b2);</span><br><span class="line">        b2.getA().setA(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b--&gt;&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;b2--&gt;&quot;</span> + b2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">b--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b2--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b2--&gt;B&#123;b=<span class="number">3</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b2--&gt;B&#123;b=<span class="number">3</span>, a=A&#123;a=<span class="number">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>通过上面代码执行结果我们不难看出，这个时候无论是修改b2中的a属性（引用类型）还是b属性（基本类型），都不会影响到原型对象中的值了。</p><blockquote><p>❓那这个是怎么实现的呢？</p></blockquote><p><strong>深克隆模式</strong>实现的关键在于❶行处，在B对象通过调用clone()复制自己的同时，将a属性(引用类型)也clone了一份，并且赋值给生成的b2对象。</p><p><strong>深克隆原理</strong>就是在每一个原型对象执行<code>clone()</code>方法的时候，同时将该对象中每一个引用类型的属性的内容也拷贝一份，并设置到新创建的对象中。假设，每一个引用类型中又嵌套着其它的引用类型的属性，再重复上面操作，以此类推，递归执行下去……这中间只要有一个没有这样操作，深克隆就失败。</p><p>这也是原型模式一大缺点，在实现深克隆复制时，每个原型的子类都必须实现<code>clone()</code>的操作，尤其是包含多层嵌套引用类型的对象时，必须要递归的让所有相关对象都正确的实现克隆操作，十分繁琐易错。</p><p>那有没有更好的办法来实现深克隆呢？</p><p>当然有！😎</p><h2 id="序列化和反序列化实现深克隆"><a href="#序列化和反序列化实现深克隆" class="headerlink" title="序列化和反序列化实现深克隆"></a>序列化和反序列化实现深克隆</h2><p>可以使用序列化和反序列化的手段实现对象的深克隆！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer b;</span><br><span class="line">    <span class="keyword">private</span> A a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeepClone2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        a.setA(<span class="number">1</span>);</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        b.setA(a);</span><br><span class="line">        b.setB(<span class="number">2</span>);</span><br><span class="line">        </span><br><span class="line">        ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">        ObjectOutputStream oos = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">        oos.writeObject(b);</span><br><span class="line">        ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray()));</span><br><span class="line">        B b2 = (B) ois.readObject();</span><br><span class="line">        System.out.println(<span class="string">&quot;b--&gt;&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;b2--&gt;&quot;</span> + b2);</span><br><span class="line">        b2.setB(<span class="number">3</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b--&gt;&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;b2--&gt;&quot;</span> + b2);</span><br><span class="line">        b2.getA().setA(<span class="number">10</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;b--&gt;&quot;</span> + b);</span><br><span class="line">        System.out.println(<span class="string">&quot;b2--&gt;&quot;</span> + b2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出：</span></span><br><span class="line">b--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b2--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b2--&gt;B&#123;b=<span class="number">3</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b--&gt;B&#123;b=<span class="number">2</span>, a=A&#123;a=<span class="number">1</span>&#125;&#125;</span><br><span class="line">b2--&gt;B&#123;b=<span class="number">3</span>, a=A&#123;a=<span class="number">10</span>&#125;&#125;</span><br></pre></td></tr></table></figure><p>通过上面的代码不难看出，序列化和反序列化确实实现了<strong>深克隆</strong>，而且在实现方式上比之前用重写<code>clone()</code>的方式要简单的多，唯一需要做的就是给需要克隆的对象以及引用类型实现<code>Serializable</code>接口即可。</p><p>最后来做个总结，其实<strong>原型模式</strong>更适合叫做<strong>克隆模式</strong>，它的<strong>本质</strong>就在于<strong>通过一定技术手段生成一个自身的副本</strong>。这可以通过我们在文章最开始那样手动<code>new</code>一个，也可以通过<code>Object.clone()</code>，还可以通过<code>序列化和反序列化</code>实现。如果原型对象中存在引用类型的属性，根据是否同时克隆该属性可以分为<strong>深克隆模式</strong>和<strong>浅克隆模式</strong>。</p><h2 id="何时使用原型模式？"><a href="#何时使用原型模式？" class="headerlink" title="何时使用原型模式？"></a>何时使用原型模式？</h2><p>在大部分场景下，我们主要会使用<code>Object.clone()</code>方法来实现克隆，根据上面对<code>clone()</code>方法执行性能测试结果，在创建大量复杂对象时，这个方法的创建效率要远高于<code>new</code>的方式。因此<strong>如果需要创建大量并且复杂对象时</strong>可以采用<strong>原型模式</strong>。</p><p>另外，原型模式可以像工厂方法模式一样，可以在事先不知道具体类型的前提下创建出对象，也就是基于接口创建对象，而且实现方式比工厂模式更高效简单。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>脚本语言Lua-OpenRestry</title>
      <link href="/2019/11/27/lua/"/>
      <url>/2019/11/27/lua/</url>
      
        <content type="html"><![CDATA[<p><a href="https://moonbingbing.gitbooks.io/openresty-best-practices/content/">OpenRestry最佳实战（资料）</a><br><a href="http://luajit.org/download.html">LuaJIT安装</a><br><a href="http://openresty.org/cn/">OpenResty官网</a></p><span id="more"></span><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><h4 id="方式一："><a href="#方式一：" class="headerlink" title="方式一："></a>方式一：</h4><p>hello.lua:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/lua</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World！&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>执行<code>./hello.lua</code></p></blockquote><h4 id="方式二："><a href="#方式二：" class="headerlink" title="方式二："></a>方式二：</h4><p>helloworld.lua:</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello World!&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>执行<code>lua helloworld.lua</code></p></blockquote><p>在常用基本类型中，除了<code>table</code>是按<strong>址</strong>传递类型外，其它的都是按<strong>值</strong>传递参数。 用全局变量来代替函数参数的不好编程习惯应该被抵制，良好的编程习惯应该是减少全局变量的使用。</p>]]></content>
      
      
      <categories>
          
          <category> Lua </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Lua </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式|③工厂模式</title>
      <link href="/2019/11/24/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A2%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/24/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A2%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;今天我们开始一个新的模式——<strong>工厂模式</strong>。工厂模式作为本系列第二个登场的角色，可想而知它的重要性了。另外和单例模式相比，工厂模式会相对复杂一些，因为单例模式只涉及一个对象，而工厂模式会涉及到多个对象。而且这一模式在实际开发中，那真的是应用得太太太太太太™广泛了……😱再多的太都不足形容。因此，<strong>这个模式也是我们需要深入掌握的一个模式</strong>。</p><span id="more"></span><h2 id="为什么需要工厂模式"><a href="#为什么需要工厂模式" class="headerlink" title="为什么需要工厂模式"></a>为什么需要工厂模式</h2><p>看过我之前写的文章的应该都清楚我的风格，学一样东西，我会先简单思考一下，这玩意到底有啥用，学了能帮我解决什么，才能决定我如何学以及学习的深度。同样，今天学习工厂模式，我们先来看看.</p><blockquote><p>❓工厂模式是个什么玩意？到底有什么用？为什么会出现这一模式？帮我们解决了什么问题？如果没有它会怎么样？</p></blockquote><p>工厂模式，顾名思义，跟工厂有关。何为工厂？工厂就是用来生产产品的，例如汽车工厂用来生产汽车，粮食工厂用来生产粮食等。那在面向对象软件开发领域，自然是用这种模式来生产对象的。所以工厂模式也是属于之前说过的<strong>创建型模式</strong>。那老问题来了，平时我们创建一个对象大多数情况都是直接new一下不就有了吗？为什么非要按照你工厂模式的套路来创建对象？</p><p>为方便理解，下面我举个简单的例子，如下代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    Dao dao = <span class="keyword">new</span> JpaDao(); ❶</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//使用dao进行一系列持久层操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>做过Java后端开发的对上面的代码套路太熟悉不过了，这是一个经典的<code>Service</code>层，调用<code>DAO</code>层API完成数据库操作，这没有什么好说的。现在假设这个团队使用的持久层框架是JPA，所以他们把所有的数据库操作都封装在<code>JpaDao</code>这个工具类中，然后在<code>Service</code>类里面通过new得到一个实例，并在具体业务方法中使用它来完成数据库操作。这代码执行结果会有问题吗？当然不会，这代码肯定能跑起来，业务逻辑正常执行完成。</p><blockquote><p>❓但是思考一下，这样的代码会有啥问题？</p></blockquote><p>假设某一天，经过团队讨论，决定不用<code>JPA</code>这玩意了，还是使用<code>Mybatis</code>。于是团队各大高手通宵达旦，连夜又将<code>Mybatis</code>封装了一波，并开发出来一个<code>MybatisDao</code>工具包，打算用它来替换之前工程中使用的<code>JpaDao</code>。好了，现在问题来了，原来<code>Dao dao = new JpaDao()</code>这一行是写死在每一个<code>Service</code>类中，现在需要将所有<code>Service</code>类中的<code>Dao dao = new JpaDao()</code>修改为<code>Dao dao = new MybatisDao()</code>。要是整个工程就只有几个<code>Service</code>类，那还好办，改就改了。那要是成千上万呢？那通宵加班是免不了了……😭而且，要是下次又换个别的框架，又来这么一下，那还不得吐血啊⁉️……😒</p><p>在这个系列文章开篇，我们提到过设计的几大原则，这个代码就涉及到了其中的<strong>开闭原则</strong>。</p><blockquote><p>👉开闭原则倡导，软件实体应当对扩展开放，对修改关闭。</p></blockquote><p>翻译成人话就是说，你想要扩展或者修改以前已经写好的代码的功能，你可以往里面加入新的代码，但是绝对不允许修改以前已经写好的代码。很显然，上面代码违反了这一原则。</p><blockquote><p>❓那么我们来分析一下，这个代码关键问题在哪里，才会导致这种不可收拾的结果？</p></blockquote><p>不难发现，在这个代码中，<code>Service</code>和<code>JpaDao</code>是紧耦合的，也就意味着，每个<code>Service</code>你只能使用<code>JpaDao</code>，要想使用其它的，没有其他选择，必须修改代码。</p><blockquote><p>❓如何解决？</p></blockquote><p>思考一下，既然上面提到，这个代码中核心问题是<code>Service</code>和<code>JpaDao</code>的耦合导致代码的扩展性很差，那自然想到，有什么办法可以让它解耦？问题关键在于，在❶处是直接new出来一个非常具体的底层对象！</p><blockquote><p>⚠️new操作本身就是一个耦合的操作！</p></blockquote><p>所以要想<code>Service</code>和<code>JpaDao</code>解耦，必须拿掉这个<code>new</code>的逻辑。可是对象还是得创建啊，<code>new</code>拿掉了还怎么创建呢？<code>new</code>当然还是要<code>new</code>的，但是得让他挪个地方。优化代码如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    Dao dao = DaoFactory.getDao(); ❶</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用dao进行一系列持久层操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后我将所有的<code>new</code>的代码全部抽取到<code>Service</code>类外部的一个单独<code>DaoFactory</code>类中，如下，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dao <span class="title">getDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpaDao(); ❷</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样优化后有一个明显好处，以后不管你团队换啥持久层实现，所有的Service类是不需要再动了，比如需要将持久层框架改为<code>Mybatis</code>，只需要修改一下<code>DaoFactory</code>类❷处，将其改为<code>return new MybatisDao()</code>就可以了，这样一来，修改代码的工作量极大减少。这个方案和刚开始的相比，可以说已经是一个很大的进步了。但是，现在虽然代码修改工作量少了，可是根本问题还是没有解决，<code>DaoFactory</code>的代码还是得修改啊？开闭原则该违反还是违反。作为一个对技术有极致的程序猿👨‍💻‍，怎么可能容忍这等事情呢⁉️</p><p><strong>绝对不可能！</strong></p><p>还有没有妙招？当然有！</p><p>其实上面<code>DaoFactory</code>之所以还需要修改，罪魁祸首还是因为❷处直接<code>new</code>了一个具体对象！哎呀，这万恶的<code>new</code>啊……😒想要解耦，必须拿掉<code>new</code>的逻辑，可是还是那个问题，不<code>new</code>怎么创建对象？依稀还记得当前大明湖畔的<strong>反射</strong>吗？Java当中的反射太强大了，给一个字符串就可以直接创建一个对象，牛逼🐂！这样就不需要通过<code>new</code>啦！那问题来了，这个字符串怎么传？要是通过方法参数传入，那不还得修改源代码吗？有没有一种方案可以不用通过代码传递参数的？没错，配置文件！哈哈，O了，于是再次优化方案，如下，</p><p>在类路径下创建<code>config.properties</code>文件，配置内容如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dao=com.example.demo.pattern.factory.JpaDao</span><br></pre></td></tr></table></figure><p>然后DaoFactory内容修改如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Dao <span class="title">getDao</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Properties prop = <span class="keyword">new</span> Properties();</span><br><span class="line">        prop.load(DaoFactory.class.getClassLoader().getResourceAsStream(<span class="string">&quot;config.properties&quot;</span>));</span><br><span class="line">        Class&lt;?&gt; dao = Class.forName((String) prop.get(<span class="string">&quot;dao&quot;</span>));</span><br><span class="line">        <span class="keyword">return</span> (Dao) dao.newInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大家看出其中的奥秘了吗？这样一来就把代码中耦合的部分提取到了<strong>外部配置文件</strong>，后续再要修改<code>Dao</code>实现方式，只需要提供对应的<code>xxxDao</code>类，并将其全类名配置在<code>config.properties</code>中即可。所有的<code>Service</code>类中获取<code>Dao</code>的方式还是通过<code>DaoFactory.getDao()</code>，再也不需要修改了。O了，这真是个绝妙的完美方案啊~👏</p><p>说到这儿，大家可能有点懵逼了，哎，今天不是说好讲工厂模式的吗？讲了一大圈废话，这讲的是啥？哈哈，如果你能看懂上面这个例子，那么，恭喜你，你已经学习了工厂模式一部分内容。没错，上面这个例子就是一个经典的<strong>简单工厂模式</strong>的案例。</p><h2 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h2><p>简单工厂模式是工厂模式的第一种形式，又叫<strong>静态工厂模式</strong>。顾名思义，因为这种工厂模式中<strong>获取对象的方法</strong>一般都定义成<strong>静态方法</strong>，形式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,P&gt; <span class="function">R <span class="title">getInstance</span><span class="params">(P type)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据传入的type不同做if else判断返回不同类型的对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者还有另一种形式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,P&gt; <span class="function">R <span class="title">getInstance01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建一种类型的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> &lt;R,P&gt; <span class="function">R <span class="title">getInstance02</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//创建另一种类型的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这两种形式本质上跟前面例子中<code>DaoFactory.getDao()</code>方法是一样的，无非我们是通过直接修改<strong>返回值</strong>（或者修改<strong>配置文件</strong>）来返回不同类型对象，这边是通过对传入的字段判断达到返回不同类型对象的目的。</p><p>当然，你也可以将获取对象的方法定义成普通方法，然后通过<code>Factory</code>的实例调用其<code>getInstance()</code>，完全没问题。如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;R,P&gt; <span class="function">R <span class="title">getInstance</span><span class="params">(P type)</span></span>&#123;</span><br><span class="line">        <span class="comment">//根据传入的type不同做if else判断返回不同类型的对象。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实这种方式又叫做<strong>实例工厂模式</strong>。这两种方式的区别在于，<strong>静态工厂</strong>可以直接用类名调用而不需要创建出工厂类的实例。但是我们知道，静态方法可以继承，但是没有办法被重写，没有重写也就不可能实现多态的特性了。所以静态工厂是<strong>没有办法</strong>通过继承方式来动态<strong>改变</strong>工厂创建对象的行为的。</p><blockquote><p>👉优缺点</p></blockquote><p>通过上面这个例子，我们不难看出，<strong>简单工厂模式</strong>确实在一定程度上实现代码的解耦，而这种解耦的特点在于，这种模式将对象的创建和使用分离，其实这个特点是所有创建型模式的共性，包括前面聊过的<strong>单例模式</strong>，以及接下去后面还会讲到的其他的创建型模式都有这个特点。另外，<strong>简单工厂模式</strong>也起到了一定的封装功能。试想一下，假设上面的<code>DaoFactory.getDao()</code>返回的<code>JpaDao</code>和<code>MybatisDao</code>对象创建过程非常繁琐冗长，如果不使用工厂模式，<code>JpaDao</code>和<code>MybatisDao</code>对象的创建逻辑就会散落在项目中各个<code>Service</code>类，以及其他用到该对象的地方，造成代码<strong>重复冗余</strong>。</p><p>但是这种模式的缺点也很明显，<strong>不符合开闭原则</strong>。这种模式的本质在于通过一个传入的参数，做<code>if else</code>判断，来达到返回不同类型对象的目的。因此，如果需要增加新的类型，就不得不去修改原来的代码，<strong>违反开闭原则</strong>。虽然这个问题可以通过前面反射+外部配置文件的方式在一定程度上得到缓解，但是这只是一种“投机取巧”的解决方案，并没有从根本上解决简单工厂模式的问题。</p><p>或许也就是因为这原因，很遗憾，<strong>简单工厂模式</strong>其实<strong>并不属于GOF23体系</strong>。</p><p>那么有没有更好的办法，从根本上解决简单工厂模式的问题呢？答案当然是有的！</p><h2 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h2><blockquote><p>❓其实，简单工厂模式之所以违反开闭原则，关键在于什么？</p></blockquote><p>那就是它把所有对象的创建都集中在同一个工厂类里面了！因此，当新增一个新对象时，必然会需要修改这个共享工厂类，违反开闭原则自然不可避免。</p><blockquote><p>❓思考一下，既然问题关键在于，所有对象的创建都跟这个唯一的工厂类耦合了，那我每个对象各自都配置一个单独的工厂类，这个工厂类只创建各自类型的对象，那这样不就解决耦合的问题了吗？</p></blockquote><p>这就引出了工厂模式的第二种形式——<strong>工厂方法模式</strong>。工厂方法模式的产生就是为了解决上面提到的简单工厂模式所遇到的问题的。工厂方法模式是<strong>在简单工厂模式基础上进一步抽象，将工厂类设计成抽象类或接口</strong>，不同的产品实现各自的工厂实体类。创建对象时，只需要提供对应的产品类和该产品的工厂类即可，不需要知道内部创建过程。</p><p>就比如上面例子的<code>DaoFactory</code>类，现在我们将其抽象成接口，然后同时为每一个DAO类实现一个对应的工厂实现类，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">DaoFactory</span></span>&#123;</span><br><span class="line">    <span class="function">Dao <span class="title">getDao</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">JpaDaoFactory</span> <span class="keyword">implements</span> <span class="title">DaoFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dao <span class="title">getDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JpaDao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MybatisDaoFactory</span> <span class="keyword">implements</span> <span class="title">DaoFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dao <span class="title">getDao</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MybatisDao();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在创建<code>Service</code>类时将具体的实现类对应的工厂类传入，利用<strong>多态</strong>就可以实现不同的持久层实现切换。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Dao dao;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Service</span><span class="params">(DaoFactory daoFactory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dao = daoFactory.getDao();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">service</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//使用dao进行一系列持久层操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>❓优缺点</p></blockquote><p>从上面例子不难看出，工厂方法模式轻松解决了简单工厂模式的问题，<strong>符合开闭原则</strong>。在上面例子中，当需要切换另外某持久层实现，比如<code>JDBC</code>，此时只需要提供一个对应的<code>JDBCDaoFactory</code>实现<code>DaoFactory</code>的<code>getDao</code>方法，返回对应的<code>Dao</code>对象即可，对于原先代码再不需要做任何修改。</p><p>其实在工厂方法模式中，可以引申出另外一种设计原则，<strong>依赖倒置原则</strong>。</p><blockquote><p>👉依赖倒置原则倡导我们要面向接口编程，不要面向实现编程。就比如上面例子中，和Service类耦合的是最高层接口DaoFactory，而底层实现是当程序运行时才决定的。</p></blockquote><p><strong>那工厂方法模式有缺点吗？当然，没有什么是完美的。</strong></p><p>很明显的一点，每个类型的对象都会有一个与之对应的工厂类。如果对象的类型不是很多，那还好。但是如果对象的类型非常多，意味着会需要创建很多的工厂实现类，造成类数量膨胀，对后续维护带来一些麻烦。</p><p><strong>而且，这当中有一种特殊情况！</strong></p><p>有时候这些对象类型很多，但是彼此之间有依赖或者关系很紧密，属于同一个系列的东西，完全可以一起创建，没必要再另起炉灶，为每个对象单独创建一个工厂实现类了。但是使用工厂方法模式，你还是不得不为每个对象单独创建一个工厂实现类，因此非常繁琐。为了帮助理解这一点，下面举个例子。</p><p>假设现在需要创建一个手枪对象，但是有手枪，肯定需要配备子弹吧？没有子弹你玩什么枪？也就是说，你还要附带创建一个子弹对象。那如果使用上面的工厂方法模式能不能完成这一需求呢？</p><p>当然没问题，只要定义一个手枪和子弹对象的公共工厂接口，然后各自创建不同的工厂实现类即可。但是这样的话，你需要有两个工厂实现类。如果还需要配备其它和手枪相关的装备，还需要再继续创建一个对应的工厂实现类。再继续延伸，手枪可能还会分很多种类，上面说的只是其中一类，要是还有另外一种类的手枪，你也需要这么来一波操作，工厂实现类的数量继续翻倍。以此类推……</p><blockquote><p>❓发现问题了没？</p></blockquote><p>这也是上面总结的工厂方法模式的<strong>缺点</strong>。当随着创建的对象类型越来越多，工厂实现类数量也跟着膨胀。而这个例子中，创建的对象都是和手枪紧密相关的，你要创建手枪，其余组件也是需要跟着创建的，那这个时候也就没必要再单独为每一个组件配置一个工厂实现类了，直接在同一个工厂类中一起创建，这样不就解决工厂实现类数量膨胀问题了吗？而这正是前面的工厂方法模式遇到的最大问题啊⁉️哈哈，O了~</p><p>其实这个思路的实现，就是我们接下来要聊的<strong>抽象工厂模式</strong>了！</p><h2 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h2><p>抽象工厂模式是工厂模式的第三种形式，也是工厂模式中最为复杂和难以理解的一种形式。在GOF23中，抽象工厂模式其实是作为单独一个模式存在的，但是因为它和上面的两类工厂模式，尤其是工厂方法模式，存有较为密切的联系，所以我这边就放一起说了。</p><p><strong>抽象工厂模式出现，就是为了解决上述工厂方法模式存在的问题，可以看成是工厂方法模式的升级。</strong></p><blockquote><p>❓怎么理解？</p></blockquote><p>说实话，这句话是本文中最难理解的一句话了，下面我来做分析。</p><p>从上面工厂方法模式的例子不难看出，<strong>工厂方法模式创建的对象其实归根到底都是同一类对象</strong>。还是说手枪的例子，无论创建的是A类手枪及其附属组件，还是B类手枪及其附属组件，归根到底他们都属于同一个底层接口的实现。怎么理解？请看下图。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-1.png" alt="抽象工厂模式-1"></p><p>由上图不难得出，虽然武器分为A类和B类，但是从工厂方法模式角度，他们都是属于武器这一层级，这就导致了需要为每一个单独武器指定各自的工厂类，从而导致类数量膨胀问题。</p><p>自然会想到，那为什么不单独为每一类武器指定一个工厂类，这样不就可以大幅减少工厂类的数量了吗？如下图。</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-2.png" alt="抽象工厂模式-2"></p><p>这样当每一类武器组件数量特别多，而组件之间又是紧密关联的时候，对减少工厂类数量起到极大的效果。下面我们就用代码简单的实现一下上面的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Weapon</span> </span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Gun</span> <span class="keyword">extends</span> <span class="title">Weapon</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Bullet</span> <span class="keyword">extends</span> <span class="title">Weapon</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//A类武器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GunA</span> <span class="keyword">implements</span> <span class="title">Gun</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulletA</span> <span class="keyword">implements</span> <span class="title">Bullet</span></span>&#123;&#125;</span><br><span class="line"><span class="comment">//B类武器</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GunB</span> <span class="keyword">implements</span> <span class="title">Gun</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BulletB</span> <span class="keyword">implements</span> <span class="title">Bullet</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顶层武器工厂</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">WeaponFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Gun <span class="title">getGun</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Bullet <span class="title">getBullet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//A类武器工厂，用来创建A类武器，包括A类手枪和A类子弹</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AWeaponFactory</span> <span class="keyword">implements</span> <span class="title">WeaponFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gun <span class="title">getGun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GunA();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bullet <span class="title">getBullet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BulletA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//B类武器工厂，用来创建B类武器，包括B类手枪和B类子弹</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BWeaponFactory</span> <span class="keyword">implements</span> <span class="title">WeaponFactory</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Gun <span class="title">getGun</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GunB();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Bullet <span class="title">getBullet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> BulletB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实上面的A类武器和B类武器有一个专用术语叫做<strong>产品族</strong>。抽象工厂模式就是为了创建一系列以产品族为单位的对象，而产品族内各个单独组件关系密切。这样在需要创建大量系列对象时可以大大提高开发效率，降低维护成本。</p><blockquote><p>👉抽象工厂模式和工厂方法模式的关系</p></blockquote><p>前面提到过，<strong>抽象工厂模式是工厂方法模式的升级</strong>。</p><blockquote><p>❓那到底升级了啥？</p></blockquote><p>其实是由原来的单一产品的生产升级成为了系列产品的生产。设想一下，假设上面手枪的例子中，每一类武器中就只生产一种武器（组件），比如就只生产手枪吧，不生产子弹等其他组件了，如下图，</p><p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-3.png" alt="抽象工厂模式-3"></p><p>发现了什么没有？震惊！这居然转变为我们之前讲过的工厂方法模式啦！卧槽，niubibility，这才是“抽象工厂模式是工厂方法模式的升级”这句话阐述的本质。<strong>换句话说，当你的产品族中只生产一种产品的时候，你的抽象工厂模式其实已经退化为工厂方法模式了</strong>。反过来说，当生产多种产品时，工厂方法模式就进化为抽象工厂模式。</p><blockquote><p>❓那么抽象工厂模式存在什么问题？</p></blockquote><p>和工厂方法模式用来生产单一产品不同，抽象工厂模式天生就是为<strong>生产产品族</strong>而生的，而对于生产单一产品却无能为力。</p><blockquote><p>❓怎么理解？</p></blockquote><p>还是上面手枪的例子，现在假设在武器装备中，我需要再加一个组件，比如手榴弹，怎么操作？你需要在<code>WeaponFactory</code>接口中添加返回手榴弹对象的接口，这一加不得了了……所有的武器实现类全部需要修改并追加该方法的实现，违反了开闭原则。而如果需要添加一个新的产品族，那就简单了，比如新增一个C类武器，那就只需要添加一个C类武器的工厂实现类就好了，并不会对原有的代码造成任何影响。</p><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>工厂模式的三种形式都介绍完了，那我们实际开发中该如何去选择呢？</p><ul><li>从设计原则来说，<strong>简单工厂模式</strong>不符合开闭原则。但是很神奇，在实际场景中，简单工厂模式确实<strong>用的最多</strong>的。个人觉得有以下这些原因:<ul><li>一、相对实现方式比较简单，维护起来也不困难。</li><li>二、实际场景中需要工厂模式创建的对象数量一般也不会特别多。</li><li>三、可以通过反射+外部配置文件的手段解决开闭原则的问题。</li></ul></li><li><strong>工厂方法模式</strong>是专门用于解决单个对象创建工作，本身模式没问题，也符合开闭原则。但是存在工厂类数量膨胀的问题。如果需要创建的工厂类不是很多，是一种不错的选择。</li><li><strong>抽象工厂模式</strong>天生就是为生产产品族而生的。所以如果你需要创建的对象非常之多，但是对象之间存在明显产品族特征，那么这个时候用抽象工厂模式非常合适。</li></ul><h2 id="抛砖引玉"><a href="#抛砖引玉" class="headerlink" title="抛砖引玉"></a>抛砖引玉</h2><p>关于工厂模式的理论内容就说到这里，接下去，我们看看工厂模式在实际开发中的应用场景。开头就说过，工厂模式应用非常之广，在JDK底层源码以及各大主流框架中随处可见，下面我就挑几处比较熟悉常用的例子说说。</p><ul><li>JDK当中的<code>Calendar</code>类相信大家都比较熟悉，我们经常会通过这个类来获取当前的日期时间。<code>Calendar</code>类的构造器都是<code>protected</code>的，所以要获得一个<code>Calendar</code>对象需要通过调用其<code>getInstance()</code>方法，这个方法内部就采用了<strong>静态工厂模式</strong>来返回一个<code>Calendar</code>对象。<code>getInstance()</code>最终会通过调用<code>createCalendar()</code>方法，并且会传入两个<code>TimeZone</code>和<code>Locale</code>类型的参数。核心代码片段如下:  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone, Locale aLocale)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//此处省略大量无关代码</span></span><br><span class="line">    Calendar cal = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">        String caltype = aLocale.getUnicodeLocaleType(<span class="string">&quot;ca&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;buddhist&quot;</span>:</span><br><span class="line">                    cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;japanese&quot;</span>:</span><br><span class="line">                    cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">&quot;gregory&quot;</span>:</span><br><span class="line">                    cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (cal == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (aLocale.getLanguage() == <span class="string">&quot;th&quot;</span> &amp;&amp; aLocale.getCountry() == <span class="string">&quot;TH&quot;</span>) &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aLocale.getVariant() == <span class="string">&quot;JP&quot;</span> &amp;&amp; aLocale.getLanguage() == <span class="string">&quot;ja&quot;</span></span><br><span class="line">                &amp;&amp; aLocale.getCountry() == <span class="string">&quot;JP&quot;</span>) &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>  不难看出，<code>createCalendar()</code>方法就是通过对传入的<code>Locale</code>类型的参数内容判断，从而返回不同的<code>Calendar</code>对象。这是典型的<strong>简单工厂模式</strong>。</li><li>另外在<code>Spring</code>当中有一个<code>FactoryBean</code>接口，这个接口是用来指定其实现类为一个具体的工厂类，以创建特定类型的对象。比如，其实现类<code>ThreadPoolExecutorFactoryBean</code>就是用来创建返回一个线程池对象，<code>ProxyFactoryBean</code>用来创建返回一个代理对象等，这是典型的<strong>工厂方法模式</strong>的体现。<code>FactoryBean</code>的实现类较多，大家有兴趣可以自己看看，这边不再赘述。</li></ul><p>其实，工厂模式在学习过程中是比较好辨别的，一般以<code>Factory</code>结尾命名的类，比如<code>Mybatis</code>中的<code>SqlSessionFactory</code>，<code>Spring</code>中的<code>BeanFactory</code>等，都是工厂模式的典型代表。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式|②单例模式</title>
      <link href="/2019/11/23/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A1%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/11/23/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A1%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<p>&emsp;今天要和大家分享的是GOF23模式中第一个模式——<strong>单例模式</strong>。这个模式号称是GOF23所有设计模式中最简单的一个设计模式。不过，等你看完这篇文章后会发现，这句话听听就好，别当真。😂单例模式简单吗？这是不存在的，要想吃透里面的细节并不容易，尤其是初学者。但是单例模式在实际生活和开发中，却是<strong>大量</strong>的被使用到，因此，这个模式我们是需要深入学习掌握的。下面不废话直入主题。</p><span id="more"></span><h2 id="为什么要使用单例模式"><a href="#为什么要使用单例模式" class="headerlink" title="为什么要使用单例模式"></a>为什么要使用单例模式</h2><p>单例模式属于上篇说过的设计模式三大分类中的第一类——<strong>创建型模式</strong>，自然是跟对象的创建相关，而且听这名字——单例，也就是说，这个模式在创建对象的同时，还致力于控制创建对象的数量，是的，只能创建一个实例，多的不要。或者从这一方面讲，它确实是最简单的模式。每个Java程序员都知道，Java中的对象都是使用new关键字来加载类并在堆内存中开辟空间创建对象，这是平时用到最多创建对象的方式。也知道每次new都会产生一个全新的对象。一直这样用着，好像从来没觉得有啥不好，更没有怎么思考过，这玩意居然还要去控制它的数量。</p><blockquote><p>那么问题来了，到底我们为什么要控制对象创建的个数？直接new一下多省事啊❓</p></blockquote><p>既然这个模式存在并且大量使用，说明有些场景下，没它还真不行。那么什么场景下会没它不行呢？我举个栗子🌰，比如我们平时使用的Windows上的回收站，是不是只有一个？要是有多个，会发生什么？我刚把回收站清空了，换到另一个回收站看垃圾还在，那这垃圾到底是在，还是不在？是不是很诡异了？另外比如博客上会有一个博客访问人数统计，这个东西要是不是单例的会有啥问题？今天统计了流量有100个，第二天用了一个新的计数器，又回到0了重新开始统计，那这个统计还有意义吗？</p><blockquote><p>也就是说，有些场景下，不使用单例模式，会导致系统同一时刻出现多个状态缺乏同步，用户自然无法判断当前处于什么状态.</p></blockquote><p>在技术领域，单例模式的场景更是不计其数。</p><p>比如XXX池的基本都是单例，为什么呢？对象的创建是一个比较耗时耗费资源的过程，尤其是像线程、数据库连接等，都属于使用非常频繁，但是创建销毁又非常耗时的资源，如果不使用池来控制其数量和创建，会对性能造成极大的影响。另外，像线程池中的线程，可能会需要相互通信，如果不是在同一个池中，对通信也会有影响。</p><blockquote><p>通过控制创建对象的数量，可以节约系统资源开销</p></blockquote><p>另外像应用中的日志系统，一般也会采用单例模式。这样所有的日志都会统一追加，方便后续管理。</p><p>读取配置的类一般会使用一个单例去统一加载读取。因为一般配置只会在应用启动时加载一次，而且会需要给整个应用所有对象共享。</p><blockquote><p>全局数据共享</p></blockquote><p>还有在各大主流开源框架以及JDK源码当中，也是大量使用到这种模式。后续我也会抛砖引玉给大家举两个例子。</p><p>正是存在上述这些痛点，使得有时候我们创建对象还真不能再简单任性直接new一下，需要对其做一些精细控制。那怎么才能控制只创建一个对象呢？</p><p>经过无数前人总结，一般有以下这些经典的解决方案：</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>啥叫饿汉式？饿了就立刻想到吃，类比到创建对象也是如此，当类一初始化，该类的对象就立刻会被实例化。</p><blockquote><p>👉怎么实现？</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125; ❶</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();❷</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当外部调用<code>HungrySingleton.getInstance()</code>时，就会返回唯一的<code>instance</code>实例。为什么是唯一的？</p><p>这代码中有几个要点:</p><ul><li>标注❶处该类的构造器用<code>private</code>修饰，防止外部手动通过new创建。后面的例子都需要这样，后面就不解释了。</li><li>标注❷处是核心，instance使用static修饰，然后调用new创建对象，我们知道static修饰的东西都属于类，而且在类加载阶段就已经被加载，并且只能被加载一次。就是类加载这种特性很好的保证了单例的特性，也天然防止了并发的问题。</li></ul><p>卧槽，单例模式居然如此简单，这么轻松就完成一个，这就算完事了？呵呵……</p><p>这个代码确实实现了单例的效果，只要调用<code>HungrySingleton.getInstance()</code>，你就算是神仙也造不出第二个对象……（其实后面会知道，还是有办法的）</p><blockquote><p>👉但是想想，这个方法有啥问题没？</p></blockquote><p>没错，一旦类初始化时就会创建这个对象，有人说，创建就创建呗，这有啥大不了的？大部分情况下确实是没啥问题，但是如果创建这个对象极其耗费时间和资源呢？这样必然会造成巨大的性能损耗。</p><p>另外还有一种情况，有的时候我只是想单纯的加载一下类，但并不想去用该对象，那这个时候这种模式就属于浪费内存了。什么意思？我举个栗子🌰，如下代码，其他代码和上面一样，就是加了❶行，然后我现在外部调用HungrySingleton.flag，会发生什么？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> flag = <span class="number">1</span>;❶</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleton instance = <span class="keyword">new</span> HungrySingleton();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>学过Java类加载机制的都知道，当去访问一个类的静态属性的时候会触发该类初始化，这就导致，我明明只是想使用一下flag属性，并不想用HungrySingleton对象，但由于你访问了flag导致HungrySingleton的初始化，从而导致instance被实例化，造成内存泄露。</p><p>看来这种方案可行，但不是完美的，那有啥更好方案，既能保证只创建单个对象，又可以做到<strong>真正需要使用该对象时再创建它</strong>（延迟加载），从来达到节约系统资源目的？答案当然是有的！</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>和饿汉相反，懒汉自然是很懒，能不吃就不吃饭，等到实在饿得不行了（需要用该对象了）才去吃饭（创建对象）。</p><blockquote><p>👉怎么实现？</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleton instance = <span class="keyword">null</span>;❶ </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;❷</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123; ❸</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关注❶处，类加载时不会立刻创建对象了，然后当<code>LazySingleton.getInstance()</code>调用❷处方法时，通过判断instance == null，如果有了就不创建了，没有就才会创建。</p><p>哈哈，既实现了延迟加载，节约资源，又保证了单例，貌似没毛病。飘了~😎</p><p>没错，在单线程下面确实如此，可惜忽略了多线程场景。为什么在多线程下会有问题？分析一下，现在有两个线程A和B，同时到达❸处，自然此时instance = new LazySingleton()这一行没被调用过，自然❸处条件成立，然后A和B同时进入了if{}代码块，后面的事情就知道了，A和B线程都会调用instance = new LazySingleton()，从而创建多个对象，破坏了单例。</p><p>那怎么办？有并发问题？那就加锁同步呗……</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>;❶</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; ❷</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这代码中有几个要点</p><ul><li>标注❶处其它和上面一样，多了一个<code>volatile</code>修饰，这主要是为了保证多线程下内存可见性。因为高速缓存关系，一个线程的修改并不一定要实时同步到另一线程，<code>volatile</code>可以用来解决这个问题。</li><li>标注❷处加<code>synchronized</code>同步锁，可以保证同一时刻只会有一个线程进入getInstance()方法，自然只会有一个线程调用<code>instance = new LazySingleton()</code>，单例自然就保证了。但同时这个带来了一个新问题，因为每个线程不管instance有没有被创建过，都会去调用getInstance()，因为if(instance == null)是需要进入方法后才判断的，然而getInstance()又是一个同步的，同一时刻只会有一个线程进入，其余线程都必须等待，这就会导致线程阻塞，导致性能下降。</li></ul><p>上述方法确实实现了延迟创建对象，但是<code>性能低下</code>的问题如何解决？聪明的攻城狮们又想到了新的方案……</p><h3 id="双重检测锁"><a href="#双重检测锁" class="headerlink" title="双重检测锁"></a>双重检测锁</h3><blockquote><p>👉怎么实现？</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> LazySingleton instance = <span class="keyword">null</span>; ❷</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> LazySingleton <span class="title">getInstance</span><span class="params">()</span></span>&#123; ❶</span><br><span class="line">      <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123; ❸</span><br><span class="line">        <span class="keyword">synchronized</span> (LazySingleton.class) &#123; ❺</span><br><span class="line">          <span class="keyword">if</span>(instance == <span class="keyword">null</span>)❹</span><br><span class="line">          instance = <span class="keyword">new</span> LazySingleton();❻</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码看上去会比较复杂，讲几个关注点：</p><ul><li>标注❶处方法内部和上面例子代码最大的区别在于，有❸❹两处if判断。<strong>为什么要两次判断？</strong><ul><li>第一次if判断是为了提高效率。怎么理解？回顾懒汉式方案代码，<code>synchronized</code>将整个方法加同步锁，也就是说，不管外部（线程）在调用<code>getInstance()</code>方法这一刻该对象是否已经被创建好，都需要阻塞等待。而❸处的if判断就使得，只有此时真的还没有创建出对象才会进入<code>synchronized</code>代码块，如果已经创建了就直接<code>return</code>了，所以显然提高性能了。</li><li>那么❹处的第二次if判断又是为什么？这才是用来<strong>保证多线程安全</strong>的。又怎么理解？设想下面这种场景。A和B两个线程同时来到❺处，此时因为<code>synchronized</code>缘故，只能有一个线程进入，假设A拿到了这把锁，进入<code>synchronized</code>代码块，然后通过❻创建出了一个<code>LazySingleton</code>实例，然后离开<code>synchronized</code>代码块，然后把锁释放了，但是还没等到它<code>return</code>的时候，B线程拿到了这把锁，进入<code>synchronized</code>代码块，此时要是没有❹处if判断，B线程照样可以来到❻处，以迅雷不及掩耳之势噼里啪啦一顿操作，又创建出一个<code>LazySingleton</code>实例。显然此时，单例模式已经被破坏了。所以❹处的判断也不可省略。</li></ul></li><li>标注❷处看上去和懒汉式的代码没区别，但是这边<code>volatile</code>语义已经发生改变，已经不单纯是为了内存可见的问题了，还涉及到<strong>指令重排序</strong>的问题。怎么理解？一切问题出在❻处。震惊！❻处看似平常的一行代码居然会有问题。是的，下面我来详解。❻处会创建一个<code>LazySingleton</code>实例，并且赋值给<code>instance</code>变量，很遗憾，这一个动作在指令层面并非原子操作。这个动作可以分为4步:<ul><li>1.申请内存空间</li><li>2.初始化默认值</li><li>3.执行构造器初始化</li><li>4.将<code>instance</code>指向创建的对象</li></ul>  而有些编译器会对代码做指令重排序，因为3和4本身相互并不存在依赖，指令重排序的存在可能会导致3和4顺序发生颠倒。这会有什么问题？首先在单线程下并不会有什么问题，为什么？因为指令重排序的前提就是不改变在单线程下的结果，无论先执行3还是4，最后返回的对象都是初始化好后的。但是在多线程下呢？设想一种极端场景，现在假设A线程拿到锁进入到❻处，然后它完成了上面4步的1和2，因为现在指令重排序了，下面A线程会将<code>instance</code>指向创建的对象，也就是说，此时<code>instance != null</code>了！然后正当A要去执行构造器初始化对象时，巧得很，这时候B线程来到❸处，判断instance == null不成立了，直接返回，独留A线程在原地骂娘“尼玛，我™还没初始化对象呢……”，因为返回了一个没有经过初始化的对象，后续操作自然会有问题。正是因为这个原因，所以❷处<code>volatile</code>不可省略，<strong>主要原因就在于防止指令重排序</strong>，避免上述问题。</li></ul><p>那是不是这样就万无一失了呢？很遗憾，上述如此严密的控制，还是不能完全保证出问题。What？那就是上述的做法有个前提，<strong>JDK必须是JDK5或更高版本</strong>，因为从JDK5才开始使用新的JSR-133内存模型规范，而在这个规范中才增强了<code>volatile</code>这个语义……</p><p>卧槽，原来搞了大半天还是有问题啊……心好累，而且说实话，就算不考虑JDK版本这个问题，这种方案的实现代码太过丑陋，本身看着就不是很爽，而且考虑的东西太多，稍有闪失就GG了。所以，这种方案虽然分析了这么多，但是其实没有实际意义，实际工作中强烈不建议使用。那还有没有好的方案啊？当然有啊！</p><h3 id="静态内部类实现"><a href="#静态内部类实现" class="headerlink" title="静态内部类实现"></a>静态内部类实现</h3><p>根据类加载机制，外部类的初始化并不会导致静态内部类的初始化。</p><blockquote><p>👉怎么验证？</p></blockquote><p>如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Inner loading ...&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Demo.a);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过<code>Demo.a</code>引用外部类<code>Demo</code>的静态变量<code>a</code>，会导致外部类的初始化，如果<code>Inner</code>被初始化了，必然会执行<code>static</code>块，从而打印<code>&quot;Inner loading ...&quot;</code>，然而很遗憾，这个代码执行结果只会打印出<code>&quot;1&quot;</code>。这也印证了开始的结论。有了这个结论，我们就可以利用它实现优雅的单例了。哈哈~😍</p><blockquote><p>👉怎么实现？</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerSingleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerSingletonInstance</span> </span>&#123; ❶</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerSingleton instance = <span class="keyword">new</span> StaticInnerSingleton();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerSingleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123; ❷</span><br><span class="line">        <span class="keyword">return</span> StaticInnerSingletonInstance.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>讲几个关注点：</p><ul><li>❶处<code>StaticInnerSingletonInstance</code>是一个静态内部类，内部静态字段<code>instance</code>负责创建对象。因为上面的结论，所以当外部类<code>StaticInnerSingleton</code>初始化时，并不会导致<code>StaticInnerSingletonInstance</code>初始化，进而导致<code>instance</code>的初始化。所以实现了<strong>延迟加载</strong>。</li><li>当外部调用❷处<code>getInstance()</code>时，通过<code>StaticInnerSingletonInstance.instance</code>对<code>instance</code>引用才会导致对象的创建。由于<code>static</code>的属性<strong>只会跟随类加载初始化一次，天然保证了线程安全问题</strong>。</li></ul><p>这个方案算是完美解决了上述所有方案的问题，且保留了所有的优点。算是一个完美方案。</p><p>还有没有其它方案？必须的！</p><h3 id="枚举实现"><a href="#枚举实现" class="headerlink" title="枚举实现"></a>枚举实现</h3><p>用枚举实现单例是最简单的了，因为，<strong>Java中的枚举类型本身就天然单例的</strong>.</p><blockquote><p>👉怎么实现？</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">EnumSingletonInstance</span></span>&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EnumSingletonInstance <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">       <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>唯一遗憾的是，这个方案和<strong>饿汉式</strong>一样，<strong>没法延迟加载</strong>。枚举类加载自然就会初始化<code>INSTANCE</code>。</p><p>常用的单例模式的方案基本就是这些。那这样是不是就真的万无一失了呢？很遗憾的告诉大家，上述这些方法还不是绝对能保证只创建一个对象。mmp……我擦，我就想玩个单例咋这么累呢？心塞……😭是的，上面的方案除了<strong>枚举方案</strong>，其余方案都可以被破解。下面我们来了解一下。</p><h2 id="破解单例"><a href="#破解单例" class="headerlink" title="破解单例"></a>破解单例</h2><p>破解单例有两种方法，<strong>反射</strong>或者<strong>反序列化</strong>。下面我用代码做简单演示。以饿汉式为例，其余模式同理，大家可以自行测试。</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><blockquote><p>👉怎么破解？</p></blockquote><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式的代码省略，参考前面饿汉式章节</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(HungrySingleton.getInstance());</span><br><span class="line">    System.out.println(HungrySingleton.getInstance());</span><br><span class="line">    System.out.println(<span class="string">&quot;反射破解单例...&quot;</span>);</span><br><span class="line">    HungrySingleton instance1 = HungrySingleton.class.newInstance();</span><br><span class="line">    HungrySingleton instance2 = HungrySingleton.class.newInstance();</span><br><span class="line">    System.out.println(instance1);</span><br><span class="line">    System.out.println(instance2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如图，很清楚的看到单例被破解了:<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A0%B4%E8%A7%A3%E5%8D%95%E4%BE%8B-%E5%8F%8D%E5%B0%84.png" alt="破解单例-反射"></p><blockquote><p>👉如何防止？</p></blockquote><p>很简单，因为<code>Class.newInstance()</code>是通过调用<code>HungrySingleton</code>无参构造器创建对象的，只要在构造器中加入有以下逻辑即可。这样，当类初始化时，第一次正常创建出实例并赋值给<code>instance</code>。当再想通过反射想要破解单例时，自然会抛出异常阻止继续实例化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式的其它代码，参考前面饿汉式章节</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">HungrySingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (instance != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Exception(<span class="string">&quot;只能创建一个对象！&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><blockquote><p>👉怎么破解？</p></blockquote><p>另外，通过<strong>序列化</strong>和<strong>反序列化</strong>也可以破解单例。（<strong>前提是单例类实现了Serializable接口</strong>）</p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    System.out.println(HungrySingleton.getInstance());</span><br><span class="line">    System.out.println(HungrySingleton.getInstance());</span><br><span class="line">    System.out.println(<span class="string">&quot;反序列化破解单例...&quot;</span>);</span><br><span class="line">    HungrySingleton instance1 = HungrySingleton.getInstance();</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(baos);</span><br><span class="line">    out.writeObject(instance1);<span class="comment">//序列化</span></span><br><span class="line">    ObjectInputStream ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray()));</span><br><span class="line">    HungrySingleton instance2 = (HungrySingleton) ois.readObject();<span class="comment">//反序列化</span></span><br><span class="line">    System.out.println(instance1);</span><br><span class="line">    System.out.println(instance2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果如图，很清楚的看到单例也被破解了:<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%A0%B4%E8%A7%A3%E5%8D%95%E4%BE%8B-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96.png" alt="破解单例-反序列化"></p><blockquote><p>👉如何防止？</p></blockquote><p>也非常简单，只需要在单例类中添加如下<code>readResolve()</code>方法，然后在方法体中返回我们的单例实例即可。为什么？因为<code>readResolve()</code>方法是在<code>readObject()</code>方法之后才被调用，因而它每次都会用我们自己生成的单实例替换从流中读取的对象。这样自然就保证了单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">readResolve</span><span class="params">()</span> <span class="keyword">throws</span> ObjectStreamException</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何选择"><a href="#如何选择" class="headerlink" title="如何选择"></a>如何选择</h2><p>关于单例模式的全部内容就是这些，最后来做个总结，那么这么多的单例模式实现方案我们到底需要选择哪个呢？技术选型从来不是非黑即白的问题，而是需要根据你的实际应用场景决定的。不过从上述各种单例模式的特点，我们可以得出以下结论：</p><ul><li>从<strong>安全性</strong>角度考虑，枚举显然是最安全的，保证绝对的单例，因为可以天然防止反射和反序列化的破解手段。而其它方案一定场合下全部可以被破解。</li><li>从<strong>延迟加载</strong>考虑，<strong>懒汉式</strong>、<strong>双重检测锁</strong>、<strong>静态内部类</strong>方案都可以实现，然而<strong>双重检测锁</strong>方案代码实现复杂，而且还有对JDK版本的要求，首先排除。<strong>懒汉式</strong>加锁性能较差，而<strong>静态内部类</strong>实现方法既能够延迟加载节约资源，另外也不需要加锁，性能较好，所以这方面考虑<strong>静态内部类</strong>方案最佳。<blockquote><p>👉一般选用原则：<br>&emsp;&emsp;单例对象占用资源少，不需要延时加载：枚举式好于饿汉式。<br>&emsp;&emsp;单例对象占用资源大，需要延时加载：静态内部类式好于懒汉式。</p></blockquote></li></ul><h2 id="抛砖引玉"><a href="#抛砖引玉" class="headerlink" title="抛砖引玉"></a>抛砖引玉</h2><p>前面也提到，单例模式在开源框架中被使用的非常之多，下面我就抛砖引玉挑选几处给大家讲解一下，</p><p>下面这个代码截取自<strong>Mybatis</strong>中，这是一个典型的使用<strong>静态内部类</strong>方式实现单例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">VFS</span> </span>&#123;</span><br><span class="line">  ... <span class="comment">//省略大量无关代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">VFSHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> VFS INSTANCE = createVFS();</span><br><span class="line">        <span class="function"><span class="keyword">static</span> VFS <span class="title">createVFS</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            ... <span class="comment">//省略创建过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">... <span class="comment">//省略大量无关代码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> VFS <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> VFSHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">  ... <span class="comment">//省略大量无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在JDK底层也是大量使用了单例模式，比如，<code>Runtime</code>类是JDK中表示Java运行时的环境的一个类，其内部实现也是采用单例模式，因为一个应用程序只需要一个运行时的环境即可，并且是采用<strong>饿汉式</strong>方式实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Runtime currentRuntime = <span class="keyword">new</span> Runtime();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Runtime <span class="title">getRuntime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentRuntime;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Runtime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最后啰嗦一句"><a href="#最后啰嗦一句" class="headerlink" title="最后啰嗦一句"></a>最后啰嗦一句</h2><p>在结束之前，我再多说一句，网上有些文章经常会用Spring的单例bean和Mybatis中的ErrorContext类作为单例模式的例子，其实这是有问题的。</p><ul><li>首先，Spring中的单例bean跟本文讲的单例模式并没有关系，不是一回事，可能也就名字比较像，这也是容易混淆的地方，实现方式当然也就天差地别了。Spring的单例bean是通过将指定类首次创建的bean进行缓存，后续去获取的时候，如果设置为<code>singleton</code>，就直接会从缓存中返回之前缓存的对象，而不会创建新对象。但是这个是有前提的，那就是在同一个容器中。如果在你的JVM中存在多个Spring容器，该类也就会创建多个实例了。所以这是不能算是真正的单例模式。本文上述描述的单例模式是指JVM进程级别的，也就是说，只要是在同一个JVM中，单例类只会存在一个对象。</li><li><code>Mybatis</code>中的ErrorContext类中采用的是ThreadLocal机制保证同一个线程跟唯一一个ErrorContext实例绑定，但是这个也是有前提的，那就是在线程范围内的，在每一个线程内部，确实做到了只创建一个实例，但是从应用级别或者JVM级别依然不是单例，所以不能将其称之为单例模式。</li></ul><blockquote><p>一言以蔽之，真正的单例模式，是指JVM进程级别的！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式|①开篇</title>
      <link href="/2019/11/23/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A0%E5%BC%80%E7%AF%87/"/>
      <url>/2019/11/23/GOF/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E2%91%A0%E5%BC%80%E7%AF%87/</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式到底是什么？"><a href="#设计模式到底是什么？" class="headerlink" title="设计模式到底是什么？"></a>设计模式到底是什么？</h2><ul><li>总结起来就一句话:<strong>设计模式</strong>就是一些过去技术的大师们总结出来的一系列<strong>写代码的套路</strong>。  </li><li>大佬们经过实践总结又将其这些套路分为三类：<strong>创建型</strong>、<strong>结构型</strong>、<strong>行为型</strong>。 <ul><li><strong>创建型模式</strong>，是为了创建对象使用的，至于为什么创建个对象（直接new一个不就完事了吗）还需要如此多不同的套路，后续你就知道，这边不赘述。</li><li><strong>结构性模式</strong>，是用来组织不同的小对象，从而变成更大更复杂结构的对象。</li><li><strong>行为型模式</strong>，是用来控制协调不同的对象的运行流程，因为实际开发场景下，不可能是孤零零一个对象在运行，会涉及多个对象交互，这中间的协调工作就会使用到行为型模式。</li></ul></li></ul><span id="more"></span><ul><li>每一类型的模式都包含多个<strong>具体模式</strong>，如下图(共23种设计模式)。后续每篇文章都会对其中一个模式做详解剖析，这边就不再赘述。<br><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png" alt="设计模式"></li></ul><h2 id="这些套路到底好在哪里？"><a href="#这些套路到底好在哪里？" class="headerlink" title="这些套路到底好在哪里？"></a>这些套路到底好在哪里？</h2><ul><li>很多人学设计模式觉得很难，很重要原因是，不知道这个模式到底好在哪里？解决了什么痛点？我能用它来干啥?所以只能生搬硬套。其实模仿也是无可厚非的，进步就是从模仿优秀者开始的。但是如果想要能驾驭一门知识，还是需要了解其本质的。</li><li>所以这边需要提一下一个跟设计模式紧密相关的概念——<strong>面向对象的七大设计原则</strong>。其实，如何评判一个设计模式好坏，就是用这七个原则来衡量的。这些原则有<strong>开闭原则</strong>、<strong>里氏替换原则</strong>、<strong>依赖倒置原则</strong>、<strong>单一职责原则</strong>、<strong>接口隔离原则</strong>、<strong>迪米特法则</strong>、<strong>组合聚合复用原则</strong>。还是比较抽象的，但是我这边就不展开了，大家也没必要去死记硬背这些原则，没意义。后续在讲到每个设计模式的优缺点时候，我会穿插提到这些设计原则，到时再做详解。</li></ul><h2 id="设计模式一定需要用吗？"><a href="#设计模式一定需要用吗？" class="headerlink" title="设计模式一定需要用吗？"></a>设计模式一定需要用吗？</h2><ul><li>这边先泼个冷水，这个设计模式系列你看完，你还真不一定能立刻用上，甚至有的时候你用了还是画蛇添足，会给应用带来一些不必要的问题和麻烦。尴尬……设计模式对不同层级的程序（应用层级、类库层级、框架层级）重要性不一样。设计模式更多可能会用在一些类库和框架的设计，或者对老项目重构，在业务逻辑开发中使用的比较少，甚至会引入不必要的复杂度。</li><li>当用则用，不合适，或者感觉没把握，千万不要强上！👀当你的开发受到阻碍，亟需一条出路，哎，这个时候设计模式可以登场了……</li></ul><h2 id="那这是为什么呢？"><a href="#那这是为什么呢？" class="headerlink" title="那这是为什么呢？"></a>那这是为什么呢？</h2><ul><li>因为像类库框架这类产品，会被不同的人大量重复使用，所以对其重用性、扩展性、灵活性有很高的要求。而对于普通的业务逻辑开发，这方面要求较低。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>项目中常用到的MySQL优化</title>
      <link href="/2019/11/20/database/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84MySQL%E4%BC%98%E5%8C%96/"/>
      <url>/2019/11/20/database/%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E5%88%B0%E7%9A%84MySQL%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h2 id="EXPLAIN"><a href="#EXPLAIN" class="headerlink" title="EXPLAIN"></a>EXPLAIN</h2><ul><li>做MySQL优化，我们要善用<code>EXPLAIN</code>查看SQL执行计划。</li><li>下面来个简单的示例，标注（1、2、3、4、5）我们要重点关注的数据：<br><img src="/images/database/EXPLAIN-Example.png" alt="EXPLAIN-Example"></li><li><a href="EXPLAIN%E5%AD%97%E6%AE%B5%E8%AF%B4%E6%98%8E.md">EXPLAIN字段说明</a></li><li><strong>type列</strong>:连接类型。一个好的SQL语句至少要达到range级别。杜绝出现all级别。</li><li><strong>key列</strong>:使用到的索引名。如果没有选择索引，值是NULL。可以采取强制索引方式。</li><li><strong>key_len列</strong>:索引长度。</li><li><strong>rows列</strong>:扫描行数。该值是个预估值。</li><li><strong>extra列</strong>:详细说明。注意，常见的不太友好的值，如下：Using filesort，Using temporary。</li></ul><h2 id="SQL语句中IN包含的值不应过多"><a href="#SQL语句中IN包含的值不应过多" class="headerlink" title="SQL语句中IN包含的值不应过多"></a>SQL语句中IN包含的值不应过多</h2><span id="more"></span><ul><li>MySQL对于IN做了相应的优化，即将IN中的常量全部存储在一个数组里面，而且这个数组是排好序的。但是如果数值较多，产生的消耗也是比较大的。再例如：<code>select id from t where num in(1,2,3)</code>对于连续的数值，能用<code>between</code>就不要用<code>in</code>了；再或者使用连接来替换。</li></ul><h2 id="SELECT语句务必指明字段名称"><a href="#SELECT语句务必指明字段名称" class="headerlink" title="SELECT语句务必指明字段名称"></a>SELECT语句务必指明字段名称</h2><ul><li><code>SELECT *</code>增加很多不必要的消耗（CPU、IO、内存、网络带宽）；增加了使用覆盖索引的可能性；当表结构发生改变时，前断也需要更新。所以要求直接在select后面接上字段名。</li></ul><h2 id="当只需要一条数据的时候，使用-limit-1"><a href="#当只需要一条数据的时候，使用-limit-1" class="headerlink" title="当只需要一条数据的时候，使用 limit 1"></a>当只需要一条数据的时候，使用 limit 1</h2><ul><li>这是为了使<code>EXPLAIN</code>中type列达到const类型</li></ul><h2 id="如果排序字段没有用到索引，就尽量少排序"><a href="#如果排序字段没有用到索引，就尽量少排序" class="headerlink" title="如果排序字段没有用到索引，就尽量少排序"></a>如果排序字段没有用到索引，就尽量少排序</h2><h2 id="如果限制条件中其他字段没有索引，尽量少用or"><a href="#如果限制条件中其他字段没有索引，尽量少用or" class="headerlink" title="如果限制条件中其他字段没有索引，尽量少用or"></a>如果限制条件中其他字段没有索引，尽量少用or</h2><ul><li>or两边的字段中，如果有一个不是索引字段，而其他条件也不是索引字段，会造成该查询不走索引的情况。很多时候使用union all或者是union（必要的时候）的方式来代替“or”会得到更好的效果。</li></ul><h2 id="尽量用union-all代替union"><a href="#尽量用union-all代替union" class="headerlink" title="尽量用union all代替union"></a>尽量用union all代替union</h2><ul><li><code>union</code>和<code>union all</code>的差异主要是前者需要将结果集合并后再进行唯一性过滤操作，这就会涉及到排序，增加大量的CPU运算，加大资源消耗及延迟。当然，union all的前提条件是两个结果集没有重复数据。</li></ul><h2 id="不使用ORDER-BY-RAND"><a href="#不使用ORDER-BY-RAND" class="headerlink" title="不使用ORDER BY RAND()"></a>不使用ORDER BY RAND()</h2><ul><li><code>select id from </code>dynamic<code> order by rand() limit 1000;</code></li><li>上面的SQL语句，可优化为：<br><code>select id from </code>dynamic<code>t1 join (select rand() * (select max(id) from</code>dynamic<code>) as nid) t2 on t1.id &gt; t2.nid limit 1000;</code></li></ul><h2 id="区分in和exists、not-in和not-exists"><a href="#区分in和exists、not-in和not-exists" class="headerlink" title="区分in和exists、not in和not exists"></a>区分in和exists、not in和not exists</h2><ul><li><code>select * from 表A where id in (select id from 表B)</code></li><li>上面SQL语句相当于:</li><li><code>select * from 表A where exists(select * from 表B where 表B.id=表A.id)</code></li><li>区分<code>in</code>和<code>exists</code>主要是造成了驱动顺序的改变（这是性能变化的关键），如果是<code>exists</code>，那么以外层表为驱动表，先被访问，如果是IN，那么先执行子查询。<ul><li>所以<code>IN</code>适合于外表大而内表小的情况；</li><li><code>EXISTS</code>适合于外表小而内表大的情况。</li></ul></li><li>关于<code>not in</code>和<code>not exists</code>，推荐使用<code>not exists</code>，不仅仅是效率问题，<code>not in</code>可能存在逻辑问题。如何高效的写出一个替代not exists的SQL语句？</li><li>原SQL语句：<ul><li><code>select colname … from A表 where a.id not in (select b.id from B表)</code></li></ul></li><li>高效的SQL语句：<ul><li><code>select colname … from A表 Left join B表 on where a.id = b.id where b.id is null</code></li></ul></li><li>取出的结果集如下图表示，A表不在B表中的数据：<br><img src="/images/database/not_in.png" alt="not in"></li></ul><h2 id="使用合理的分页方式以提高分页的效率"><a href="#使用合理的分页方式以提高分页的效率" class="headerlink" title="使用合理的分页方式以提高分页的效率"></a>使用合理的分页方式以提高分页的效率</h2><ul><li><code>select id,name from product limit 866613, 20</code></li><li>使用上述SQL语句做分页的时候，可能有人会发现，随着表数据量的增加，直接使用limit分页查询会越来越慢。</li><li>优化的方法如下：可以取前一页的最大行数的id，然后根据这个最大的id来限制下一页的起点。比如此列中，上一页最大的id是866612。SQL可以采用如下的写法：</li><li><code>select id,name from product where id&gt; 866612 limit 20</code></li></ul><h2 id="分段查询"><a href="#分段查询" class="headerlink" title="分段查询"></a>分段查询</h2><ul><li>在一些用户选择页面中，可能一些用户选择的时间范围过大，造成查询缓慢。主要的原因是扫描行数过多。这个时候可以通过程序，分段进行查询，循环遍历，将结果合并处理进行展示。</li></ul><h2 id="避免在where子句中对字段进行null值判断"><a href="#避免在where子句中对字段进行null值判断" class="headerlink" title="避免在where子句中对字段进行null值判断"></a>避免在where子句中对字段进行null值判断</h2><ul><li>对于null的判断会导致引擎放弃使用索引而进行全表扫描。</li></ul><h2 id="不建议使用-前缀模糊查询"><a href="#不建议使用-前缀模糊查询" class="headerlink" title="不建议使用%前缀模糊查询"></a>不建议使用%前缀模糊查询</h2><ul><li>例如<code>LIKE &#39;%name&#39;</code>或者<code>LIKE &#39;%name%&#39;</code>，这种查询会导致索引失效而进行全表扫描。但是可以使用<code>LIKE &#39;name%&#39;</code>。</li><li>那如何查询%name%？</li><li>答案：使用全文索引。</li><li>在我们查询中经常会用到<code>select id,num from &lt;table_name&gt; where name like &#39;%zhangsan%&#39;;</code>。这样的语句，普通索引是无法满足查询需求的。庆幸的是在MySQL中，有全文索引来帮助我们。</li><li>创建全文索引的SQL语法是：<br><code>ALTER TABLE &lt;table_name&gt; ADD FULLTEXT INDEX </code>idx_name<code> (</code>name<code>);</code></li><li>使用全文索引的SQL语句是：<br><code>select id,num from &lt;table_name&gt; where match(name) against(&#39;zhangsan&#39; in boolean mode);</code></li><li>注意：在需要创建全文索引之前，请联系DBA确定能否创建。同时需要注意的是查询语句的写法与普通索引的区别。</li></ul><h2 id="避免在where子句中对字段进行表达式操作"><a href="#避免在where子句中对字段进行表达式操作" class="headerlink" title="避免在where子句中对字段进行表达式操作"></a>避免在where子句中对字段进行表达式操作</h2><ul><li>比如：<br><code>select user_id,user_project from user_base where age*2=36;</code></li><li>中对字段就行了算术运算，这会造成引擎放弃使用索引，建议改成：<br><code>select user_id,user_project from user_base where age=36/2;</code></li></ul><h2 id="避免隐式类型转换"><a href="#避免隐式类型转换" class="headerlink" title="避免隐式类型转换"></a>避免隐式类型转换</h2><ul><li>where子句中出现column字段的类型和传入的参数类型不一致的时候发生的类型转换，建议先确定where中的参数类型。</li></ul><h2 id="对于联合索引来说，要遵守最左前缀法则"><a href="#对于联合索引来说，要遵守最左前缀法则" class="headerlink" title="对于联合索引来说，要遵守最左前缀法则"></a>对于联合索引来说，要遵守最左前缀法则</h2><ul><li>举列来说索引含有字段id、name、school，可以直接用id字段，也可以id、name这样的顺序，但是name;school都无法使用这个索引。所以在创建联合索引的时候一定要注意索引字段顺序，常用的查询字段放在最前面。</li></ul><h2 id="必要时可以使用force-index来强制查询走某个索引"><a href="#必要时可以使用force-index来强制查询走某个索引" class="headerlink" title="必要时可以使用force index来强制查询走某个索引"></a>必要时可以使用force index来强制查询走某个索引</h2><ul><li>有的时候MySQL优化器采取它认为合适的索引来检索SQL语句，但是可能它所采用的索引并不是我们想要的。这时就可以采用<code>force index</code>来强制优化器使用我们制定的索引。</li></ul><h2 id="注意范围查询语句"><a href="#注意范围查询语句" class="headerlink" title="注意范围查询语句"></a>注意范围查询语句</h2><ul><li>对于联合索引来说，如果存在范围查询，比如between、&gt;、&lt;等条件时，会造成后面的索引字段失效。</li></ul><h2 id="关于JOIN优化"><a href="#关于JOIN优化" class="headerlink" title="关于JOIN优化"></a>关于JOIN优化</h2><p><img src="/images/database/join.png" alt="join"></p><ul><li><code>LEFT JOIN</code>:A表为驱动表.</li><li><code>INNER JOIN</code>:MySQL会自动找出那个数据少的表作用驱动表.</li><li><code>RIGHT JOIN</code>:B表为驱动表.</li><li>注意：<ul><li>MySQL中没有<code>full join</code>，可以用以下方式来解决：<br><code>select * from A left join B on B.name = A.namewhere B.name is null union all select * from B;</code></li><li>尽量使用<code>inner join</code>，避免<code>left join</code>：<ul><li>参与联合查询的表至少为2张表，一般都存在大小之分。如果连接方式是<code>inner join</code>，在没有其他过滤条件的情况下MySQL会自动选择小表作为驱动表，但是<code>left join</code>在驱动表的选择上遵循的是左边驱动右边的原则，即<code>left join</code>左边的表名为驱动表。</li></ul></li><li>合理利用索引：<ul><li>被驱动表的索引字段作为on的限制字段。</li></ul></li><li>利用小表去驱动大表：</li><li>巧用<code>STRAIGHT_JOIN</code>：<ul><li><code>inner join</code>是由MySQL选择驱动表，但是有些特殊情况需要选择另个表作为驱动表，比如有group by、order by等「Using filesort」、「Using temporary」时。<code>STRAIGHT_JOIN</code>来强制连接顺序，在<code>STRAIGHT_JOIN</code>左边的表名就是驱动表，右边则是被驱动表。在使用STRAIGHT_JOIN有个前提条件是该查询是内连接，也就是<code>inner join</code>。其他链接不推荐使用STRAIGHT_JOIN，否则可能造成查询结果不准确。</li><li>这个方式有时能减少3倍的时间。</li></ul></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>工作中能用到的Git命令大全</title>
      <link href="/2019/11/19/git/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E8%83%BD%E7%94%A8%E5%88%B0%E7%9A%84Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/"/>
      <url>/2019/11/19/git/%E5%B7%A5%E4%BD%9C%E4%B8%AD%E8%83%BD%E7%94%A8%E5%88%B0%E7%9A%84Git%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><ul><li><code>git branch</code>:创建分支</li><li><code>git branch -b</code>:创建并切换到新建的分支上</li><li><code>git checkout</code>:切换分支</li><li><code>git branch</code>:查看分支列表</li><li><code>git branch -v</code>:查看所有分支的最后一次操作</li><li><code>git branch -vv</code>:查看当前分支</li></ul><span id="more"></span><ul><li><code>git brabch -b 分支名 origin/分支名</code>:创建远程分支到本地</li><li><code>git branch --merged</code>:查看别的分支和当前分支合并过的分支</li><li><code>git branch --no-merged</code>:查看未与当前分支合并的分支</li><li><code>git branch -d 分支名</code>:删除本地分支</li><li><code>git branch -D 分支名</code>:强行删除分支</li><li><code>git branch origin :分支名</code>:删除远处仓库分支</li><li><code>git merge 分支名</code>:合并分支到当前分支上</li></ul><h2 id="暂存操作"><a href="#暂存操作" class="headerlink" title="暂存操作"></a>暂存操作</h2><ul><li><code>git stash</code>:暂存当前修改</li><li><code>git stash apply</code>:恢复最近的一次暂存</li><li><code>git stash pop</code>:恢复暂存并删除暂存记录</li><li><code>git stash list</code>:查看暂存列表</li><li><code>git stash drop 暂存名(例：stash@&#123;0&#125;)</code>:移除某次暂存</li><li><code>git stash clear</code>:清除暂存</li></ul><h2 id="回退操作"><a href="#回退操作" class="headerlink" title="回退操作"></a>回退操作</h2><ul><li><code>git reset --hard HEAD^</code>:回退到上一个版本</li><li><code>git reset --hard ahdhs1(commit_id)</code>:回退到某个版本</li><li><code>git checkout -- file</code>:撤销修改的文件(如果文件加入到了暂存区，则回退到暂存区的，如果文件加入到了版本库，则还原至加入版本库之后的状态)</li><li><code>git reset HEAD file</code>:撤回暂存区的文件修改到工作区</li></ul><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><ul><li><code>git tag 标签名</code>:添加标签(默认对当前版本)</li><li><code>git tag 标签名 commit_id</code>:对某一提交记录打标签</li><li><code>git tag -a 标签名 -m &#39;描述&#39;</code>:创建新标签并增加备注</li><li><code>git tag</code>:列出所有标签列表</li><li><code>git show 标签名</code>:查看标签信息</li><li><code>git tag -d 标签名</code>:删除本地标签</li><li><code>git push origin 标签名</code>:推送标签到远程仓库</li><li><code>git push origin --tags</code>:推送所有标签到远程仓库</li><li><code>git push origin :refs/tags/标签名</code>:从远程仓库中删除标签</li></ul><h2 id="常规操作"><a href="#常规操作" class="headerlink" title="常规操作"></a>常规操作</h2><ul><li><code>git push origin test</code>:推送本地分支到远程仓库</li><li><code>git rm -r --cached</code>:文件/文件夹名字 取消文件被版本控制</li><li><code>git reflog</code>:获取执行过的命令</li><li><code>git log --graph</code>:查看分支合并图</li><li><code>git merge --no-ff -m &#39;合并描述&#39; 分支名</code>:不使用Fast forward方式合并，采用这种方式合并可以看到合并记录</li><li><code>git check-ignore -v 文件名</code>:查看忽略规则</li><li><code>git add -f 文件名</code>:强制将文件提交</li></ul><h2 id="Git创建项目仓库"><a href="#Git创建项目仓库" class="headerlink" title="Git创建项目仓库"></a>Git创建项目仓库</h2><ul><li><code>git init</code>:初始化</li><li><code>git remote add origin url</code>:关联远程仓库</li><li><code>git pull</code>:拉取文件</li><li><code>git fetch</code>:获取远程仓库中所有的分支到本地</li></ul><h2 id="忽略已加入到版本库中的文件"><a href="#忽略已加入到版本库中的文件" class="headerlink" title="忽略已加入到版本库中的文件"></a>忽略已加入到版本库中的文件</h2><ul><li><code>git update-index --assume-unchanged file</code>:忽略单个文件</li><li><code>git rm -r --cached 文件/文件夹名字 (. 忽略全部文件)</code>:</li></ul><h2 id="取消忽略文件"><a href="#取消忽略文件" class="headerlink" title="取消忽略文件"></a>取消忽略文件</h2><ul><li><code>git update-index --no-assume-unchanged file</code>:</li></ul><h2 id="拉取、上传免密码"><a href="#拉取、上传免密码" class="headerlink" title="拉取、上传免密码"></a>拉取、上传免密码</h2><ul><li><code>git config --global credential.helper store</code>:</li></ul>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArrayList集合为什么不能使用foreach增删改</title>
      <link href="/2019/11/18/ArrayList%E9%9B%86%E5%90%88%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8foreach%E5%A2%9E%E5%88%A0%E6%94%B9/"/>
      <url>/2019/11/18/ArrayList%E9%9B%86%E5%90%88%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E4%BD%BF%E7%94%A8foreach%E5%A2%9E%E5%88%A0%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<h2 id="导语"><a href="#导语" class="headerlink" title="导语"></a>导语</h2><ul><li>编程过程中常常需要使用到集合，而ArrayList也是我们常常使用的，但是最近在一次删除和增加中出现了一些问题，分享记录下。  </li><li>请看下面两段代码，哪段代码会报错呢，或者都成功呢。</li></ul><span id="more"></span><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList1 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList1.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">arrayList1.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : arrayList1) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(s)) &#123;</span><br><span class="line">        arrayList1.remove(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; arrayList2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList2.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">arrayList2.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (String s : arrayList2) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(s)) &#123;</span><br><span class="line">        arrayList2.remove(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序运行结果如下：</p><blockquote><p>arrayList1的remove方法成功执行，但是arrayList2的remove方法运行抛出ConcurrentModificationException异常。</p></blockquote><h2 id="寻找原因"><a href="#寻找原因" class="headerlink" title="寻找原因"></a>寻找原因</h2><ul><li><p>为了寻找原因，我们只能看源代码了。<br>因为foreach的本质就是使用的迭代器<strong>Iterator</strong>,所有的Collection集合类都会实现Iterable接口。  </p></li><li><p>找到ArrayList类的iterator()方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* Returns an iterator over the elements in this list in proper sequence.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* &lt;p&gt;The returned iterator is &lt;a href=&quot;#fail-fast&quot;&gt;&lt;i&gt;fail-fast&lt;/i&gt;&lt;/a&gt;.</span></span><br><span class="line"><span class="comment">*</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> an iterator over the elements in this list in proper sequence</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>ArrayList使用自己的Itr内部类，并且实现了Iterator接口</p></blockquote></li><li><p>迭代器的本质是先调用<code>hasNext()</code>方法判断存不存在下一个元素，然后再使用<code>next()</code>方法取下一个元素  </p></li><li><p><code>ArrayList</code>的内部类<code>Itr</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">    <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such</span></span><br><span class="line">    <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">    Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@SuppressWarnings(&quot;unchecked&quot;)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        checkForComodification();</span><br><span class="line">        <span class="keyword">int</span> i = cursor;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        cursor = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">    &#125;</span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>上面arraylist1为什么能remove成功呢，其实它只<strong>循环了一次</strong>，所以成功了。  </p></li><li><p>因为它在remove元素1之后，它的size - 1变成1，然后Itr内部的cursor变量由0变成1<br>此时1 = 1，循环结束，所以成功了。  </p></li><li><p>arraylist2为什么remove失败呢，因为他在循环第二次的时候，也remove成功了，但是第三次判断next的时候cursor的值为2导致不等于现在的size 1,所以执行了next方法，最重要的来了，之前remove的操作导致ArrayList的modCount值加1，然后Itr类中的expectedModCount保持不变，所以会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">checkForComodification</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (modCount != expectedModCount)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同理可得，由于add操作也会导致modCount自增，所以不允许在foreach中删除、增加、修改ArrayList中的元素。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>对此，推荐大家使用迭代器Iterator删除元素：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; arrayList2 = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">arrayList2.add(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">arrayList2.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">Iterator&lt;String&gt; iterator = arrayList2.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">    String item = iterator.next();</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">&quot;1&quot;</span>.equals(item)) &#123;</span><br><span class="line">        iterator.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>如果存在并发操作，还需要对Iterator进行加锁操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mysql错误码大全</title>
      <link href="/2019/11/13/database/mysql%E9%94%99%E8%AF%AF%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
      <url>/2019/11/13/database/mysql%E9%94%99%E8%AF%AF%E7%A0%81%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql错误码大全"><a href="#mysql错误码大全" class="headerlink" title="mysql错误码大全"></a>mysql错误码大全</h1><ul><li>错误消息信息列在share/errmsg.txt文件中。“%d”和“%s”分别代表编号和字符串，显示时，它们将被消息值取代。</li><li>错误值列在share/errmsg.txt文件中，用于生成include/mysqld_error.h和include/mysqld_ername.h MySQL源文件中的定义。</li><li>SQLSTATE值列在share/errmsg.txt文件中，用于生成include/sql_state.h MySQL源文件中的定义。<br>由于更新很频繁，这些文件中可能包含这里未列出的额外错误消息。</li><li>错误：1000 SQLSTATE: HY000 (ER_HASHCHK)<ul><li>消息：hashchk</li></ul></li><li>错误：1001 SQLSTATE: HY000 (ER_NISAMCHK)<ul><li>消息：isamchk</li></ul></li></ul><span id="more"></span><ul><li>错误：1002 SQLSTATE: HY000 (ER_NO)<ul><li>消息：NO</li></ul></li><li>错误：1003 SQLSTATE: HY000 (ER_YES)<ul><li>消息：YES</li></ul></li><li>错误：1004 SQLSTATE: HY000 (ER_CANT_CREATE_FILE)<ul><li>消息：无法创建文件’%s’ (errno: %d)</li></ul></li><li>错误：1005 SQLSTATE: HY000 (ER_CANT_CREATE_TABLE)<ul><li>消息：无法创建表’%s’ (errno: %d)</li></ul></li><li>错误：1006 SQLSTATE: HY000 (ER_CANT_CREATE_DB)<ul><li>消息：无法创建数据库’%s’ (errno: %d)</li></ul></li><li>错误：1007 SQLSTATE: HY000 (ER_DB_CREATE_EXISTS)<ul><li>消息：无法创建数据库’%s’，数据库已存在。</li></ul></li><li>错误：1008 SQLSTATE: HY000 (ER_DB_DROP_EXISTS)<ul><li>消息：无法撤销数据库’%s’，数据库不存在。</li></ul></li><li>错误：1009 SQLSTATE: HY000 (ER_DB_DROP_DELETE)<ul><li>消息：撤销数据库时出错（无法删除’%s’，errno: %d）</li></ul></li><li>错误：1010 SQLSTATE: HY000 (ER_DB_DROP_RMDIR)<ul><li>消息：撤销数据库时出错（can’t rmdir ‘%s’, errno: %d）</li></ul></li><li>错误：1011 SQLSTATE: HY000 (ER_CANT_DELETE_FILE)<ul><li>消息：删除’%s’时出错 (errno: %d)</li></ul></li><li>错误：1012 SQLSTATE: HY000 (ER_CANT_FIND_SYSTEM_REC)<ul><li>消息：无法读取系统表中的记录。</li></ul></li><li>错误：1013 SQLSTATE: HY000 (ER_CANT_GET_STAT)<ul><li>消息：无法获取’%s’的状态(errno: %d)</li></ul></li><li>错误：1014 SQLSTATE: HY000 (ER_CANT_GET_WD)<ul><li>消息：无法获得工作目录(errno: %d)</li></ul></li><li>错误：1015 SQLSTATE: HY000 (ER_CANT_LOCK)<ul><li>消息：无法锁定文件(errno: %d)</li></ul></li><li>错误：1016 SQLSTATE: HY000 (ER_CANT_OPEN_FILE)<ul><li>消息：无法打开文件：’%s’ (errno: %d)</li></ul></li><li>错误：1017 SQLSTATE: HY000 (ER_FILE_NOT_FOUND)<ul><li>消息：无法找到文件： ‘%s’ (errno: %d)</li></ul></li><li>错误：1018 SQLSTATE: HY000 (ER_CANT_READ_DIR)<ul><li>消息：无法读取’%s’的目录 (errno: %d)</li></ul></li><li>错误：1019 SQLSTATE: HY000 (ER_CANT_SET_WD)<ul><li>消息：无法为’%s’更改目录 (errno: %d)</li></ul></li><li>错误：1020 SQLSTATE: HY000 (ER_CHECKREAD)<ul><li>消息：自上次读取以来表’%s’中的记录已改变。</li></ul></li><li>错误：1021 SQLSTATE: HY000 (ER_DISK_FULL)<ul><li>消息：磁盘满(%s)；等待某人释放一些空间…</li></ul></li><li>错误：1022 SQLSTATE: 23000 (ER_DUP_KEY)<ul><li>消息：无法写入；复制表’%s’的 键。</li></ul></li><li>错误：1023 SQLSTATE: HY000 (ER_ERROR_ON_CLOSE)<ul><li>消息：关闭’%s’时出错 (errno: %d)</li></ul></li><li>错误：1024 SQLSTATE: HY000 (ER_ERROR_ON_READ)<ul><li>消息：读取文件’%s’时出错 (errno: %d)</li></ul></li><li>错误：1025 SQLSTATE: HY000 (ER_ERROR_ON_RENAME)<ul><li>消息：将’%s’重命名为’%s’时出错 (errno: %d)</li></ul></li><li>错误：1026 SQLSTATE: HY000 (ER_ERROR_ON_WRITE)<ul><li>消息：写入文件’%s’时出错 (errno: %d)</li></ul></li><li>错误：1027 SQLSTATE: HY000 (ER_FILE_USED)<ul><li>消息：’%s’已锁定，拒绝更改。</li></ul></li><li>错误：1028 SQLSTATE: HY000 (ER_FILSORT_ABORT)<ul><li>消息：分类失败</li></ul></li><li>错误：1029 SQLSTATE: HY000 (ER_FORM_NOT_FOUND)<ul><li>消息：对于’%s’，视图’%s’不存在。</li></ul></li><li>错误：1030 SQLSTATE: HY000 (ER_GET_ERRNO)<ul><li>消息：从存储引擎中获得错误%d。</li></ul></li><li>错误：1031 SQLSTATE: HY000 (ER_ILLEGAL_HA)<ul><li>消息：关于’%s’的表存储引擎不含该选项。</li></ul></li><li>错误：1032 SQLSTATE: HY000 (ER_KEY_NOT_FOUND)<ul><li>消息：无法在’%s’中找到记录。</li></ul></li><li>错误：1033 SQLSTATE: HY000 (ER_NOT_FORM_FILE)<ul><li>消息：文件中的不正确信息：’%s’</li></ul></li><li>错误：1034 SQLSTATE: HY000 (ER_NOT_KEYFILE)<ul><li>消息：对于表’%s’， 键文件不正确，请尝试修复。</li></ul></li><li>错误：1035 SQLSTATE: HY000 (ER_OLD_KEYFILE)<ul><li>消息：旧的键文件，对于表’%s’，请修复之！</li></ul></li><li>错误：1036 SQLSTATE: HY000 (ER_OPEN_AS_READONLY)<ul><li>消息：表’%s’是只读的。</li></ul></li><li>错误：1037 SQLSTATE: HY001 (ER_OUTOFMEMORY)<ul><li>消息：内存溢出，重启服务器并再次尝试（需要%d字节）。</li></ul></li><li>错误：1038 SQLSTATE: HY001 (ER_OUT_OF_SORTMEMORY)<ul><li>消息：分类内存溢出，增加服务器的分类缓冲区大小。</li></ul></li><li>错误：1039 SQLSTATE: HY000 (ER_UNEXPECTED_EOF)<ul><li>消息：读取文件’%s’时出现意外EOF (errno: %d)</li></ul></li><li>错误：1040 SQLSTATE: 08004 (ER_CON_COUNT_ERROR)<ul><li>消息：连接过多。</li></ul></li><li>错误：1041 SQLSTATE: HY000 (ER_OUT_OF_RESOURCES)<ul><li>消息：内存溢出，请检查是否mysqld或其他进程使用了所有可用内存，如不然，或许应使用’ulimit’允许mysqld使用更多内存，或增加交换空间的大小。</li></ul></li><li>错误：1042 SQLSTATE: 08S01 (ER_BAD_HOST_ERROR)<ul><li>消息：无法获得该地址给出的主机名。</li></ul></li><li>错误：1043 SQLSTATE: 08S01 (ER_HANDSHAKE_ERROR)<ul><li>消息：不良握手</li></ul></li><li>错误：1044 SQLSTATE: 42000 (ER_DBACCESS_DENIED_ERROR)<ul><li>消息：拒绝用户‘%s‘@’%s’访问数据库’%s’。</li></ul></li><li>错误：1045 SQLSTATE: 28000 (ER_ACCESS_DENIED_ERROR)<ul><li>消息：拒绝用户‘%s‘@’%s’的访问（使用密码：%s）</li></ul></li><li>错误：1046 SQLSTATE: 3D000 (ER_NO_DB_ERROR)<ul><li>消息：未选择数据库。</li></ul></li><li>错误：1047 SQLSTATE: 08S01 (ER_UNKNOWN_COM_ERROR)<ul><li>消息：未知命令。</li></ul></li><li>错误：1048 SQLSTATE: 23000 (ER_BAD_NULL_ERROR)<ul><li>消息：列’%s’不能为空。</li></ul></li><li>错误：1049 SQLSTATE: 42000 (ER_BAD_DB_ERROR)<ul><li>消息：未知数据库’%s’。</li></ul></li><li>错误：1050 SQLSTATE: 42S01 (ER_TABLE_EXISTS_ERROR)<ul><li>消息：表’%s’已存在。</li></ul></li><li>错误：1051 SQLSTATE: 42S02 (ER_BAD_TABLE_ERROR)<ul><li>消息：未知表’%s’。</li></ul></li><li>错误：1052 SQLSTATE: 23000 (ER_NON_UNIQ_ERROR)<ul><li>消息：%s中的列’%s’不明确。</li></ul></li><li>错误：1053 SQLSTATE: 08S01 (ER_SERVER_SHUTDOWN)<ul><li>消息：在操作过程中服务器关闭。</li></ul></li><li>错误：1054 SQLSTATE: 42S22 (ER_BAD_FIELD_ERROR)<ul><li>消息：’%s’中的未知列’%s’。</li></ul></li><li>错误：1055 SQLSTATE: 42000 (ER_WRONG_FIELD_WITH_GROUP)<ul><li>消息：’%s’不在GROUP BY中。</li></ul></li><li>错误：1056 SQLSTATE: 42000 (ER_WRONG_GROUP_FIELD)<ul><li>消息：无法在’%s’上创建组。</li></ul></li><li>错误：1057 SQLSTATE: 42000 (ER_WRONG_SUM_SELECT)<ul><li>消息：语句中有sum函数和相同语句中的列。</li></ul></li><li>错误：1058 SQLSTATE: 21S01 (ER_WRONG_VALUE_COUNT)<ul><li>消息：列计数不匹配值计数。</li></ul></li><li>错误：1059 SQLSTATE: 42000 (ER_TOO_LONG_IDENT)<ul><li>消息：ID名称’%s’过长。</li></ul></li><li>错误：1060 SQLSTATE: 42S21 (ER_DUP_FIELDNAME)<ul><li>消息：重复列名’%s’。</li></ul></li><li>错误：1061 SQLSTATE: 42000 (ER_DUP_KEYNAME)<ul><li>消息：重复键名称’%s’。</li></ul></li><li>错误：1062 SQLSTATE: 23000 (ER_DUP_ENTRY)<ul><li>消息：键%d的重复条目’%s’。</li></ul></li><li>错误：1063 SQLSTATE: 42000 (ER_WRONG_FIELD_SPEC)<ul><li>消息：对于列’%s’，列分类符不正确。</li></ul></li><li>错误：1064 SQLSTATE: 42000 (ER_PARSE_ERROR)<ul><li>消息：在行%d上，%s靠近’%s’。</li></ul></li><li>错误：1065 SQLSTATE: 42000 (ER_EMPTY_QUERY)<ul><li>消息：查询为空。</li></ul></li><li>错误：1066 SQLSTATE: 42000 (ER_NONUNIQ_TABLE)<ul><li>消息：非唯一的表/别名：’%s’</li></ul></li><li>错误：1067 SQLSTATE: 42000 (ER_INVALID_DEFAULT)<ul><li>消息：关于’%s’的无效默认值。</li></ul></li><li>错误：1068 SQLSTATE: 42000 (ER_MULTIPLE_PRI_KEY)<ul><li>消息：定义了多个主键。</li></ul></li><li>错误：1069 SQLSTATE: 42000 (ER_TOO_MANY_KEYS)<ul><li>消息：指定了过多键：允许的最大键数是%d。</li></ul></li><li>错误：1070 SQLSTATE: 42000 (ER_TOO_MANY_KEY_PARTS)<ul><li>消息：指定了过多键部分：允许的最大键部分是%d。</li></ul></li><li>错误：1071 SQLSTATE: 42000 (ER_TOO_LONG_KEY)<ul><li>消息：指定的键过长，最大键长度是%d字节。</li></ul></li><li>错误：1072 SQLSTATE: 42000 (ER_KEY_COLUMN_DOES_NOT_EXITS)<ul><li>消息：键列’%s’在表中不存在。</li></ul></li><li>错误：1073 SQLSTATE: 42000 (ER_BLOB_USED_AS_KEY)<ul><li>消息：BLOB列’%s’不能与已使用的表类型用在 键说明中。</li></ul></li><li>错误：1074 SQLSTATE: 42000 (ER_TOO_BIG_FIELDLENGTH)<ul><li>消息：对于列’%s’，列长度过大 (max = %d)，请使用BLOB或TEXT取而代之。</li></ul></li><li>错误：1075 SQLSTATE: 42000 (ER_WRONG_AUTO_KEY)<ul><li>消息：不正确的表定义，只能有1个auto列，而且必须将其定义为 键。</li></ul></li><li>错误：1076 SQLSTATE: HY000 (ER_READY)<ul><li>消息：%s，连接就绪。版本：’%s’，套接字：’%s’，端口：%d</li></ul></li><li>错误：1077 SQLSTATE: HY000 (ER_NORMAL_SHUTDOWN)<ul><li>消息：%s，正常关闭。</li></ul></li><li>错误：1078 SQLSTATE: HY000 (ER_GOT_SIGNAL)<ul><li>消息：%s，获得信号%d。放弃！</li></ul></li><li>错误：1079 SQLSTATE: HY000 (ER_SHUTDOWN_COMPLETE)<ul><li>消息：%s，关闭完成</li></ul></li><li>错误：1080 SQLSTATE: 08S01 (ER_FORCING_CLOSE)<ul><li>消息：%s，强制关闭线程%ld，用户：’%s’</li></ul></li><li>错误：1081 SQLSTATE: 08S01 (ER_IPSOCK_ERROR)<ul><li>消息：无法创建IP套接字</li></ul></li><li>错误：1082 SQLSTATE: 42S12 (ER_NO_SUCH_INDEX)<ul><li>消息：表’%s’中没有与CREATE INDEX中索引类似的索引，重新创建表。</li></ul></li><li>错误：1083 SQLSTATE: 42000 (ER_WRONG_FIELD_TERMINATORS)<ul><li>消息：字段分隔符参量不是预期的，请参考手册。</li></ul></li><li>错误：1084 SQLSTATE: 42000 (ER_BLOBS_AND_NO_TERMINATED)<ul><li>消息：不能与BLOB一起使用固定行长度，请使用’fields terminated by’。</li></ul></li><li>错误：1085 SQLSTATE: HY000 (ER_TEXTFILE_NOT_READABLE)<ul><li>消息：文件’%s’必须在数据库目录下，或能被所有人读取。</li></ul></li><li>错误：1086 SQLSTATE: HY000 (ER_FILE_EXISTS_ERROR)<ul><li>消息：文件’%s’已存在。</li></ul></li><li>错误：1087 SQLSTATE: HY000 (ER_LOAD_INFO)<ul><li>消息：记录，%ld；已删除，%ld；已跳过，%ld；警告，%ld</li></ul></li><li>错误：1088 SQLSTATE: HY000 (ER_ALTER_INFO)<ul><li>消息：记录，%ld；重复，%ld</li></ul></li><li>错误：1089 SQLSTATE: HY000 (ER_WRONG_SUB_KEY)<ul><li>消息：不正确的子部分键，使用的键部分不是字符串，所用的长度长于键部分，或存储引擎不支持唯一子键。</li></ul></li><li>错误：1090 SQLSTATE: 42000 (ER_CANT_REMOVE_ALL_FIELDS)<ul><li>消息：不能用ALTER TABLE删除所有列，请使用DROP TABLE取而代之。</li></ul></li><li>错误：1091 SQLSTATE: 42000 (ER_CANT_DROP_FIELD_OR_KEY)<ul><li>消息：不能撤销’%s’，请检查列/键是否存在。</li></ul></li><li>错误：1092 SQLSTATE: HY000 (ER_INSERT_INFO)<ul><li>消息：记录，%ld；复制，%ld；告警，%ld</li></ul></li><li>错误：1093 SQLSTATE: HY000 (ER_UPDATE_TABLE_USED)<ul><li>消息：不能在FROM子句中制定要更新的目标表’%s’。</li></ul></li><li>错误：1094 SQLSTATE: HY000 (ER_NO_SUCH_THREAD)<ul><li>消息：未知线程ID：%lu</li></ul></li><li>错误：1095 SQLSTATE: HY000 (ER_KILL_DENIED_ERROR)<ul><li>消息：你不是线程%lu的所有者。</li></ul></li><li>错误：1096 SQLSTATE: HY000 (ER_NO_TABLES_USED)<ul><li>消息：未使用任何表。</li></ul></li><li>错误：1097 SQLSTATE: HY000 (ER_TOO_BIG_SET)<ul><li>消息：列%s和SET的字符串过多。</li></ul></li><li>错误：1098 SQLSTATE: HY000 (ER_NO_UNIQUE_LOGFILE)<ul><li>消息：不能生成唯一的日志文件名%s.(1-999)</li></ul></li><li>错误：1099 SQLSTATE: HY000 (ER_TABLE_NOT_LOCKED_FOR_WRITE)<ul><li>消息：表’%s’已用READ锁定，不能更新。</li></ul></li><li>错误：1100 SQLSTATE: HY000 (ER_TABLE_NOT_LOCKED)<ul><li>消息：未使用LOCK TABLES锁定表’%s’。</li></ul></li><li>错误：1101 SQLSTATE: 42000 (ER_BLOB_CANT_HAVE_DEFAULT)<ul><li>消息：BLOB/TEXT列’%s’不能有默认值。</li></ul></li><li>错误：1102 SQLSTATE: 42000 (ER_WRONG_DB_NAME)<ul><li>消息：不正确的数据库名’%s’。</li></ul></li><li>错误：1103 SQLSTATE: 42000 (ER_WRONG_TABLE_NAME)<ul><li>消息：不正确的表名’%s’。</li></ul></li><li>错误：1104 SQLSTATE: 42000 (ER_TOO_BIG_SELECT)<ul><li>消息：SELECT将检查超过MAX_JOIN_SIZE的行，如果SELECT正常，请检查WHERE，并使用SET SQL_BIG_SELECTS=1或SET SQL_MAX_JOIN_SIZE=#。</li></ul></li><li>错误：1105 SQLSTATE: HY000 (ER_UNKNOWN_ERROR)<ul><li>消息：未知错误。</li></ul></li><li>错误：1106 SQLSTATE: 42000 (ER_UNKNOWN_PROCEDURE)<ul><li>消息：未知过程’%s’</li></ul></li><li>错误：1107 SQLSTATE: 42000 (ER_WRONG_PARAMCOUNT_TO_PROCEDURE)<ul><li>消息：对于过程’%s’，参数计数不正确</li></ul></li><li>错误：1108 SQLSTATE: HY000 (ER_WRONG_PARAMETERS_TO_PROCEDURE)<ul><li>消息：对于过程’%s’，参数不正确</li></ul></li><li>错误：1109 SQLSTATE: 42S02 (ER_UNKNOWN_TABLE)<ul><li>消息：%s中的未知表%s</li></ul></li><li>错误：1110 SQLSTATE: 42000 (ER_FIELD_SPECIFIED_TWICE)<ul><li>消息：列’%s’被指定了两次。</li></ul></li><li>错误：1111 SQLSTATE: HY000 (ER_INVALID_GROUP_FUNC_USE)<ul><li>消息：无效的分组函数使用</li></ul></li><li>错误：1112 SQLSTATE: 42000 (ER_UNSUPPORTED_EXTENSION)<ul><li>消息：表’%s’使用了该MySQL版本中不存在的扩展。</li></ul></li><li>错误：1113 SQLSTATE: 42000 (ER_TABLE_MUST_HAVE_COLUMNS)<ul><li>消息：1个表至少要有1列。</li></ul></li><li>错误：1114 SQLSTATE: HY000 (ER_RECORD_FILE_FULL)<ul><li>消息：表’%s’已满。</li></ul></li><li>错误：1115 SQLSTATE: 42000 (ER_UNKNOWN_CHARACTER_SET)<ul><li>消息：未知字符集’%s’。</li></ul></li><li>错误：1116 SQLSTATE: HY000 (ER_TOO_MANY_TABLES)<ul><li>消息：表过多，MySQL在1个联合操作中只能使用%d个表。</li></ul></li><li>错误：1117 SQLSTATE: HY000 (ER_TOO_MANY_FIELDS)<ul><li>消息：列过多。</li></ul></li><li>错误：1118 SQLSTATE: 42000 (ER_TOO_BIG_ROWSIZE)<ul><li>消息：行的大小过大。对于所使用的表类型，不包括BLOB，最大行大小为%ld。必须将某些列更改为TEXT或BLOB。</li></ul></li><li>错误：1119 SQLSTATE: HY000 (ER_STACK_OVERRUN)<ul><li>消息：线程堆栈溢出，已使用，%ld堆栈的%ld。如果需要，请使用’mysqld -O thread_stack=#’指定较大的堆栈。</li></ul></li><li>错误：1120 SQLSTATE: 42000 (ER_WRONG_OUTER_JOIN)<ul><li>消息：在OUTER JOIN中发现交叉关联，请检查ON条件。</li></ul></li><li>错误：1121 SQLSTATE: 42000 (ER_NULL_COLUMN_IN_INDEX)<ul><li>消息：列’%s’与UNIQUE或INDEX一起使用，但未定义为NOT NULL。</li></ul></li><li>错误：1122 SQLSTATE: HY000 (ER_CANT_FIND_UDF)<ul><li>消息：无法加载函数’%s’。</li></ul></li><li>错误：1123 SQLSTATE: HY000 (ER_CANT_INITIALIZE_UDF)<ul><li>消息：无法初始化函数’%s’; %s</li></ul></li><li>错误：1124 SQLSTATE: HY000 (ER_UDF_NO_PATHS)<ul><li>消息：对于共享库，不允许任何路径。</li></ul></li><li>错误：1125 SQLSTATE: HY000 (ER_UDF_EXISTS)<ul><li>消息：函数’%s’已存在。</li></ul></li><li>错误：1126 SQLSTATE: HY000 (ER_CANT_OPEN_LIBRARY)<ul><li>消息：不能打开共享库’%s’ (errno: %d %s)</li></ul></li><li>错误：1127 SQLSTATE: HY000 (ER_CANT_FIND_DL_ENTRY)<ul><li>消息：不能发现库中的符号’%s’。</li></ul></li><li>错误：1128 SQLSTATE: HY000 (ER_FUNCTION_NOT_DEFINED)<ul><li>消息：函数’%s’未定义。</li></ul></li><li>错误：1129 SQLSTATE: HY000 (ER_HOST_IS_BLOCKED)<ul><li>消息：由于存在很多连接错误，主机’%s’被屏蔽，请用’mysqladmin flush-hosts’解除屏蔽。</li></ul></li><li>错误：1130 SQLSTATE: HY000 (ER_HOST_NOT_PRIVILEGED)<ul><li>消息：不允许将主机’%s’连接到该MySQL服务器。</li></ul></li><li>错误：1131 SQLSTATE: 42000 (ER_PASSWORD_ANONYMOUS_USER)<ul><li>消息：你正在已匿名用户身份使用MySQL，不允许匿名用户更改密码。</li></ul></li><li>错误：1132 SQLSTATE: 42000 (ER_PASSWORD_NOT_ALLOWED)<ul><li>消息：必须有更新mysql数据库中表的权限才能更改密码。</li></ul></li><li>错误：1133 SQLSTATE: 42000 (ER_PASSWORD_NO_MATCH)<ul><li>消息：无法在用户表中找到匹配行。</li></ul></li><li>错误：1134 SQLSTATE: HY000 (ER_UPDATE_INFO)<ul><li>消息：行匹配，%ld；已更改，%ld；警告，%ld</li></ul></li><li>错误：1135 SQLSTATE: HY000 (ER_CANT_CREATE_THREAD)<ul><li>消息：无法创建新线程(errno %d)，如果未出现内存溢出，请参阅手册以了解可能的与操作系统有关的缺陷。</li></ul></li><li>错误：1136 SQLSTATE: 21S01 (ER_WRONG_VALUE_COUNT_ON_ROW)<ul><li>消息：列计数不匹配行%ld上的值计数。</li></ul></li><li>错误：1137 SQLSTATE: HY000 (ER_CANT_REOPEN_TABLE)<ul><li>消息：无法再次打开表’%s’。</li></ul></li><li>错误：1138 SQLSTATE: 22004 (ER_INVALID_USE_OF_NULL)<ul><li>消息：NULL值使用无效。</li></ul></li><li>错误：1139 SQLSTATE: 42000 (ER_REGEXP_ERROR)<ul><li>消息：获得来自regexp的错误’%s’。</li></ul></li><li>错误：1140 SQLSTATE: 42000 (ER_MIX_OF_GROUP_FUNC_AND_FIELDS)<ul><li>消息：如果没有GROUP BY子句，GROUP列 (MIN(),MAX(),COUNT(),…)与非GROUP列的混合不合法。</li></ul></li><li>错误：1141 SQLSTATE: 42000 (ER_NONEXISTING_GRANT)<ul><li>消息：没有为主机’%s’上的用户’%s’定义这类授权。</li></ul></li><li>错误：1142 SQLSTATE: 42000 (ER_TABLEACCESS_DENIED_ERROR)<ul><li>消息：拒绝用户‘%s‘@’%s’在表’%s’上使用%s命令。</li></ul></li><li>错误：1143 SQLSTATE: 42000 (ER_COLUMNACCESS_DENIED_ERROR)<ul><li>消息：拒绝用户‘%s‘@’%s’在表’%s’的’%s’上使用%s命令。</li></ul></li><li>错误：1144 SQLSTATE: 42000 (ER_ILLEGAL_GRANT_FOR_TABLE)<ul><li>消息：非法GRANT/REVOKE命令，请参阅手册以了解可使用那种权限。</li></ul></li><li>错误：1145 SQLSTATE: 42000 (ER_GRANT_WRONG_HOST_OR_USER)<ul><li>消息：GRANT的主机或用户参量过长。</li></ul></li><li>错误：1146 SQLSTATE: 42S02 (ER_NO_SUCH_TABLE)<ul><li>消息：表’%s.%s’不存在。</li></ul></li><li>错误：1147 SQLSTATE: 42000 (ER_NONEXISTING_TABLE_GRANT)<ul><li>消息：在表’%s’上没有为主机’%s’上的用户’%s’定义的这类授权。</li></ul></li><li>错误：1148 SQLSTATE: 42000 (ER_NOT_ALLOWED_COMMAND)<ul><li>消息：所使用的命令在该MySQL版本中不允许。</li></ul></li><li>错误：1149 SQLSTATE: 42000 (ER_SYNTAX_ERROR)<ul><li>消息：存在SQL语法错误，请参阅与你的MySQL版本对应的手册，以了解正确的语法。</li></ul></li><li>错误：1150 SQLSTATE: HY000 (ER_DELAYED_CANT_CHANGE_LOCK)<ul><li>消息：对于表%s，延迟的插入线程不能获得请求的锁定。</li></ul></li><li>错误：1151 SQLSTATE: HY000 (ER_TOO_MANY_DELAYED_THREADS)<ul><li>消息：使用的延迟线程过多。</li></ul></li><li>错误：1152 SQLSTATE: 08S01 (ER_ABORTING_CONNECTION)<ul><li>消息：与数据库’%s’和用户’%s’的连接%ld失败 (%s)</li></ul></li><li>错误：1153 SQLSTATE: 08S01 (ER_NET_PACKET_TOO_LARGE)<ul><li>消息：获得信息包大于’max_allowed_packet’字节。</li></ul></li><li>错误：1154 SQLSTATE: 08S01 (ER_NET_READ_ERROR_FROM_PIPE)<ul><li>消息：获得来自连接管道的读错误。</li></ul></li><li>错误：1155 SQLSTATE: 08S01 (ER_NET_FCNTL_ERROR)<ul><li>消息：获得来自fcntl()的错误。</li></ul></li><li>错误：1156 SQLSTATE: 08S01 (ER_NET_PACKETS_OUT_OF_ORDER)<ul><li>消息：获得信息包无序。</li></ul></li><li>错误：1157 SQLSTATE: 08S01 (ER_NET_UNCOMPRESS_ERROR)<ul><li>消息：无法解压缩通信信息包。</li></ul></li><li>错误：1158 SQLSTATE: 08S01 (ER_NET_READ_ERROR)<ul><li>消息：读取通信信息包时出错。</li></ul></li><li>错误：1159 SQLSTATE: 08S01 (ER_NET_READ_INTERRUPTED)<ul><li>消息：读取通信信息包时出现超时。</li></ul></li><li>错误：1160 SQLSTATE: 08S01 (ER_NET_ERROR_ON_WRITE)<ul><li>消息：写入通信信息包时出错。</li></ul></li><li>错误：1161 SQLSTATE: 08S01 (ER_NET_WRITE_INTERRUPTED)<ul><li>消息：写入通信信息包时出现超时。</li></ul></li><li>错误：1162 SQLSTATE: 42000 (ER_TOO_LONG_STRING)<ul><li>消息：结果字符串长于’max_allowed_packet’字节。</li></ul></li><li>错误：1163 SQLSTATE: 42000 (ER_TABLE_CANT_HANDLE_BLOB)<ul><li>消息：所使用的表类型不支持BLOB/TEXT列。</li></ul></li><li>错误：1164 SQLSTATE: 42000 (ER_TABLE_CANT_HANDLE_AUTO_INCREMENT)<ul><li>消息：所使用的表类型不支持AUTO_INCREMENT列。</li></ul></li><li>错误：1165 SQLSTATE: HY000 (ER_DELAYED_INSERT_TABLE_LOCKED)<ul><li>消息：由于用LOCK TABLES锁定了表，INSERT DELAYED不能与表’%s’一起使用。</li></ul></li><li>错误：1166 SQLSTATE: 42000 (ER_WRONG_COLUMN_NAME)<ul><li>消息：不正确的列名’%s’。</li></ul></li><li>错误：1167 SQLSTATE: 42000 (ER_WRONG_KEY_COLUMN)<ul><li>消息：所使用的存储引擎不能为列’%s’编制索引。</li></ul></li><li>错误：1168 SQLSTATE: HY000 (ER_WRONG_MRG_TABLE)<ul><li>消息：MERGE表中的所有表未同等定义。</li></ul></li><li>错误：1169 SQLSTATE: 23000 (ER_DUP_UNIQUE)<ul><li>消息：由于唯一性限制，不能写入到表’%s’。</li></ul></li><li>错误：1170 SQLSTATE: 42000 (ER_BLOB_KEY_WITHOUT_LENGTH)<ul><li>消息：在未指定键长度的键说明中使用了BLOB/TEXT列’%s’。</li></ul></li><li>错误：1171 SQLSTATE: 42000 (ER_PRIMARY_CANT_HAVE_NULL)<ul><li>消息：PRIMARY KEY的所有部分必须是NOT NULL，如果需要为NULL的关键字，请使用UNIQUE取而代之。</li></ul></li><li>错误：1172 SQLSTATE: 42000 (ER_TOO_MANY_ROWS)<ul><li>消息：结果有1个以上的行组成。</li></ul></li><li>错误：1173 SQLSTATE: 42000 (ER_REQUIRES_PRIMARY_KEY)<ul><li>消息：该表类型要求主键。</li></ul></li><li>错误：1174 SQLSTATE: HY000 (ER_NO_RAID_COMPILED)<ul><li>消息：该MySQL版本是未使用RAID支持而编译的。</li></ul></li><li>错误：1175 SQLSTATE: HY000 (ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE)<ul><li>消息：你正在使用安全更新模式，而且试图在不使用WHERE的情况下更新使用了KEY列的表。</li></ul></li><li>错误：1176 SQLSTATE: HY000 (ER_KEY_DOES_NOT_EXITS)<ul><li>消息：在表’%s’中，键’%s’不存在。</li></ul></li><li>错误：1177 SQLSTATE: 42000 (ER_CHECK_NO_SUCH_TABLE)<ul><li>消息：无法打开表。</li></ul></li><li>错误：1178 SQLSTATE: 42000 (ER_CHECK_NOT_IMPLEMENTED)<ul><li>消息：用于表的引擎不支持%s。</li></ul></li><li>错误：1179 SQLSTATE: 25000 (ER_CANT_DO_THIS_DURING_AN_TRANSACTION)<ul><li>消息：不允许在事务中执行该命令。</li></ul></li><li>错误：1180 SQLSTATE: HY000 (ER_ERROR_DURING_COMMIT)<ul><li>消息：在COMMIT期间出现错误%d。</li></ul></li><li>错误：1181 SQLSTATE: HY000 (ER_ERROR_DURING_ROLLBACK)<ul><li>消息：在ROLLBACK期间出现错误%d。</li></ul></li><li>错误：1182 SQLSTATE: HY000 (ER_ERROR_DURING_FLUSH_LOGS)<ul><li>消息：在FLUSH_LOGS期间出现错误%d。</li></ul></li><li>错误：1183 SQLSTATE: HY000 (ER_ERROR_DURING_CHECKPOINT)<ul><li>消息：在CHECKPOINT期间出现错误%d。</li></ul></li><li>错误：1184 SQLSTATE: 08S01 (ER_NEW_ABORTING_CONNECTION)<ul><li>消息：与数据库’%s’、用户’%s’和主机’%s’的连接%ld失败 (%s)。</li></ul></li><li>错误：1185 SQLSTATE: HY000 (ER_DUMP_NOT_IMPLEMENTED)<ul><li>消息：针对表的存储引擎不支持二进制表转储。</li></ul></li><li>错误：1186 SQLSTATE: HY000 (ER_FLUSH_MASTER_BINLOG_CLOSED)<ul><li>消息：Binlog已关闭，不能RESET MASTER。</li></ul></li><li>错误：1187 SQLSTATE: HY000 (ER_INDEX_REBUILD)<ul><li>消息：重新创建转储表’%s’的索引失败。</li></ul></li><li>错误：1188 SQLSTATE: HY000 (ER_MASTER)<ul><li>消息：来自主连接’%s’的错误。</li></ul></li><li>错误：1189 SQLSTATE: 08S01 (ER_MASTER_NET_READ)<ul><li>消息：读取主连接时出现网络错误。</li></ul></li><li>错误：1190 SQLSTATE: 08S01 (ER_MASTER_NET_WRITE)<ul><li>消息：写入主连接时出现网络错误。</li></ul></li><li>错误：1191 SQLSTATE: HY000 (ER_FT_MATCHING_KEY_NOT_FOUND)<ul><li>消息：无法找到与列列表匹配的FULLTEXT索引。</li></ul></li><li>错误：1192 SQLSTATE: HY000 (ER_LOCK_OR_ACTIVE_TRANSACTION)<ul><li>消息：由于存在活动的锁定表或活动的事务，不能执行给定的命令。</li></ul></li><li>错误：1193 SQLSTATE: HY000 (ER_UNKNOWN_SYSTEM_VARIABLE)<ul><li>消息：未知的系统变量’%s’。</li></ul></li><li>错误：1194 SQLSTATE: HY000 (ER_CRASHED_ON_USAGE)<ul><li>消息：表’%s’被标记为崩溃，应予以修复。</li></ul></li><li>错误：1195 SQLSTATE: HY000 (ER_CRASHED_ON_REPAIR)<ul><li>消息：表’%s’被标记为崩溃，而且上次修复失败（自动？）</li></ul></li><li>错误：1196 SQLSTATE: HY000 (ER_WARNING_NOT_COMPLETE_ROLLBACK)<ul><li>消息：不能回滚某些非事务性已变动表。</li></ul></li><li>错误：1197 SQLSTATE: HY000 (ER_TRANS_CACHE_FULL)<ul><li>消息：多语句事务要求更多的’max_binlog_cache_size’存储字节，增大mysqld变量，并再次尝试。</li></ul></li><li>错误：1198 SQLSTATE: HY000 (ER_SLAVE_MUST_STOP)<ul><li>消息：运行从实例时不能执行该操作，请首先运行STOP SLAVE。</li></ul></li><li>错误：1199 SQLSTATE: HY000 (ER_SLAVE_NOT_RUNNING)<ul><li>消息：该操作需要运行的从实例，请配置SLAVE并执行START SLAVE。</li></ul></li><li>错误：1200 SQLSTATE: HY000 (ER_BAD_SLAVE)<ul><li>消息：服务器未配置为从服务器，请更正config文件，或使用CHANGE MASTER TO。</li></ul></li><li>错误：1201 SQLSTATE: HY000 (ER_MASTER_INFO)<ul><li>消息：无法初始化主服务器信息结构，在MySQL错误日志中可找到更多错误    - 消息。</li></ul></li><li>错误：1202 SQLSTATE: HY000 (ER_SLAVE_THREAD)<ul><li>消息：无法创建从线程，请检查系统资源。</li></ul></li><li>错误：1203 SQLSTATE: 42000 (ER_TOO_MANY_USER_CONNECTIONS)<ul><li>消息：用户%s已有了超过’max_user_connections’的活动连接。</li></ul></li><li>错误：1204 SQLSTATE: HY000 (ER_SET_CONSTANTS_ONLY)<ul><li>消息：或许仅应与SET一起使用常量表达式。</li></ul></li><li>错误：1205 SQLSTATE: HY000 (ER_LOCK_WAIT_TIMEOUT)<ul><li>消息：超过了锁定等待超时，请尝试重新启动事务。</li></ul></li><li>错误：1206 SQLSTATE: HY000 (ER_LOCK_TABLE_FULL)<ul><li>消息：总的锁定数超出了锁定表的大小。</li></ul></li><li>错误：1207 SQLSTATE: 25000 (ER_READ_ONLY_TRANSACTION)<ul><li>消息：在READ UNCOMMITTED事务期间，无法获得更新锁定。</li></ul></li><li>错误：1208 SQLSTATE: HY000 (ER_DROP_DB_WITH_READ_LOCK)<ul><li>消息：当线程保持为全局读锁定时，不允许DROP DATABASE。</li></ul></li><li>错误：1209 SQLSTATE: HY000 (ER_CREATE_DB_WITH_READ_LOCK)<ul><li>消息：当线程保持为全局读锁定时，不允许CREATE DATABASE。</li></ul></li><li>错误：1210 SQLSTATE: HY000 (ER_WRONG_ARGUMENTS)<ul><li>消息：为%s提供的参量不正确。</li></ul></li><li>错误：1211 SQLSTATE: 42000 (ER_NO_PERMISSION_TO_CREATE_USER)<ul><li>消息：不允许‘%s‘@’%s’创建新用户。</li></ul></li><li>错误：1212 SQLSTATE: HY000 (ER_UNION_TABLES_IN_DIFFERENT_DIR)<ul><li>消息：不正确的表定义，所有的MERGE表必须位于相同的数据库中。</li></ul></li><li>错误：1213 SQLSTATE: 40001 (ER_LOCK_DEADLOCK)<ul><li>消息：试图获取锁定时发现死锁，请尝试重新启动事务。</li></ul></li><li>错误：1214 SQLSTATE: HY000 (ER_TABLE_CANT_HANDLE_FT)<ul><li>消息：所使用的表类型不支持FULLTEXT索引。</li></ul></li><li>错误：1215 SQLSTATE: HY000 (ER_CANNOT_ADD_FOREIGN)<ul><li>消息：无法添加外键约束。</li></ul></li><li>错误：1216 SQLSTATE: 23000 (ER_NO_REFERENCED_ROW)<ul><li>消息：无法添加或更新子行，外键约束失败。</li></ul></li><li>错误：1217 SQLSTATE: 23000 (ER_ROW_IS_REFERENCED)<ul><li>消息：无法删除或更新父行，外键约束失败。</li></ul></li><li>错误：1218 SQLSTATE: 08S01 (ER_CONNECT_TO_MASTER)<ul><li>消息：连接至主服务器%s时出错。</li></ul></li><li>错误：1219 SQLSTATE: HY000 (ER_QUERY_ON_MASTER)<ul><li>消息：在主服务器%s上执行查询时出错。</li></ul></li><li>错误：1220 SQLSTATE: HY000 (ER_ERROR_WHEN_EXECUTING_COMMAND)<ul><li>消息：执行命令%s: %s时出错。</li></ul></li><li>错误：1221 SQLSTATE: HY000 (ER_WRONG_USAGE)<ul><li>消息：%s和%s的用法不正确。</li></ul></li><li>错误：1222 SQLSTATE: 21000 (ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT)<ul><li>消息：所使用的SELECT语句有不同的列数。</li></ul></li><li>错误：1223 SQLSTATE: HY000 (ER_CANT_UPDATE_WITH_READLOCK)<ul><li>消息：由于存在冲突的读锁定，无法执行查询。</li></ul></li><li>错误：1224 SQLSTATE: HY000 (ER_MIXING_NOT_ALLOWED)<ul><li>消息：禁止混合事务性表和非事务性表。</li></ul></li><li>错误：1225 SQLSTATE: HY000 (ER_DUP_ARGUMENT)<ul><li>消息：在语句中使用了两次选项’%s’。</li></ul></li><li>错误：1226 SQLSTATE: 42000 (ER_USER_LIMIT_REACHED)<ul><li>消息：用户’%s’超出了’%s’资源（当前值：%ld）。</li></ul></li><li>错误：1227 SQLSTATE: 42000 (ER_SPECIFIC_ACCESS_DENIED_ERROR)<ul><li>消息：拒绝访问，需要%s权限才能执行该操作。</li></ul></li><li>错误：1228 SQLSTATE: HY000 (ER_LOCAL_VARIABLE)<ul><li>消息：变量’%s’是1种SESSION变量，不能与SET GLOBAL一起使用。</li></ul></li><li>错误：1229 SQLSTATE: HY000 (ER_GLOBAL_VARIABLE)<ul><li>消息：变量’%s’是1种GLOBAL变量，应使用SET GLOBAL来设置它。</li></ul></li><li>错误：1230 SQLSTATE: 42000 (ER_NO_DEFAULT)<ul><li>消息：变量’%s’没有默认值。</li></ul></li><li>错误：1231 SQLSTATE: 42000 (ER_WRONG_VALUE_FOR_VAR)<ul><li>消息：变量’%s’不能设置为值’%s’。</li></ul></li><li>错误：1232 SQLSTATE: 42000 (ER_WRONG_TYPE_FOR_VAR)<ul><li>消息：变量’%s’的参量类型不正确。</li></ul></li><li>错误：1233 SQLSTATE: HY000 (ER_VAR_CANT_BE_READ)<ul><li>消息：变量’%s’只能被设置，不能被读取。</li></ul></li><li>错误：1234 SQLSTATE: 42000 (ER_CANT_USE_OPTION_HERE)<ul><li>消息：不正确的’%s’用法/位置。</li></ul></li><li>错误：1235 SQLSTATE: 42000 (ER_NOT_SUPPORTED_YET)<ul><li>消息：该MySQL版本尚不支持’%s’。</li></ul></li><li>错误：1236 SQLSTATE: HY000 (ER_MASTER_FATAL_ERROR_READING_BINLOG)<ul><li>消息：从二进制日志读取数据时，获得来自主服务器的致命错误%d: ‘%s’。</li></ul></li><li>错误：1237 SQLSTATE: HY000 (ER_SLAVE_IGNORED_TABLE)<ul><li>消息：由于“replicate-*-table”规则，从SQL线程忽略了查询。。</li></ul></li><li>错误：1238 SQLSTATE: HY000 (ER_INCORRECT_GLOBAL_LOCAL_VAR)<ul><li>消息：变量’%s’是一种%s变量。</li></ul></li><li>错误：1239 SQLSTATE: 42000 (ER_WRONG_FK_DEF)<ul><li>消息：对于 ‘%s’: %s， 外键定义不正确。</li></ul></li><li>错误：1240 SQLSTATE: HY000 (ER_KEY_REF_DO_NOT_MATCH_TABLE_REF)<ul><li>消息：键引用和表引用不匹配。</li></ul></li><li>错误：1241 SQLSTATE: 21000 (ER_OPERAND_COLUMNS)<ul><li>消息：操作数应包含%d列。</li></ul></li><li>错误：1242 SQLSTATE: 21000 (ER_SUBQUERY_NO_1_ROW)<ul><li>消息：子查询返回1行以上。</li></ul></li><li>错误：1243 SQLSTATE: HY000 (ER_UNKNOWN_STMT_HANDLER)<ul><li>消息：指定给%s的未知预处理语句句柄。</li></ul></li><li>错误：1244 SQLSTATE: HY000 (ER_CORRUPT_HELP_DB)<ul><li>消息：帮助数据库崩溃或不存在。</li></ul></li><li>错误：1245 SQLSTATE: HY000 (ER_CYCLIC_REFERENCE)<ul><li>消息：对子查询的循环引用。</li></ul></li><li>错误：1246 SQLSTATE: HY000 (ER_AUTO_CONVERT)<ul><li>消息：将列’%s’从%s转换为%s。</li></ul></li><li>错误：1247 SQLSTATE: 42S22 (ER_ILLEGAL_REFERENCE)<ul><li>消息：引用’%s’不被支持 (%s)。</li></ul></li><li>错误：1248 SQLSTATE: 42000 (ER_DERIVED_MUST_HAVE_ALIAS)<ul><li>消息：所有的导出表必须有自己的别名。</li></ul></li><li>错误：1249 SQLSTATE: 01000 (ER_SELECT_REDUCED)<ul><li>消息：在优化期间简化了选择%u。</li></ul></li><li>错误：1250 SQLSTATE: 42000 (ER_TABLENAME_NOT_ALLOWED_HERE)<ul><li>消息：来自某一SELECT的表’%s’不能在%s中使用。</li></ul></li><li>错误：1251 SQLSTATE: 08004 (ER_NOT_SUPPORTED_AUTH_MODE)<ul><li>消息：客户端不支持服务器请求的鉴定协议，请考虑升级MySQL客户端。</li></ul></li><li>错误：1252 SQLSTATE: 42000 (ER_SPATIAL_CANT_HAVE_NULL)<ul><li>消息：SPATIAL索引的所有部分必须是NOT NULL。</li></ul></li><li>错误：1253 SQLSTATE: 42000 (ER_COLLATION_CHARSET_MISMATCH)<ul><li>消息：对于CHARACTER SET ‘%s’，COLLATION ‘%s’无效。</li></ul></li><li>错误：1254 SQLSTATE: HY000 (ER_SLAVE_WAS_RUNNING)<ul><li>消息：从服务器正在运行。</li></ul></li><li>错误：1255 SQLSTATE: HY000 (ER_SLAVE_WAS_NOT_RUNNING)<ul><li>消息：从服务器已停止。</li></ul></li><li>错误：1256 SQLSTATE: HY000 (ER_TOO_BIG_FOR_UNCOMPRESS)<ul><li>消息：解压的数据过大，最大大小为%d（也可能是，解压数据的长度已损坏）。</li></ul></li><li>错误：1257 SQLSTATE: HY000 (ER_ZLIB_Z_MEM_ERROR)<ul><li>消息：ZLIB，无足够内存。</li></ul></li><li>错误：1258 SQLSTATE: HY000 (ER_ZLIB_Z_BUF_ERROR)<ul><li>消息：ZLIB，输出缓冲区内无足够空间（也可能是，解压数据的长度已损坏）。</li></ul></li><li>错误：1259 SQLSTATE: HY000 (ER_ZLIB_Z_DATA_ERROR)<ul><li>消息：ZLIB，输入数据已损坏。</li></ul></li><li>错误：1260 SQLSTATE: HY000 (ER_CUT_VALUE_GROUP_CONCAT)<ul><li>消息：%d行被GROUP_CONCAT()截去。</li></ul></li><li>错误：1261 SQLSTATE: 01000 (ER_WARN_TOO_FEW_RECORDS)<ul><li>消息：行%ld不包含所有列的数据。</li></ul></li><li>错误：1262 SQLSTATE: 01000 (ER_WARN_TOO_MANY_RECORDS)<ul><li>消息：行%ld被解短，它包含的数据大于输入列中的数据。</li></ul></li><li>错误：1263 SQLSTATE: 22004 (ER_WARN_NULL_TO_NOTNULL)<ul><li>消息：列被设为默认值，在行%ld上将NULL提供给了NOT NULL列。</li></ul></li><li>错误：1264 SQLSTATE: 22003 (ER_WARN_DATA_OUT_OF_RANGE)<ul><li>消息：为行%ld上的列’%s’调整超出范围的值。</li></ul></li><li>错误：1265 SQLSTATE: 01000 (WARN_DATA_TRUNCATED)<ul><li>消息：为行%ld上的列’%s’截短数据。</li></ul></li><li>错误：1266 SQLSTATE: HY000 (ER_WARN_USING_OTHER_HANDLER)<ul><li>消息：为表%s使用存储引擎%s。</li></ul></li><li>错误：1267 SQLSTATE: HY000 (ER_CANT_AGGREGATE_2COLLATIONS)<ul><li>消息：对于操作’%s’，非法混合了校对(%s,%s)和(%s,%s)。</li></ul></li><li>错误：1268 SQLSTATE: HY000 (ER_DROP_USER)<ul><li>消息：无法撤销1个或多个请求的用户。</li></ul></li><li>错误：1269 SQLSTATE: HY000 (ER_REVOKE_GRANTS)<ul><li>消息：无法撤销所有权限，为1个或多个请求的用户授权。</li></ul></li><li>错误：1270 SQLSTATE: HY000 (ER_CANT_AGGREGATE_3COLLATIONS)<ul><li>消息：对于操作’%s’，非法混合了校对(%s,%s)、(%s,%s)和(%s,%s)。</li></ul></li><li>错误：1271 SQLSTATE: HY000 (ER_CANT_AGGREGATE_NCOLLATIONS)<ul><li>消息：对于操作’%s’，非法混合了校对。</li></ul></li><li>错误：1272 SQLSTATE: HY000 (ER_VARIABLE_IS_NOT_STRUCT)<ul><li>消息：变量’%s’不是变量组分（不能用作XXXX.variable_name）。</li></ul></li><li>错误：1273 SQLSTATE: HY000 (ER_UNKNOWN_COLLATION)<ul><li>消息：未知校对’%s’。</li></ul></li><li>错误：1274 SQLSTATE: HY000 (ER_SLAVE_IGNORED_SSL_PARAMS)<ul><li>消息：由于该MySQL从服务器是在不支持SSL的情况下编译的，CHANGE MASTER中的SSL参数被忽略，随后，如果启动了具备SSL功能的MySQL，可使用这些参数。</li></ul></li><li>错误：1275 SQLSTATE: HY000 (ER_SERVER_IS_IN_SECURE_AUTH_MODE)<ul><li>消息：服务器正运行在“–secure-auth”模式下，但‘%s‘@’%s’有1个采用旧格式的密码，请将密码更改为新格式。</li></ul></li><li>错误：1276 SQLSTATE: HY000 (ER_WARN_FIELD_RESOLVED)<ul><li>消息：SELECT #%d的字段或引用’%s%s%s%s%s’是在SELECT #%d中确定的。</li></ul></li><li>错误：1277 SQLSTATE: HY000 (ER_BAD_SLAVE_UNTIL_COND)<ul><li>消息：对于START SLAVE UNTIL，不正确的参数或参数组合。</li></ul></li><li>错误：1278 SQLSTATE: HY000 (ER_MISSING_SKIP_SLAVE)<ul><li>消息：与START SLAVE UNTIL一起执行按步复制时，建议使用“–skip-slave-start”，否则，如果发生未预料的从服务器mysqld重启，间出现问题。</li></ul></li><li>错误：1279 SQLSTATE: HY000 (ER_UNTIL_COND_IGNORED)<ul><li>消息：SQL线程未启动，因而UNTIL选项被忽略。</li></ul></li><li>错误：1280 SQLSTATE: 42000 (ER_WRONG_NAME_FOR_INDEX)<ul><li>消息：不正确的索引名’%s’。</li></ul></li><li>错误：1281 SQLSTATE: 42000 (ER_WRONG_NAME_FOR_CATALOG)<ul><li>消息：不正确的目录名’%s’。</li></ul></li><li>错误：1282 SQLSTATE: HY000 (ER_WARN_QC_RESIZE)<ul><li>消息：查询高速缓冲设置大小%lu时失败，新的查询高速缓冲的大小是%lu。</li></ul></li><li>错误：1283 SQLSTATE: HY000 (ER_BAD_FT_COLUMN)<ul><li>消息：列’%s’不能是FULLTEXT索引的一部分。</li></ul></li><li>错误：1284 SQLSTATE: HY000 (ER_UNKNOWN_KEY_CACHE)<ul><li>消息：未知的键高速缓冲’%s’。</li></ul></li><li>错误：1285 SQLSTATE: HY000 (ER_WARN_HOSTNAME_WONT_WORK)<ul><li>消息：MySQL是在“–skip-name-resolve”模式下启动的，必须在不使用该开关的情况下重启它，以便该授权能起作用。</li></ul></li><li>错误：1286 SQLSTATE: 42000 (ER_UNKNOWN_STORAGE_ENGINE)<ul><li>消息：未知的表引擎’%s’。</li></ul></li><li>错误：1287 SQLSTATE: HY000 (ER_WARN_DEPRECATED_SYNTAX)<ul><li>消息：’%s’已过时，请使用’%s’取而代之。</li></ul></li><li>错误：1288 SQLSTATE: HY000 (ER_NON_UPDATABLE_TABLE)<ul><li>消息：%s的目标表%s不可更新。</li></ul></li><li>错误：1289 SQLSTATE: HY000 (ER_FEATURE_DISABLED)<ul><li>消息：’%s’特性已被禁止，要想使其工作，需要用’%s’创建MySQL。</li></ul></li><li>错误：1290 SQLSTATE: HY000 (ER_OPTION_PREVENTS_STATEMENT)<ul><li>消息：MySQL正使用%s选项运行，因此不能执行该语句。</li></ul></li><li>错误：1291 SQLSTATE: HY000 (ER_DUPLICATED_VALUE_IN_TYPE)<ul><li>消息：列’%s’在%s中有重复值’%s’。</li></ul></li><li>错误：1292 SQLSTATE: 22007 (ER_TRUNCATED_WRONG_VALUE)<ul><li>消息：截短了不正确的%s值: ‘%s’</li></ul></li><li>错误：1293 SQLSTATE: HY000 (ER_TOO_MUCH_AUTO_TIMESTAMP_COLS)<ul><li>消息：不正确的表定义，在DEFAULT或ON UPDATE子句中，对于CURRENT_TIMESTAMP，只能有一个TIMESTAMP列。</li></ul></li><li>错误：1294 SQLSTATE: HY000 (ER_INVALID_ON_UPDATE)<ul><li>消息：对于’%s’列，ON UPDATE子句无效。</li></ul></li><li>错误：1295 SQLSTATE: HY000 (ER_UNSUPPORTED_PS)<ul><li>消息：在预处理语句协议中，尚不支持该命令。</li></ul></li><li>错误：1296 SQLSTATE: HY000 (ER_GET_ERRMSG)<ul><li>消息：从%s获得错误%d ‘%s’。</li></ul></li><li>错误：1297 SQLSTATE: HY000 (ER_GET_TEMPORARY_ERRMSG)<ul><li>消息：从%s获得临时错误%d ‘%s’。</li></ul></li><li>错误：1298 SQLSTATE: HY000 (ER_UNKNOWN_TIME_ZONE)<ul><li>消息：未知或不正确的时区: ‘%s’</li></ul></li><li>错误：1299 SQLSTATE: HY000 (ER_WARN_INVALID_TIMESTAMP)<ul><li>消息：在行%ld的列’%s’中存在无效的TIMESTAMP值。</li></ul></li><li>错误：1300 SQLSTATE: HY000 (ER_INVALID_CHARACTER_STRING)<ul><li>消息：无效的%s字符串: ‘%s’</li></ul></li><li>错误：1301 SQLSTATE: HY000 (ER_WARN_ALLOWED_PACKET_OVERFLOWED)<ul><li>消息：%s()的结果大于max_allowed_packet (%ld)，已截短</li></ul></li><li>错误：1302 SQLSTATE: HY000 (ER_CONFLICTING_DECLARATIONS)<ul><li>消息：冲突声明：’%s%s’和’%s%s’</li></ul></li><li>错误：1303 SQLSTATE: 2F003 (ER_SP_NO_RECURSIVE_CREATE)<ul><li>消息：不能从另一个存储子程序中创建%s。</li></ul></li><li>错误：1304 SQLSTATE: 42000 (ER_SP_ALREADY_EXISTS)<ul><li>消息：%s %s已存在。</li></ul></li><li>错误：1305 SQLSTATE: 42000 (ER_SP_DOES_NOT_EXIST)<ul><li>消息：%s %s不存在。</li></ul></li><li>错误：1306 SQLSTATE: HY000 (ER_SP_DROP_FAILED)<ul><li>消息：DROP %s %s失败</li></ul></li><li>错误：1307 SQLSTATE: HY000 (ER_SP_STORE_FAILED)<ul><li>消息：CREATE %s %s失败。</li></ul></li><li>错误：1308 SQLSTATE: 42000 (ER_SP_LILABEL_MISMATCH)<ul><li>消息：%s无匹配标签: %s</li></ul></li><li>错误：1309 SQLSTATE: 42000 (ER_SP_LABEL_REDEFINE)<ul><li>消息：重新定义标签%s</li></ul></li><li>错误：1310 SQLSTATE: 42000 (ER_SP_LABEL_MISMATCH)<ul><li>消息：末端标签%s无匹配项</li></ul></li><li>错误：1311 SQLSTATE: 01000 (ER_SP_UNINIT_VAR)<ul><li>消息：正在引用未初始化的变量%s。</li></ul></li><li>错误：1312 SQLSTATE: 0A000 (ER_SP_BADSELECT)<ul><li>消息：PROCEDURE %s不能在给定场景下返回结果集。</li></ul></li><li>错误：1313 SQLSTATE: 42000 (ER_SP_BADRETURN)<ul><li>消息：仅在FUNCTION中允许RETURN。</li></ul></li><li>错误：1314 SQLSTATE: 0A000 (ER_SP_BADSTATEMENT)<ul><li>消息：在存储程序中不允许%s。</li></ul></li><li>错误：1315 SQLSTATE: 42000 (ER_UPDATE_LOG_DEPRECATED_IGNORED)<ul><li>消息：更新日志已被放弃，并用二进制日志取代，SET SQL_LOG_UPDATE被忽略。</li></ul></li><li>错误：1316 SQLSTATE: 42000 (ER_UPDATE_LOG_DEPRECATED_TRANSLATED)<ul><li>消息：更新日志已被放弃，并用二进制日志取代，SET SQL_LOG_UPDATE已被截短为SET SQL_LOG_BIN。</li></ul></li><li>错误：1317 SQLSTATE: 70100 (ER_QUERY_INTERRUPTED)<ul><li>消息：查询执行被中断。</li></ul></li><li>错误：1318 SQLSTATE: 42000 (ER_SP_WRONG_NO_OF_ARGS)<ul><li>消息：对于%s %s，参量数目不正确，预期为%u，但却是%u。</li></ul></li><li>错误：1319 SQLSTATE: 42000 (ER_SP_COND_MISMATCH)<ul><li>消息：未定义的CONDITION: %s</li></ul></li><li>错误：1320 SQLSTATE: 42000 (ER_SP_NORETURN)<ul><li>消息：在FUNCTION %s中未发现RETURN。</li></ul></li><li>错误：1321 SQLSTATE: 2F005 (ER_SP_NORETURNEND)<ul><li>消息：FUNCTION %s结束时缺少RETURN。</li></ul></li><li>错误：1322 SQLSTATE: 42000 (ER_SP_BAD_CURSOR_QUERY)<ul><li>消息：光标语句必须是SELECT。</li></ul></li><li>错误：1323 SQLSTATE: 42000 (ER_SP_BAD_CURSOR_SELECT)<ul><li>消息：光标SELECT不得有INTO。</li></ul></li><li>错误：1324 SQLSTATE: 42000 (ER_SP_CURSOR_MISMATCH)<ul><li>消息：未定义的CURSOR: %s</li></ul></li><li>错误：1325 SQLSTATE: 24000 (ER_SP_CURSOR_ALREADY_OPEN)<ul><li>消息：光标已打开</li></ul></li><li>错误：1326 SQLSTATE: 24000 (ER_SP_CURSOR_NOT_OPEN)<ul><li>消息：光标未打开</li></ul></li><li>错误：1327 SQLSTATE: 42000 (ER_SP_UNDECLARED_VAR)<ul><li>消息：未声明的变量：%s</li></ul></li><li>错误：1328 SQLSTATE: HY000 (ER_SP_WRONG_NO_OF_FETCH_ARGS)<ul><li>消息：不正确的FETCH变量数目。</li></ul></li><li>错误：1329 SQLSTATE: 02000 (ER_SP_FETCH_NO_DATA)<ul><li>消息：FETCH无数据。</li></ul></li><li>错误：1330 SQLSTATE: 42000 (ER_SP_DUP_PARAM)<ul><li>消息：重复参数: %s</li></ul></li><li>错误：1331 SQLSTATE: 42000 (ER_SP_DUP_VAR)<ul><li>消息：重复变量: %s</li></ul></li><li>错误：1332 SQLSTATE: 42000 (ER_SP_DUP_COND)<ul><li>消息：重复条件: %s</li></ul></li><li>错误：1333 SQLSTATE: 42000 (ER_SP_DUP_CURS)<ul><li>消息：重复光标: %s</li></ul></li><li>错误：1334 SQLSTATE: HY000 (ER_SP_CANT_ALTER)<ul><li>消息：ALTER %s %s失败。</li></ul></li><li>错误：1335 SQLSTATE: 0A000 (ER_SP_SUBSELECT_NYI)<ul><li>消息：不支持Subselect值。</li></ul></li><li>错误：1336 SQLSTATE: 0A000 (ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG)<ul><li>消息：在存储函数或触发程序中，不允许%s。</li></ul></li><li>错误：1337 SQLSTATE: 42000 (ER_SP_VARCOND_AFTER_CURSHNDLR)<ul><li>消息：光标或句柄声明后面的变量或条件声明。</li></ul></li><li>错误：1338 SQLSTATE: 42000 (ER_SP_CURSOR_AFTER_HANDLER)<ul><li>消息：句柄声明后面的光标声明。</li></ul></li><li>错误：1339 SQLSTATE: 20000 (ER_SP_CASE_NOT_FOUND)<ul><li>消息：对于CASE语句，未发现Case。</li></ul></li><li>错误：1340 SQLSTATE: HY000 (ER_FPARSER_TOO_BIG_FILE)<ul><li>消息：配置文件’%s’过大。</li></ul></li><li>错误：1341 SQLSTATE: HY000 (ER_FPARSER_BAD_HEADER)<ul><li>消息：文件’%s’中存在残缺的文件类型标题。</li></ul></li><li>错误：1342 SQLSTATE: HY000 (ER_FPARSER_EOF_IN_COMMENT)<ul><li>消息：解析’%s’时，文件意外结束。</li></ul></li><li>错误：1343 SQLSTATE: HY000 (ER_FPARSER_ERROR_IN_PARAMETER)<ul><li>消息：解析参数’%s’时出错（行：’%s’）。</li></ul></li><li>错误：1344 SQLSTATE: HY000 (ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER)<ul><li>消息：跳过未知参数’%s’时，文件意外结束。</li></ul></li><li>错误：1345 SQLSTATE: HY000 (ER_VIEW_NO_EXPLAIN)<ul><li>消息：EXPLAIN/SHOW无法发出，缺少对基本表的权限。</li></ul></li><li>错误：1346 SQLSTATE: HY000 (ER_FRM_UNKNOWN_TYPE)<ul><li>消息：文件’%s’在其题头中有未知的类型’%s’。</li></ul></li><li>错误：1347 SQLSTATE: HY000 (ER_WRONG_OBJECT)<ul><li>消息：’%s.%s’不是%s。</li></ul></li><li>错误：1348 SQLSTATE: HY000 (ER_NONUPDATEABLE_COLUMN)<ul><li>消息：列’%s’不可更新。</li></ul></li><li>错误：1349 SQLSTATE: HY000 (ER_VIEW_SELECT_DERIVED)<ul><li>消息：视图的SELECT在FROM子句中包含子查询。</li></ul></li><li>错误：1350 SQLSTATE: HY000 (ER_VIEW_SELECT_CLAUSE)<ul><li>消息：视图的SELECT包含’%s’子句。</li></ul></li><li>错误：1351 SQLSTATE: HY000 (ER_VIEW_SELECT_VARIABLE)<ul><li>消息：视图的SELECT包含1个变量或参数。</li></ul></li><li>错误：1352 SQLSTATE: HY000 (ER_VIEW_SELECT_TMPTABLE)<ul><li>消息：视图的SELECT引用了临时表’%s’。</li></ul></li><li>错误：1353 SQLSTATE: HY000 (ER_VIEW_WRONG_LIST)<ul><li>消息：视图的SELECT和视图的字段列表有不同的列计数。</li></ul></li><li>错误：1354 SQLSTATE: HY000 (ER_WARN_VIEW_MERGE)<ul><li>消息：此时，不能在这里使用视图合并算法（假定未定义算法）。</li></ul></li><li>错误：1355 SQLSTATE: HY000 (ER_WARN_VIEW_WITHOUT_KEY)<ul><li>消息：正在更新的视图没有其基本表的完整键。</li></ul></li><li>错误：1356 SQLSTATE: HY000 (ER_VIEW_INVALID)<ul><li>消息：视图’%s.%s’引用了无效的表、列、或函数，或视图的定义程序／调用程序缺少使用它们的权限。</li></ul></li><li>错误：1357 SQLSTATE: HY000 (ER_SP_NO_DROP_SP)<ul><li>消息：无法从另一个存储子程序中撤销或更改%s。</li></ul></li><li>错误：1358 SQLSTATE: HY000 (ER_SP_GOTO_IN_HNDLR)<ul><li>消息：在存储子程序句柄中不允许GOTO。</li></ul></li><li>错误：1359 SQLSTATE: HY000 (ER_TRG_ALREADY_EXISTS)<ul><li>消息：触发程序已存在。</li></ul></li><li>错误：1360 SQLSTATE: HY000 (ER_TRG_DOES_NOT_EXIST)<ul><li>消息：触发程序不存在。</li></ul></li><li>错误：1361 SQLSTATE: HY000 (ER_TRG_ON_VIEW_OR_TEMP_TABLE)<ul><li>消息：触发程序的’%s’是视图或临时表。</li></ul></li><li>错误：1362 SQLSTATE: HY000 (ER_TRG_CANT_CHANGE_ROW)<ul><li>消息：在%strigger中，不允许更新%s行。</li></ul></li><li>错误：1363 SQLSTATE: HY000 (ER_TRG_NO_SUCH_ROW_IN_TRG)<ul><li>消息：在%s触发程序中没有%s行。</li></ul></li><li>错误：1364 SQLSTATE: HY000 (ER_NO_DEFAULT_FOR_FIELD)<ul><li>消息：字段’%s’没有默认值。</li></ul></li><li>错误：1365 SQLSTATE: 22012 (ER_DIVISION_BY_ZERO)<ul><li>消息：被0除。</li></ul></li><li>错误：1366 SQLSTATE: HY000 (ER_TRUNCATED_WRONG_VALUE_FOR_FIELD)<ul><li>消息：不正确的%s值，’%s’，对于行%ld 上的列’%s’。</li></ul></li><li>错误：1367 SQLSTATE: 22007 (ER_ILLEGAL_VALUE_FOR_TYPE)<ul><li>消息：解析过程中发现非法%s ‘%s’值。</li></ul></li><li>错误：1368 SQLSTATE: HY000 (ER_VIEW_NONUPD_CHECK)<ul><li>消息：不可更新视图’%s.%s’上的CHECK OPTION。</li></ul></li><li>错误：1369 SQLSTATE: HY000 (ER_VIEW_CHECK_FAILED)<ul><li>消息：CHECK OPTION失败，’%s.%s’</li></ul></li><li>错误：1370 SQLSTATE: 42000 (ER_PROCACCESS_DENIED_ERROR)<ul><li>消息：对于子程序’%s’，拒绝用户‘%s‘@’%s’使用%s命令。</li></ul></li><li>错误：1371 SQLSTATE: HY000 (ER_RELAY_LOG_FAIL)<ul><li>消息：清除旧中继日志失败，%s</li></ul></li><li>错误：1372 SQLSTATE: HY000 (ER_PASSWD_LENGTH)<ul><li>消息：密码混编应是%d位的十六进制数。</li></ul></li><li>错误：1373 SQLSTATE: HY000 (ER_UNKNOWN_TARGET_BINLOG)<ul><li>消息：在binlog索引中未发现目标日志。</li></ul></li><li>错误：1374 SQLSTATE: HY000 (ER_IO_ERR_LOG_INDEX_READ)<ul><li>消息：读取日志索引文件时出现I/O错误。</li></ul></li><li>错误：1375 SQLSTATE: HY000 (ER_BINLOG_PURGE_PROHIBITED)<ul><li>消息：服务器配置不允许binlog清除。</li></ul></li><li>错误：1376 SQLSTATE: HY000 (ER_FSEEK_FAIL)<ul><li>消息：fseek()失败。</li></ul></li><li>错误：1377 SQLSTATE: HY000 (ER_BINLOG_PURGE_FATAL_ERR)<ul><li>消息：在日志清除过程中出现致命错误。</li></ul></li><li>错误：1378 SQLSTATE: HY000 (ER_LOG_IN_USE)<ul><li>消息：可清除的日志正在使用，不能清除。</li></ul></li><li>错误：1379 SQLSTATE: HY000 (ER_LOG_PURGE_UNKNOWN_ERR)<ul><li>消息：在日志清除过程中出现未知错误。</li></ul></li><li>错误：1380 SQLSTATE: HY000 (ER_RELAY_LOG_INIT)<ul><li>消息：初始化中继日志位置失败，%s</li></ul></li><li>错误：1381 SQLSTATE: HY000 (ER_NO_BINARY_LOGGING)<ul><li>消息：未使用二进制日志功能。</li></ul></li><li>错误：1382 SQLSTATE: HY000 (ER_RESERVED_SYNTAX)<ul><li>消息：’%s’语法保留给MySQL服务器内部使用。</li></ul></li><li>错误：1383 SQLSTATE: HY000 (ER_WSAS_FAILED)<ul><li>消息：WSAStartup失败。</li></ul></li><li>错误：1384 SQLSTATE: HY000 (ER_DIFF_GROUPS_PROC)<ul><li>消息：尚不能用不同的组处理过程。</li></ul></li><li>错误：1385 SQLSTATE: HY000 (ER_NO_GROUP_FOR_PROC)<ul><li>消息：对于该过程，SELECT必须有1个组。</li></ul></li><li>错误：1386 SQLSTATE: HY000 (ER_ORDER_WITH_PROC)<ul><li>消息：不能与该过程一起使用ORDER子句。</li></ul></li><li>错误：1387 SQLSTATE: HY000 (ER_LOGGING_PROHIBIT_CHANGING_OF)<ul><li>消息：二进制日志功能和复制功能禁止更改全局服务器%s。</li></ul></li><li>错误：1388 SQLSTATE: HY000 (ER_NO_FILE_MAPPING)<ul><li>消息：无法映射文件: %s, errno: %d</li></ul></li><li>错误：1389 SQLSTATE: HY000 (ER_WRONG_MAGIC)<ul><li>消息：%s中有错</li></ul></li><li>错误：1390 SQLSTATE: HY000 (ER_PS_MANY_PARAM)<ul><li>消息：预处理语句包含过多的占位符。</li></ul></li><li>错误：1391 SQLSTATE: HY000 (ER_KEY_PART_0)<ul><li>消息：键部分’%s’的长度不能为0。</li></ul></li><li>错误：1392 SQLSTATE: HY000 (ER_VIEW_CHECKSUM)<ul><li>消息：视图文本校验和失败。</li></ul></li><li>错误：1393 SQLSTATE: HY000 (ER_VIEW_MULTIUPDATE)<ul><li>消息：无法通过联合视图’%s.%s’更改1个以上的基本表。</li></ul></li><li>错误：1394 SQLSTATE: HY000 (ER_VIEW_NO_INSERT_FIELD_LIST)<ul><li>消息：不能在没有字段列表的情况下插入联合视图’%s.%s’。</li></ul></li><li>错误：1395 SQLSTATE: HY000 (ER_VIEW_DELETE_MERGE_VIEW)<ul><li>消息：不能从联合视图’%s.%s’中删除。</li></ul></li><li>错误：1396 SQLSTATE: HY000 (ER_CANNOT_USER)<ul><li>消息：对于%s的操作%s失败。</li></ul></li><li>错误：1397 SQLSTATE: XAE04 (ER_XAER_NOTA)<ul><li>消息：XAER_NOTA: 未知XID</li></ul></li><li>错误：1398 SQLSTATE: XAE05 (ER_XAER_INVAL)<ul><li>消息：XAER_INVAL: 无效参量（或不支持的命令）</li></ul></li><li>错误：1399 SQLSTATE: XAE07 (ER_XAER_RMFAIL)<ul><li>消息：XAER_RMFAIL: 当全局事务处于%s状态时，不能执行命令。</li></ul></li><li>错误：1400 SQLSTATE: XAE09 (ER_XAER_OUTSIDE)<ul><li>消息：XAER_OUTSIDE: 某些工作是在全局事务外完成的。</li></ul></li><li>错误：1401 SQLSTATE: XAE03 (ER_XAER_RMERR)<ul><li>消息：XAER_RMERR: 在事务分支中出现致命错误，请检查数据一致性。</li></ul></li><li>错误：1402 SQLSTATE: XA100 (ER_XA_RBROLLBACK)<ul><li>消息：XA_RBROLLBACK: 回滚了事务分支。</li></ul></li><li>错误：1403 SQLSTATE: 42000 (ER_NONEXISTING_PROC_GRANT)<ul><li>消息：在子程序’%s’上没有为主机’%s’上的用户’%s’定义的这类授权。</li></ul></li><li>错误：1404 SQLSTATE: HY000 (ER_PROC_AUTO_GRANT_FAIL)<ul><li>消息：无法授予EXECUTE和ALTER ROUTINE权限。</li></ul></li><li>错误：1405 SQLSTATE: HY000 (ER_PROC_AUTO_REVOKE_FAIL)<ul><li>消息：无法撤销已放弃子程序上的所有权限。</li></ul></li><li>错误：1406 SQLSTATE: 22001 (ER_DATA_TOO_LONG)<ul><li>消息：对于行%ld上的列’%s’来说，数据过长。</li></ul></li><li>错误：1407 SQLSTATE: 42000 (ER_SP_BAD_SQLSTATE)<ul><li>消息：不良SQLSTATE: ‘%s’</li></ul></li><li>错误：1408 SQLSTATE: HY000 (ER_STARTUP)<ul><li>消息：%s，连接就绪；版本，’%s’；套接字，’%s’；端口，%d %s</li></ul></li><li>错误：1409 SQLSTATE: HY000 (ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR)<ul><li>消息：不能从具有固定大小行的文件中将值加载到变量。</li></ul></li><li>错误：1410 SQLSTATE: 42000 (ER_CANT_CREATE_USER_WITH_GRANT)<ul><li>消息：不允许用GRANT创建用户。</li></ul></li><li>错误：1411 SQLSTATE: HY000 (ER_WRONG_VALUE_FOR_TYPE)<ul><li>消息：不正确的%s值，’%s’，对于函数%s</li></ul></li><li>错误：1412 SQLSTATE: HY000 (ER_TABLE_DEF_CHANGED)<ul><li>消息：表定义已更改，请再次尝试事务。</li></ul></li><li>错误：1413 SQLSTATE: 42000 (ER_SP_DUP_HANDLER)<ul><li>消息：在相同块中声明了重复句柄。</li></ul></li><li>错误：1414 SQLSTATE: 42000 (ER_SP_NOT_VAR_ARG)<ul><li>消息：子程序%s的OUT或INOUT参量不是变量。</li></ul></li><li>错误：1415 SQLSTATE: 0A000 (ER_SP_NO_RETSET)<ul><li>消息：不允许从%s返回结果集。</li></ul></li><li>错误：1416 SQLSTATE: 22003 (ER_CANT_CREATE_GEOMETRY_OBJECT)<ul><li>消息：不能从发送给GEOMETRY字段的数据中获取几何对象。</li></ul></li><li>错误：1417 SQLSTATE: HY000 (ER_FAILED_ROUTINE_BREAK_BINLOG)<ul><li>消息：1个子程序失败，在其声明没有NO SQL或READS SQL DATA，而且二进制日志功能已启用，如果更新了非事务性表，二进制日志将丢失其变化信息。</li></ul></li><li>错误：1418 SQLSTATE: HY000 (ER_BINLOG_UNSAFE_ROUTINE)<ul><li>消息：在该子程序的在其声明没有DETERMINISTIC、NO SQL或READS SQL DATA，而且二进制日志功能已启用（你或许打算使用不太安全的log_bin_trust_routine_creators变量）。</li></ul></li><li>错误：1419 SQLSTATE: HY000 (ER_BINLOG_CREATE_ROUTINE_NEED_SUPER)<ul><li>消息：你没有SUPER权限，而且二进制日志功能已启用（你或许打算使用不太安全的log_bin_trust_routine_creators变量）。</li></ul></li><li>错误：1420 SQLSTATE: HY000 (ER_EXEC_STMT_WITH_OPEN_CURSOR)<ul><li>消息：不能执行该预处理语句，该预处理语句有与之相关的打开光标。请复位语句并再次执行。</li></ul></li><li>错误：1421 SQLSTATE: HY000 (ER_STMT_HAS_NO_OPEN_CURSOR)<ul><li>消息：语句(%lu)没有打开的光标。</li></ul></li><li>错误：1422 SQLSTATE: HY000 (ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG)<ul><li>消息：在存储函数或触发程序中，不允许显式或隐式提交。</li></ul></li><li>错误：1423 SQLSTATE: HY000 (ER_NO_DEFAULT_FOR_VIEW_FIELD)<ul><li>消息：视图’%s.%s’基本表的字段没有默认值。</li></ul></li><li>错误：1424 SQLSTATE: HY000 (ER_SP_NO_RECURSION)<ul><li>消息：不允许递归存储子程序。</li></ul></li><li>错误：1425 SQLSTATE: 42000 (ER_TOO_BIG_SCALE)<ul><li>消息：为列’%s’指定了过大的标度%d。最大为%d。</li></ul></li><li>错误：1426 SQLSTATE: 42000 (ER_TOO_BIG_PRECISION)<ul><li>消息：为列’%s’指定了过高的精度%d。最大为%d。</li></ul></li><li>错误：1427 SQLSTATE: 42000 (ER_M_BIGGER_THAN_D)<ul><li>消息：对于float(M,D)、double(M,D)或decimal(M,D)，M必须&gt;= D (列’%s’)。</li></ul></li><li>错误：1428 SQLSTATE: HY000 (ER_WRONG_LOCK_OF_SYSTEM_TABLE)<ul><li>消息：不能将系统’%s.%s’表的写锁定与其他表结合起来。</li></ul></li><li>错误：1429 SQLSTATE: HY000 (ER_CONNECT_TO_FOREIGN_DATA_SOURCE)<ul><li>消息：无法连接到外部数据源，数据库’%s’！</li></ul></li><li>错误：1430 SQLSTATE: HY000 (ER_QUERY_ON_FOREIGN_DATA_SOURCE)<ul><li>消息：处理作用在外部数据源上的查询时出现问题。数据源错误：’%s’</li></ul></li><li>错误：1431 SQLSTATE: HY000 (ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST)<ul><li>消息：你试图引用的外部数据源不存在。数据源错误：’%s’</li></ul></li><li>错误：1432 SQLSTATE: HY000 (ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE)<ul><li>消息：无法创建联合表。数据源连接字符串’%s’格式不正确。</li></ul></li><li>错误：1433 SQLSTATE: HY000 (ER_FOREIGN_DATA_STRING_INVALID)<ul><li>消息：数据源连接字符串’%s’格式不正确。</li></ul></li><li>错误：1434 SQLSTATE: HY000 (ER_CANT_CREATE_FEDERATED_TABLE)<ul><li>消息：无法创建联合表。外部数据源错误：’%s’</li></ul></li><li>错误：1435 SQLSTATE: HY000 (ER_TRG_IN_WRONG_SCHEMA)<ul><li>消息：触发程序位于错误的方案中。</li></ul></li><li>错误：1436 SQLSTATE: HY000 (ER_STACK_OVERRUN_NEED_MORE)<ul><li>消息：线程堆栈溢出，%ld字节堆栈用了%ld字节，并需要%ld字节。请使用’mysqld -O thread_stack=#’指定更大的堆栈。</li></ul></li><li>错误：1437 SQLSTATE: 42000 (ER_TOO_LONG_BODY)<ul><li>消息：’%s’的子程序主体过长。</li></ul></li><li>错误：1438 SQLSTATE: HY000 (ER_WARN_CANT_DROP_DEFAULT_KEYCACHE)<ul><li>消息：无法撤销默认的keycache。</li></ul></li><li>错误：1439 SQLSTATE: 42000 (ER_TOO_BIG_DISPLAYWIDTH)<ul><li>消息：对于列’%s’，显示宽度超出范围(max = %d)</li></ul></li><li>错误：1440 SQLSTATE: XAE08 (ER_XAER_DUPID)<ul><li>消息：XAER_DUPID: XID已存在</li></ul></li><li>错误：1441 SQLSTATE: 22008 (ER_DATETIME_FUNCTION_OVERFLOW)<ul><li>消息：日期时间函数，%s字段溢出。</li></ul></li><li>错误：1442 SQLSTATE: HY000 (ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG)<ul><li>消息：由于它已被调用了该存储函数／触发程序的语句使用，不能在存储函数／触发程序中更新表’%s’。</li></ul></li><li>错误：1443 SQLSTATE: HY000 (ER_VIEW_PREVENT_UPDATE)<ul><li>消息：表’%s’的定义不允许在表’%s上执行操作%s。</li></ul></li><li>错误：1444 SQLSTATE: HY000 (ER_PS_NO_RECURSION)<ul><li>消息：预处理语句包含引用了相同语句的存储子程序调用。不允许以这类递归方式执行预处理语句。</li></ul></li><li>错误：1445 SQLSTATE: HY000 (ER_SP_CANT_SET_AUTOCOMMIT)<ul><li>消息：不允许从存储函数或触发程序设置autocommit。</li></ul></li><li>错误：1446 SQLSTATE: HY000 (ER_NO_VIEW_USER)<ul><li>消息：视图定义人不完全合格。</li></ul></li><li>错误：1447 SQLSTATE: HY000 (ER_VIEW_FRM_NO_USER)<ul><li>消息：视图%s.%s没有定义人信息（旧的表格式）。当前用户将被当作定义人。请重新创建视图！</li></ul></li><li>错误：1448 SQLSTATE: HY000 (ER_VIEW_OTHER_USER)<ul><li>消息：需要SUPER权限才能创建具有%s@%s定义器的视图。</li></ul></li><li>错误：1449 SQLSTATE: HY000 (ER_NO_SUCH_USER)<ul><li>消息：没有注册的%s@%s。</li></ul></li><li>错误：1450 SQLSTATE: HY000 (ER_FORBID_SCHEMA_CHANGE)<ul><li>消息：不允许将方案从’%s’变为’%s’。</li></ul></li><li>错误：1451 SQLSTATE: 23000 (ER_ROW_IS_REFERENCED_2)<ul><li>消息：不能删除或更新父行，外键约束失败(%s)。</li></ul></li><li>错误：1452 SQLSTATE: 23000 (ER_NO_REFERENCED_ROW_2)<ul><li>消息：不能添加或更新子行，外键约束失败(%s)。</li></ul></li><li>错误：1453 SQLSTATE: 42000 (ER_SP_BAD_VAR_SHADOW)<ul><li>消息：必须用<code>...</code>引用变量，或重新命名变量。</li></ul></li><li>错误：1454 SQLSTATE: HY000 (ER_PARTITION_REQUIRES_VALUES_ERROR)<ul><li>消息：对于每个分区，%s PARTITIONING需要VALUES %s的定义。</li></ul></li><li>错误：1455 SQLSTATE: HY000 (ER_PARTITION_WRONG_VALUES_ERROR)<ul><li>消息：在分区定义中，只有%s PARTITIONING能使用VALUES %s。</li></ul></li><li>错误：1456 SQLSTATE: HY000 (ER_PARTITION_MAXVALUE_ERROR)<ul><li>消息：MAXVALUE只能在最后1个分区定义中使用。</li></ul></li><li>错误：1457 SQLSTATE: HY000 (ER_PARTITION_SUBPARTITION_ERROR)<ul><li>消息：子分区只能是哈希分区，并按键分区。</li></ul></li><li>错误：1458 SQLSTATE: HY000 (ER_PARTITION_WRONG_NO_PART_ERROR)<ul><li>消息：定义了错误的分区数，与前面的设置不匹配。</li></ul></li><li>错误：1459 SQLSTATE: HY000 (ER_PARTITION_WRONG_NO_SUBPART_ERROR)<ul><li>消息：定义了错误的子分区数，与前面的设置不匹配。</li></ul></li><li>错误：1460 SQLSTATE: HY000 (ER_CONST_EXPR_IN_PARTITION_FUNC_ERROR)<ul><li>消息：在分区（子分区）函数中不允许使用常量／随机表达式。</li></ul></li><li>错误：1461 SQLSTATE: HY000 (ER_NO_CONST_EXPR_IN_RANGE_OR_LIST_ERROR)<ul><li>消息：RANGE/LIST VALUES中的表达式必须是常量。</li></ul></li><li>错误：1462 SQLSTATE: HY000 (ER_FIELD_NOT_FOUND_PART_ERROR)<ul><li>消息：在表中未发现分区函数字段列表中的字段。</li></ul></li><li>错误：1463 SQLSTATE: HY000 (ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR)<ul><li>消息：仅在KEY分区中允许使用字段列表。</li></ul></li><li>错误：1464 SQLSTATE: HY000 (ER_INCONSISTENT_PARTITION_INFO_ERROR)<ul><li>消息：frm文件中的分区信息与能够写入到frm文件中的不一致。</li></ul></li><li>错误：1465 SQLSTATE: HY000 (ER_PARTITION_FUNC_NOT_ALLOWED_ERROR)<ul><li>消息：%s函数返回了错误类型。</li></ul></li><li>错误：1466 SQLSTATE: HY000 (ER_PARTITIONS_MUST_BE_DEFINED_ERROR)<ul><li>消息：对于%s分区，必须定义每个分区。</li></ul></li><li>错误：1467 SQLSTATE: HY000 (ER_RANGE_NOT_INCREASING_ERROR)<ul><li>消息：对于各分区，VALUES LESS THAN值必须严格增大。</li></ul></li><li>错误：1468 SQLSTATE: HY000 (ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR)<ul><li>消息：VALUES值必须与分区函数具有相同的类型。</li></ul></li><li>错误：1469 SQLSTATE: HY000 (ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR)<ul><li>消息：Multiple definition of same constant in list partitioning</li></ul></li><li>错误：1470 SQLSTATE: HY000 (ER_PARTITION_ENTRY_ERROR)<ul><li>消息：在查询中，不能独立使用分区功能。</li></ul></li><li>错误：1471 SQLSTATE: HY000 (ER_MIX_HANDLER_ERROR)<ul><li>消息：在该MySQL版本中，不允许分区中的句柄组合。</li></ul></li><li>错误：1472 SQLSTATE: HY000 (ER_PARTITION_NOT_DEFINED_ERROR)<ul><li>消息：对于分区引擎，有必要定义所有的%s。</li></ul></li><li>错误：1473 SQLSTATE: HY000 (ER_TOO_MANY_PARTITIONS_ERROR)<ul><li>消息：定义了过多分区。</li></ul></li><li>错误：1474 SQLSTATE: HY000 (ER_SUBPARTITION_ERROR)<ul><li>消息：对于子分区，仅能将RANGE/LIST分区与HASH/KEY分区混合起来。</li></ul></li><li>错误：1475 SQLSTATE: HY000 (ER_CANT_CREATE_HANDLER_FILE)<ul><li>消息：无法创建特定的句柄文件。</li></ul></li><li>错误：1476 SQLSTATE: HY000 (ER_BLOB_FIELD_IN_PART_FUNC_ERROR)<ul><li>消息：在分区函数中，不允许使用BLOB字段。</li></ul></li><li>错误：1477 SQLSTATE: HY000 (ER_CHAR_SET_IN_PART_FIELD_ERROR)<ul><li>消息：如果为分区函数选择了二进制校对，才允许使用VARCHAR。</li></ul></li><li>错误：1478 SQLSTATE: HY000 (ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF)<ul><li>消息：在分区函数中，%s需要包含所有文件。</li></ul></li><li>错误：1479 SQLSTATE: HY000 (ER_NO_PARTS_ERROR)<ul><li>消息：%s的数目= 0不是允许的值。</li></ul></li><li>错误：1480 SQLSTATE: HY000 (ER_PARTITION_MGMT_ON_NONPARTITIONED)<ul><li>消息：无法在非分区表上进行分区管理。</li></ul></li><li>错误：1481 SQLSTATE: HY000 (ER_DROP_PARTITION_NON_EXISTENT)<ul><li>消息：分区列表中的错误出现变化。</li></ul></li><li>错误：1482 SQLSTATE: HY000 (ER_DROP_LAST_PARTITION)<ul><li>消息：不能删除所有分区，请使用DROP TABLE取而代之。</li></ul></li><li>错误：1483 SQLSTATE: HY000 (ER_COALESCE_ONLY_ON_HASH_PARTITION)<ul><li>消息：COALESCE PARTITION仅能在HASH/KEY分区上使用。</li></ul></li><li>错误：1484 SQLSTATE: HY000 (ER_ONLY_ON_RANGE_LIST_PARTITION)<ul><li>消息：%s PARTITION仅能在RANGE/LIST分区上使用。</li></ul></li><li>错误：1485 SQLSTATE: HY000 (ER_ADD_PARTITION_SUBPART_ERROR)<ul><li>消息：试图用错误的子分区数增加分区。</li></ul></li><li>错误：1486 SQLSTATE: HY000 (ER_ADD_PARTITION_NO_NEW_PARTITION)<ul><li>消息：必须至少添加1个分区。</li></ul></li><li>错误：1487 SQLSTATE: HY000 (ER_COALESCE_PARTITION_NO_PARTITION)<ul><li>消息：必须至少合并1个分区。</li></ul></li><li>错误：1488 SQLSTATE: HY000 (ER_REORG_PARTITION_NOT_EXIST)<ul><li>消息：重组的分区数超过了已有的分区数。</li></ul></li><li>错误：1489 SQLSTATE: HY000 (ER_SAME_NAME_PARTITION)<ul><li>消息：在表中，所有分区必须有唯一的名称。</li></ul></li><li>错误：1490 SQLSTATE: HY000 (ER_CONSECUTIVE_REORG_PARTITIONS)<ul><li>消息：重组分区集合时，它们必须连续。</li></ul></li><li>错误：1491 SQLSTATE: HY000 (ER_REORG_OUTSIDE_RANGE)<ul><li>消息：新分区的范围超过了已重组分区的范围。</li></ul></li><li>错误：1492 SQLSTATE: HY000 (ER_DROP_PARTITION_FAILURE)<ul><li>消息：在该版本的句柄中，不支持撤销分区。</li></ul></li><li>错误：1493 SQLSTATE: HY000 (ER_DROP_PARTITION_WHEN_FK_DEFINED)<ul><li>消息：在表上定义了外键约束时，不能舍弃分区。</li></ul></li><li>错误：1494 SQLSTATE: HY000 (ER_PLUGIN_IS_NOT_LOADED)<ul><li>消息：未加载插件’%s’<br>B.2. 客户端错误代码和    - 消息<br>客户端错误信息来自下述源文件：</li></ul></li><li>圆括号中的错误值和符号与include/errmsg.h MySQL源文件中的定义对应。</li><li><pre><code>- 消息值与libmysql/errmsg.c文件中列出的错误    - 消息对应。%d和%s分别代表数值和字符串，显示时，它们将被    - 消息值取代。</code></pre>由于更新很频繁，这些文件中可能包含这里未列出的额外错误    - 消息。</li><li>错误：2000 (CR_UNKNOWN_ERROR)<ul><li>消息：未知MySQL错误。</li></ul></li><li>错误：2001 (CR_SOCKET_CREATE_ERROR)<ul><li>消息：不能创建UNIX套接字(%d)</li></ul></li><li>错误：2002 (CR_CONNECTION_ERROR)<ul><li>消息：不能通过套接字’%s’ (%d)连接到本地MySQL服务器。</li></ul></li><li>错误：2003 (CR_CONN_HOST_ERROR)<ul><li>消息：不能连接到’%s’ (%d)上的MySQL服务器。</li></ul></li><li>错误：2004 (CR_IPSOCK_ERROR)<ul><li>消息：不能创建TCP/IP套接字(%d)</li></ul></li><li>错误：2005 (CR_UNKNOWN_HOST)<ul><li>消息：未知的MySQL服务器主机’%s’ (%d)</li></ul></li><li>错误：2006 (CR_SERVER_GONE_ERROR)<ul><li>消息：MySQL服务器不可用。</li></ul></li><li>错误：2007 (CR_VERSION_ERROR)<ul><li>消息：协议不匹配，服务器版本= %d，客户端版本= %d</li></ul></li><li>错误：2008 (CR_OUT_OF_MEMORY)<ul><li>消息：MySQL客户端内存溢出。</li></ul></li><li>错误：2009 (CR_WRONG_HOST_INFO)<ul><li>消息：错误的主机信息</li></ul></li><li>错误：2010 (CR_LOCALHOST_CONNECTION)<ul><li>消息：通过UNIX套接字连接的本地主机。</li></ul></li><li>错误：2011 (CR_TCP_CONNECTION)<ul><li>消息：%s，通过TCP/IP</li></ul></li><li>错误：2012 (CR_SERVER_HANDSHAKE_ERR)<ul><li>消息：服务器握手过程中出错。</li></ul></li><li>错误：2013 (CR_SERVER_LOST)<ul><li>消息：查询过程中丢失了与MySQL服务器的连接。</li></ul></li><li>错误：2014 (CR_COMMANDS_OUT_OF_SYNC)<ul><li>消息：命令不同步，你现在不能运行该命令。</li></ul></li><li>错误：2015 (CR_NAMEDPIPE_CONNECTION)<ul><li>消息：命名管道，%s</li></ul></li><li>错误：2016 (CR_NAMEDPIPEWAIT_ERROR)<ul><li>消息：无法等待命名管道，主机，%s；管道，%s (%lu)</li></ul></li><li>错误：2017 (CR_NAMEDPIPEOPEN_ERROR)<ul><li>消息：无法打开命名管道，主机，%s；管道，%s (%lu)</li></ul></li><li>错误：2018 (CR_NAMEDPIPESETSTATE_ERROR)<ul><li>消息：无法设置命名管道的状态，主机，%s；管道，%s (%lu)</li></ul></li><li>错误：2019 (CR_CANT_READ_CHARSET)<ul><li>消息：无法初始化字符集%s (路径：%s)</li></ul></li><li>错误：2020 (CR_NET_PACKET_TOO_LARGE)<ul><li>消息：获得的信息包大于’max_allowed_packet’字节。</li></ul></li><li>错误：2021 (CR_EMBEDDED_CONNECTION)<ul><li>消息：嵌入式服务器。</li></ul></li><li>错误：2022 (CR_PROBE_SLAVE_STATUS)<ul><li>消息：SHOW SLAVE STATUS出错：</li></ul></li><li>错误：2023 (CR_PROBE_SLAVE_HOSTS)<ul><li>消息：SHOW SLAVE HOSTS出错：</li></ul></li><li>错误：2024 (CR_PROBE_SLAVE_CONNECT)<ul><li>消息：连接到从服务器时出错：</li></ul></li><li>错误：2025 (CR_PROBE_MASTER_CONNECT)<ul><li>消息：连接到主服务器时出错：</li></ul></li><li>错误：2026 (CR_SSL_CONNECTION_ERROR)<ul><li>消息：SSL连接错误</li></ul></li><li>错误：2027 (CR_MALFORMED_PACKET)<ul><li>消息：残缺信息包。</li></ul></li><li>错误：2028 (CR_WRONG_LICENSE)<ul><li>消息：该客户端库仅授权给具有’%s’许可的MySQL服务器使用。</li></ul></li><li>错误：2029 (CR_NULL_POINTER)<ul><li>消息：空指针的无效使用。</li></ul></li><li>错误：2030 (CR_NO_PREPARE_STMT)<ul><li>消息：语句未准备好。</li></ul></li><li>错误：2031 (CR_PARAMS_NOT_BOUND)<ul><li>消息：没有为预处理语句中的参数提供数据。</li></ul></li><li>错误：2032 (CR_DATA_TRUNCATED)<ul><li>消息：数据截短。</li></ul></li><li>错误：2033 (CR_NO_PARAMETERS_EXISTS)<ul><li>消息：语句中不存在任何参数。</li></ul></li><li>错误：2034 (CR_INVALID_PARAMETER_NO)<ul><li>消息：无效的参数编号。</li></ul></li><li>错误：2035 (CR_INVALID_BUFFER_USE)<ul><li>消息：不能为非字符串／非二进制数据类型发送长数据（参数：%d）。</li></ul></li><li>错误：2036 (CR_UNSUPPORTED_PARAM_TYPE)<ul><li>消息：正使用不支持的缓冲区类型， %d （参数：%d）</li></ul></li><li>错误：2037 (CR_SHARED_MEMORY_CONNECTION)<ul><li>消息：共享内存，%s</li></ul></li><li>错误：2038 (CR_SHARED_MEMORY_CONNECT_REQUEST_ERROR)<ul><li>消息：不能打开共享内存，客户端不能创建请求事件(%lu)</li></ul></li><li>错误：2039 (CR_SHARED_MEMORY_CONNECT_ANSWER_ERROR)<ul><li>消息：不能打开共享内存，未收到服务器的应答事件(%lu)</li></ul></li><li>错误：2040 (CR_SHARED_MEMORY_CONNECT_FILE_MAP_ERROR)<ul><li>消息：不能打开共享内存，服务器不能分配文件映射(%lu)</li></ul></li><li>错误：2041 (CR_SHARED_MEMORY_CONNECT_MAP_ERROR)<ul><li>消息：不能打开共享内存，服务器不能获得文件映射的指针(%lu)</li></ul></li><li>错误：2042 (CR_SHARED_MEMORY_FILE_MAP_ERROR)<ul><li>消息：不能打开共享内存，客户端不能分配文件映射(%lu)</li></ul></li><li>错误：2043 (CR_SHARED_MEMORY_MAP_ERROR)<ul><li>消息：不能打开共享内存，客户端不能获得文件映射的指针(%lu)</li></ul></li><li>错误：2044 (CR_SHARED_MEMORY_EVENT_ERROR)<ul><li>消息：不能打开共享内存，客户端不能创建%s事件(%lu)</li></ul></li><li>错误：2045 (CR_SHARED_MEMORY_CONNECT_ABANDONED_ERROR)<ul><li>消息：不能打开共享内存，无来自服务器的应答 (%lu)</li></ul></li><li>错误：2046 (CR_SHARED_MEMORY_CONNECT_SET_ERROR)<ul><li>消息：不能打开共享内存，不能将请求事件发送到服务器(%lu)</li></ul></li><li>错误：2047 (CR_CONN_UNKNOW_PROTOCOL)<ul><li>消息：错误或未知协议</li></ul></li><li>错误：2048 (CR_INVALID_CONN_HANDLE)<ul><li>消息：无效的连接句柄</li></ul></li><li>错误：2049 (CR_SECURE_AUTH)<ul><li>消息：拒绝使用旧鉴定协议（早于4.1.1）的连接（开启了客户端’secure_auth’选项）。</li></ul></li><li>错误：2050 (CR_FETCH_CANCELED)<ul><li>消息：行检索被mysql_stmt_close()调用取消。</li></ul></li><li>错误：2051 (CR_NO_DATA)<ul><li>消息：在未事先获取行的情况下试图读取列。</li></ul></li><li>错误：2052 (CR_NO_STMT_METADATA)<ul><li>消息：预处理语句不含元数据。</li></ul></li><li>错误：2053 (CR_NO_RESULT_SET)<ul><li>消息：在没有与语句相关的结果集时试图读取行。</li></ul></li><li>错误：2054 (CR_NOT_IMPLEMENTED)<ul><li>消息：该特性尚未实施。 </li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> mysql </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Oracle错误码大全</title>
      <link href="/2019/11/13/database/oracle%E9%94%99%E8%AF%AF%E7%A0%81%E5%A4%A7%E5%85%A8/"/>
      <url>/2019/11/13/database/oracle%E9%94%99%E8%AF%AF%E7%A0%81%E5%A4%A7%E5%85%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="oracle错误码大全"><a href="#oracle错误码大全" class="headerlink" title="oracle错误码大全"></a>oracle错误码大全</h1><ul><li>本篇文章是对oracle错误代码进行了详细的总结与分析，需要的朋友参考下:</li><li>ORA-00001: 违反唯一约束条件 (.)</li><li>ORA-00017: 请求会话以设置跟踪事件</li><li>ORA-00018: 超出最大会话数</li><li>ORA-00019: 超出最大会话许可数</li><li>ORA-00020: 超出最大进程数 ()</li><li>ORA-00021: 会话附属于其它某些进程；无法转换会话</li></ul><span id="more"></span><ul><li>ORA-00022: 无效的会话 ID；访问被拒绝</li><li>ORA-00023: 会话引用进程私用内存；无法分离会话</li><li>ORA-00024: 单一进程模式下不允许从多个进程注册</li><li>ORA-00025: 无法分配</li><li>ORA-00026: 丢失或无效的会话 ID</li><li>ORA-00027: 无法删去当前会话</li><li>ORA-00028: 您的会话己被删去</li><li>ORA-00029: 会话不是用户会话</li><li>ORA-00030: 用户会话 ID 不存在。</li><li>ORA-00031: 标记要删去的会话</li><li>ORA-00032: 无效的会话移植口令</li><li>ORA-00033: 当前的会话具有空的移植口令</li><li>ORA-00034: 无法在当前 PL/SQL 会话中</li><li>ORA-00035: LICENSE_MAX_USERS 不能小于当前用户数</li><li>ORA-00036: 超过递归SQL() 级的最大值</li><li>ORA-00037: 无法转换到属于不同服务器组的会话</li><li>ORA-00038: 无法创建会话: 服务器组属于其它用户</li><li>ORA-00050: 获取入队时操作系统出错</li><li>ORA-00051: 等待资源超时</li><li>ORA-00052: 超出最大入队资源数 ()</li><li>ORA-00053: 超出最大入队数</li><li>ORA-00054: 资源正忙，要求指定 NOWAIT</li><li>ORA-00055: 超出 DML 锁的最大数</li><li>ORA-00056: 对象 ‘.’ 上的 DDL 锁以不兼容模式挂起</li><li>ORA-00057: 超出临时表锁的最大数</li><li>ORA-00058: DB_BLOCK_SIZE 必须为才可安装此数据库(非 )</li><li>ORA-00059: 超出 DB_FILES 的最大值</li><li>ORA-00060: 等待资源时检测到死锁</li><li>ORA-00061: 另一个例程设置了不同的 DML_LOCKS</li><li>ORA-00062: 无法获得 DML 全表锁定；DML_LOCKS 为 0</li><li>ORA-00063: 超出 LOG_FILES 的最大数</li><li>ORA-00064: 对象过大以至无法分配在此 O/S (，)</li><li>ORA-00065: FIXED_DATE 的初始化失败</li><li>ORA-00066: LOG_FILES 为 但需要成为 才可兼容</li><li>ORA-00067: 值 对参数 无效；至少必须为</li><li>ORA-00068: 值 对参数 无效，必须在 和 之间</li><li>ORA-00069: 无法获得锁定 – 禁用了表锁定</li><li>ORA-00070: 命令无效</li><li>ORA-00071: 进程号必须介于 1 和 之间</li><li>ORA-00072: 进程””不活动</li><li>ORA-00073: 命令 介于 和 个参数之间时使用</li><li>ORA-00074: 未指定进程</li><li>ORA-00075: 在此例程未找到进程 “”</li><li>ORA-00076: 未找到转储</li><li>ORA-00077: 转储 无效</li><li>ORA-00078: 无法按名称转储变量</li><li>ORA-00079: 未找到变量</li><li>ORA-00080: 层次 指定的全局区域无效</li><li>ORA-00081: 地址范围 [，) 不可读</li><li>ORA-00082: 的内存大小不在有效集合 [1], [2], [4] 之内</li><li>ORA-00083: 警告: 可能损坏映射的 SGA</li><li>ORA-00084: 全局区域必须为 PGA, SGA 或 UGA</li><li>ORA-00085: 当前调用不存在</li><li>ORA-00086: 用户调用不存在</li><li>ORA-00087: 命令无法在远程例程上执行</li><li>ORA-00088: 共享服务器无法执行命令</li><li>ORA-00089: ORADEBUG 命令中无效的例程号</li><li>ORA-00090: 未能将内存分配给群集数据库 ORADEBUG 命令</li><li>ORA-00091: LARGE_POOL_SIZE 至少必须为</li><li>ORA-00092: LARGE_POOL_SIZE 必须大于 LARGE_POOL_MIN_ALLOC</li><li>ORA-00093: 必须介于 和 之间</li><li>ORA-00094: 要求整数值</li><li>ORA-00096: 值 对参数 无效，它必须来自 之间</li><li>ORA-00097: 使用 Oracle SQL 特性不在 SQL92 级中</li><li>ORA-00099: 等待资源时发生超时，可能是 PDML 死锁所致</li><li>ORA-00100: 未找到数据</li><li>ORA-00101: 系统参数 DISPATCHERS 的说明无效</li><li>ORA-00102: 调度程序无法使用网络协议</li><li>ORA-00103: 无效的网络协议；供调度程序备用</li><li>ORA-00104: 检测到死锁；全部公用服务器已锁定等待资源</li><li>ORA-00105: 未配置网络协议 的调度机制</li><li>ORA-00106: 无法在连接到调度程序时启动/关闭数据库</li><li>ORA-00107: 无法连接到 ORACLE 监听器进程</li><li>ORA-00108: 无法设置调度程序以同步进行连接</li><li>ORA-00111: 由于服务器数目限制在 , 所以没有启动所有服务器</li><li>ORA-00112: 仅能创建多达 (最多指定) 个调度程序</li><li>ORA-00113: 协议名 过长</li><li>ORA-00114: 缺少系统参数 SERVICE_NAMES 的值</li><li>ORA-00115: 连接被拒绝；调度程序连接表已满</li><li>ORA-00116: SERVICE_NAMES 名过长</li><li>ORA-00117: 系统参数 SERVICE_NAMES 的值超出范围</li><li>ORA-00118: 系统参数 DISPATCHERS 的值超出范围</li><li>ORA-00119: 系统参数 的说明无效</li><li>ORA-00120: 未启用或安装调度机制</li><li>ORA-00121: 在缺少 DISPATCHERS 的情况下指定了 SHARED_SERVERS</li><li>ORA-00122: 无法初始化网络配置</li><li>ORA-00123: 空闲公用服务器终止</li><li>ORA-00124: 在缺少 MAX_SHARED_SERVERS 的情况下指定了 DISPATCHERS</li><li>ORA-00125: 连接被拒绝；无效的演示文稿</li><li>ORA-00126: 连接被拒绝；无效的重复</li><li>ORA-00127: 调度进程 不存在</li><li>ORA-00128: 此命令需要调度进程名</li><li>ORA-00129: 监听程序地址验证失败 ‘’</li><li>ORA-00130: 监听程序地址 ‘’ 无效</li><li>ORA-00131: 网络协议不支持注册 ‘’</li><li>ORA-00132: 语法错误或无法解析的网络名称 ‘’</li><li>ORA-00150: 重复的事务处理 ID</li><li>ORA-00151: 无效的事务处理 ID</li><li>ORA-00152: 当前会话与请求的会话不匹配</li><li>ORA-00153: XA 库中的内部错误</li><li>ORA-00154: 事务处理监视器中的协议错误</li><li>ORA-00155: 无法在全局事务处理之外执行工作</li><li>ORA-00160: 全局事务处理长度 超出了最大值 ()</li><li>ORA-00161: 事务处理的分支长度 非法 (允许的最大长度为 )</li><li>ORA-00162: 外部 dbid 的长度 超出了最大值 ()</li><li>ORA-00163: 内部数据库名长度 超出了最大值 ()</li><li>ORA-00164: 在分布式事务处理中不允许独立的事务处理</li><li>ORA-00165: 不允许对远程操作进行可移植分布式自治转换</li><li>ORA-00200: 无法创建控制文件</li><li>ORA-00201: 控制文件版本 与 ORACLE 版本 不兼容</li><li>ORA-00202: 控制文件: ‘’</li><li>ORA-00203: 使用错误的控制文件</li><li>ORA-00204: 读控制文件时出错 (块 ，# 块 )</li><li>ORA-00205: 标识控制文件出错，有关详情，请检查警告日志</li><li>ORA-00206: 写控制文件时出错 (块 ，# 块 )</li><li>ORA-00207: 控制文件不能用于同一数据库</li><li>ORA-00208: 控制文件的名称数超出限制</li><li>ORA-00209: 控制文件块大小不匹配，有关详情，请检查警告日志</li><li>ORA-00210: 无法打开指定的控制文件</li><li>ORA-00211: 控制文件与先前的控制文件不匹配</li><li>ORA-00212: 块大小 低于要求的最小大小 ( 字节)</li><li>ORA-00213: 不能重新使用控制文件；原文件大小为 ，还需</li><li>ORA-00214: 控制文件 ‘’ 版本 与文件 ‘’ 版本 不一致</li><li>ORA-00215: 必须至少存在一个控制文件</li><li>ORA-00216: 无法重新调整从 8.0.2 移植的控制文件大小</li><li>ORA-00217: 从 9.0.1 进行移植无法重新调整控制文件的大小</li><li>ORA-00218: 控制文件的块大小 与 DB_BLOCK_SIZE () 不匹配</li><li>ORA-00219: 要求的控制文件大小 超出了允许的最大值</li><li>ORA-00220: 第一个例程未安装控制文件，有关详情，请检查警告日志</li><li>ORA-00221: 写入控制文件出错</li><li>ORA-00222: 操作将重新使用当前已安装控制文件的名称</li><li>ORA-00223: 转换文件无效或版本不正确</li><li>ORA-00224: 控制文件重设大小尝试使用非法记录类型 ()</li><li>ORA-00225: 控制文件的预期大小 与实际大小 不同</li><li>ORA-00226: 备用控制文件打开时不允许进行操作</li><li>ORA-00227: 控制文件中检测到损坏的块: (块 ，# 块 )</li><li>ORA-00228: 备用控制文件名长度超出了最大长度</li><li>ORA-00229: 操作不允许: 已挂起快照控制文件入队</li><li>ORA-00230: 操作不允许: 无法使用快照控制文件入队</li><li>ORA-00231: 快照控制文件未命名</li><li>ORA-00232: 快照控制文件不存在, 已损坏或无法读取</li><li>ORA-00233: 控制文件副本已损坏或无法读取</li><li>ORA-00234: 标识或打开快照或复制控制文件时出错</li><li>ORA-00235: 控制文件固定表因并发更新而不一致</li><li>ORA-00236: 快照操作不允许: 挂上的控制文件为备份文件</li><li>ORA-00237: 快照操作不允许: 控制文件新近创建</li><li>ORA-00238: 操作将重用属于数据库一部分的文件名</li><li>ORA-00250: 未启动存档器</li><li>ORA-00251: LOG_ARCHIVE_DUPLEX_DEST 不能是与字符串 相同的目的地</li><li>ORA-00252: 日志 在线程 上为空，无法存档</li><li>ORA-00253: 字符限制在 以内，归档目的字符串 超出此限制</li><li>ORA-00254: 存档控制字符串 ‘’ 时出错</li><li>ORA-00255: 存档日志 (线程 , 序列 # ) 时出错</li><li>ORA-00256: 无法翻译归档目的字符串</li><li>ORA-00257: 存档器错误。在释放之前仅限于内部连接</li><li>ORA-00258: NOARCHIVELOG 模式下的人工存档必须标识日志</li><li>ORA-00259: 日志 (打开线程 ) 为当前日志，无法存档</li><li>ORA-00260: 无法找到联机日志序列 (线程 )</li><li>ORA-00261: 正在存档或修改日志 (线程 )</li><li>ORA-00262: 当前日志 (关闭线程 ) 无法切换</li><li>ORA-00263: 线程 没有需要存档的记录</li><li>ORA-00264: 不要求恢复</li><li>ORA-00265: 要求例程恢复，无法设置 ARCHIVELOG 模式</li><li>ORA-00266: 需要存档日志文件名</li><li>ORA-00267: 无需存档日志文件名</li><li>ORA-00268: 指定的日志文件不存在 ‘’</li><li>ORA-00269: 指定的日志文件为线程 的一部分 (非 )</li><li>ORA-00270: 创建存档日志 时出错</li><li>ORA-00271: 没有需要存档的日志</li><li>ORA-00272: 写存档日志 时出错</li><li>ORA-00273: 未记录的直接加载数据的介质恢复</li><li>ORA-00274: 非法恢复选项</li><li>ORA-00275: 已经开始介质恢复</li><li>ORA-00276: CHANGE 关键字已指定但未给出更改编号</li><li>ORA-00277: UNTIL 恢复标志 的非法选项</li><li>ORA-00278: 此恢复不再需要日志文件 ‘’</li><li>ORA-00279: 更改 (在 生成) 对于线程 是必需的</li><li>ORA-00280: 更改 对于线程 是按序列 # 进行的</li><li>ORA-00281: 不能使用调度进程执行介质恢复</li><li>ORA-00282: UPI 调用不被支持，请使用 ALTER DATABASE RECOVER</li><li>ORA-00283: 恢复会话因错误而取消</li><li>ORA-00284: 恢复会话仍在进行</li><li>ORA-00285: TIME 未作为字符串常数给出</li><li>ORA-00286: 无可用成员，或成员无有效数据</li><li>ORA-00287: 未找到指定的更改编号 (在线程 中)</li><li>ORA-00288: 要继续恢复，请键入 ALTER DATABASE RECOVER CONTINUE</li><li>ORA-00289: 建议:</li><li>ORA-00290: 操作系统出现存档错误。请参阅下面的错误</li><li>ORA-00291: PARALLEL 选项要求数字值</li><li>ORA-00292: 未安装并行恢复功能</li><li>ORA-00293: 控制文件与重做日志不同步</li><li>ORA-00294: 无效的存档日志格式标识 ‘’</li><li>ORA-00295: 数据文件号 无效，必须介于 1 与 之间</li><li>ORA-00296: 已超出 RECOVER DATAFILE LIST 的最大文件数 ()</li><li>ORA-00297: 必须在 RECOVER DATAFILE START 之前指定 RECOVER DATAFILE LIST</li><li>ORA-00298: 丢失或无效的 TIMEOUT 间隔</li><li>ORA-00299: 必须在数据文件 上使用文件级介质恢复</li><li>ORA-00300: 指定的重做日志块大小 非法 - 超出限制</li><li>ORA-00301: 添加日志文件 ‘’ 时出错 - 无法创建文件</li><li>ORA-00302: 日志超出限制</li><li>ORA-00303: 无法处理多次中断的重做</li><li>ORA-00304: 请求的 INSTANCE_NUMBER 在使用中</li><li>ORA-00305: 日志 (线程 ) 不一致；属于另一个数据库</li><li>ORA-00306: 此数据库中的例程限制</li><li>ORA-00307: 请求的 INSTANCE_NUMBER 超出限制，最大为</li><li>ORA-00308: 无法打开存档日志 ‘’</li><li>ORA-00309: 日志属于错误的数据库</li><li>ORA-00310: 存档日志包含序列 ；要求序列</li><li>ORA-00311: 无法从存档日志读取标题</li><li>ORA-00312: 联机日志 线程 : ‘’</li><li>ORA-00313: 无法打开日志组 (线程 ) 的成员</li><li>ORA-00314: 日志 (线程 )，预计序号 与 不匹配</li><li>ORA-00315: 日志 (线程 )，标题中的线程 # 错误</li><li>ORA-00316: 日志 (线程 )，标题中的类型 不是日志文件</li><li>ORA-00317: 标题中的文件类型 不是日志文件</li><li>ORA-00318: 日志 (线程 )，预计文件大小 与 不匹配</li><li>ORA-00319: 日志 (线程 ) 具有错误的日志重置状态</li><li>ORA-00320: 无法从日志 (线程 ) 读取文件标题</li><li>ORA-00321: 日志 (线程 )，无法更新日志文件标题</li><li>ORA-00322: 日志 (线程 ) 不是当前副本</li><li>ORA-00323: 线程 的当前日志不可用而所有其它日志均需要存档</li><li>ORA-00324: 日志文件 ‘’ 的翻译名 ‘’ 太长， 字符超出 限制</li><li>ORA-00325: 已归档线程 的日志，标题中的线程 # 错误</li><li>ORA-00326: 日志在更改 开始，需要更早的更改</li><li>ORA-00327: 日志 (线程 )，实际大小 小于需要的</li><li>ORA-00328: 归档日志在更改 结束，需要稍后的更改</li><li>ORA-00329: 归档日志在更改 开始，需要更改</li><li>ORA-00330: 归档日志在更改 结束，需要更改</li><li>ORA-00331: 日志版本 与 ORACLE 版本 不兼容</li><li>ORA-00332: 归档日志过小 - 可能未完全归档</li><li>ORA-00333: 重做日志读取块 计数 出错</li><li>ORA-00334: 归档日志: ‘’</li><li>ORA-00335: 联机日志 : 没有此编号的日志，日志不存在</li><li>ORA-00336: 大小为 的日志文件块数小于最小 块数</li><li>ORA-00337: 日志文件 ‘’ 不存在且未指定大小</li><li>ORA-00338: 日志 (线程 ) 比控制文件更新</li><li>ORA-00339: 归档日志未包含任何重做</li><li>ORA-00340: 处理联机日志 (线程 ) 时出现 I/O 错误</li><li>ORA-00341: 日志 (线程 )，标题中的日志 # 错误</li><li>ORA-00342: 归档日志在上一个 RESETLOGS 之前创建程序包</li><li>ORA-00343: 错误过多，已关闭日志成员</li><li>ORA-00344: 无法重新创建联机日志 ‘’</li><li>ORA-00345: 重做日志写入块 计数 出错</li><li>ORA-00346: 日志成员标记为 STALE</li><li>ORA-00347: 日志 (线程 )，预计块大小 与 不匹配</li><li>ORA-00348: 单一进程重做失败；必须中止例程</li><li>ORA-00349: 无法获得 ‘’ 的块大小</li><li>ORA-00350: 日志 (线程 ) 中需要归档</li><li>ORA-00351: recover-to 时间无效</li><li>ORA-00352: 线程 的所有日志均需要归档 - 无法启用</li><li>ORA-00353: 日志损坏接近块 更改 时间</li><li>ORA-00354: 损坏重做日志块标题</li><li>ORA-00355: 更改编号无次序</li><li>ORA-00356: 更改说明中的长度不一致</li><li>ORA-00357: 日志文件指定了过多成员，最大为</li><li>ORA-00358: 指定了过多文件成员，最大为</li><li>ORA-00359: 日志文件组 不存在</li><li>ORA-00360: 非日志文件成员:</li><li>ORA-00361: 无法删除最后一个日志成员 (组 )</li><li>ORA-00362: 组成组 中的有效日志文件要求输入成员</li><li>ORA-00363: 日志不是归档版本</li><li>ORA-00364: 无法将标题写入新日志成员</li><li>ORA-00365: 指定日志不是正确的下一个日志</li><li>ORA-00366: 日志 (线程 )，文件标题中的校验和错误</li><li>ORA-00367: 日志文件标题中的校验和错误</li><li>ORA-00368: 重做日志块中的校验和错误</li><li>ORA-00369: 线程 的当前日志不可用且其它日志已被清除</li><li>ORA-00370: Rcbchange 操作过程中可能出现死锁</li><li>ORA-00371: 共享池内存不足</li><li>ORA-00372: 此时无法修改文件</li><li>ORA-00373: 联机日志版本 与 ORACLE 版本 不兼容</li><li>ORA-00374: 参数 db_block_size = 无效; 它必须是 的倍数, 范围为 [..]</li><li>ORA-00375: 无法获得默认 db_block_size</li><li>ORA-00376: 此时无法读取文件</li><li>ORA-00377: 文件 的频繁备份导致写操作延迟</li><li>ORA-00378: 无法按指定创建缓冲池</li><li>ORA-00379: 缓冲池 中无法提供 K 块大小的空闲缓冲区</li><li>ORA-00380: 无法指定 db_k_cache_size, 因为 K 是标准块大小</li><li>ORA-00381: 无法将新参数和旧参数同时用于缓冲区高速缓存的大小说明</li><li>ORA-00382: 不是有效的块大小, 有效范围为 [..]</li><li>ORA-00383: DEFAULT 高速缓存的块大小 不能减少至零</li><li>ORA-00384: 没有足够的内存来增加高速缓存的大小</li><li>ORA-00385: cannot enable Very Large Memory with new buffer cache parameters</li><li>ORA-00390: 日志 (线程 ) 正被清除，无法成为当前日志</li><li>ORA-00391: 所有线程必须同时转换为新的日志格式</li><li>ORA-00392: 日志 (线程 ) 正被清除，不允许操作</li><li>ORA-00393: 脱机数据文件的恢复需要日志 (线程 )</li><li>ORA-00394: 在尝试存档时重新使用联机日志</li><li>ORA-00395: ‘克隆’ 数据库的联机日志必须重命名</li><li>ORA-00396: 错误 需要退回到单次遍历恢复</li><li>ORA-00397: 对于文件 (块 ), 检测到写入丢失情况</li><li>ORA-00398: 由于重新配置而中止了线程恢复</li><li>ORA-00399: 重做日志中的更改说明已损坏</li><li>ORA-00400: 无效的版本值 (对于参数 )</li><li>ORA-00401: 此版本不支持参数 的值</li><li>ORA-00402: 版本 的数据库更改无法用于版本</li><li>ORA-00403: () 不同于其它例程 ()</li><li>ORA-00404: 未找到转换文件: ‘’</li><li>ORA-00405: 兼容类型””</li><li>ORA-00406: COMPATIBLE 参数需要为 或更大</li><li>ORA-00407: 不允许从版本 . 到 . 滚动升级</li><li>ORA-00408: 参数 设置为 TRUE</li><li>ORA-00409: COMPATIBLE 必须是 或更高值才能使用 AUTO SEGMENT SPACE MANAGEMENT</li><li>ORA-00436: 没有 ORACLE软件使用权，请与 Oracle 公司联系获得帮助</li><li>ORA-00437: 没有 ORACLE 软件功能使用权，请与 Oracle 公司联系获得帮助</li><li>ORA-00438: 未安装 选项</li><li>ORA-00439: 未启用特性:</li><li>ORA-00443: 背景进程 “” 未启动</li><li>ORA-00444: 背景进程 “” 启动时失败</li><li>ORA-00445: 背景进程 “” 在 秒之后仍没有启动</li><li>ORA-00446: 背景进程意外启动</li><li>ORA-00447: 背景进程出现致命错误</li><li>ORA-00448: 背景进程正常结束</li><li>ORA-00449: 背景进程 ‘’ 因错误 异常终止</li><li>ORA-00470: LGWR 进程因错误而终止</li><li>ORA-00471: DBWR 进程因错误而终止</li><li>ORA-00472: PMON 进程因错误而终止</li><li>ORA-00473: ARCH 进程因错误而终止</li><li>ORA-00474: SMON 进程因错误而终止</li><li>ORA-00475: TRWR 进程因错误而终止</li><li>ORA-00476: RECO 进程因错误而终止</li><li>ORA-00477: SNP* 进程因错误而终止</li><li>ORA-00478: SMON 进程由于 错误终止</li><li>ORA-00480: LCK* 进程因错误而终止</li><li>ORA-00481: LMON 进程因错误而终止</li><li>ORA-00482: LMD* 进程因错误而终止</li><li>ORA-00483: 关闭进程过程中异常终止</li><li>ORA-00484: LMS* 进程因错误而终止</li><li>ORA-00485: DIAG 进程由于 错误终止</li><li>ORA-00486: 功能不可用</li><li>ORA-00568: 超出中断处理程序的最大数</li><li>ORA-00574: osndnt: $CANCEL 失败 (中断)</li><li>ORA-00575: osndnt: $QIO 失败 (发送 out-of-band 中断)</li><li>ORA-00576: 带内中断协议错误</li><li>ORA- 00577: 带外中断协议错误</li><li>ORA-00578: 重置协议错误</li><li>ORA-00579: osndnt: 服务器收到连接请求格式不正确</li><li>ORA-00580: 协议版本不匹配</li><li>ORA-00581: osndnt: 无法分配上下文区域</li><li>ORA-00582: osndnt: 无法撤消分配上下文区域</li><li>ORA-00583: osndnt: $TRNLOG 失败</li><li>ORA-00584: 无法关闭连接</li><li>ORA-00585: 主机名称格式错误</li><li>ORA-00586: osndnt: LIB$ASN_WTH_MBX 失败</li><li>ORA-00587: 无法连接到远程主机</li><li>ORA-00588: 来自主机的信息过短</li><li>ORA-00589: 来自主机的信息数据长度错误</li><li>ORA-00590: 来自主机的信息类型错误</li><li>ORA-00591: 写入的字节数错误</li><li>ORA-00592: osndnt: $QIO 失败 (邮箱队列)</li><li>ORA-00593: osndnt: $DASSGN 失败 (网络设备)</li><li>ORA-00594: osndnt: $DASSGN 失败 (邮箱)</li><li>ORA-00595: osndnt: $QIO 失败 (接收)</li><li>ORA-00596: osndnt: $QIO 失败 (发送)</li><li>ORA-00597: osndnt: $QIO 失败 (邮箱队列)</li><li>ORA-00598: osndnt: $QIO IO 失败 (邮箱读取)</li><li>ORA-00600: 内部错误代码，参数: [], [], [], [], [], [], [], []</li><li>ORA-00601: 清除锁定冲突</li><li>ORA-00602: 内部编程异常错误</li><li>ORA-00603: ORACLE 服务器会话因致命错误而终止</li><li>ORA-00604: 递归 SQL 层 出现错误</li><li>ORA-00606: 内部错误代码</li><li>ORA-00607: 当更改数据块时出现内部错误</li><li>ORA-00701: 无法改变热启动数据库所需的对象</li><li>ORA-00702: 引导程序版本 ‘’ 与版本 ‘’ 不一致</li><li>ORA-00703: 超出行高速缓存例程锁的最大数</li><li>ORA-00704: 引导程序进程失败</li><li>ORA-00705: 启动过程中的状态不一致；请在关闭例程后重新启动</li><li>ORA-00706: 更改文件 ‘’ 的格式时出错</li><li>ORA-00816: 错误信息无法转换</li><li>ORA-00900: 无效 SQL 语句</li><li>ORA-00901: 无效 CREATE 命令</li><li>ORA-00902: 无效数据类型</li><li>ORA-00903: 表名无效</li><li>ORA-00904: : 无效的标识符</li><li>ORA-00905: 缺少关键字</li><li>ORA-00906: 缺少左括号</li><li>ORA-00907: 缺少右括号</li><li>ORA-00908: 缺少 NULL 关键字</li><li>ORA-00909: 参数个数无效</li><li>ORA-00910: 指定的长度对于数据类型而言过长</li><li>ORA-00911: 无效字符</li><li>ORA-00913: 值过多</li><li>ORA-00914: 缺少 ADD 关键字</li><li>ORA-00915: 当前不允许网络访问字典表</li><li>ORA-00917: 缺少逗号</li><li>ORA-00918: 未明确定义列</li><li>ORA-00919: 无效函数</li><li>ORA-00920: 无效的关系运算符</li><li>ORA-00921: 未预期的 SQL 命令结尾</li><li>ORA-00922: 缺少或无效选项</li><li>ORA-00923: 未找到预期 FROM 关键字</li><li>ORA-00924: 缺少 BY 关键字</li><li>ORA-00925: 缺失 INTO 关键字</li><li>ORA-00926: 缺少 VALUES 关键字</li><li>ORA-00927: 缺少等号</li><li>ORA-00928: 缺少 SELECT 关键字</li><li>ORA-00929: 缺少句号</li><li>ORA-00930: 缺少星号</li><li>ORA-00931: 缺少标识</li><li>ORA-00932: 不一致的数据类型: 要求 得到的却是</li><li>ORA-00933: SQL 命令未正确结束</li><li>ORA-00934: 此处不允许使用分组函数</li><li>ORA-00935: 分组函数的嵌套太深</li><li>ORA-00936: 缺少表达式</li><li>ORA-00937: 非单组分组函数</li><li>ORA-00938: 函数没有足够的参数</li><li>ORA-00939: 函数的参数过多</li><li>ORA-00940: 无效的 ALTER 命令</li><li>ORA-00941: 群集名缺少</li><li>ORA-00942: 表或视图不存在</li><li>ORA-00943: 群集不存在</li><li>ORA-00944: 没有足够的聚簇列数</li><li>ORA-00945: 指定的聚簇列不存在</li><li>ORA-00946: 缺少 TO 关键字</li><li>ORA-00947: 没有足够的值</li><li>ORA-00948: 不再支持 ALTER CLUSTER 语句</li><li>ORA-00949: 非法引用远程数据库</li><li>ORA-00950: 无效 DROP 选项</li><li>ORA-00951: 群集非空</li><li>ORA-00952: 缺少 GROUP 关键字</li><li>ORA-00953: 缺少或无效索引名</li><li>ORA-00954: 缺少 IDENTIFIED 关键字</li><li>ORA-00955: 名称已由现有对象使用</li><li>ORA-00956: 缺少或无效审计选项</li><li>ORA-00957: 列名重复</li><li>ORA-00958: 缺少 CHECK 关键字</li><li>ORA-00959: 表空间’’不存在</li><li>ORA-00960: 选择列表中的命名含糊</li><li>ORA-00961: 错误的日期/间隔值</li><li>ORA-00962: group-by / order-by 表达式过多</li><li>ORA-00963: 不支持的间隔类型</li><li>ORA-00964: 表名不在 FROM 列表中</li><li>ORA-00965: 列别名中不允许’*’</li><li>ORA-00966: 缺少 TABLE 关键字</li><li>ORA-00967: 缺少 WHERE 关键字</li><li>ORA-00968: 缺少 INDEX 关键字</li><li>ORA-00969: 缺少 ON 关键字</li><li>ORA-00970: 缺少 WITH 关键字</li><li>ORA-00971: 缺少 SET 关键字</li><li>ORA-00972: 标识过长</li><li>ORA-00973: 无效的行数估计</li><li>ORA-00974: 无效 PCTFREE 值 (百分比)</li><li>ORA-00975: 不允许日期 + 日期</li><li>ORA-00976: 此处不允许为 LEVEL, PRIOR 或 ROWNUM</li><li>ORA-00977: 重复的审计选项</li><li>ORA-00978: 嵌套分组函数没有 GROUT BY</li><li>ORA-00979: 不是 GROUP BY 表达式</li><li>ORA-00980: 同义词转换不再有效</li><li>ORA-00981: 不能将表和系统审计选项混在一起</li><li>ORA-00982: 缺少加号</li><li>ORA-00984: 列在此处不允许</li><li>ORA-00985: 无效的程序名</li><li>ORA-00986: 缺少或无效组名</li><li>ORA-00987: 缺少或无效用户名</li><li>ORA-00988: 缺少或无效口令</li><li>ORA-00989: 给出的用户名口令过多</li><li>ORA-00990: 缺少或无效权限</li><li>ORA-00991: 过程仅有 MAC 权限</li><li>ORA-00992: REVOKE 命令格式无效</li><li>ORA-00993: 缺少 GRANT 关键字</li><li>ORA-00994: 缺少 OPTION 关键字</li><li>ORA-00995: 缺少或无效同义词标识</li><li>ORA-00996: 连接运算符是 || 而不是 |</li><li>ORA-00997: 非法使用 LONG 数据类型</li><li>ORA-00998: 必须使用列别名命名此表达式</li><li>ORA-00999: 无效的视图名</li><li>ORA-01000: 超出打开游标的最大数</li><li>ORA-01001: 无效的游标</li><li>ORA-01002: 读取违反顺序</li><li>ORA-01003: 语句未进行语法分析</li><li>ORA-01004: 不支持默认用户名特性；登录被拒绝</li><li>ORA-01005: 未给出口令；登录被拒绝</li><li>ORA-01006: 赋值变量不存在</li><li>ORA-01007: 选择列表中没有变量</li><li>ORA-01008: 并非所有变量都已关联</li><li>ORA-01009: 缺少法定参数</li><li>ORA-01010: 无效的 OCI 操作</li><li>ORA-01011: 在与第 6 版服务器会话时不能使用第 7 版兼容模式</li><li>ORA-01012: 没有登录</li><li>ORA-01013: 用户请求取消当前的操作</li><li>ORA-01014: ORACLE 正在关闭过程中</li><li>ORA-01015: 循环登录请求</li><li>ORA-01016: 此函数仅可以在读取后调用</li><li>ORA-01017: 无效的用户名/口令；拒绝登录</li><li>ORA-01018: 列不具有 LONG 数据类型</li><li>ORA-01019: 无法在用户方分配内存</li><li>ORA-01020: 未知的上下文状态</li><li>ORA-01021: 指定的上下文大小无效</li><li>ORA-01022: 此配置中不支持数据库操作</li><li>ORA-01023: 未找到游标上下文 (无效的游标编号)</li><li>ORA-01024: OCI 调用中的数据类型无效</li><li>ORA-01025: UPI 参数超出范围</li><li>ORA-01026: 赋值列表中存在多个大小 &gt; 4000 的缓冲区</li><li>ORA-01027: 在数据定义操作中不允许对变量赋值</li><li>ORA-01028: 内部双工错误</li><li>ORA-01029: 内部双工错误</li><li>ORA-01030: SELECT …INTO 变量不存在</li><li>ORA-01031: 权限不足</li><li>ORA-01032: 没有这样的用户标识</li><li>ORA-01033: ORACLE 正在初始化或关闭过程中</li><li>ORA-01034: ORACLE 不可用</li><li>ORA-01035: ORACLE 只允许具有 RESTRICTED SESSION 权限的用户使用</li><li>ORA-01036: 非法的变量名/编号</li><li>ORA-01037: 超出最大游标内存</li><li>ORA-01038: 无法写入数据库文件版本 (使用 ORACLE 版本 )</li><li>ORA-01039: 视图基本对象的权限不足</li><li>ORA-01040: 口令中的字符无效；登录被拒绝</li><li>ORA-01041: 内部错误，hostdef 扩展名不存在</li><li>ORA-01042: 不允许使用打开游标分离会话</li><li>ORA-01043: 用户方内存损坏 [], [], [], []</li><li>ORA-01044: 缓冲区大小 (与变量关联) 超出了最大限制</li><li>ORA-01045: 用户 没有 CREATE SESSION 权限；登录被拒绝</li><li>ORA-01046: 无法获得扩展上下文区域的空间</li><li>ORA-01047: 以上错误出现在 schema=, package=, procedure= 中</li><li>ORA-01048: 给定的上下文中无法找到指定的过程</li><li>ORA-01049: 流动 RPC 中不支持按名称赋值</li><li>ORA-01050: 无法获得打开上下文区域的空间</li><li>ORA-01051: 延迟 rpc 缓冲区格式无效</li><li>ORA-01052: 未指定所需的目的 LOG_ARCHIVE_DUPLEX_DEST</li><li>ORA-01053: 无法读取用户存储地址</li><li>ORA-01054: 无法写入用户存储地址</li><li>ORA-01057: 用户出口中引用的 block.field 无效或有歧义</li><li>ORA-01058: 内部 New Upi 接口错误</li><li>ORA-01059: 在赋值或执行之前进行语法分析</li><li>ORA-01060: 不允许数组赋值或执行</li><li>ORA-01061: 无法使用第 7 版客户应用程序启动第 8 版服务器</li><li>ORA-01062: 无法分配定义缓冲区所需的内存</li><li>ORA-01070: 服务器使用 Oracle 的旧版本</li><li>ORA-01071: 无法不启动 ORACLE 而执行操作</li><li>ORA-01072: 无法停止 ORACLE；因为 ORACLE 不在运行</li><li>ORA-01073: 致命的连接错误: 不能识别的调用类型</li><li>ORA-01074: 无法关闭 ORACLE；请首先在注册会话中注销</li><li>ORA-01075: 您现在已登录</li><li>ORA-01076: 尚不支持每个进程的多次登录</li><li>ORA-01077: 背景进程初始化失败</li><li>ORA-01078: 处理系统参数失败</li><li>ORA-01079: ORALCE 数据库未正确创建，操作中止</li><li>ORA-01080: 关闭 ORACLE 时出错</li><li>ORA-01081: 无法启动已在运行的 ORACLE — 请首先关闭</li><li>ORA-01082: ‘row_locking = always’ 要求事务处理处理选项</li><li>ORA-01083: 参数 “” 的值与其它例程序的相应参数值不一致。</li><li>ORA-01084: OCI 调用中的参数无效</li><li>ORA-01085: 延迟 rpc 到 “..” 之前的错误</li><li>ORA-01086: 从未创建保留点 ‘’</li><li>ORA-01087: 不能启动 ORALCE — 现在已登录</li><li>ORA-01088: 不能在存在活动进程时关闭 ORACLE</li><li>ORA-01089: 正在进行紧急关闭 - 不允许进行任何操作</li><li>ORA-01090: 正在进行关闭 — 不允许连接</li><li>ORA-01091: 强行启动出错</li><li>ORA-01092: ORACLE 例程终止。强行断开连接</li><li>ORA-01093: ALTER DATABASE CLOSE 仅允许在没有连接会话时使用</li><li>ORA-01094: ALTER DATABASE CLOSE 正在进行。不允许连接</li><li>ORA-01095: DML 语句处理了零个行</li><li>ORA- 01096: 程序版本 () 与例程 () 不兼容</li><li>ORA-01097: 无法在事务处理过程中关闭 - 首先提交或返回</li><li>ORA-01098: 在 Long Insert 过程中出现程序接口错误</li><li>ORA-01099: 如果在单进程模式下启动，则无法在 SHARED 模式下安装数据库</li><li>ORA-01100: 数据库已安装</li><li>ORA-01101: 要创建的数据库当前正由其它例程安装</li><li>ORA-01102: 无法在 EXCLUSIVE 模式下安装数据库</li><li>ORA-01103: 控制文件中的数据库名 ‘’ 不是 ‘’</li><li>ORA-01104: 控制文件数 () 不等于</li><li>ORA-01105: 安装与其它例程的安装不兼容</li><li>ORA-01106: 必须在卸下之前关闭数据库</li><li>ORA-01107: 必须安装数据库才可以进行介质恢复</li><li>ORA-01108: 文件 正处于备份或介质恢复过程中</li><li>ORA-01109: 数据库未打开</li><li>ORA-01110: 数据文件 : ‘’</li><li>ORA-01111: 数据文件 名称未知 - 请重命名以更正文件</li><li>ORA-01112: 未启动介质恢复</li><li>ORA-01113: 文件 需要介质恢复</li><li>ORA-01114: 将块写入文件 时出现 IO 错误 (块 # )</li><li>ORA-01115: 从文件 读取块时出现 IO 错误 (块 # )</li><li>ORA-01116: 打开数据库文件时出错</li><li>ORA-01117: 对文件 ‘’ 添加非法块大小: ；限制为</li><li>ORA-01118: 无法添加任何其它数据库文件: 超出限制</li><li>ORA-01119: 创建数据库文件 ‘’ 时出错</li><li>ORA-01120: 无法删除联机数据库文件</li><li>ORA-01121: 无法重命名数据库文件 - 文件在使用中或在恢复中</li><li>ORA-01122: 数据库文件 验证失败</li><li>ORA-01123: 无法启动联机备份；未启用介质恢复</li><li>ORA-01124: 无法恢复数据文件 - 文件在使用中或在恢复中</li><li>ORA-01125: 无法禁用介质恢复 - 文件 设置了联机备份</li><li>ORA-01126: 对于此操作，数据库必须以 EXCLUSIVE 模式安装且未打开</li><li>ORA-01127: 数据库名 ‘’ 超出 个字符的限制</li><li>ORA-01128: 无法启动联机备份 - 文件 处于脱机状态</li><li>ORA-01129: 用户默认或临时表空间不存在</li><li>ORA-01130: 数据库文件版本 与 ORACLE 版本 不兼容</li><li>ORA-01131: DB_FILES 系统参数值 超出限制</li><li>ORA-01132: 数据库文件名 ‘’ 的长度超出 个字符的限制</li><li>ORA-01133: 日志文件名 ‘’ 的长度超出 个字符的限制</li><li>ORA-01134: 数据库已由其它例程独立安装</li><li>ORA-01135: DML/query 访问的文件 处于脱机状态</li><li>ORA-01136: 文件 ( 块) 的指定大小小于 块的原大小</li><li>ORA-01137: 数据文件 仍处于脱机过程中</li><li>ORA-01138: 数据库必须在此例程中打开或根本没有打开</li><li>ORA-01139: RESETLOGS 选项仅在不完全数据库恢复后有效</li><li>ORA-01140: 无法结束联机备份 - 所有文件均处于脱机状态</li><li>ORA-01141: 重命名数据文件 时出错 - 未找到新文件 ‘’</li><li>ORA-01142: 无法结束联机备份 - 没有文件在备份中</li><li>ORA-01143: 不能禁用介质恢复 - 文件 需要介质恢复</li><li>ORA-01144: 文件大小 ( 块) 超出 块的最大数</li><li>ORA-01145: 除非启用了介质恢复，否则不允许紧急脱机</li><li>ORA-01146: 无法启动联机备份 - 文件 已在备份中</li><li>ORA-01147: SYSTEM 表空间文件 处于脱机状态</li><li>ORA-01149: 无法关闭 - 文件 设置了联机备份</li><li>ORA-01150: 无法防止写入 - 文件 设置了联机备份</li><li>ORA-01151: 如果需要，请使用介质恢复以恢复块和恢复备份</li><li>ORA-01152: 文件 没有从完备的旧备份中恢复</li><li>ORA-01153: 激活了不兼容的介质恢复</li><li>ORA-01154: 数据库正在运行。现在不允许打开, 关闭, 安装和拆卸</li><li>ORA-01155: 正在打开, 关闭, 安装或拆卸数据库</li><li>ORA-01156: 进行中的恢复可能需要访问文件</li><li>ORA-01157: 无法标识/锁定数据文件 - 请参阅 DBWR 跟踪文件</li><li>ORA-01158: 数据库 已安装</li><li>ORA-01159: 文件并非来自先前文件的同一数据库 - 数据库标识错误</li><li>ORA-01160: 文件不是</li><li>ORA-01161: 文件标题中的数据库名 与给定的名称 不匹配</li><li>ORA-01162: 文件标题中的块大小 与配置的块大小不匹配</li><li>ORA-01163: SIZE 子句表示 (块)，但应与标题 匹配</li><li>ORA-01164: MAXLOGFILES 不可以超出</li><li>ORA-01165: MAXDATAFILES 不可以超出</li><li>ORA-01166: 文件数量 大于 ()</li><li>ORA-01167: 这两个文件为相同的文件/组号或相同的文件</li><li>ORA-01168: 物理块大小 与其它成员的大小 不匹配</li><li>ORA-01169: 未找到 DATAFILE 编号 1。此编号必须存在</li><li>ORA-01170: 文件未找到 ‘’</li><li>ORA-01171: 数据文件因高级检查点错误而将脱机</li><li>ORA-01172: 线程的恢复停止在块（在文件中）</li><li>ORA-01173: 数据字典指明从系统表空间丢失的数据文件</li><li>ORA-01174: DB_FILES 为 ，但需要为 才能兼容</li><li>ORA-01175: 例程允许数据字典具有多于个文件</li><li>ORA-01176: 控制文件允许数据字典具有多于个文件</li><li>ORA-01177: 数据文件与字典不匹配- 可能是旧的原型</li><li>ORA-01178: 文件 在最后一个 CREATE CONTROLFILE 之前创建，无法重新创建</li><li>ORA-01179: 文件 不存在</li><li>ORA-01180: 无法创建数据文件 1</li><li>ORA-01181: 文件在最后一个 RESETLOGS 之前创建，无法重新创建</li><li>ORA-01182: 无法创建数据文件 - 文件在使用中或在恢复中</li><li>ORA-01183: 无法在 SHARED 模式下安装数据库</li><li>ORA-01184: 日志文件组已经存在</li><li>ORA-01185: 日志文件组号无效</li><li>ORA-01186: 文件 验证测试失败</li><li>ORA-01187: 由于验证测试失败而无法从文件 读取</li><li>ORA-01188: 标题中的块大小与物理块大小不匹配</li><li>ORA-01189: 文件来自于与先前文件不同的 RESETLOGS</li><li>ORA-01190: 控制文件或数据文件来自于最后一个 RESETLOGS 之前</li><li>ORA-01191: 文件已经脱机 - 无法进行正常脱机</li><li>ORA-01192: 必须启用至少一个线程</li><li>ORA-01193: 文件与恢复开始时的文件不同</li><li>ORA-01194: 文件需要更多的恢复来保持一致性</li><li>ORA-01195: 文件的联机备份需要更多的恢复来保持一致性</li><li>ORA-01196: 文件由于介质恢复会话失败而不一致</li><li>ORA-01197: 线程仅包含一个日志</li><li>ORA-01198: 在选项为 RESETLOGS 时必须指定日志文件的大小</li><li>ORA-01199: 文件不处于联机备份模式</li><li>ORA-01200: 的实际文件大小小于块的正确大小</li><li>ORA-01201: 文件标题无法正确写入</li><li>ORA-01202: 此文件的原型错误 - 创建时间错误</li><li>ORA-01203: 此文件的原型错误 - 创建 SCN 错误</li><li>ORA-01204: 文件号是而不是 - 文件错误</li><li>ORA-01205: 不是数据文件 - 标题的类型编号是</li><li>ORA-01206: 文件不是此数据库的一部份 - 数据库标识错误</li><li>ORA-01207: 文件比控制文件更新 - 旧的控制文件</li><li>ORA-01208: 数据文件是旧的版本 - 不能访问当前版本</li><li>ORA-01209: 数据文件来自最后一个 RESETLOGS 之前</li><li>ORA-01210: 数据文件标题是介质损坏</li><li>ORA-01211: Oracle7 数据文件不是来自于 Oracle8 的移植版本</li><li>ORA-01212: MAXLOGMEMBERS 不可以超出</li><li>ORA-01213: MAXINSTANCES 不可以超出</li><li>ORA-01214: MAXLOGHISTORY 不可以超出</li><li>ORA-01215: 启用的线程在 CREATE CONTROLFILE 之后丢失</li><li>ORA-01216: 线程预计在 CREATE CONTROLFILE 之后禁用</li><li>ORA-01217: 日志文件成员属于一个不同的日志文件组</li><li>ORA-01218: 日志文件成员来自于不同的时间点</li><li>ORA-01219: 数据库未打开: 仅允许在固定表/视图中查询</li><li>ORA-01220: 在数据库打开之前基于文件的分类非法</li><li>ORA-01221: 数据文件与背景进程的文件不同</li><li>ORA-01222: 的 MAXINSTANCES 要求 MAXLOGFILES 至少是而不是</li><li>ORA-01223: 必须指定 RESETLOGS 以设置新的数据库名</li><li>ORA-01224: 标题中的组号与 GROUP 不匹配</li><li>ORA-01225: 线程编号大于 MAXINSTANCES</li><li>ORA-01226: 日志成员的文件标题与其它成员不一致</li><li>ORA-01227: 日志与其它日志不一致</li><li>ORA-01228: SET DATABASE 选项要求安装源数据库</li><li>ORA-01229: 数据文件与日志不一致</li><li>ORA-01230: 无法设置只读 - 文件处于脱机状态</li><li>ORA-01231: 无法设置读写 - 文件处于脱机状态</li><li>ORA-01232: 无法启动联机备份 - 文件是只读文件</li><li>ORA-01233: 文件是只读文件 - 无法使用备份控制文件恢复</li><li>ORA-01234: 无法终止文件的备份 - 文件在使用或在恢复中</li><li>ORA-01235: END BACKUP 对文件失败而对成功</li><li>ORA-01236: 文件标题访问的初始化过程中出现错误</li><li>ORA-01237: 无法扩展数据文件</li><li>ORA-01238: 无法收缩数据文件</li><li>ORA-01239: 数据库必须在 ARCHIVELOG 模式下使用外部高速缓存</li><li>ORA-01240: 一个命令中添加的数据文件过多</li><li>ORA- 01241: 外部高速缓存已停止</li><li>ORA-01242: 数据文件出现介质错误: 数据库处于 NOARCHIVELOG 模式</li><li>ORA-01243: 系统表空间文件出现介质错误</li><li>ORA-01244: 未命名的数据文件由介质恢复添加至控制文件</li><li>ORA-01245: RESETLOGS 完成时脱机文件将丢失</li><li>ORA-01246: 通过表空间的 TSPITR 来恢复文件</li><li>ORA-01247: 通过表空间的 TSPITR 来恢复数据库</li><li>ORA-01248: 文件在将来的不完整恢复中创建</li><li>ORA-01249: 不允许在 ‘克隆’ 数据库中存档</li><li>ORA-01250: 文件标题访问的终止过程中出现错误</li><li>ORA-01251: 文件号的未知文件标题版本读取</li><li>ORA-01252: 无法禁止写 - 文件在恢复管理器备份中</li><li>ORA-01253: 无法启动联机备份 - 文件在恢复管理器备份中</li><li>ORA-01254: 无法结束联机备份 - 文件在恢复管理器备份中</li><li>ORA-01255: 无法关闭 - 文件在恢复管理器备份中</li><li>ORA-01256: 在锁定数据库文件 时出错</li><li>ORA-01257: 不能重用数据库文件 ，文件大小未知</li><li>ORA-01258: 无法删除临时文件</li><li>ORA-01259: 无法删除数据文件</li><li>ORA-01260: 当数据库打开时, 不能发出 ALTER DATABASE END BACKUP 命令</li><li>ORA-01261: 无法转换参数 目标字符串</li><li>ORA-01262: 在文件目标目录上无法进行统计</li><li>ORA-01263: 文件目标目录的名称无效</li><li>ORA-01264: 无法创建 文件名</li><li>ORA-01265: 无法删除文件</li><li>ORA-01266: 无法创建唯一的文件名</li><li>ORA-01267: 无法获取日期/时间</li><li>ORA-01268: 用于变更永久性 TABLESPACE 的 TEMPFILE 子句无效</li><li>ORA-01269: 目标参数字符串过长</li><li>ORA-01270: STANDBY_PRESERVES_NAMES 为 true 时, 不允许进行 操作</li><li>ORA-01271: 无法创建文件 的新文件名</li><li>ORA-01272: 只有当提供文件名时, 才允许 REUSE。</li><li>ORA-01274: 无法添加数据文件 ‘’ - 无法创建文件</li><li>ORA-01275: 自动进行备用文件管理时, 不允许进行 操作。</li><li>ORA-01276: 无法添加文件 。 相应文件具有一个 Oracle 管理文件文件名。</li><li>ORA-01277: 文件 ‘’ 已存在</li><li>ORA-01278: 创建文件 ‘’ 出错</li><li>ORA-01279: db_files 太大</li><li>ORA-01280: 严重的 LogMiner 错误。</li><li>ORA-01281: 指定的 SCN 范围无效</li><li>ORA-01282: 指定的日期范围无效</li><li>ORA-01283: 指定选项无效</li><li>ORA-01284: 文件 无法打开</li><li>ORA-01285: 读取文件 时出错</li><li>ORA-01286: 由于 DB_ID 不匹配无法添加文件 </li><li>ORA-01287: 文件 来源于其他的数据库原型</li><li>ORA-01288: 文件 来自不同的数据库实体</li><li>ORA-01289: 无法添加重复的日志文件</li><li>ORA-01290: 无法删除未列出的日志文件</li><li>ORA-01291: 丢失的日志文件</li><li>ORA-01292: 当前 LogMiner 会话无指定的日志文件</li><li>ORA-01293: 时间或 SCN 范围没有完全包含在列出的日志文件中</li><li>ORA-01294: 当处理字典文件 中的信息时出错，可能损坏</li><li>ORA-01295: 字典 和日志文件之间的 DB_ID 不匹配</li><li>ORA-01296: 字典 和日志文件之间的字符集不匹配</li><li>ORA-01297: 字典 和日志文件之间的重做版本不匹配</li><li>ORA-01298: 字典 和最早的日志文件不是 SCN 可兼容的</li><li>ORA-01299: 字典 对应于不同的数据库原型</li><li>ORA-01300: 字典 和最早的日志文件之间已启用的线程位向量不匹配</li><li>ORA-01301: dbms_logmnr.USE_COLMAP 只用于有效字典</li><li>ORA-01302: 在 logmnr.opt 文件中出现语法错误</li><li>ORA-01303: 在 logmnr.opt 文件中指定的方案 不存在</li><li>ORA-01304: 在 logmnr.opt 文件中指定的表 , 方案 不存在</li><li>ORA-01305: 在 logmnr.opt 文件中指定的列 不存在于表 ,, 方案 中</li><li>ORA-01306: 在从 v$logmnr_contents 中选择之前必须调用 dbms_logmnr.start_logmnr()</li><li>ORA-01307: 当前无活动的 LogMiner 会话</li><li>ORA-01308: 未设置初始化参数 utl_file_dir</li><li>ORA-01309: 会话无效</li><li>ORA-01310: lcr_mine 函数不支持请求的返回类型</li><li>ORA-01311: mine_value 函数的调用非法</li><li>ORA-01312: 指定的表/列不存在</li><li>ORA-01313: LogMiner 字典列类型不同于指定的类型</li><li>ORA-01314: 要挖掘的列名字面上应是字符串</li><li>ORA-01315: 日志文件在选取过程中已被添加或移去</li><li>ORA-01316: 已连接到 Logminer 会话中</li><li>ORA-01317: 未连接到 Logminer 会话中</li><li>ORA-01318: Logminer 会话未启动</li><li>ORA-01319: Logminer 会话属性无效</li><li>ORA-01320: Logminer 字典属性无效</li><li>ORA-01321: SCN 范围没有完全包含在所列日志文件中</li><li>ORA-01322: 这样的表不存在</li><li>ORA-01323: 状态无效</li><li>ORA-01324: 由于 DB_ID 匹配出错, 无法添加文件</li><li>ORA-01325: 要构建日志流, 必须启用“归档日志”模式</li><li>ORA-01326: 要构建日志流, 兼容性必须大于等于 8.2</li><li>ORA-01327: 无法按构建的要求锁定系统字典 (锁为排他锁)</li><li>ORA-01328: 一次只能进行一个构建操作</li><li>ORA-01329: 无法截断所需的构建表</li><li>ORA-01330: 加载所需的构建表时出现问题</li><li>ORA-01331: 运行构建时出现一般错误</li><li>ORA-01332: Logminer 字典内部错误</li><li>ORA-01333: 无法构建 Logminer 字典</li><li>ORA-01334: logminer 字典进程上下文无效或缺失</li><li>ORA-01335: 此功能尚未实现</li><li>ORA-01336: 无法打开指定的字典文件</li><li>ORA-01337: 日志文件的兼容版本不同</li><li>ORA-01338: 其他进程已附加到 LogMiner 会话</li><li>ORA-01339: 日志文件过旧</li><li>ORA-01340: NLS error</li><li>ORA-01341: LogMiner 内存不足</li><li>ORA-01342: LogMiner 由于无法暂存检查点数据而无法恢复会话</li><li>ORA-01343: LogMiner - 遇到崩溃的重做块</li><li>ORA-01344: LogMiner 协调器已挂接</li><li>ORA-01345: 必须启用补充日志数据以纳入到日志流中</li><li>ORA-01346: 从属 LogMiner 会话依赖于存在补充性的记录数据</li><li>ORA-01347: 未找到补充日志数据</li><li>ORA-01348: LogMiner 测试事件</li><li>ORA-01349: LogMiner 跟踪事件</li><li>ORA-01350: 必须指定表空间名</li><li>ORA-01351: 为 Logminer 字典提供的表空间不存在</li><li>ORA-01352: 为 Logminer 溢出提供的表空间不存在</li><li>ORA-01353: 正在退出 Logminer 会话</li><li>ORA-01370: 指定的重启 SCN 太旧</li><li>ORA-01371: 未找到完整的 LogMiner 目录</li><li>ORA-01372: 用于指定 LogMiner 操作的进程数不足</li><li>ORA-01373: insufficient memory for staging persistent LogMiner session</li><li>ORA-01374: log_parallelism greater than 1 not supported in this release</li><li>ORA-01400: 无法将 NULL 插入 ()</li><li>ORA-01401: 插入的值对于列过大</li><li>ORA-01402: 视图 WITH CHECK OPTIDN 违反 where 子句</li><li>ORA-01403: 未找到数据</li><li>ORA-01404: ALTER COLUMN 将使索引过大</li><li>ORA-01405: 读取的列值为 NULL</li><li>ORA-01406: 读取的列值被截断</li><li>ORA-01407: 无法更新 () 为 NULL</li><li>ORA-01408: 此列列表已编制索引</li><li>ORA-01409: 不可以使用 NOSORT 选项；行不是按升序排列</li><li>ORA-01410: 无效的 ROWID</li><li>ORA-01411: 无法在指示器中存储列长度</li><li>ORA-01412: 此数据类型不允许零长度</li><li>ORA-01413: 压缩十进制数字缓冲区中的非法值</li><li>ORA-01414: 尝试对数组赋值时的无效数组长度</li><li>ORA-01415: 太多不同的聚组函数</li><li>ORA-01416: 两表无法彼此外部连接</li><li>ORA-01417: 表可以外部连接到至多一个其它的表</li><li>ORA-01418: 指定的索引不存在</li><li>ORA-01419: datdts: 非法的格式代码</li><li>ORA-01420: datstd: 非法的格式代码</li><li>ORA-01421: datrnd/dattrn: 非法的精确度规定</li><li>ORA-01422: 实际返回的行数超出请求的行数</li><li>ORA-01423: 检查实际读取的多余行时出错</li><li>ORA-01424: 换码符之后缺少或非法字符</li><li>ORA-01425: 换码符必须是长度为 1 的字符串</li><li>ORA-01426: 数字溢出</li><li>ORA-01427: 单行子查询返回多于一个行</li><li>ORA-01428: 参数’’超出范围</li><li>ORA-01429: 索引组织表: 没有存储溢出行段的数据段</li><li>ORA-01430: 表中已经存在要添加的列</li><li>ORA-01431: GRANT 命令中的内部不一致</li><li>ORA-01432: 要删除的公用同义词不存在</li><li>ORA-01433: 要创建的同义词已经定义</li><li>ORA-01434: 要删除的隐含同义词不存在</li><li>ORA-01435: 用户不存在</li><li>ORA-01436: 用户数据中的 CONNECT BY 循环</li><li>ORA-01437: 无法连接 CONNECT BY</li><li>ORA-01438: 值大于此列指定的允许精确度</li><li>ORA-01439: 要更改数据类型，则要修改的列必须为空 (empty)</li><li>ORA-01440: 要减小精确度或标度，则要修改的列必须为空 (empty)</li><li>ORA-01441: 无法减小列长度, 因为一些值过大</li><li>ORA-01442: 要修改为 NOT NULL 的列已经是 NOT NULL</li><li>ORA-01443: 内部不一致；结果视图列中的数据类型非法</li><li>ORA-01444: 内部不一致；内部数据类型映射为无效外部类型</li><li>ORA-01445: 无法从没有键值保存表的连接视图中选择 ROWID</li><li>ORA-01446: 无法从含 DISTINCT, GROUP BY 等子句的视图中选择 ROWID</li><li>ORA-01447: ALTER TABLE 语句无法用于聚簇列</li><li>ORA-01448: 在更改要求的类型之前必须删除索引</li><li>ORA-01449: 列包含 NULL 值；无法将其改变为 NOT NULL</li><li>ORA-01450: 超出最大的关键字长度 ()</li><li>ORA-01451: 要修改为 NULL 的列无法修改为 NULL</li><li>ORA-01452: 无法 CREATE UNIQUE INDEX；找到重复的关键字</li><li>ORA-01453: SET TRANSACTION 必须是事务处理的第一个语句</li><li>ORA-01454: 无法将列转换为数值数据类型</li><li>ORA-01455: 转换列溢出整数数据类型</li><li>ORA-01456: 不可以在 READ ONLY 事务处理中执行插入/删除/更新操作</li><li>ORA-01457: 转换列溢出十进制数据类型</li><li>ORA-01458: 内部变量字符串长度非法</li><li>ORA-01459: 变量字符串长度非法</li><li>ORA-01460: 转换请求无法实现或不合理</li><li>ORA-01461: 仅可以为插入 LONG 列的 LONG 值赋值</li><li>ORA-01462: 不能插入超出 4000 个字符的文字型字符串</li><li>ORA-01463: 不能使用当前约束条件修改列数据类型</li><li>ORA-01464: 表或视图的循环授权（授予原始授权者）</li><li>ORA-01465: 无效的十六进制数字</li><li>ORA-01466: 无法读数据 - 表定义已更改</li><li>ORA-01467: 分类 (sort) 关键字过长</li><li>ORA-01468: 一个谓词只能引用一个外部连接表</li><li>ORA-01469: PRIOR 后面只能跟列名</li><li>ORA-01470: In-list 迭代不支持混合运算符</li><li>ORA-01471: 无法创建与对象同名的同义词</li><li>ORA-01472: 无法将 CONNECT BY 用于 DISTINCT，GROUP BY 等的视图</li><li>ORA-01473: CONNECT BY 子句中不能具有子查询</li><li>ORA-01474: START WITH 或 PRIOR 不能没有 CONNECT BY</li><li>ORA-01475: 必须对游标重新进行语法分析以更改赋值变量的数据类型</li><li>ORA-01476: 除数为 0</li><li>ORA-01477: 用户数据区域描述符过大</li><li>ORA-01478: 数组赋值不可以包括任何 LONG 列</li><li>ORA-01479: 缓冲区中的最后一个字符不是 Null</li><li>ORA-01480: STR 赋值变量缺少空后缀</li><li>ORA-01481: 无效的数字格式模型</li><li>ORA-01482: 不受支持的字符集</li><li>ORA-01483: DATE 或 NUMBER 赋值变量的长度无效</li><li>ORA-01484: 数组仅可以与 PL/SQL 语句关联</li><li>ORA-01485: 编译赋值长度不同于执行赋值长度</li><li>ORA-01486: 数组元素的大小过大</li><li>ORA-01487: 给定缓冲区的压缩十进制数字过大</li><li>ORA-01488: 输入数据中的无效半字节或字节</li><li>ORA-01489: 字符串连接的结果过长</li><li>ORA-01490: 无效的 ANALYZE 命令</li><li>ORA-01491: CASCADE 选项无效</li><li>ORA-01492: LIST 选项无效</li><li>ORA-01493: 指定的 SAMPLE 大小无效</li><li>ORA-01494: 指定的 SIZE 无效</li><li>ORA-01495: 未找到指定的链接行表</li><li>ORA-01496: 指定的链接行表不正确</li><li>ORA-01497: 非法的 ANALYZE CLUSTER 选项</li><li>ORA-01498: 块检查失败 - 请参阅跟踪文件</li><li>ORA-01499: 表/索引交叉引用失败 - 请参阅跟踪文件</li><li>ORA-01500: 无法获得日期/时间</li><li>ORA-01501: CREATE DATABASE 失败</li><li>ORA-01502: 索引’.’或这类索引的分区处于不可用状态</li><li>ORA-01503: CREATE CONTROLFILE 失败</li><li>ORA-01504: 数据库名’’与参数 db_name ‘’不匹配</li><li>ORA-01505: 添加日志文件时出错</li><li>ORA-01506: 缺少或非法数据库名</li><li>ORA-01507: 未安装数据库</li><li>ORA-01508: 无法创建数据库；文件’’的行出错</li><li>ORA-01509: 指定的名称’’与实际名称’’不匹配</li><li>ORA-01510: 删除日志文件时出错</li><li>ORA-01511: 重命名日志/数据文件时出错</li><li>ORA-01512: 重命名日志文件时出错 - 未找到新文件</li><li>ORA-01513: 操作系统返回无效的当前时间</li><li>ORA-01514: 日志说明中出现错误: 没有此类日志</li><li>ORA-01515: 删除日志组时出错: 没有此类日志</li><li>ORA-01516: 不存在的日志文件, 数据文件或临时文件 ‘’</li><li>ORA-01517: 日志成员: ‘’</li><li>ORA-01518: CREATE DATABASE 必须指定多于一个日志文件</li><li>ORA-01519: 在处理文件’’的邻近行时出错</li><li>ORA-01520: 要添加的数据文件数 () 超出限制</li><li>ORA-01521: 添加数据文件时出错</li><li>ORA-01522: 要重命名的文件’’不存在</li><li>ORA-01523: 无法将数据文件重命名为’’ - 文件已是数据库的一部分</li><li>ORA-01524: 无法将数据文件创建为’’ - 文件已是数据库的一部分</li><li>ORA-01525: 重命名数据文件时出错</li><li>ORA-01526: 打开文件’’时出错</li><li>ORA-01527: 读文件出错</li><li>ORA-01528: 处理 SQL 语句时出现 EOF</li><li>ORA-01529: 关闭文件’’时出错</li><li>ORA-01530: 例程已安装数据库</li><li>ORA-01531: 例程已打开数据库</li><li>ORA-01532: 无法创建数据库；例程在他处启动</li><li>ORA-01533: 无法重命名文件’’；文件不属于表空间</li><li>ORA-01534: 回退段’’不存在</li><li>ORA-01535: 回退段’’已经存在</li><li>ORA-01536: 超出表空间’’的空间限量</li><li>ORA-01537: 无法添加数据文件’’ - 文件已是数据库的一部分</li><li>ORA-01538: 无法获得任何回退段</li><li>ORA-01539: 表空间’’未联机</li><li>ORA-01540: 表空间’’未脱机</li><li>ORA-01541: 系统表空间无法脱机；如有必要请关闭</li><li>ORA-01542: 表空间’’脱机，无法在其中分配空间</li><li>ORA-01543: 表空间 ‘’ 已经存在</li><li>ORA-01544: 无法删除系统回退段</li><li>ORA-01545: 指定的回退段’’不可用</li><li>ORA-01546: 表空间包含活动回退段’’</li><li>ORA-01547: 警告: RECOVER 成功但 OPEN RESETLOGS 将出现如下错误</li><li>ORA-01548: 已找到活动回退段’’，终止删除表空间</li><li>ORA-01549: 表空间非空，请使用 INCLUDING CONTENTS 选项</li><li>ORA-01550: 无法删除系统表空间</li><li>ORA-01551: 扩展回退段，释放用的块</li><li>ORA-01552: 非系统表空间’’无法使用系统回退段</li><li>ORA-01553: MAXEXTENTS 不得小于当前分配的区</li><li>ORA-01554: 超出事务处理表的事务处理空间</li><li>ORA-01555: 快照过旧: 回退段号 在名称为 “” 过小</li><li>ORA-01556: 回退段的 MINEXTENTS 必须大于 1</li><li>ORA-01557: 回退段的区必须至少为块</li><li>ORA-01558: 超出回退段中的事务处理标识（号）</li><li>ORA-01559: 回退段的 MAXEXTENTS 值必须大于 1</li><li>ORA-01560: LIKE 样式包含的字符不完整或非法</li><li>ORA-01561: 无法删除指定表空间中的所有对象</li><li>ORA-01562: 扩展回退段号失败</li><li>ORA-01563: 回退段是 PUBLIC，需要使用 PUBLIC 关键字</li><li>ORA-01564: 回退段不是 PUBLIC</li><li>ORA-01565: 标识文件’’时出错</li><li>ORA-01566: 文件在 DROP LOGFILE 中被指定了多次</li><li>ORA-01567: 删除日志时将在线索中保留少于两个日志文件</li><li>ORA-01568: 无法在 PUBLIC 设置空间限量</li><li>ORA-01569: 对于系统字典表来说，数据文件过小</li><li>ORA-01570: MINEXTENTS 不得大于当前分配的区</li><li>ORA-01571: 重做版本与 ORACLE 版本不兼容</li><li>ORA-01572: 回退段 ‘’ 无法联机， 区已超出</li><li>ORA-01573: 正在关闭例程，不允许继续更改</li><li>ORA-01574: 超出并发事务处理的最大数</li><li>ORA-01575: 等待空间管理资源超时</li><li>ORA-01576: 例程锁定协议版本与 ORACLE 版本不兼容</li><li>ORA-01577: 无法添加日志文件’’ - 文件已是数据库的一部分</li><li>ORA-01578: ORACLE 数据块损坏（文件号，块号）</li><li>ORA-01579: 恢复过程中出现写错误</li><li>ORA-01580: 创建控制备份文件时出错</li><li>ORA-01581: 尝试使用已分配的回退段 () 新区 ()</li><li>ORA-01582: 无法打开要备份的控制文件</li><li>ORA-01583: 无法获得要备份的控制文件的块大小</li><li>ORA-01584: 无法获得要备份的控制文件的文件大小</li><li>ORA-01585: 标识备份文件时出错</li><li>ORA-01586: 无法打开要备份的目标文件</li><li>ORA-01587: 复制控制文件的备份文件时出错</li><li>ORA-01588: 要打开数据库则必须使用 RESETLOGS 选项</li><li>ORA-01589: 要打开数据库则必须使用 RESETLOGS 或 NORESETLOGS 选项</li><li>ORA-01590: 段可用列表数 () 超出最大数</li><li>ORA-01591: 锁定已被有问题的分配事务处理挂起</li><li>ORA-01592: 将第 7 版回退段 () 转换为 Oracle 8 版格式时出错</li><li>ORA-01593: 回退段最佳大小 ( blks) 小于计算的初始大小 ( blks)</li><li>ORA-01594: 尝试放回已释放的回退段 () 区 ()</li><li>ORA-01595: 释放区 () 回退段 () 时出错</li><li>ORA-01596: 无法在参数中指定系统</li><li>ORA-01597: 无法改变联机或脱机系统回退段</li><li>ORA-01598: 回退段’’未联机</li><li>ORA-01599: 无法获得回退段 (), 高速缓存空间已满</li><li>ORA-01600: 至多只有一个””在子句””（）中</li><li>ORA-01601: 子句””（）中的存储桶大小非法</li><li>ORA-01603: 子句””（）中的分组大小非法</li><li>ORA-01604: 子句””（）中的编号范围非法</li><li>ORA-01605: 子句””（）中缺少编号</li><li>ORA-01606: gc_files_to_locks 不同于另一已安装例程的参数</li><li>ORA-01608: 无法将回退段’’联机，其状态为 ()</li><li>ORA-01609: 日志是线程的当前日志 - 无法删除成员</li><li>ORA-01610: 使用 BACKUP CONTROLFILE 选项的恢复必须已完成</li><li>ORA-01611: 线程编号无效 - 必须介于 1 和之间</li><li>ORA-01612: 线程已经启用</li><li>ORA-01613: 线程只有日志 - 要求至少启用 2 个日志</li><li>ORA-01614: 线程正忙 - 无法启用</li><li>ORA-01615: 线程已安装 - 无法禁用</li><li>ORA-01616: 线程已打开 - 无法禁用</li><li>ORA-01617: 无法安装: 不是有效的线程编号</li><li>ORA-01618: 线程未启用 - 无法安装</li><li>ORA-01619: 线程已由另一例程安装</li><li>ORA-01620: 没有可用于安装的公用线程</li><li>ORA-01621: 数据库打开时无法重命名当前日志的成员</li><li>ORA-01622: 必须指定线程编号 - 没有特定默认值</li><li>ORA-01623: 日志是线程的当前日志 - 无法删除</li><li>ORA-01624: 线程的紧急恢复需要日志</li><li>ORA-01625: 回退段’’不属于此例程</li><li>ORA-01626: 回退段号’’无法处理更多事务处理</li><li>ORA-01627: 回退段号’’未联机</li><li>ORA-01628: 已达到 max # extents ()（回退段）</li><li>ORA-01629: 已达到 max # extents ()，此时正在保存表空间的撤消</li><li>ORA-01630: 表空间中的 temp 段达到 max # extents()</li><li>ORA-01631: 表.达到 max # extents ()</li><li>ORA-01632: 索引.达到 max # extents ()</li><li>ORA-01633: 此操作需要 Real Application Clusters 选件</li><li>ORA-01634: 回退段号’’即将脱机</li><li>ORA-01635: 指定的回退段编号 ‘’ 不可用</li><li>ORA-01636: 回退段’’已联机</li><li>ORA-01637: 回退段’’正被另一例程 (#) 使用</li><li>ORA-01638: 参数 不允许 ORACLE 版本 装载群集数据库</li><li>ORA-01640: 无法将活动事务处理的表空间设置为只读</li><li>ORA-01641: 表空间’’未联机- 无法添加数据文件</li><li>ORA-01642: 只读表空间’’无需开始备份</li><li>ORA-01643: 系统表空间无法设置为只读</li><li>ORA-01644: 表空间’’已经是只读</li><li>ORA-01645: 上次尝试设置读写已完成一半</li><li>ORA-01646: 表空间’’不是只读 - 无法设置为读写</li><li>ORA-01647: 表空间’’是只读，无法在其中分配空间</li><li>ORA-01648: 日志是禁用线程的当前日志</li><li>ORA-01649: 不允许进行备份控制文件操作</li><li>ORA-01650: 回退段无法通过（在表空间中）扩展</li><li>ORA-01651: 无法通过（在表空间中）扩展保存撤消段</li><li>ORA-01652: 无法通过（在表空间中）扩展 temp 段</li><li>ORA-01653: 表.无法通过（在表空间中）扩展</li><li>ORA-01654: 索引.无法通过（在表空间中）扩展</li><li>ORA-01655: 群集 . 无法通过 (在表空间 中) 扩展</li><li>ORA-01656: 最大区数 () 已在群集 . 中达到</li><li>ORA-01657: 无效的 SHRINK 选项值</li><li>ORA-01658: 无法为表空间中的段创建 INITIAL 区</li><li>ORA-01659: 无法分配超出的 MINEXTENTS（在表空间中）</li><li>ORA-01660: 表空间’’已是永久性</li><li>ORA-01661: 表空间’’已是临时性</li><li>ORA-01662: 表空间’’非空且无法设置为暂时性</li><li>ORA-01663: 表空间’’的内容不断变动</li><li>ORA-01664: 扩展排序段的事务处理已终止</li><li>ORA-01665: 控制文件不是一个备用控制文件</li><li>ORA-01666: 控制文件用于备用数据库</li><li>ORA-01667: 无法添加任何其它表空间: 超出限制</li><li>ORA-01668: 对于数据文件的脱机，备用数据库要求使用 DROP 选项</li><li>ORA-01669: 备用数据库控制文件不一致</li><li>ORA-01670: 备用数据库恢复需要新数据文件</li><li>ORA-01671: 控制文件是备份文件，无法设置备用控制文件</li><li>ORA-01672: 控制文件可能缺少文件或具有额外文件</li><li>ORA-01673: 未标识数据文件</li><li>ORA-01674: 数据文件是一个旧的原型而非当前文件</li><li>ORA-01675: max_commit_propagation_delay 与其它例程不一致</li><li>ORA-01676: ‘’的备用文件名转换超出的最大长度</li><li>ORA-01677: 备用文件名转换参数不同于其它例程</li><li>ORA-01678: 参数 必须是一对样式字符串和取代字符串</li><li>ORA-01679: 数据库必须以 EXCLUSIVE 安装且未打开以激活</li><li>ORA-01680: 无法通过（在表空间中）扩展 LOB 段</li><li>ORA-01681: max # extents () 已在表空间中的 LOB 段达到</li><li>ORA-01682: 只读 DB 无法在表空间中分配临时空间</li><li>ORA-01683: 索引.分区无法通过（在表空间中）扩展</li><li>ORA-01684: max # extents () 已在表.分区中达到</li><li>ORA-01685: max # extents () 已在索引.分区中达到</li><li>ORA-01686: max # files () 对于表空间已达到</li><li>ORA-01687: 表空间’’的指定记录属性与现有属性相同</li><li>ORA-01688: 表.分区无法通过（在表空间中）扩展</li><li>ORA-01689: 子句””（）中出现语法错误</li><li>ORA-01690: 排序区太小</li><li>ORA-01691: Lob 段.无法通过（在表空间中）扩展</li><li>ORA-01692: Lob 段.分区无法通过（在表空间中）扩展</li><li>ORA-01693: max # extents () 已在 lob 段.中达到</li><li>ORA-01694: max # extents () 已在 lob 段.分区中达到</li><li>ORA-01695: 将回退段转换为版本 8.0.2 时出错</li><li>ORA-01696: 控制文件不是 ‘克隆’ 控制文件</li><li>ORA-01697: 控制文件用于 ‘克隆’ 数据库</li><li>ORA-01698: ‘克隆’ 数据库仅可以具有 SYSTEM 联机回退段</li><li>ORA-01699: 正在导入表空间’’以用于时间点恢复</li><li>ORA-01700: 列表中的用户名重复</li><li>ORA-01701: 此处不允许有群集</li><li>ORA-01702: 此处不允许有视图</li><li>ORA-01703: 缺少 SYNONYM 关键字</li><li>ORA-01704: 文字字符串过长</li><li>ORA-01705: 无法在关联列中指定外部连接</li><li>ORA-01706: 用户函数的结果值过大</li><li>ORA-01707: 缺少 LIST 关键字</li><li>ORA-01708: 需要 ACCESS 或 SESSION</li><li>ORA-01709: 程序不存在</li><li>ORA-01710: 缺少 OF 关键字</li><li>ORA-01711: 列出的权限重复</li><li>ORA-01712: 您不能授予不具有的权限</li><li>ORA-01713: 该权限的 GRANT OPTION 不存在</li><li>ORA-01714: 执行用户函数时出错</li><li>ORA-01715: UNIQUE 不可以与簇索引一起使用</li><li>ORA-01716: NOSORT 不可以与簇索引一起使用</li><li>ORA-01717: seccta: 访问已过时的模式标记无效</li><li>ORA-01718: NOAUDIT 不允许 BY ACCESS | SESSION 子句</li><li>ORA-01719: OR 或 IN 操作数中不允许外部连接运算符 (+)</li><li>ORA-01720: 授权选项对于’.’不存在</li><li>ORA-01721: USERENV(COMMITSCN) 在事务处理中调用了多次</li><li>ORA-01722: 无效数字</li><li>ORA-01723: 不允许长度为 0 的列</li><li>ORA-01724: 浮点（数）精确度超出范围（1 到 126）</li><li>ORA-01725: 此处不允许 USERENV(‘COMMITSCN’)</li><li>ORA-01726: 此处不允许有表</li><li>ORA-01727: 数字精度说明符超出范围（1 到 38）</li><li>ORA-01728: 数字标度说明符超出范围（-84 到 127）</li><li>ORA-01729: 需要数据库链接名</li><li>ORA-01730: 指定的列名数无效</li><li>ORA-01731: 出现循环的视图定义</li><li>ORA-01732: 此视图的数据操纵操作非法</li><li>ORA-01733: 此处不允许虚拟列</li><li>ORA-01734: 非法的参数 - EXTENT MIN 高于 EXTENT MAX</li><li>ORA-01735: 非法的 ALTER TABLE 选项</li><li>ORA-01736: 需要 [NOT] SUCCESSFUL</li><li>ORA-01737: 有效模式: [ROW] SHARE, [[SHARE] ROW] EXCLUSIVE, SHARE UPDATE</li><li>ORA-01738: 缺少 IN 关键字</li><li>ORA-01739: 缺少 MODE 关键字</li><li>ORA-01740: 标识中缺少双引号</li><li>ORA-01741: 非法的零长度标识</li><li>ORA-01742: 备注错误终止</li><li>ORA-01743: 仅能编制纯函数的索引</li><li>ORA-01744: 不合理的 INTO</li><li>ORA-01745: 无效的主机/赋值变量名</li><li>ORA-01746: 此处不允许指示符变量</li><li>ORA-01747: 无效的用户.表.列，表.列，或列规格</li><li>ORA-01748: 此处只允许简单的列名</li><li>ORA-01749: 用户不可以自/至自己 GRANT/REVOKE 权限</li><li>ORA-01750: UPDATE/REFERENCES 仅可以从整个表而不能按列 REVOKE</li><li>ORA-01751: 无效的转储撤消选项</li><li>ORA-01752: 不能从没有一个键值保存表的视图中删除</li><li>ORA-01753: 列定义与聚簇列定义不兼容</li><li>ORA-01754: 表只能包含一个 LONG 类型的列</li><li>ORA-01755: 必须指定区编号或块编号</li><li>ORA-01756: 括号内的字符串没有正确结束</li><li>ORA-01757: 必须指定对象编号</li><li>ORA-01758: 要添加法定 (NOT NULL) 列，则表必须为空</li><li>ORA-01759: 未正确定义用户函数</li><li>ORA-01760: 函数的参数非法</li><li>ORA-01761: DML 操作与连结中的唯一表不对应</li><li>ORA-01762: vopdrv: FROM 中没有视图查询块</li><li>ORA-01763: 更新或删除涉及到外部连结表</li><li>ORA-01764: 连结的新更新值不能保证为唯一</li><li>ORA-01765: 不允许指定表的所有者名</li><li>ORA-01766: 此上下文中不允许有字典表</li><li>ORA-01767: UPDATE …SET 表达式必须是子查询</li><li>ORA-01768: 数字字符串过长</li><li>ORA-01769: 重复的 CLUSTER 选项说明</li><li>ORA-01770: CREATE CLUSTER 命令中不允许有 CLUSTER 选项</li><li>ORA-01771: 选项对聚簇表非法</li><li>ORA-01772: 必须指定 LEVEL 的值</li><li>ORA-01773: 此 CERATE TABLE 中没有指定列的数据类型</li><li>ORA-01774: 转储撤消选项指定了多次</li><li>ORA-01775: 同义词的循环嵌套链</li><li>ORA-01776: 无法通过连接视图修改多个基表</li><li>ORA-01777: 此系统中不允许 WITH GRANT OPTION</li><li>ORA-01778: 超出最大子查询的嵌套层</li><li>ORA-01779: 无法修改与非键值保存表对应的列</li><li>ORA-01780: 要求文字字符串</li><li>ORA-01781: UNRECOVERABLE 不能指定没有 AS SELECT</li><li>ORA-01782: 不能为群集或聚簇表指定 UNRECOVERABLE</li><li>ORA-01783: 只可以指定 RECOVERABLE 或 UNRECOVERABLE 子句</li><li>ORA-01784: 不能指定 RECOVERABLE 具有禁用的数据库介质恢复</li><li>ORA-01785: ORDER BY 项必须是 SELECT-list 表达式的数目</li><li>ORA-01786: 此查询表达式不允许 FOR UPDATE</li><li>ORA-01787: 每个查询块只允许有一个子句</li><li>ORA-01788: 此查询块中要求 CONNECT BY 子句</li><li>ORA-01789: 查询块具有不正确的结果列数</li><li>ORA-01790: 表达式必须具有与对应表达式相同的数据类型</li><li>ORA-01791: 不是 SELECTed 表达式</li><li>ORA-01792: 表或视图中的最大列数为 1000</li><li>ORA-01793: 索引列的最大数为 32</li><li>ORA-01794: 群集列的最大数目为 32</li><li>ORA-01795: 列表中的最大表达式数为 1000</li><li>ORA-01796: 此运算符不能与列表一起使用</li><li>ORA-01797: 此运算符后面必须跟 ANY 或 ALL</li><li>ORA-01798: 缺少 EXCEPTION 关键字</li><li>ORA-01799: 列不可以外部连接到子查询</li><li>ORA-01800: 日期格式中的文字过长以致无法处理</li><li>ORA-01801: 日期格式对于内部缓冲区过长</li><li>ORA-01802: Julian 日期超出范围</li><li>ORA-01803: 无法获得日期/时间</li><li>ORA-01804: 时区信息无法初始化</li><li>ORA-01810: 格式代码出现两次</li><li>ORA-01811: Julian 日期导致年度中的日无法使用</li><li>ORA-01812: 只可以指定一次年度</li><li>ORA-01813: 只可以指定一次小时</li><li>ORA-01814: AM/PM 因使用 A.M./P.M. 而发生冲突</li><li>ORA-01815: BC/AD 因使用 B.C./A.D. 而发生冲突</li><li>ORA-01816: 只可以指定一次月份</li><li>ORA-01817: 只可以指定一次周中的日</li><li>ORA-01818: ‘HH24’ 导致上下午指示符无法使用</li><li>ORA-01819: 带符号的年度导致 BC/AD 无法使用</li><li>ORA-01820: 格式代码无法以日期输入格式显示</li><li>ORA-01821: 日期格式无法识别</li><li>ORA-01822: 此日历的纪元格式代码无效</li><li>ORA-01830: 日期格式图片在转换整个输入字符串之前结束</li><li>ORA-01831: 年度与 Julian 日期发生冲突</li><li>ORA-01832: 年度中的日与 Julian 日期发生冲突</li><li>ORA-01833: 月份与 Julian 日期发生冲突</li><li>ORA-01834: 月份中的日与 Julian 日期发生冲突</li><li>ORA-01835: 周中的日与 Julian 日期发生冲突</li><li>ORA-01836: 小时与日中的秒发生冲突</li><li>ORA-01837: 小时中的分与日中的秒发生冲突</li><li>ORA-01838: 分中的秒与日中的秒发生冲突</li><li>ORA-01839: 指定月份的日期无效</li><li>ORA-01840: 输入值对于日期格式不够长</li><li>ORA-01841: （全）年度值必须介于 -4713 和 +9999 之间，且不为 0</li><li>ORA-01842: 季度值必须介于 1 和 4 之间</li><li>ORA-01843: 无效的月份</li><li>ORA-01844: 年度中的周值必须介于 1 和 52 之间</li><li>ORA-01845: 月份中的周值必须介于 1 和 5 之间</li><li>ORA-01846: 周中的日无效</li><li>ORA-01847: 月份中日的值必须介于 1 和当月最后一日之间</li><li>ORA-01848: 年度中的日值必须介于 1 和 365 之间（闰年为 366）</li><li>ORA-01849: 小时值必须介于 1 和 12 之间</li><li>ORA-01850: 小时值必须介于 0 和 23 之间</li><li>ORA-01851: 分钟值必须介于 0 和 59 之间</li><li>ORA-01852: 秒值必须介于 0 和 59 之间</li><li>ORA-01853: 日中的秒值必须介于 0 和 86399 之间</li><li>ORA-01854: julian 日期必须介于 1 和 5373484 之间</li><li>ORA-01855: 要求 AM/A.M. 或 PM/P.M.</li><li>ORA-01856: 要求 BC/B.C. 或 AD/A.D.</li><li>ORA-01857: 无效的时区</li><li>ORA-01858: 在要求输入数字处找到非数字字符</li><li>ORA-01859: 在要求输入字母处找到非字母字符</li><li>ORA-01860: 年度中的周值必须介于 1 和 53 之间</li><li>ORA-01861: 文字与格式字符串不匹配</li><li>ORA-01862: 数字值与格式项目的长度不匹配</li><li>ORA-01863: 年度不支持当前日历</li><li>ORA-01864: 日期超出当前日历的范围</li><li>ORA-01865: 无效的纪元</li><li>ORA-01866: 日期时间类无效</li><li>ORA-01867: 间隔无效</li><li>ORA-01868: 间隔的前导精度太小</li><li>ORA-01869: 保留以供将来使用</li><li>ORA-01870: 间隔或日期时间不是相互可比较的</li><li>ORA-01871: 秒数必须少于 60</li><li>ORA-01872: 保留以供将来使用</li><li>ORA-01873: 间隔的前导精度太小</li><li>ORA-01874: 时区小时必须在 -12 和 13 之间</li><li>ORA-01875: 时区分钟必须在 -59 和 59 之间</li><li>ORA-01876: 年份必须不少于 -4713</li><li>ORA-01877: 内部缓冲区的字符串太长</li><li>ORA-01878: 在日期时间或间隔中没有找到指定的字段</li><li>ORA-01879: hh25 字段必须在 0 和 24 之间</li><li>ORA-01880: 零点几秒必须在 0 和 999999999 之间</li><li>ORA-01881: 时区区域 ID %d 无效</li><li>ORA-01882: 未找到时区区域 </li><li>ORA-01883: 在区域转换过程中禁用了重叠</li><li>ORA-01890: 检测到 NLS 错误</li><li>ORA-01891: 日期时间/间隔内部错误</li><li>ORA-01898: 精确度说明符过多</li><li>ORA-01899: 错误的精度说明符</li><li>ORA-01900: 需要 LOGFILE 关键字</li><li>ORA-01901: 需要 ROLLBACK 关键字</li><li>ORA-01902: 需要 SEGMENT 关键字</li><li>ORA-01903: 需要 EVENTS 关键字</li><li>ORA-01904: 需要 DATAFILE 关键字</li><li>ORA-01905: 需要 STORAGE 关键字</li><li>ORA-01906: 需要 BACKUP 关键字</li><li>ORA-01907: 需要 TABLESPACE 关键字</li><li>ORA-01908: 需要 EXISTS 关键字</li><li>ORA-01909: 需要 REUSE 关键字</li><li>ORA-01910: 需要 TABLES 关键字</li><li>ORA-01911: 需要 CONTENTS 关键字</li><li>ORA-01912: 需要 ROW 关键字</li><li>ORA-01913: 需要 EXCLUSIVE 关键字</li><li>ORA-01914: 审计选项对于序号无效</li><li>ORA-01915: 审计选项对于视图无效</li><li>ORA-01917: 用户或角色 ‘’ 不存在</li><li>ORA-01918: 用户’’不存在</li><li>ORA-01919: 角色’’不存在</li><li>ORA-01920: 用户名’’与另外一个用户名或角色名发生冲突</li><li>ORA-01921: 角色名’’与另一个用户名或角色名发生冲突</li><li>ORA-01922: 必须指定 CASCADE 以删除’’</li><li>ORA-01923: CASCADE 已中止，对象被另一用户锁定</li><li>ORA-01924: 角色’’未被授权或不存在</li><li>ORA-01925: 超出已启用角色的最大数</li><li>ORA-01926: 无法将 WITH GRANT OPTION GRANT 角色</li><li>ORA-01927: 无法 REVOKE 您未授权的权限</li><li>ORA-01928: 未对 GRANT 选项授权所有权限</li><li>ORA-01929: 没有要 GRANT 的权限</li><li>ORA-01930: 不支持审计对象</li><li>ORA-01931: 无法将授予角色</li><li>ORA-01932: ADMIN 选项未授权给角色’’</li><li>ORA-01933: 无法使用角色权限来创建存储对象</li><li>ORA-01934: 检测到循环的角色授权</li><li>ORA-01935: 缺少用户或角色名</li><li>ORA-01936: 不能在创建用户或角色时指定所有者</li><li>ORA-01937: 缺少或无效的角色名</li><li>ORA-01938: 必须为 CREATE USER 指定 IDENTIFIED BY</li><li>ORA-01939: 只可以指定 ADMIN OPTION</li><li>ORA-01940: 无法删除当前已连接的用户</li><li>ORA-01941: 需要 SEQUENCE 关键字</li><li>ORA-01942: 无法同时指定 IDENTIFIED BY 和 EXTERNALLY</li><li>ORA-01943: 已经指定 IDENTIFIED BY</li><li>ORA-01944: 已经指定 IDENTIFIED EXTERNALLY</li><li>ORA-01945: 已经指定 DEFAULT ROLE[S]</li><li>ORA-01946: 已经指定 DEFAULT TABLESPACE</li><li>ORA-01947: 已经指定 TEMPORARY TABLESPACE</li><li>ORA-01948: 标识符的名称长度 () 超过最大长度 ()</li><li>ORA-01949: 需要 ROLE 关键字</li><li>ORA-01950: 表空间’’中无权限</li><li>ORA-01951: ROLE ‘’未授予’’</li><li>ORA-01952: 系统权限未授予’’</li><li>ORA-01953: 命令不再有效，请参阅 ALTER USER</li><li>ORA-01954: DEFAULT ROLE 子句对 CREATE USER 无效</li><li>ORA-01955: DEFAULT ROLE ‘’未授予用户</li><li>ORA-01956: 使用 OS_ROLES 时命令无效</li><li>ORA-01957: 需要的 MIN 或 MAX 关键字未找到</li><li>ORA-01958: 必须为 LAYER 选项提供整数</li><li>ORA-01959: 必须为 OPCODE 选项提供整数</li><li>ORA-01960: 无效的转储日志文件选项</li><li>ORA-01961: 无效的转储选项</li><li>ORA-01962: 必须指定文件号或日志序号</li><li>ORA-01963: 必须指定块编号</li><li>ORA-01964: 必须为 TIME 选项指定时间</li><li>ORA-01965: 必须指定 PERIOD</li><li>ORA-01967: 无效的 CREATE CONTROLFILE 选项</li><li>ORA-01968: 仅指定 RESETLOGS 或 NORESETLOGS 一次</li><li>ORA-01969: 您必须指定 RESETLOGS 或 NORESETLOGS</li><li>ORA-01970: 您必须为 CREATE CONTROLFILE 指定数据库名</li><li>ORA-01971: 非法的 ALTER TRACING 选项</li><li>ORA-01972: 必须为 ALTER TRACING ENABLE 或 DISABLE 指定字符串</li><li>ORA-01973: 缺少更改编号</li><li>ORA-01974: 非法的存档选项</li><li>ORA-01975: 更改编号中的字符非法</li><li>ORA-01976: 缺少更改编号</li><li>ORA-01977: 缺少线程编号</li><li>ORA-01978: 缺少序号</li><li>ORA-01979: 角色’’缺少口令或口令无效</li><li>ORA-01980: OS ROLE 初始化过程中出错</li><li>ORA-01981: 必须指定 CASCADE CONSTRAINTS 以执行此撤消</li><li>ORA-01982: 审计选项对于视图无效</li><li>ORA-01983: 无效的 DEFAULT 审计选项</li><li>ORA-01984: 无效的程序/程序包/函数审计选项</li><li>ORA-01985: 因超出 LICENSE_MAX_USERS 参数而无法创建用户</li><li>ORA-01986: 无效的 OPTIMIZER_GOAL 选项</li><li>ORA-01987: 客户 OS 用户名过长</li><li>ORA-01988: 不允许远程 os 登录</li><li>ORA-01989: 操作系统未授权角色’’</li><li>ORA-01990: 打开口令文件’’时出错</li><li>ORA-01991: 无效的口令文件’’</li><li>ORA-01992: 关闭口令文件’’时出错</li><li>ORA-01993: 写口令文件’’时出错</li><li>ORA-01994: GRANT 失败: 无法添加用户至公用口令文件</li><li>ORA-01995: 读口令文件’’时出错</li><li>ORA-01996: GRANT 失败: 口令文件’’已满</li><li>ORA-01997: GRANT 失败: 用户’’由外部标识</li><li>ORA-01998: REVOKE 失败: 用户 SYS 始终具有 SYSOPER 和 SYSDBA</li><li>ORA-01999: 口令文件模式已由’’更改为’’</li><li>ORA-02000: 缺少关键字</li><li>ORA-02001: 用户 SYS 不允许创建可用列表组的索引</li><li>ORA-02002: 写入审记线索时出错</li><li>ORA-02003: 无效的 USERENV 参数</li><li>ORA-02004: 违反安全性</li><li>ORA-02005: 隐含 (-1) 长度对数据类型的定义和赋值无效</li><li>ORA-02006: 无效的压缩十进制格式字符串</li><li>ORA-02007: 不能使用含 REBUILD 的 ALLOCATE 或 DEALLOCATE 选项</li><li>ORA-02008: 已指定非数字列的非零标度</li><li>ORA-02009: 指定的文件大小不得为 0</li><li>ORA-02010: 缺少主机连接字符串</li><li>ORA-02011: 重复的数据库链接名</li><li>ORA-02012: 缺少 USING 关键字</li><li>ORA-02013: 缺少 CONNECT 关键字</li><li>ORA-02014: 不能从具有 DISTINCT, GROUP BY 等的视图选择 UPDATE FOR</li><li>ORA-02015: 不能从远程表选择 FOR UPDATE</li><li>ORA-02016: 不能在远程数据库中使用 START WITH 子查询</li><li>ORA-02017: 要求整数值</li><li>ORA-02018: 同名的数据库链接具有开放连接</li><li>ORA-02019: 未找到远程数据库的连接说明</li><li>ORA-02020: 过多的数据库链接在使用中</li><li>ORA-02021: 不允许对远程数据库进行 DDL 操作</li><li>ORA-02022: 远程语句的远程对象具有未优化的视图</li><li>ORA-02023: 远程数据库无法对 START WITH 或 CONNECT BY 谓词求值</li><li>ORA-02024: 未找到数据库链接</li><li>ORA-02025: SQL 语句的所有表均必须在远程数据库中</li><li>ORA-02026: 缺少 LINK 关键字</li><li>ORA-02027: 不支持 LONG 列的多行 UPDATE</li><li>ORA-02028: 服务器不支持行数的准确读取</li><li>ORA-02029: 缺少 FLLE 关键字</li><li>ORA-02030: 只能从固定的表/视图查询</li><li>ORA-02031: 没有 ROWID 适用于固定表或外部组织的表</li><li>ORA-02032: 聚簇表无法在簇索引建立之前使用</li><li>ORA-02033: 此簇的簇索引已经存在</li><li>ORA-02034: 不允许加速赋值</li><li>ORA-02035: 非法的成组操作组合</li><li>ORA-02036: 自动游标打开的变量描述过多</li><li>ORA-02037: 未初始化的加速赋值存储</li><li>ORA-02038: 不允许对数组类型定义</li><li>ORA-02039: 不允许对数组类型赋值</li><li>ORA-02040: 远程数据库不支持两段式提交</li><li>ORA-02041: 客户数据库未开始一个事务处理</li><li>ORA-02042: 分布式事务处理过多</li><li>ORA-02043: 必须在执行之前结束当前事务处理</li><li>ORA-02044: 事务处理管理器登录被拒绝: 事务处理正在进行</li><li>ORA-02045: 全局事务处理中的本地会话过多</li><li>ORA-02046: 分布式事务处理已经开始</li><li>ORA-02047: 无法连接运行中的分布式事务处理</li><li>ORA-02048: 尝试不登录而开始分布式事务处理</li><li>ORA-02049: 超时: 分布式事务处理等待锁定</li><li>ORA-02050: 事务处理已重算，某些远程 DBs 可能有问题</li><li>ORA-02051: 同一事务处理中的另一会话失败</li><li>ORA-02052: 远程事务处理在失败</li><li>ORA-02053: 事务处理已提交，某些远程 DBs 可能有问题</li><li>ORA-02054: 事务处理有问题</li><li>ORA-02055: 分布式更新操作失效；要求回退</li><li>ORA-02056: 2PC: : 无效的两段命令编号（源于）</li><li>ORA-02057: 2PC: : 无效的两段恢复状态编号（源于）</li><li>ORA-02058: 未找到 ID的准备事务处理</li><li>ORA-02059: - ORA-2PC-CRASH-TEST- 在提交备注中</li><li>ORA-02060: 选择指定了分布表连接的更新</li><li>ORA-02061: 锁定表指定了分布式表的列表</li><li>ORA-02062: 分布式恢复收到 DBID ，预计为</li><li>ORA-02063: 紧接着（源于）</li><li>ORA-02064: 不支持分布式操作</li><li>ORA-02065: 非法的 ALTER SYSTEM 选项</li><li>ORA-02066: DISPATCHERS 文本缺失或无效</li><li>ORA-02067: 要求事务处理或保存点回退</li><li>ORA-02068: 以下严重错误源于</li><li>ORA-02069: 此操作的 global_names 参数必须设置为 TRUE</li><li>ORA-02070: 数据库不支持此上下文中的</li><li>ORA-02071: 初始化远程数据库的功能时出错</li><li>ORA-02072: 分布式数据库网络协议匹配错误</li><li>ORA-02073: 远程更新中不支持序号</li><li>ORA-02074: 无法在分布式事务处理中</li><li>ORA-02075: 另一例程已更改事务处理的状态</li><li>ORA-02076: 序列与更新表或 long 列位于不同的地方</li><li>ORA-02077: 选择的 long 列必须来自于同一地方的表</li><li>ORA-02078: ALTER SYSTEM FIXED_DATE 的设置无效</li><li>ORA-02079: 没有新的会话可与提交的分布式事务处理连接</li><li>ORA-02080: 数据库链接正在使用中</li><li>ORA-02081: 数据库链接未打开</li><li>ORA-02082: 回送数据库链接必须具有连结限定词</li><li>ORA-02083: 数据库名称含有非法字符 ‘’</li><li>ORA-02084: 数据库名不全</li><li>ORA-02085: 数据库链接与相连结</li><li>ORA-02086: 数据库 (链路) 名过长</li><li>ORA-02087: 对象被同一事务处理的另一进程锁定</li><li>ORA-02088: 未安装分布式数据库选项</li><li>ORA-02089: COMMIT 不允许在附属会话中</li><li>ORA-02090: 网络错误: 试图 callback+passthru</li><li>ORA-02091: 事务处理已重算</li><li>ORA-02092: 超出分布式事务处理的事务处理表槽</li><li>ORA-02093: TRANSACTIONS_PER_ROLLBACK_SEGMENT() 大于最大的可能数 ()</li><li>ORA-02094: 未安装复制选项</li><li>ORA-02095: 无法修改指定的初始化参数</li><li>ORA-02096: 此选项的指定初始化参数不可修改</li><li>ORA-02097: 无法修改参数，因为指定的值无效</li><li>ORA-02098: 对索引表引用 (: I) 进行语法分析时出错</li><li>ORA-02099: 内部使用，不得打印</li><li>ORA-02100: PCC: 内存不足 (如无法分配)</li><li>ORA-02101: PCC: 不一致的游标高速缓存 (uce/cuc 不匹配)</li><li>ORA-02102: PCC: 不一致的游标高速缓存 (此 uce 无 cur 条目)</li><li>ORA-02103: PCC: 不一致的游标高速缓存 (超出 cuc 的引用范围)</li><li>ORA-02104: PCC: 不一致的主高速缓存 (cuc 不可用)</li><li>ORA-02105: PCC: 不一致的游标高速缓存 (高速缓存中无 cuc 条目)</li><li>ORA-02106: PCC: 不一致的游标高速缓存 (OraCursor nr 已坏)</li><li>ORA-02107: PCC: 对运行时库来说此程序过旧: 请重新对其编译</li><li>ORA-02108: PCC: 无效的描述符传送给运行时库</li><li>ORA-02109: PCC: 不一致的主高速缓存 (超出位置引用范围)</li><li>ORA-02110: PCC: 不一致的主高速缓存 (无效的 sqi 类型)</li><li>ORA-02111: PCC: 堆栈 (Heap) 一致性错误</li><li>ORA-02112: PCC: SELECT..INTO 返回过多行</li><li>ORA-02140: 无效的表空间名称</li><li>ORA-02141: 无效的 OFFLINE 选项</li><li>ORA-02142: 缺少或无效的 ALTER TABLESPACE 选项</li><li>ORA-02143: 无效的 STORAGE 选项</li><li>ORA-02144: 未指定 ALTER CLUSTER 的选项</li><li>ORA-02145: 缺少 STORAGE 选项</li><li>ORA-02146: SHARED 指定了多次</li><li>ORA-02147: 与 SHARED/EXCLUSIVE 选项冲突</li><li>ORA-02148: EXCLUSIVE 指定了多次</li><li>ORA-02149: 指定的分区不存在</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> oracle </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Influxdb介绍</title>
      <link href="/2019/11/11/database/influxdb%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/11/11/database/influxdb%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="Influxdb介绍"><a href="#Influxdb介绍" class="headerlink" title="Influxdb介绍"></a>Influxdb介绍</h1><p><a href="https://blog.csdn.net/vtnews/article/details/80197045">influxdb</a>  <a href="http://docs.influxdata.com/influxdb/v1.7/introduction/getting-started/">influxdb官方文档</a></p><h2 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h2><p><code>systemctl status influxd</code><br><code>systemctl start influxd</code></p><span id="more"></span><h2 id="influxDB名词："><a href="#influxDB名词：" class="headerlink" title="influxDB名词："></a>influxDB名词：</h2><ul><li>database：数据库；</li><li>measurement：数据库中的表；</li><li>points：表里面的一行数据。<h2 id="influxDB中独有的一些概念"><a href="#influxDB中独有的一些概念" class="headerlink" title="influxDB中独有的一些概念"></a>influxDB中独有的一些概念</h2></li><li>Point由时间戳（time）、数据（field）和标签（tags）组成。<ul><li>time：每条数据记录的时间，也是数据库自动生成的主索引；</li><li>fields：各种记录的值；</li><li>tags：各种有索引的属性。</li></ul></li><li>series：series是共同retention policy，measurement和tag set的集合。series表示这个表里面的所有的数据可以在图标上画成几条线（注：线条的个数由tags排列组合计算出来）<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2></li><li>InfluxDB HTTP API 默认在8086端口运行<h2 id="InfluxDB"><a href="#InfluxDB" class="headerlink" title="InfluxDB"></a>InfluxDB</h2><h3 id="查看InfluxDB版本"><a href="#查看InfluxDB版本" class="headerlink" title="查看InfluxDB版本"></a>查看InfluxDB版本</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">influx -version</span><br></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2></li><li>GROUP BY 参数只能是time和tag</li><li>fill(200)：表示如果这个时间段没有数据，以200填充，</li><li>聚合函数 只能是field</li><li>不支持if(),in()</li><li>where语句可使用比较运算符或者正则表达式时：<ul><li>使用比较运算符当比较对象是field且值是<strong>字符串类型</strong>时必须使用<strong>单引号</strong></li><li>使用比较运算符当比较对象是tag时必须使用<strong>单引号</strong></li><li>使用正则表达式时必须<strong>没有单引号</strong></li></ul></li></ul><h2 id="InfluxDB数据库操作"><a href="#InfluxDB数据库操作" class="headerlink" title="InfluxDB数据库操作"></a>InfluxDB数据库操作</h2><h3 id="进入命令行influx-command-line-interface-CLI"><a href="#进入命令行influx-command-line-interface-CLI" class="headerlink" title="进入命令行influx command line interface (CLI)"></a>进入命令行influx command line interface (CLI)</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">influx -precision rfc3339</span><br><span class="line">#-precision：指定返回时间戳的格式/精度。</span><br><span class="line">#rfc3339：告诉InfluxDB返回RFC3339格式的时间戳（YYYY-MM-DDTHH：MM：SS.nnnnnnnnnZ）。</span><br></pre></td></tr></table></figure><h3 id="查询时设置时区"><a href="#查询时设置时区" class="headerlink" title="查询时设置时区"></a>查询时设置时区</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span><span class="operator">-</span>name<span class="operator">&gt;</span> tz(<span class="string">&#x27;Asia/Shanghai&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="查询TAG-KEY"><a href="#查询TAG-KEY" class="headerlink" title="查询TAG_KEY"></a>查询TAG_KEY</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> TAG KEYS [<span class="keyword">from</span> weather]</span><br></pre></td></tr></table></figure><h3 id="查询FIELD-KEY及其FIELD-TYPE"><a href="#查询FIELD-KEY及其FIELD-TYPE" class="headerlink" title="查询FIELD_KEY及其FIELD_TYPE"></a>查询FIELD_KEY及其FIELD_TYPE</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> FIELD KEYS [<span class="keyword">from</span> <span class="operator">&lt;</span><span class="keyword">table</span><span class="operator">-</span>name<span class="operator">&gt;</span>]</span><br></pre></td></tr></table></figure><h3 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE <span class="operator">&lt;</span>db<span class="operator">-</span>name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="显示所有数据库"><a href="#显示所有数据库" class="headerlink" title="显示所有数据库"></a>显示所有数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> databases</span><br></pre></td></tr></table></figure><h3 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> database <span class="operator">&lt;</span>db<span class="operator">-</span>name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use <span class="operator">&lt;</span>db<span class="operator">-</span>name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h3 id="显示该数据库中所有的表（其中主索引始终是time）"><a href="#显示该数据库中所有的表（其中主索引始终是time）" class="headerlink" title="显示该数据库中所有的表（其中主索引始终是time）"></a>显示该数据库中所有的表（其中主索引始终是time）</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> MEASUREMENTS</span><br></pre></td></tr></table></figure><h3 id="查看某张表的series"><a href="#查看某张表的series" class="headerlink" title="查看某张表的series"></a>查看某张表的series</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> series <span class="keyword">from</span> table_name</span><br></pre></td></tr></table></figure><h2 id="InfluxDB数据操作"><a href="#InfluxDB数据操作" class="headerlink" title="InfluxDB数据操作"></a>InfluxDB数据操作</h2><h3 id="新建表（向数据库中插入数据。）"><a href="#新建表（向数据库中插入数据。）" class="headerlink" title="新建表（向数据库中插入数据。）"></a>新建表（向数据库中插入数据。）</h3><p>InfluxDB中没有显式的新建表的语句，只能通过insert数据的方式来建立新表。 </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="operator">&lt;</span>measurement<span class="operator">&gt;</span>[,<span class="operator">&lt;</span>tag<span class="operator">-</span>key<span class="operator">&gt;=</span><span class="operator">&lt;</span>tag<span class="operator">-</span><span class="keyword">value</span><span class="operator">&gt;</span>...] <span class="operator">&lt;</span>field<span class="operator">-</span>key<span class="operator">&gt;=</span><span class="operator">&lt;</span>field<span class="operator">-</span><span class="keyword">value</span><span class="operator">&gt;</span>[,<span class="operator">&lt;</span>field2<span class="operator">-</span>key<span class="operator">&gt;=</span><span class="operator">&lt;</span>field2<span class="operator">-</span><span class="keyword">value</span><span class="operator">&gt;</span>...] [unix<span class="operator">-</span>nano<span class="operator">-</span><span class="type">timestamp</span>]</span><br></pre></td></tr></table></figure><ul><li>其中：<ul><li>weather: 表名  </li><li>altitude=1000,area=北：tag；  </li><li>temperature=11,humidity=-4：field（value）</li></ul></li><li>例子：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> weather,altitude<span class="operator">=</span><span class="number">1000</span>,area<span class="operator">=</span>北 temperature<span class="operator">=</span><span class="number">11</span>,humidity<span class="operator">=</span><span class="number">-4</span></span><br><span class="line"><span class="comment">-- 或者添加数据时，自己写入时间戳</span></span><br><span class="line"><span class="keyword">insert</span> weather,altitude<span class="operator">=</span><span class="number">1000</span>,area<span class="operator">=</span>北 temperature<span class="operator">=</span><span class="number">11</span>,humidity<span class="operator">=</span><span class="number">-4</span> <span class="number">1567564802768578364</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> measurement <span class="operator">&lt;</span><span class="keyword">table</span><span class="operator">-</span>name<span class="operator">&gt;</span></span><br></pre></td></tr></table></figure><h2 id="数据库数据保存策略-Retention-Policies"><a href="#数据库数据保存策略-Retention-Policies" class="headerlink" title="数据库数据保存策略(Retention Policies)"></a>数据库数据保存策略(Retention Policies)</h2><p>主要用于指定数据保留时间，超过指定时间，就删除这部分数据</p><h3 id="查看当前数据库数据保存策略-Retention-Policies"><a href="#查看当前数据库数据保存策略-Retention-Policies" class="headerlink" title="查看当前数据库数据保存策略(Retention Policies)"></a>查看当前数据库数据保存策略(Retention Policies)</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> retention policies <span class="keyword">on</span> &quot;db_name&quot;</span><br></pre></td></tr></table></figure><h3 id="创建新的Retention-Policies"><a href="#创建新的Retention-Policies" class="headerlink" title="创建新的Retention Policies"></a>创建新的Retention Policies</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> retention policy &quot;rp_name&quot; <span class="keyword">on</span> &quot;db_name&quot; duration <span class="number">3</span>w replication <span class="number">1</span> <span class="keyword">default</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>rp_name：策略名</li><li>db_name：具体的数据库名</li><li>3w：保存3周，3周之前的数据将被删除，influxdb具有各种事件参数，比如：h（小时），d（天），w（星期）</li><li>replication 1：副本个数，一般为1就可以了</li><li>default：设置为默认策略</li></ul><h3 id="修改Retention-Policies"><a href="#修改Retention-Policies" class="headerlink" title="修改Retention Policies"></a>修改Retention Policies</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">alter</span> retention policy &quot;rp_name&quot; <span class="keyword">on</span> &quot;db_name&quot; duration <span class="number">30</span>d <span class="keyword">default</span></span><br></pre></td></tr></table></figure><h3 id="删除Retention-Policies"><a href="#删除Retention-Policies" class="headerlink" title="删除Retention Policies"></a>删除Retention Policies</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> retention policy &quot;rp_name&quot;</span><br></pre></td></tr></table></figure><h2 id="连续查询（Continous-Queries）（CQ）"><a href="#连续查询（Continous-Queries）（CQ）" class="headerlink" title="连续查询（Continous Queries）（CQ）"></a>连续查询（Continous Queries）（CQ）</h2><p>当数据超过保存策略里指定的时间之后就会被删除，但是这时候可能并不想数据被完全删掉，怎么办？<br>influxdb提供了联系查询，可以做数据统计采样。<br>这个一个在数据库中自动周期运行的InfluxQL的查询。Continuous query在<code>select</code>语句里需要一个函数，并且一定会包含一个<code>GROUP BY time()</code>的语法。</p><h3 id="查看数据库的Continous-Queries"><a href="#查看数据库的Continous-Queries" class="headerlink" title="查看数据库的Continous Queries"></a>查看数据库的Continous Queries</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> continuous queries</span><br></pre></td></tr></table></figure><h3 id="创建新的Continous-Queries"><a href="#创建新的Continous-Queries" class="headerlink" title="创建新的Continous Queries"></a>创建新的Continous Queries</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#(关键字要大写)</span><br><span class="line"><span class="keyword">CREATE</span> CONTINUOUS QUERY cq_name <span class="keyword">ON</span> db_name </span><br><span class="line"><span class="keyword">BEGIN</span> </span><br><span class="line">    <span class="keyword">SELECT</span> <span class="built_in">sum</span>(log) <span class="keyword">INTO</span> new_table_name <span class="keyword">FROM</span> table_name <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="type">time</span>(<span class="number">5</span>m) </span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>cq_name：连续查询名字</li><li>db_name：数据库名字</li><li>sum(count)：计算总和</li><li>table_name：当前表名</li><li>new_table_name：存新的数据的表名</li><li>30m：时间间隔为30分钟</li></ul><h3 id="删除Continous-Queries"><a href="#删除Continous-Queries" class="headerlink" title="删除Continous Queries"></a>删除Continous Queries</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> CONTINUOUS query cp_name <span class="keyword">on</span> db_name</span><br></pre></td></tr></table></figure><h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h3 id="显示用户"><a href="#显示用户" class="headerlink" title="显示用户"></a>显示用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> users</span><br></pre></td></tr></table></figure><h3 id="创建用户"><a href="#创建用户" class="headerlink" title="创建用户"></a>创建用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> &quot;username&quot; <span class="keyword">with</span> password <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure><h3 id="创建管理员权限用户"><a href="#创建管理员权限用户" class="headerlink" title="创建管理员权限用户"></a>创建管理员权限用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> &quot;username&quot; <span class="keyword">with</span> password <span class="string">&#x27;password&#x27;</span> <span class="keyword">with</span> <span class="keyword">all</span> privileges</span><br></pre></td></tr></table></figure><h3 id="删除用户"><a href="#删除用户" class="headerlink" title="删除用户"></a>删除用户</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">user</span> &quot;username&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> influxdb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> influxdb </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
